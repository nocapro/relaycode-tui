uuid: c32d7256-4ed8-4c91-b956-6a54f67d4f9f
projectId: relaycode-tui
createdAt: '2025-09-26T08:09:22.589Z'
gitCommitMsg: >-
  refactor(ui): Centralize UI constants and abstract list navigation

  This commit executes the first two parts of a major refactoring plan to
  improve code quality and reduce duplication.

  Part 1: UI Constant Consolidation - Creates a single source of truth for UI
  constants (`src/constants/ui.constants.ts`). - Moves `TRANSACTION_STATUS_UI`,
  `FILE_STATUS_UI`, and a unified `FILE_CHANGE_ICONS` into the new file. -
  Updates all dependent components to import from the new centralized location.
  - De-duplicates the `MAX_LOGS` constant between `log.store.ts` and
  `log.constants.ts`.

  Part 2: Abstracted List Navigation - Introduces a new generic
  `useListNavigator` hook to handle all common list navigation keyboard inputs
  (arrows, page up/down). - Refactors `useCopyScreen`, `useDebugLogScreen`, and
  `useDebugMenu` to use this new hook, removing significant boilerplate from
  each. - Simplifies `copy.store.ts` by replacing multiple navigation actions
  with a single `setSelectedIndex` action.
promptSummary: >-
  The user requested to execute parts 1 and 2 of a multi-part refactoring plan
  to improve DRYness and reduce lines of code in the application.
reasoning:
  - >-
    Excellent. I will execute Parts 1 and 2 of your master plan. This
    refactoring will centralize UI constants and abstract list navigation logic
    into a reusable hook, significantly improving code quality and reducing
    duplication.
  - '### Part 1: Consolidate UI Constants'
  - >-
    First, I will create a new file for shared UI constants, move existing
    constants into it, and update all components that were using the old,
    scattered definitions. I'll also de-duplicate a logging constant.
  - '### Part 2: Abstract Keyboard Navigation'
  - >-
    Next, I will create the generic `useListNavigator` hook to encapsulate all
    common list navigation logic. I will then refactor `useCopyScreen`,
    `useDebugLogScreen`, and `useDebugMenu` to use this new, simpler
    abstraction. This involves modifying `copy.store.ts` to simplify its state
    management actions.
operations:
  - type: write
    path: src/constants/ui.constants.ts
    content: |-
      export const TRANSACTION_STATUS_UI = {
          COMMITTED: { text: '✓ Committed', color: 'green' },
          HANDOFF: { text: '→ Handoff', color: 'magenta' },
          REVERTED: { text: '↩ Reverted', color: 'gray' },
          APPLIED: { text: '✓ Applied', color: 'blue' },
          COMMITTING: { text: '→ Committing', color: 'magenta' },
          PENDING: { text: '? Pending', color: 'yellow' },
          FAILED: { text: '✗ Failed', color: 'red' },
      } as const;

      export const FILE_STATUS_UI = {
          APPROVED: { icon: '[✓]', color: 'green' },
          REJECTED: { icon: '[✗]', color: 'red' },
          FAILED: { icon: '[!]', color: 'red' },
          AWAITING: { icon: '[●]', color: 'yellow' },
          RE_APPLYING: { icon: '[●]', color: 'cyan' },
      } as const;

      export const FILE_CHANGE_ICONS = {
          MOD: '[MOD]',
          ADD: '[ADD]',
          DEL: '[DEL]',
          REN: '[REN]',
      } as const;
    patchStrategy: replace
  - type: write
    path: src/constants/history.constants.ts
    content: |+
      --- src/constants/history.constants.ts
      +++ src/constants/history.constants.ts
      @@ -8,22 +8,6 @@
           PROMPT: '/prompt',
           REASONING: '/reasoning',
       } as const;
      -
      -export const TRANSACTION_STATUS_UI = {
      -    COMMITTED: { text: '✓ Committed', color: 'green' },
      -    HANDOFF: { text: '→ Handoff', color: 'magenta' },
      -    REVERTED: { text: '↩ Reverted', color: 'gray' },
      -    APPLIED: { text: '✓ Applied', color: 'blue' },
      -    COMMITTING: { text: '→ Committing', color: 'magenta' },
      -    PENDING: { text: '? Pending', color: 'yellow' },
      -    FAILED: { text: '✗ Failed', color: 'red' },
      -} as const;
      -
      -export const FILE_TYPE_MAP = {
      -    MOD: '[MOD]',
      -    ADD: '[ADD]',
      -    DEL: '[DEL]',
      -    REN: '[REN]',
      -} as const;
       
       export const BULK_ACTIONS_OPTIONS = [
           '(1) Revert Selected Transactions',

    patchStrategy: standard-diff
  - type: write
    path: src/constants/detail.constants.ts
    content: |+
      --- src/constants/detail.constants.ts
      +++ src/constants/detail.constants.ts
      @@ -14,13 +14,6 @@
           NONE: 'NONE',
       } as const;
       
      -export const FILE_CHANGE_TYPE_ICONS = {
      -    MOD: '[MOD]',
      -    ADD: '[ADD]',
      -    DEL: '[DEL]',
      -    REN: '[REN]',
      -} as const;
      -
       export const DETAIL_FOOTER_ACTIONS = {
           REVERT_CONFIRM: [
               { key: 'Enter', label: 'Confirm Revert' },

    patchStrategy: standard-diff
  - type: write
    path: src/constants/review.constants.ts
    content: |+
      --- src/constants/review.constants.ts
      +++ src/constants/review.constants.ts
      @@ -19,14 +19,6 @@
           PARTIAL_FAILURE: 'PARTIAL_FAILURE',
       } as const;
       
      -export const FILE_STATUS_UI = {
      -    APPROVED: { icon: '[✓]', color: 'green' },
      -    REJECTED: { icon: '[✗]', color: 'red' },
      -    FAILED: { icon: '[!]', color: 'red' },
      -    AWAITING: { icon: '[●]', color: 'yellow' },
      -    RE_APPLYING: { icon: '[●]', color: 'cyan' },
      -} as const;
      -
       export const BULK_REPAIR_OPTIONS = [
           '(1) Copy Bulk Re-apply Prompt (for single-shot AI)',
           '(2) Bulk Change Strategy & Re-apply',

    patchStrategy: standard-diff
  - type: write
    path: src/components/DashboardScreen.tsx
    content: >+
      --- src/components/DashboardScreen.tsx

      +++ src/components/DashboardScreen.tsx

      @@ -6,7 +6,7 @@
       import { useDashboardScreen } from '../hooks/useDashboardScreen';
       import { UI_CONFIG } from '../config/ui.config'; //
       import ActionFooter from './ActionFooter';
      -import { DASHBOARD_FOOTER_ACTIONS, DASHBOARD_STATUS } from
      '../constants/dashboard.constants';

      -import { TRANSACTION_STATUS_UI, FILE_TYPE_MAP } from
      '../constants/history.constants';

      +import { DASHBOARD_FOOTER_ACTIONS, DASHBOARD_STATUS } from
      '../constants/dashboard.constants';

      +import { TRANSACTION_STATUS_UI, FILE_CHANGE_ICONS } from
      '../constants/ui.constants';
       
       // --- Sub-components & Helpers ---
       
      @@ -34,7 +34,7 @@
                    </Box>
                    <Box flexDirection="column" paddingLeft={1}>
                       {files.map(file => (
                            <Text key={file.id}>
      -                        <Text
      color="gray">{FILE_TYPE_MAP[file.type]}</Text> {file.path}

      +                        <Text
      color="gray">{FILE_CHANGE_ICONS[file.type]}</Text> {file.path}
                           </Text>
                       ))}
                    </Box>

    patchStrategy: standard-diff
  - type: write
    path: src/components/ReviewScreen.tsx
    content: >+
      --- src/components/ReviewScreen.tsx

      +++ src/components/ReviewScreen.tsx

      @@ -3,8 +3,9 @@
       import DiffScreen from './DiffScreen';
       import ReasonScreen from './ReasonScreen';
       import type { ScriptResult, FileItem, FileChangeType } from '../types/domain.types';
       import { useReviewScreen } from '../hooks/useReviewScreen';
      -import { REVIEW_BODY_VIEWS, REVIEW_FOOTER_ACTIONS, FILE_STATUS_UI,
      BULK_REPAIR_OPTIONS, BULK_INSTRUCT_OPTIONS } from
      '../constants/review.constants';

      +import { REVIEW_BODY_VIEWS, REVIEW_FOOTER_ACTIONS, BULK_REPAIR_OPTIONS,
      BULK_INSTRUCT_OPTIONS } from '../constants/review.constants';
       import ActionFooter from './ActionFooter';
      +import { FILE_STATUS_UI } from '../constants/ui.constants';
       
       // --- Sub-components ---
       

    patchStrategy: standard-diff
  - type: write
    path: src/components/TransactionDetailScreen.tsx
    content: >+
      --- src/components/TransactionDetailScreen.tsx

      +++ src/components/TransactionDetailScreen.tsx

      @@ -4,8 +4,9 @@
       import ReasonScreen from './ReasonScreen';
       import type { FileChangeType } from '../types/domain.types';
       import { useTransactionDetailScreen } from '../hooks/useTransactionDetailScreen';
      -import { DETAIL_BODY_VIEWS, DETAIL_FOOTER_ACTIONS, FILE_CHANGE_TYPE_ICONS
      } from '../constants/detail.constants';

      +import { DETAIL_BODY_VIEWS, DETAIL_FOOTER_ACTIONS } from
      '../constants/detail.constants';
       import ActionFooter from './ActionFooter';
      +import { FILE_CHANGE_ICONS } from '../constants/ui.constants';
       
       const RevertModal = ({ transactionHash }: { transactionHash: string }) => {
           return (
      @@ -95,7 +96,7 @@
                                    return (
                                       <Text key={file.id} color={isFileSelected ? 'cyan' : undefined}>
                                           {isFileSelected ? '> ' : '  '}
      -                                    {FILE_CHANGE_TYPE_ICONS[file.type]}
      <Text color={typeColor(file.type)}>{file.path}</Text>{stats}

      +                                    {FILE_CHANGE_ICONS[file.type]} <Text
      color={typeColor(file.type)}>{file.path}</Text>{stats}
                                       </Text>
                                   );
                               })}

    patchStrategy: standard-diff
  - type: write
    path: src/components/TransactionHistoryScreen.tsx
    content: >+
      --- src/components/TransactionHistoryScreen.tsx

      +++ src/components/TransactionHistoryScreen.tsx

      @@ -4,8 +4,9 @@
       import Separator from './Separator';
       import type { Transaction, FileItem } from '../types/domain.types';
       import { useTransactionHistoryScreen } from '../hooks/useTransactionHistoryScreen';
      -import { HISTORY_FOOTER_ACTIONS, TRANSACTION_STATUS_UI, FILE_TYPE_MAP,
      BULK_ACTIONS_OPTIONS, HISTORY_VIEW_MODES } from
      '../constants/history.constants';

      +import { HISTORY_FOOTER_ACTIONS, BULK_ACTIONS_OPTIONS, HISTORY_VIEW_MODES
      } from '../constants/history.constants';
       import ActionFooter from './ActionFooter';
      +import { TRANSACTION_STATUS_UI, FILE_CHANGE_ICONS } from
      '../constants/ui.constants';
       
       // --- Sub-components ---
       
      @@ -58,7 +59,7 @@
               <Box flexDirection="column" paddingLeft={6}>
                   <Text color={isSelected ? 'cyan' : undefined}>
                       {isSelected ? '> ' : '  '}{' '}
      -                {icon} {FILE_TYPE_MAP[file.type]} {file.path}

      +                {icon} {FILE_CHANGE_ICONS[file.type]} {file.path}
                   </Text>
                   {isLoading && <Box paddingLeft={8}><Spinner type="dots" /></Box>}
                   {isExpanded && !isLoading && <DiffPreview diff={file.diff} />}

    patchStrategy: standard-diff
  - type: write
    path: src/stores/log.store.ts
    content: |+
      --- src/stores/log.store.ts
      +++ src/stores/log.store.ts
      @@ -1,5 +1,6 @@
       import { create } from 'zustand';
       import type { LogEntry, LogLevel } from '../types/log.types';
      +import { MAX_LOGS } from '../constants/log.constants';
       
       interface LogState {
           logs: LogEntry[];
      @@ -9,8 +10,6 @@
           };
       }
       
      -const MAX_LOGS = 200;
      -
       export const useLogStore = create<LogState>((set) => ({
           logs: [],
           actions: {

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useListNavigator.ts
    content: |-
      import { useInput, type Key } from 'ink';

      const moveIndex = (
          currentIndex: number,
          direction: 'up' | 'down',
          listSize: number,
      ): number => {
          if (direction === 'up') {
              return Math.max(0, currentIndex - 1);
          }
          return Math.min(listSize - 1, currentIndex + 1);
      };

      interface ListNavigatorOptions {
          itemCount: number;
          viewportHeight: number;
          selectedIndex: number;
          onIndexChange: (newIndex: number) => void;
          onKey?: (input: string, key: Key) => void;
          isActive: boolean;
      }

      export const useListNavigator = ({
          itemCount,
          viewportHeight,
          selectedIndex,
          onIndexChange,
          onKey,
          isActive,
      }: ListNavigatorOptions) => {
          useInput((input, key) => {
              if (key.upArrow) {
                  onIndexChange(moveIndex(selectedIndex, 'up', itemCount));
                  return;
              }
              if (key.downArrow) {
                  onIndexChange(moveIndex(selectedIndex, 'down', itemCount));
                  return;
              }
              if (key.pageUp) {
                  onIndexChange(Math.max(0, selectedIndex - viewportHeight));
                  return;
              }
              if (key.pageDown) {
                  onIndexChange(Math.min(itemCount - 1, selectedIndex + viewportHeight));
                  return;
              }

              if (onKey) {
                  onKey(input, key);
              }
          }, { isActive });
      };
    patchStrategy: replace
  - type: write
    path: src/stores/copy.store.ts
    content: >+
      --- src/stores/copy.store.ts

      +++ src/stores/copy.store.ts

      @@ -17,11 +17,7 @@
               close: () => void;
               openForReview: (transaction: Transaction, files: FileItem[], selectedFile?: FileItem) => void;
               openForDetail: (transaction: Transaction, selectedFile?: FileItem) => void;
               openForHistory: (transactions: Transaction[]) => void;
      -        navigateUp: () => void;

      -        navigateDown: () => void;

      -        navigatePageUp: (viewportHeight: number) => void;

      -        navigatePageDown: (viewportHeight: number) => void;

      +        setSelectedIndex: (index: number) => void;
               toggleSelection: () => void;
               toggleSelectionById: (id: string) => void;
               executeCopy: () => void;
      @@ -64,16 +60,9 @@
                   const items = CopyService.getCopyItemsForHistory(transactions);
                   actions.open(title, items);
               },
      -        navigateUp: () => set(state => ({

      -            selectedIndex: moveIndex(state.selectedIndex, 'up',
      state.items.length),

      -        })),

      -        navigateDown: () => set(state => ({

      -            selectedIndex: moveIndex(state.selectedIndex, 'down',
      state.items.length),

      -        })),

      -        navigatePageUp: (viewportHeight: number) => set(state => ({

      -            selectedIndex: Math.max(0, state.selectedIndex -
      viewportHeight),

      -        })),

      -        navigatePageDown: (viewportHeight: number) => set(state => ({

      -            selectedIndex: Math.min(state.items.length - 1,
      state.selectedIndex + viewportHeight),

      +        setSelectedIndex: (index) => set(state => ({

      +            selectedIndex: Math.max(0, Math.min(state.items.length - 1,
      index)),
               })),
               toggleSelection: () => set(state => {
                   const currentItem = state.items[state.selectedIndex];

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useCopyScreen.tsx
    content: >+
      --- src/hooks/useCopyScreen.tsx

      +++ src/hooks/useCopyScreen.tsx

      @@ -1,9 +1,9 @@

      -import { useInput } from 'ink';
       import { useCopyStore } from '../stores/copy.store';
       import { useViewStore } from '../stores/view.store';
       import { useViewport } from './useViewport';
       import { UI_CONFIG } from '../config/ui.config';
       import { OVERLAYS } from '../constants/view.constants';
      +import { useListNavigator } from './useListNavigator';
       
       export const useCopyScreen = () => {
           const {
      @@ -18,44 +18,31 @@
               layoutConfig: UI_CONFIG.layout.copyScreen,
           });
       
      -    useInput((input, key) => {

      -        if (key.escape) {

      -            actions.close();

      -            return;

      -        }

      -        if (key.upArrow) {

      -            actions.navigateUp();

      -            return;

      -        }

      -        if (key.downArrow) {

      -            actions.navigateDown();

      -            return;

      -        }

      -        if (key.pageUp) {

      -            actions.navigatePageUp(viewportHeight);

      -            return;

      -        }

      -        if (key.pageDown) {

      -            actions.navigatePageDown(viewportHeight);

      -            return;

      -        }

      -        if (input === ' ') {

      -            actions.toggleSelection();

      -            return;

      -        }

      -        if (key.return) {

      -            actions.executeCopy();

      -            return;

      -        }

      -        

      -        const item = items.find(i => i.key.toLowerCase() ===
      input.toLowerCase());

      -        if(item) {

      -            actions.toggleSelectionById(item.id);

      -        }

      -    }, { isActive: useViewStore.getState().activeOverlay ===
      OVERLAYS.COPY });

      +    useListNavigator({

      +        itemCount: items.length,

      +        viewportHeight,

      +        selectedIndex,

      +        onIndexChange: actions.setSelectedIndex,

      +        isActive: useViewStore.getState().activeOverlay ===
      OVERLAYS.COPY,

      +        onKey: (input, key) => {

      +            if (key.escape) {

      +                actions.close();

      +                return;

      +            }

      +            if (input === ' ') {

      +                actions.toggleSelection();

      +                return;

      +            }

      +            if (key.return) {

      +                actions.executeCopy();

      +                return;

      +            }

      +            const item = items.find(i => i.key.toLowerCase() ===
      input.toLowerCase());

      +            if (item) {

      +                actions.toggleSelectionById(item.id);

      +            }

      +        },

      +    });
       
           const itemsInView = items.slice(viewOffset, viewOffset + viewportHeight);
       

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useDebugLogScreen.tsx
    content: >+
      --- src/hooks/useDebugLogScreen.tsx

      +++ src/hooks/useDebugLogScreen.tsx

      @@ -7,7 +7,7 @@
       import { DEBUG_LOG_MODES } from '../constants/log.constants';
       import { OVERLAYS } from '../constants/view.constants';
       import { UI_CONFIG } from '../config/ui.config';
      -import { moveIndex } from '../stores/navigation.utils';

      +import { useListNavigator } from './useListNavigator';
       
       export const useDebugLogScreen = () => {
           const logs = useLogStore(s => s.logs);
      @@ -40,43 +40,35 @@
               layoutConfig: UI_CONFIG.layout.debugLog,
           });
       
      -    useInput((input, key) => { 

      +    const isOverlayActive = useViewStore.getState().activeOverlay ===
      OVERLAYS.LOG;

      +

      +    useInput((_input, key) => {
               if (mode === DEBUG_LOG_MODES.FILTER) {
                   if (key.escape || key.return) {
                       setMode(DEBUG_LOG_MODES.LIST);
                   }
      -            return;
               }
      +    }, { isActive: isOverlayActive && mode === DEBUG_LOG_MODES.FILTER });
       
      -        if (key.escape) {

      -            setActiveOverlay(OVERLAYS.NONE);

      -            return;

      -        }

      -        if (key.upArrow) {

      -            setSelectedIndex(i => moveIndex(i, 'up',
      filteredLogs.length));

      -            return;

      -        }

      -        if (key.downArrow) {

      -            setSelectedIndex(i => moveIndex(i, 'down',
      filteredLogs.length));

      -            return;

      -        }

      -        if (key.pageUp) {

      -            setSelectedIndex(i => Math.max(0, i - viewportHeight));

      -            return;

      -        }

      -        if (key.pageDown) {

      -            setSelectedIndex(i => Math.min(filteredLogs.length - 1, i +
      viewportHeight));

      -            return;

      -        }

      -        if (input.toLowerCase() === 'c') {

      -            clearLogs();

      -            setFilterQuery('');

      -            setSelectedIndex(0);

      -            return;

      -        }

      -        if (input.toLowerCase() === 'f') {

      -            setMode(DEBUG_LOG_MODES.FILTER);

      +    useListNavigator({

      +        itemCount: filteredLogs.length,

      +        viewportHeight,

      +        selectedIndex,

      +        onIndexChange: setSelectedIndex,

      +        isActive: isOverlayActive && mode === DEBUG_LOG_MODES.LIST,

      +        onKey: (input, key) => {

      +            if (key.escape) {

      +                setActiveOverlay(OVERLAYS.NONE);

      +                return;

      +            }

      +            if (input.toLowerCase() === 'c') {

      +                clearLogs();

      +                setFilterQuery('');

      +                setSelectedIndex(0);

      +                return;

      +            }

      +            if (input.toLowerCase() === 'f') {

      +                setMode(DEBUG_LOG_MODES.FILTER);

      +            }
               }
      -    }, { isActive: useViewStore.getState().activeOverlay === OVERLAYS.LOG
      });

      +    });
       
           useEffect(() => {
               LoggerService.startSimulator();

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useDebugMenu.tsx
    content: >+
      --- src/hooks/useDebugMenu.tsx

      +++ src/hooks/useDebugMenu.tsx

      @@ -1,5 +1,4 @@
       import { useState } from 'react';
      -import { useInput } from 'ink';
       import { useAppStore } from '../stores/app.store';
       import { useViewStore } from '../stores/view.store';
       import { useDashboardStore } from '../stores/dashboard.store';
      @@ -12,11 +11,11 @@
       import { useCopyStore } from '../stores/copy.store';
       import { CopyService } from '../services/copy.service';
       import type { MenuItem } from '../types/debug.types';
       import { useTransactionStore, selectTransactionsByStatus } from '../stores/transaction.store';
      -import { moveIndex } from '../stores/navigation.utils';
       import { ClipboardService } from '../services/clipboard.service';
       import { UI_CONFIG } from '../config/ui.config';
       import { OVERLAYS } from '../constants/view.constants';
       import { useViewport } from './useViewport';
      +import { useListNavigator } from './useListNavigator';
       export type { MenuItem } from '../types/debug.types';
       
       const useDebugMenuActions = () => {
      @@ -325,50 +324,42 @@
               layoutConfig: UI_CONFIG.layout.debugMenu,
           });
           
      -    useInput((input, key) => {

      -        if (key.upArrow) {

      -            setSelectedIndex(i => moveIndex(i, 'up', menuItems.length));

      -            return;

      -        }

      -        if (key.downArrow) {

      -            setSelectedIndex(i => moveIndex(i, 'down',
      menuItems.length));

      -            return;

      -        }

      -        if (key.pageUp) {

      -            setSelectedIndex(i => Math.max(0, i - viewportHeight));

      -            return;

      -        }

      -        if (key.pageDown) {

      -            setSelectedIndex(i => Math.min(menuItems.length - 1, i +
      viewportHeight));

      -            return;

      -        }

      -        if (key.return) {

      -            const item = menuItems[selectedIndex];

      -            if (item) {

      -               
      useViewStore.getState().actions.setActiveOverlay(OVERLAYS.NONE);

      -                item.action();

      -            }

      -            return;

      -        }

      -        if (key.escape) {

      -           
      useViewStore.getState().actions.setActiveOverlay(OVERLAYS.NONE);

      -            return;

      -        }

      -

      -        // No ctrl/meta keys for selection shortcuts, and only single
      characters

      -        if (key.ctrl || key.meta || input.length !== 1) return;

      -

      -        if (input >= '1' && input <= '9') {

      -            const targetIndex = parseInt(input, 10) - 1;

      -            if (targetIndex < menuItems.length) {

      -                setSelectedIndex(targetIndex);

      -            }

      -        } else if (input.toLowerCase() >= 'a' && input.toLowerCase() <=
      'z') {

      -            const targetIndex = 9 + (input.toLowerCase().charCodeAt(0) -
      'a'.charCodeAt(0));

      -            if (targetIndex < menuItems.length) {

      -                setSelectedIndex(targetIndex);

      -            }

      -        }

      -    }, { isActive: useViewStore.getState().activeOverlay ===
      OVERLAYS.DEBUG });

      +    useListNavigator({

      +        itemCount: menuItems.length,

      +        viewportHeight,

      +        selectedIndex,

      +        onIndexChange: setSelectedIndex,

      +        isActive: useViewStore.getState().activeOverlay ===
      OVERLAYS.DEBUG,

      +        onKey: (input, key) => {

      +            if (key.return) {

      +                const item = menuItems[selectedIndex];

      +                if (item) {

      +                   
      useViewStore.getState().actions.setActiveOverlay(OVERLAYS.NONE);

      +                    item.action();

      +                }

      +                return;

      +            }

      +            if (key.escape) {

      +               
      useViewStore.getState().actions.setActiveOverlay(OVERLAYS.NONE);

      +                return;

      +            }

      +

      +            // No ctrl/meta keys for selection shortcuts, and only single
      characters

      +            if (key.ctrl || key.meta || input.length !== 1) return;

      +

      +            if (input >= '1' && input <= '9') {

      +                const targetIndex = parseInt(input, 10) - 1;

      +                if (targetIndex < menuItems.length) {

      +                    setSelectedIndex(targetIndex);

      +                }

      +            } else if (input.toLowerCase() >= 'a' && input.toLowerCase()
      <= 'z') {

      +                const targetIndex = 9 +
      (input.toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0));

      +                if (targetIndex < menuItems.length) {

      +                    setSelectedIndex(targetIndex);

      +                }

      +            }

      +        },

      +    });
       
           const menuItemsInView = menuItems.slice(viewOffset, viewOffset + viewportHeight);
       

    patchStrategy: standard-diff
snapshot:
  src/constants/ui.constants.ts: null
  src/hooks/useListNavigator.ts: null
  src/constants/history.constants.ts: |-
    import type { ActionItem } from '../types/actions.types';

    export const HISTORY_VIEW_MODES = {
        LIST: 'LIST',
        FILTER: 'FILTER',
        BULK_ACTIONS: 'BULK_ACTIONS',
    } as const;

    export const HISTORY_ITEM_PATH_SEGMENTS = {
        FILE: '/file/',
        PROMPT: '/prompt',
        REASONING: '/reasoning',
    } as const;

    export const TRANSACTION_STATUS_UI = {
        COMMITTED: { text: '✓ Committed', color: 'green' },
        HANDOFF: { text: '→ Handoff', color: 'magenta' },
        REVERTED: { text: '↩ Reverted', color: 'gray' },
        APPLIED: { text: '✓ Applied', color: 'blue' },
        COMMITTING: { text: '→ Committing', color: 'magenta' },
        PENDING: { text: '? Pending', color: 'yellow' },
        FAILED: { text: '✗ Failed', color: 'red' },
    } as const;

    export const FILE_TYPE_MAP = {
        MOD: '[MOD]',
        ADD: '[ADD]',
        DEL: '[DEL]',
        REN: '[REN]',
    } as const;

    export const BULK_ACTIONS_OPTIONS = [
        '(1) Revert Selected Transactions',
        "(2) Mark as 'Git Committed'",
        '(3) Delete Selected Transactions (from Relaycode history)',
        '(Esc) Cancel',
    ] as const;

    export const HISTORY_FOOTER_ACTIONS = {
        FILTER_MODE: [{ key: 'Enter', label: 'Apply Filter & Return' }, { key: 'Esc', label: 'Cancel' }] as const,
        BULK_MODE: { text: 'Choose an option [1-3] or (Esc) Cancel' } as const,
        LIST_MODE: (openActionLabel: string, hasSelection: boolean): ActionItem[] => {
            const actions: ActionItem[] = [
                { key: '↑↓/PgUp/PgDn', label: 'Nav' },
                { key: '→', label: 'Expand' },
                { key: '←', label: 'Collapse' },
                { key: 'Spc', label: 'Select' },
                { key: 'Ent', label: 'Details' },
                { key: 'O', label: openActionLabel },
                { key: 'F', label: 'Filter' },
            ];
            if (hasSelection) {
                actions.push({ key: 'C', label: 'Copy' }, { key: 'B', label: 'Bulk' });
            }
            return actions;
        },
    };
  src/constants/review.constants.ts: |-
    import type { ApplyStep } from '../stores/review.store';
    import type { ActionItem } from '../types/actions.types';

    /**
     * Constants for the Review screen and process.
     */
    export const INITIAL_APPLY_STEPS: ApplyStep[] = [
        { id: 'snapshot', title: 'Reading initial file snapshot...', status: 'pending' },
        { id: 'memory', title: 'Applying operations to memory...', status: 'pending', substeps: [] },
        { id: 'post-command', title: 'Running post-command script...', status: 'pending', substeps: [] },
        { id: 'linter', title: 'Analyzing changes with linter...', status: 'pending', substeps: [] },
    ];

    export const REVIEW_BODY_VIEWS = {
        DIFF: 'diff',
        REASONING: 'reasoning',
        SCRIPT_OUTPUT: 'script_output',
        BULK_REPAIR: 'bulk_repair',
        CONFIRM_HANDOFF: 'confirm_handoff',
        BULK_INSTRUCT: 'bulk_instruct',
        NONE: 'none',
    } as const;

    export const PATCH_STATUS = {
        SUCCESS: 'SUCCESS',
        PARTIAL_FAILURE: 'PARTIAL_FAILURE',
    } as const;

    export const FILE_STATUS_UI = {
        APPROVED: { icon: '[✓]', color: 'green' },
        REJECTED: { icon: '[✗]', color: 'red' },
        FAILED: { icon: '[!]', color: 'red' },
        AWAITING: { icon: '[●]', color: 'yellow' },
        RE_APPLYING: { icon: '[●]', color: 'cyan' },
    } as const;

    export const BULK_REPAIR_OPTIONS = [
        '(1) Copy Bulk Re-apply Prompt (for single-shot AI)',
        '(2) Bulk Change Strategy & Re-apply',
        '(3) Handoff to External Agent',
        '(4) Bulk Abandon All Failed Files',
        '(Esc) Cancel',
    ] as const;

    export const BULK_INSTRUCT_OPTIONS = [
        '(1) Copy Bulk Re-instruct Prompt (for single-shot AI)',
        '(2) Handoff to External Agent',
        '(3) Bulk Un-reject All Files (revert to original)',
        '(4) Cancel',
    ] as const;

    interface ReviewFooterConfig {
        isFileSelected: boolean;
        fileStatus?: 'FAILED' | 'REJECTED' | 'OTHER';
        currentItemType?: 'file' | 'script' | 'reasoning' | 'prompt';
        hasFailedFiles: boolean;
        hasRejectedFiles: boolean;
        hasApprovedFiles: boolean;
    }

    export const REVIEW_FOOTER_ACTIONS = {
        DIFF_VIEW: [
            { key: '↑↓', label: 'Next/Prev File' },
            { key: 'X', label: 'Expand' },
            { key: 'PgUp/PgDn', label: 'Scroll' },
            { key: 'D/Esc', label: 'Back' },
        ] as const,
        REASONING_VIEW: [
            { key: '↑↓', label: 'Scroll Text' },
            { key: 'R', label: 'Collapse View' },
            { key: 'C', label: 'Copy Mode' },
        ] as const,
        SCRIPT_OUTPUT_VIEW: [
            { key: '↑↓', label: 'Nav' },
            { key: 'J↓/K↑', label: 'Next/Prev Error' },
            { key: 'C', label: 'Copy Output' },
            { key: 'Ent/Esc', label: 'Back' },
        ] as const,
        BULK_REPAIR_VIEW: { text: 'Use (↑↓) Nav · (Enter) Select · (1-4) Jump · (Esc) Cancel' } as const,
        BULK_INSTRUCT_VIEW: { text: 'Use (↑↓) Nav · (Enter) Select · (1-4) Jump · (Esc) Cancel' } as const,
        HANDOFF_CONFIRM_VIEW: [
            { key: 'Enter', label: 'Confirm Handoff' },
            { key: 'Esc', label: 'Cancel' },
        ] as const,
        MAIN_VIEW: (config: ReviewFooterConfig): ActionItem[] => {
            const actions: ActionItem[] = [{ key: '↑↓', label: 'Nav' }];

            if (config.isFileSelected) {
                if (config.fileStatus !== 'FAILED') actions.push({ key: 'Spc', label: 'Toggle' });
                actions.push({ key: 'D/Ent', label: 'Diff' });
                if (config.fileStatus === 'FAILED') actions.push({ key: 'T', label: 'Try Repair' });
                if (config.fileStatus === 'REJECTED') actions.push({ key: 'I', label: 'Instruct' });
            } else if (config.currentItemType === 'script') {
                actions.push({ key: 'Ent', label: 'Expand Details' });
            } else {
                actions.push({ key: 'Ent', label: 'Expand' });
            }

            if (config.currentItemType !== 'reasoning') actions.push({ key: 'R', label: 'Reasoning' });
            if (config.hasFailedFiles) actions.push({ key: 'Shift+T', label: 'Bulk Repair' });
            if (config.hasRejectedFiles) actions.push({ key: 'Shift+I', label: 'Bulk Instruct' });

            actions.push({ key: 'C', label: 'Copy' });

            if (config.hasApprovedFiles) actions.push({ key: 'A', label: 'Approve' });
            actions.push({ key: 'Q', label: 'Quit' });
            return actions;
        },
    };

    export const getReviewProcessingFooterActions = (
        isSkippable: boolean,
    ): readonly ActionItem[] => {
        const actions: ActionItem[] = [{ key: 'Ctrl+C', label: 'Cancel Process' }];
        if (isSkippable) {
            actions.push({ key: 'S', label: 'Skip Script' });
        }
        return actions;
    };
  src/constants/detail.constants.ts: |-
    import type { ActionItem } from '../types/actions.types';

    /**
     * Constants for the Transaction Detail screen.
     */
    export const NAVIGATOR_SECTIONS = {
        PROMPT: 'PROMPT',
        REASONING: 'REASONING',
        FILES: 'FILES',
    } as const;

    export const DETAIL_BODY_VIEWS = {
        PROMPT: 'PROMPT',
        REASONING: 'REASONING',
        FILES_LIST: 'FILES_LIST',
        DIFF_VIEW: 'DIFF_VIEW',
        REVERT_CONFIRM: 'REVERT_CONFIRM',
        NONE: 'NONE',
    } as const;

    export const FILE_CHANGE_TYPE_ICONS = {
        MOD: '[MOD]',
        ADD: '[ADD]',
        DEL: '[DEL]',
        REN: '[REN]',
    } as const;

    export const DETAIL_FOOTER_ACTIONS = {
        REVERT_CONFIRM: [
            { key: 'Enter', label: 'Confirm Revert' },
            { key: 'Esc', label: 'Cancel' },
        ] as const,
        BASE: (options: { openActionLabel: string; isRevertable: boolean }): ActionItem[] => {
            const { openActionLabel, isRevertable } = options;
            const actions: ActionItem[] = [
                { key: 'C', label: 'Copy' },
                { key: 'O', label: openActionLabel },
            ];
            if (isRevertable) {
                actions.push({ key: 'U', label: 'Undo' });
            }
            actions.push({ key: 'Q', label: 'Quit/Back' });
            return actions;
        },
        DIFF_VIEW: [{ key: '↑↓', label: 'Nav Files' }, { key: '←', label: 'Back to List' }] as const,
        FILE_LIST_VIEW: [
            { key: '↑↓', label: 'Nav Files' },
            { key: '→', label: 'View Diff' },
            { key: '←', label: 'Back to Sections' },
        ] as const,
        SECTION_EXPANDED: [{ key: '↑↓', label: 'Nav/Scroll' }, { key: '→', label: 'Drill In' }, { key: '←', label: 'Collapse' }] as const,
        SECTION_COLLAPSED: [{ key: '↑↓', label: 'Nav' }, { key: '→', label: 'Expand' }] as const,
    };
  src/components/DashboardScreen.tsx: "import React, { useState, useEffect, useRef } from 'react';\nimport { Box, Text } from 'ink';\nimport Spinner from 'ink-spinner';\nimport Separator from './Separator';\nimport type { Transaction, TransactionStatus } from '../types/domain.types';\nimport { useDashboardScreen } from '../hooks/useDashboardScreen';\nimport { UI_CONFIG } from '../config/ui.config'; //\nimport ActionFooter from './ActionFooter';\nimport { DASHBOARD_FOOTER_ACTIONS, DASHBOARD_STATUS } from '../constants/dashboard.constants';\nimport { TRANSACTION_STATUS_UI, FILE_TYPE_MAP } from '../constants/history.constants';\n\n// --- Sub-components & Helpers ---\n\nconst getStatusIcon = (status: TransactionStatus) => {\n    if (status === 'IN-PROGRESS' || status === 'COMMITTING') return <Spinner type=\"dots\" />;\n    const ui = TRANSACTION_STATUS_UI[status as keyof typeof TRANSACTION_STATUS_UI];\n    if (!ui) return <Text> </Text>;\n    return <Text color={ui.color}>{ui.text.split(' ')[0]}</Text>;\n};\n\nconst formatTimeAgo = (timestamp: number) => {\n    const seconds = Math.max(0, Math.floor((Date.now() - timestamp) / 1000));\n    if (seconds < 60) return `${seconds}s`;\n    const minutes = Math.floor(seconds / 60);\n    return `${minutes}m`;\n};\n\nconst ExpandedEventInfo = ({ transaction }: { transaction: Transaction }) => {\n    const stats = transaction.stats;\n    const files = transaction.files || [];\n\n    return (\n        <Box flexDirection=\"column\" paddingLeft={4} marginBottom={1} borderStyle=\"round\" borderLeft={true} borderTop={false} borderRight={false} borderBottom={false} borderColor=\"gray\">\n            {stats && (\n                <Text color=\"gray\">\n                    Stats: {stats.files} files, +{stats.linesAdded}/-{stats.linesRemoved}\n                </Text>\n            )}\n             <Box flexDirection=\"column\" paddingLeft={1}>\n                {files.map(file => (\n                     <Text key={file.id}>\n                        <Text color=\"gray\">{FILE_TYPE_MAP[file.type]}</Text> {file.path}\n                    </Text>\n                ))}\n             </Box>\n        </Box>\n    );\n};\n\nconst EventStreamItem = React.memo(({ transaction, isSelected, isExpanded, isNew }: { transaction: Transaction, isSelected: boolean, isExpanded: boolean, isNew: boolean }) => {\n    const [isAnimatingIn, setIsAnimatingIn] = useState(isNew);\n    const [isStatusFlashing, setIsStatusFlashing] = useState(false);\n    const prevStatus = useRef(transaction.status);\n\n    useEffect(() => {\n        if (isNew) {\n            const timer = setTimeout(() => setIsAnimatingIn(false), 1000);\n            return () => clearTimeout(timer);\n        }\n    }, [isNew]);\n\n    useEffect(() => {\n        if (prevStatus.current !== transaction.status) {\n            setIsStatusFlashing(true);\n            const timer = setTimeout(() => setIsStatusFlashing(false), 500);\n            prevStatus.current = transaction.status;\n            return () => clearTimeout(timer);\n        }\n    }, [transaction.status]);\n\n    const icon = getStatusIcon(transaction.status);\n    const time = formatTimeAgo(transaction.timestamp).padEnd(5, ' ');\n    const statusText = transaction.status.padEnd(11, ' ');\n    const expandIcon = isExpanded ? '▾' : '▸';\n    \n    const messageNode =\n        transaction.status === 'IN-PROGRESS' || transaction.status === 'COMMITTING'\n            ? <Text color={isAnimatingIn ? 'yellow' : 'cyan'}>{transaction.message}</Text>\n            : transaction.message;\n    \n    const content = (\n        <Text>\n            {time} {expandIcon} <Text color={isStatusFlashing ? 'yellow' : undefined} bold={isStatusFlashing}>{icon} {statusText}</Text>{' '}\n            <Text color=\"gray\">{transaction.hash}</Text>\n            {' '}· {messageNode}\n        </Text>\n    );\n\n    if (isSelected) {\n        return <Text bold color={isAnimatingIn ? 'yellow' : 'cyan'}>{'> '}{content}</Text>;\n    }\n\n    return <Text color={isAnimatingIn ? 'yellow' : undefined}>{'  '}{content}</Text>;\n});\n\nconst ConfirmationContent = ({\n    transactionsToConfirm,\n}: {\n    transactionsToConfirm: Transaction[];\n}) => {\n    const actionText = 'APPROVE';\n    \n    return (\n        <Box flexDirection=\"column\" marginY={1} paddingLeft={2}>\n            <Text bold color=\"yellow\">{actionText} ALL PENDING TRANSACTIONS?</Text>\n            <Text>\n                The following {transactionsToConfirm.length} transaction(s) will be approved:\n            </Text>\n            <Box flexDirection=\"column\" paddingLeft={1} marginTop={1}>\n                {transactionsToConfirm.map(tx => (\n                    <Text key={tx.id}>- {tx.hash}: {tx.message}</Text>\n                ))}\n            </Box>\n        </Box>\n    );\n};\n\n// --- Main Component ---\n\nconst DashboardScreen = () => {\n    const {\n        status,\n        transactions,\n        selectedTransactionIndex,\n        pendingApprovals,\n        pendingCommits,\n        isModal,\n        isProcessing,\n        viewOffset,\n        viewportHeight,\n        transactionsToConfirm,\n        expandedTransactionId,\n        newTransactionIds,\n    } = useDashboardScreen({\n        layoutConfig: UI_CONFIG.layout.dashboard,\n    });\n\n    const renderStatusBar = () => {\n        let statusText: string;\n        let statusIcon: React.ReactNode;\n        switch (status) {\n            case DASHBOARD_STATUS.LISTENING: statusText = 'LISTENING'; statusIcon = <Text color=\"green\">●</Text>; break;\n            case DASHBOARD_STATUS.PAUSED: statusText = 'PAUSED'; statusIcon = <Text color=\"yellow\">||</Text>; break;\n            case DASHBOARD_STATUS.APPROVING: statusText = 'APPROVING...'; statusIcon = <Text color=\"cyan\"><Spinner type=\"dots\"/></Text>; break;\n            default: statusText = 'LISTENING'; statusIcon = <Text color=\"green\">●</Text>; //\n        }\n\n        let approvalStr: React.ReactNode = String(pendingApprovals).padStart(2, '0');\n        const commitStr: React.ReactNode = String(pendingCommits).padStart(2, '0');\n\n        if (status === DASHBOARD_STATUS.APPROVING) approvalStr = <Text color=\"cyan\">(<Spinner type=\"dots\"/>)</Text>;\n        if (status === DASHBOARD_STATUS.CONFIRM_APPROVE) {\n            approvalStr = <Text bold color=\"yellow\">┌ {approvalStr} ┐</Text>;\n        }\n        \n        return (\n            <Text>\n                STATUS: {statusIcon} {statusText} · APPROVALS: {approvalStr} · COMMITS: {commitStr}\n            </Text>\n        );\n    };\n\n    const renderFooter = () => {\n        if (isModal) return (\n            <ActionFooter actions={DASHBOARD_FOOTER_ACTIONS.MODAL}/>\n        );\n        if (isProcessing) return <Text>Processing... This may take a moment.</Text>;\n\n\t\treturn <ActionFooter actions={DASHBOARD_FOOTER_ACTIONS.STANDARD({\n            status,\n            hasPending: pendingApprovals > 0,\n            hasApplied: pendingCommits > 0,\n        })} />;\n    };\n    \n    return (\n        <Box flexDirection=\"column\" height=\"100%\">\n            <Text color=\"cyan\">▲ relaycode dashboard</Text>\n            <Separator />\n            <Box marginY={1}>\n                {renderStatusBar()}\n            </Box>\n            \n            {isModal && (\n                <>\n                    <ConfirmationContent transactionsToConfirm={transactionsToConfirm} />\n                    <Separator />\n                </>\n            )}\n            \n            <Text bold underline> EVENT STREAM (Last 15 minutes)</Text>\n            <Box flexDirection=\"column\" marginTop={1}>\n                {transactions.length === 0 && (\n                     <Box paddingLeft={2}><Text color=\"gray\">Listening for changes... no events yet.</Text></Box>\n                )}\n                {transactions.slice(viewOffset, viewOffset + viewportHeight).map((tx, index) => {\n                    const actualIndex = viewOffset + index;\n                    const isExpanded = expandedTransactionId === tx.id;\n                    const isNew = newTransactionIds.has(tx.id);\n                    return (\n                        <React.Fragment key={tx.id}>\n                            <EventStreamItem\n                                transaction={tx}\n                                isSelected={!isModal && actualIndex === selectedTransactionIndex}\n                                isExpanded={isExpanded}\n                                isNew={isNew}\n                            />\n                            {isExpanded && <ExpandedEventInfo transaction={tx} />}\n                        </React.Fragment>\n                    );\n                })}\n            </Box>\n\n            <Box marginTop={1}><Separator /></Box>\n            {renderFooter()}\n        </Box>\n    );\n};\n\nexport default DashboardScreen;"
  src/components/ReviewScreen.tsx: >-
    import { Box, Text } from 'ink';

    import Separator from './Separator';

    import DiffScreen from './DiffScreen';

    import ReasonScreen from './ReasonScreen';

    import type { ScriptResult, FileItem, FileChangeType } from
    '../types/domain.types';

    import { useReviewScreen } from '../hooks/useReviewScreen';

    import { REVIEW_BODY_VIEWS, REVIEW_FOOTER_ACTIONS, FILE_STATUS_UI,
    BULK_REPAIR_OPTIONS, BULK_INSTRUCT_OPTIONS } from
    '../constants/review.constants';

    import ActionFooter from './ActionFooter';


    // --- Sub-components ---


    const FileItemRow = ({ file, reviewState, isFocused }: {
        file: FileItem;
        reviewState: { status: string; error?: string; details?: string };
        isFocused: boolean;
    }) => {
        const ui = FILE_STATUS_UI[reviewState.status as keyof typeof FILE_STATUS_UI] || { icon: '[?]', color: 'gray' };

        const typeColor = (type: FileChangeType) => {
            switch (type) {
                case 'ADD': return 'green';
                case 'DEL': return 'red';
                case 'REN': return 'yellow';
                default: return 'white';
            }
        };

        const diffStats = <Text>(+<Text color="green">{file.linesAdded}</Text>/-<Text color="red">{file.linesRemoved}</Text>)</Text>;
        const strategy = file.strategy === 'standard-diff' ? 'diff' : file.strategy;
        const prefix = isFocused ? '> ' : '  ';
        const colorProps = isFocused ? { bold: true, color: 'cyan' } : {};

        if (reviewState.status === 'FAILED') {
            return (
                <Box>
                    <Text {...colorProps}>
                        {prefix}<Text color={ui.color}>{ui.icon} FAILED {file.path}</Text>
                        <Text color="red">    ({reviewState.error})</Text>
                    </Text>
                </Box>
            );
        }

        if (reviewState.status === 'AWAITING') {
            return (
                <Box>
                    <Text {...colorProps}>
                        {prefix}<Text color={ui.color}>{ui.icon} AWAITING {file.path}</Text>
                        <Text color="yellow">    ({reviewState.details})</Text>
                    </Text>
                </Box>
            );
        }

        if (reviewState.status === 'RE_APPLYING') {
            return (
                 <Box>
                    <Text {...colorProps}>
                        {prefix}<Text color={ui.color}>{ui.icon} RE-APPLYING... {file.path}</Text>
                        <Text color="cyan"> (using &apos;replace&apos; strategy)</Text>
                    </Text>
                </Box>
            );
        }

        return (
            <Box>
                <Text {...colorProps}>
                    {prefix}<Text color={ui.color}>{ui.icon}</Text> {file.type}{' '}
                    <Text color={typeColor(file.type)}>{file.path}</Text>{' '}
                    {diffStats} [{strategy}]
                </Text>
            </Box>
        );
    };


    const ScriptItemRow = ({
        script,
        isSelected,
        isExpanded,
    }: {
        script: ScriptResult;
        isSelected: boolean;
        isExpanded: boolean;
    }) => {
        const icon = script.success ? '✓' : '✗';
        const iconColor = script.success ? 'green' : 'red';
        const arrow = isExpanded ? '▾' : '▸';
        const prefix = isSelected ? '> ' : '  ';
        
        // Extract script type from command (e.g., "bun run test" -> "Post-Command", "bun run lint" -> "Linter")
        const scriptType = script.command.includes('test') ? 'Post-Command' : 
                          script.command.includes('lint') ? 'Linter' : 
                          'Script';

        return (
            <Box>
                <Text bold={isSelected} color={isSelected ? 'cyan' : undefined}>
                    {prefix}<Text color={iconColor}>{icon}</Text> {scriptType}: `{script.command}` ({script.duration}s) {arrow}{' '}
                    {script.summary}
                </Text>
            </Box>
        );
    };


    // --- Main Component ---


    const ReviewScreen = () => {
        const {
            transaction,
            files,
            scripts = [],
            patchStatus,
            selectedItemIndex,
            bodyView,
            isDiffExpanded,
            reasoningScrollIndex,
            scriptErrorIndex,
            fileReviewStates,
            numFiles,
            approvedFilesCount,
            totalLinesAdded,
            totalLinesRemoved,
            selectedBulkRepairOptionIndex,
            selectedBulkInstructOptionIndex,
            navigableItems,
            navigableItemsInView,
            viewOffset,
            contentScrollIndex,
            availableBodyHeight,
            hasRejectedFiles,
        } = useReviewScreen();

        if (!transaction) {
            return <Text>Loading review...</Text>;
        }
        const { hash, message, prompt = '', reasoning = '' } = transaction;

        const renderBody = () => {
            if (bodyView === REVIEW_BODY_VIEWS.NONE) return null;

            if (bodyView === REVIEW_BODY_VIEWS.REASONING) {
                const reasoningText = reasoning || '';
                const reasoningLinesCount = reasoningText.split('\n').length;
                const visibleLinesCount = 10;
                return (
                    <Box flexDirection="column">
                        <ReasonScreen
                            reasoning={reasoningText}
                            scrollIndex={contentScrollIndex}
                            visibleLinesCount={Math.max(1, availableBodyHeight)}
                        />
                        {reasoningLinesCount > visibleLinesCount && (
                            <Text color="gray">
                                Showing lines {reasoningScrollIndex + 1}-{Math.min(reasoningScrollIndex + visibleLinesCount, reasoningLinesCount)}{' '}
                                of {reasoningLinesCount}
                            </Text>
                        )}
                    </Box>
                );
            }
            
            if (bodyView === REVIEW_BODY_VIEWS.DIFF) {
                const currentItem = navigableItems[selectedItemIndex];
                const selectedFile = currentItem?.type === 'file' ? files.find(f => f.id === currentItem.id) : undefined;
                if (!selectedFile) return null;
                return (
                    <DiffScreen
                        filePath={selectedFile.path}
                        diffContent={selectedFile.diff}
                        isExpanded={isDiffExpanded}
                        scrollIndex={contentScrollIndex}
                        maxHeight={Math.max(1, availableBodyHeight)}
                    />
                );
            }

            if (bodyView === REVIEW_BODY_VIEWS.SCRIPT_OUTPUT) {
                 const currentItem = navigableItems[selectedItemIndex];
                 const scriptItems = navigableItems.filter((i): i is { type: 'script'; id: string } => i.type === 'script');
                 const scriptIndex = currentItem?.type === 'script'
                    ? scriptItems.findIndex(i => i.id === currentItem.id)
                    : -1;
                 const selectedScript = scripts[scriptIndex] || null;
                 if (!selectedScript) return null;
                 
                 const outputLines = selectedScript.output.split('\n');
                 const errorLines = outputLines.filter((line: string) =>
                    line.includes('Error') || line.includes('Warning'),
                 );
                 
                 return (
                    <Box flexDirection="column">
                        <Text>
                            {selectedScript.command.includes('lint') ? 'LINTER' : 'SCRIPT'} OUTPUT: `{selectedScript.command}`
                        </Text>
                        <Box marginTop={1} flexDirection="column">
                            {outputLines.map((line: string, index: number) => {
                                const isError = line.includes('Error');
                                const isWarning = line.includes('Warning');
                                const isHighlighted = errorLines[scriptErrorIndex] === line;
                                
                                return (
                                    <Text 
                                        key={index} 
                                        color={isError ? 'red' : isWarning ? 'yellow' : undefined}
                                        bold={isHighlighted}
                                        backgroundColor={isHighlighted ? 'blue' : undefined}
                                    >
                                        {line}
                                    </Text>
                                );
                            })}
                        </Box>
                        {errorLines.length > 0 && (
                            <Text color="gray">
                                Error {scriptErrorIndex + 1} of {errorLines.length} highlighted
                            </Text>
                        )}
                    </Box>
                 );
            }

            if (bodyView === REVIEW_BODY_VIEWS.CONFIRM_HANDOFF) {
                return (
                    <Box flexDirection="column" gap={1}>
                        <Text bold>HANDOFF TO EXTERNAL AGENT</Text>
                        <Box flexDirection="column">
                            <Text>This action will:</Text>
                            <Text>1. Copy a detailed prompt to your clipboard for an agentic AI.</Text>
                            <Text>2. Mark the current transaction as &apos;Handoff&apos; and close this review.</Text>
                            <Text>3. Assume that you and the external agent will complete the work.</Text>
                        </Box>
                        <Text>Relaycode will NOT wait for a new patch. This is a final action.</Text>
                        <Text bold color="yellow">Are you sure you want to proceed?</Text>
                    </Box>
                );
            }

            if (bodyView === REVIEW_BODY_VIEWS.BULK_REPAIR) {
                const failedFiles = files.filter((f: FileItem) => fileReviewStates.get(f.id)?.status === 'FAILED');

                return (
                    <Box flexDirection="column" gap={1}>
                        <Text bold>BULK REPAIR ACTION</Text>

                        <Box flexDirection="column">
                            <Text>The following {failedFiles.length} files failed to apply:</Text>
                            {failedFiles.map((file: FileItem) => (
                                <Text key={file.id}>- {file.path}</Text>
                            ))}
                        </Box>

                        <Text>How would you like to proceed?</Text>

                        <Box flexDirection="column">
                            {BULK_REPAIR_OPTIONS.map((opt, i) => (
                                <Text key={i} color={selectedBulkRepairOptionIndex === i ? 'cyan' : undefined}>
                                    {selectedBulkRepairOptionIndex === i ? '> ' : '  '}
                                    {opt}
                                </Text>
                            ))}
                        </Box>
                    </Box>
                );
            }

            if (bodyView === REVIEW_BODY_VIEWS.BULK_INSTRUCT) {
                const rejectedFiles = files.filter((f: FileItem) => fileReviewStates.get(f.id)?.status === 'REJECTED');

                return (
                    <Box flexDirection="column" gap={1}>
                        <Text bold>BULK INSTRUCTION ACTION</Text>

                        <Box flexDirection="column">
                            <Text>The following {rejectedFiles.length} files were rejected:</Text>
                            {rejectedFiles.map((file: FileItem) => (
                                <Text key={file.id}>- {file.path}</Text>
                            ))}
                        </Box>
                        <Box flexDirection="column" marginTop={1}>
                            {BULK_INSTRUCT_OPTIONS.map((opt, i) => (
                                <Text key={i} color={selectedBulkInstructOptionIndex === i ? 'cyan' : undefined}>
                                    {selectedBulkInstructOptionIndex === i ? '> ' : '  '}
                                    {opt}
                                </Text>
                            ))}
                        </Box>
                    </Box>
                );
            }

            return null;
        };

        const renderFooter = () => {
            // Contextual footer for body views
            if (bodyView === REVIEW_BODY_VIEWS.DIFF) return <ActionFooter actions={REVIEW_FOOTER_ACTIONS.DIFF_VIEW}/>;
            if (bodyView === REVIEW_BODY_VIEWS.REASONING) return <ActionFooter actions={REVIEW_FOOTER_ACTIONS.REASONING_VIEW}/>;
            if (bodyView === REVIEW_BODY_VIEWS.SCRIPT_OUTPUT) return <ActionFooter actions={REVIEW_FOOTER_ACTIONS.SCRIPT_OUTPUT_VIEW}/>;
            if (bodyView === REVIEW_BODY_VIEWS.BULK_REPAIR) return <Text>{REVIEW_FOOTER_ACTIONS.BULK_REPAIR_VIEW.text}</Text>;
            if (bodyView === REVIEW_BODY_VIEWS.BULK_INSTRUCT) return <Text>{REVIEW_FOOTER_ACTIONS.BULK_INSTRUCT_VIEW.text}</Text>;
            if (bodyView === REVIEW_BODY_VIEWS.CONFIRM_HANDOFF) return <ActionFooter actions={REVIEW_FOOTER_ACTIONS.HANDOFF_CONFIRM_VIEW}/>;

            // Dynamic Main footer
            const currentItem = navigableItems[selectedItemIndex];
            const hasFailedFiles = Array.from(fileReviewStates.values()).some(s => s.status === 'FAILED');
            const fileState = currentItem?.type === 'file' ? fileReviewStates.get(currentItem.id) : undefined;

            const footerConfig = {
                isFileSelected: currentItem?.type === 'file',
                fileStatus: fileState?.status as 'FAILED' | 'REJECTED' | 'OTHER' | undefined,
                currentItemType: currentItem?.type as 'file' | 'script' | 'reasoning' | 'prompt' | undefined,
                hasFailedFiles,
                hasRejectedFiles,
                hasApprovedFiles: approvedFilesCount > 0,
            };
            return <ActionFooter actions={REVIEW_FOOTER_ACTIONS.MAIN_VIEW(footerConfig)} />;
        };

        return (
            <Box flexDirection="column">
                {/* Header */}
                <Text bold color="black" backgroundColor="yellow"> ▲ relaycode · REVIEW </Text>
                <Separator />
                
                {/* Navigator Section */}
                <Box flexDirection="column" marginY={1}>
                    <Box flexDirection="column">
                        <Text>{hash} · {message}</Text>
                        <Box>
                            <Text>
                                (<Text color="green">+{totalLinesAdded}</Text>/<Text color="red">-{totalLinesRemoved}</Text>)
                                {' '}| {numFiles} Files · ({approvedFilesCount}/{numFiles} Appr)
                                {' '}| Showing {viewOffset + 1}-
                                {Math.min(viewOffset + navigableItemsInView.length, navigableItems.length)}{' '}
                                of {navigableItems.length}
                            </Text>
                            {patchStatus === 'PARTIAL_FAILURE' && scripts.length === 0 && (
                                <Text> · Scripts: SKIPPED</Text>
                            )}
                            {patchStatus === 'PARTIAL_FAILURE' && <Text color="red" bold> · MULTIPLE PATCHES FAILED</Text>}
                        </Box>
                    </Box>

                    <Box flexDirection="column" marginTop={1}>
                        <Text color={navigableItems[selectedItemIndex]?.type === 'prompt' ? 'cyan' : undefined}>
                            {navigableItems[selectedItemIndex]?.type === 'prompt' ? '> ' : '  '}
                            (P)rompt ▸ {(prompt || '').substring(0, 50)}...
                        </Text>
                        <Text color={navigableItems[selectedItemIndex]?.type === 'reasoning' ? 'cyan' : undefined}>
                            {navigableItems[selectedItemIndex]?.type === 'reasoning' ? '> ' : '  '}
                            (R)easoning ({(reasoning || '').split('\n\n').length} steps){' '}
                            {bodyView === REVIEW_BODY_VIEWS.REASONING ? '▾' : '▸'}{' '}
                            {((reasoning || '').split('\n')[0] ?? '').substring(0, 40)}...
                        </Text>
                    </Box>
                </Box>

                <Separator />

                {/* Script Results (if any) */}
                {scripts.length > 0 && navigableItemsInView.some(i => i.type === 'script') && (
                    <>
                        <Box flexDirection="column" marginY={1}>
                            {scripts.map((script: ScriptResult) => {
                                const itemInViewIndex = navigableItemsInView.findIndex(i => i.type === 'script' && i.id === script.command);
                                if (itemInViewIndex === -1) return null;
                                
                                const isSelected = selectedItemIndex === viewOffset + itemInViewIndex;
                                return (
                                    <ScriptItemRow key={script.command} script={script} isSelected={isSelected} isExpanded={bodyView === REVIEW_BODY_VIEWS.SCRIPT_OUTPUT && isSelected} />
                                );
                            })}
                        </Box>
                        <Separator />
                    </>
                )}
                
                {/* Files Section */}
                <Box flexDirection="column" marginY={1}>
                    <Text bold>FILES</Text>
                    {files.map((file: FileItem) => {
                        const itemInViewIndex = navigableItemsInView.findIndex(i => i.type === 'file' && i.id === file.id);
                        if (itemInViewIndex === -1) return null; // Only render if visible

                        const isFocused = selectedItemIndex === viewOffset + itemInViewIndex;
                        const reviewState = fileReviewStates.get(file.id);
                        
                        return (
                            <FileItemRow key={file.id} file={file} isFocused={isFocused} reviewState={reviewState || { status: 'AWAITING' }} />
                        );
                    })}
                </Box>
                
                <Separator />
                
                {/* Body Viewport */}
                {bodyView !== REVIEW_BODY_VIEWS.NONE && (
                    <>
                        <Box marginY={1}>
                            {renderBody()}
                        </Box>
                        <Separator />
                    </>
                )}

                {/* Footer */}
                <Box>
                    {renderFooter()}
                </Box>
            </Box>
        );
    };


    export default ReviewScreen;
  src/components/TransactionDetailScreen.tsx: >-
    import { Box, Text } from 'ink';

    import Separator from './Separator';

    import DiffScreen from './DiffScreen';

    import ReasonScreen from './ReasonScreen';

    import type { FileChangeType } from '../types/domain.types';

    import { useTransactionDetailScreen } from
    '../hooks/useTransactionDetailScreen';

    import { DETAIL_BODY_VIEWS, DETAIL_FOOTER_ACTIONS, FILE_CHANGE_TYPE_ICONS }
    from '../constants/detail.constants';

    import ActionFooter from './ActionFooter';


    const RevertModal = ({ transactionHash }: { transactionHash: string }) => {
        return (
            <Box 
                borderStyle="round"
                borderColor="yellow"
                flexDirection="column"
                paddingX={2}
                width="80%"
                alignSelf='center'
            >
                <Text bold color="yellow" wrap="wrap" >REVERT THIS TRANSACTION?</Text>
                <Box height={1} />
                <Text wrap="wrap">This will create a NEW transaction that reverses all changes made by {transactionHash}. The original transaction record will be preserved.</Text>
                <Box height={1} />
                <Text wrap="wrap">Are you sure?</Text>
            </Box>
        );
    };


    const typeColor = (type: FileChangeType) => {
        switch (type) {
            case 'ADD': return 'green';
            case 'DEL': return 'red';
            case 'REN': return 'yellow';
            default: return 'white';
        }
    };


    const TransactionDetailScreen = () => {
        const {
            transaction, files,
            focusedItemPath, expandedItemPaths, bodyView, contentScrollIndex, availableBodyHeight,
        } = useTransactionDetailScreen();

        if (!transaction) {
            return <Text>Loading transaction...</Text>;
        }

        const renderNavigator = () => {
            const isPromptFocused = focusedItemPath === 'PROMPT';
            const isReasoningFocused = focusedItemPath === 'REASONING';
            const isFilesFocused = focusedItemPath.startsWith('FILES');
            
            const isPromptExpanded = expandedItemPaths.has('PROMPT');
            const isReasoningExpanded = expandedItemPaths.has('REASONING');
            const isFilesExpanded = expandedItemPaths.has('FILES');
            
            return (
                <Box flexDirection="column">
                    <Text color={isPromptFocused ? 'cyan' : undefined}>
                        {isPromptFocused ? '> ' : '  '}
                        {isPromptExpanded ? '▾' : '▸'} (<Text color="cyan" bold>P</Text>)rompt
                    </Text>
                    <Text color={isReasoningFocused ? 'cyan' : undefined}>
                        {isReasoningFocused ? '> ' : '  '}
                        {isReasoningExpanded ? '▾' : '▸'} (<Text color="cyan" bold>R</Text>)easoning{' '}
                        ({transaction.reasoning?.split('\n\n').length || 0} steps)
                    </Text>
                    <Text color={isFilesFocused ? 'cyan' : undefined}>
                        {isFilesFocused && !focusedItemPath.includes('/') ? '> ' : '  '}
                        {isFilesExpanded ? '▾' : '▸'} (<Text color="cyan" bold>F</Text>)iles ({files.length})
                    </Text>
                    {isFilesExpanded && (
                        <Box flexDirection="column" paddingLeft={2}>
                            {files.map((file) => {
                                 const fileId = `FILES/${file.id}`;
                                 const isFileSelected = focusedItemPath === fileId;
                                 const stats = file.type === 'DEL' ? ''
                                    : ` (+${file.linesAdded}/-${file.linesRemoved})`;
                                 return (
                                    <Text key={file.id} color={isFileSelected ? 'cyan' : undefined}>
                                        {isFileSelected ? '> ' : '  '}
                                        {FILE_CHANGE_TYPE_ICONS[file.type]} <Text color={typeColor(file.type)}>{file.path}</Text>{stats}
                                    </Text>
                                );
                            })}
                        </Box>
                    )}
                </Box>
            );
        };

        const renderBody = () => {
            if (bodyView === DETAIL_BODY_VIEWS.NONE) {
                return <Text color="gray">(Press → to expand a section and view its contents)</Text>;
            }
            if (bodyView === DETAIL_BODY_VIEWS.PROMPT) {
                return (
                    <Box flexDirection="column">
                        <Text>PROMPT</Text>
                        <Box marginTop={1} flexDirection="column">
                            {(transaction.prompt || '').split('\n')
                                .slice(contentScrollIndex, contentScrollIndex + availableBodyHeight)
                                .map((line, i) => <Text key={i}>{line}</Text>)
                            }
                        </Box>
                    </Box>
                );
            }
            if (bodyView === DETAIL_BODY_VIEWS.REASONING) {
                if (!transaction.reasoning) return <Text color="gray">No reasoning provided.</Text>;
                return <ReasonScreen reasoning={transaction.reasoning} scrollIndex={contentScrollIndex} visibleLinesCount={Math.max(1, availableBodyHeight)} />;
            }
            if (bodyView === DETAIL_BODY_VIEWS.FILES_LIST) {
                 return <Text color="gray">(Select a file and press → to view the diff)</Text>;
            }
            if (bodyView === DETAIL_BODY_VIEWS.DIFF_VIEW) {
                const fileId = focusedItemPath.split('/')[1];
                const file = files.find(f => f.id === fileId);
                if (!file) return null;
                return <DiffScreen filePath={file.path} diffContent={file.diff} isExpanded={true} scrollIndex={contentScrollIndex} maxHeight={Math.max(1, availableBodyHeight)} />;
            }
            return null;
        };

        const renderFooter = () => {
            if (bodyView === DETAIL_BODY_VIEWS.REVERT_CONFIRM) {
                return <ActionFooter actions={DETAIL_FOOTER_ACTIONS.REVERT_CONFIRM} />;
            }
            
            const isFileFocused = focusedItemPath.includes('/');
            const openActionLabel = isFileFocused ? 'Open File' : 'Open YAML';
            const isRevertable = ['APPLIED', 'FAILED'].includes(transaction.status);
            const baseActions = DETAIL_FOOTER_ACTIONS.BASE({
                openActionLabel,
                isRevertable,
            });

            if (isFileFocused) { // Is a file
                if (bodyView === DETAIL_BODY_VIEWS.DIFF_VIEW) {
                    return <ActionFooter actions={[...DETAIL_FOOTER_ACTIONS.DIFF_VIEW, ...baseActions]} />;
                } else {
                    return <ActionFooter actions={[...DETAIL_FOOTER_ACTIONS.FILE_LIST_VIEW, ...baseActions]} />;
                }
            }
            
            if (expandedItemPaths.has(focusedItemPath)) {
                return <ActionFooter actions={[...DETAIL_FOOTER_ACTIONS.SECTION_EXPANDED, ...baseActions]} />;
            }
            return <ActionFooter actions={[...DETAIL_FOOTER_ACTIONS.SECTION_COLLAPSED, ...baseActions]} />;
        };

        const { message, timestamp, status } = transaction;
        const date = new Date(timestamp).toISOString().replace('T', ' ').substring(0, 19);
        const fileStats = `${files.length} Files · +${files.reduce((a, f) => a + f.linesAdded, 0)} lines, -${files.reduce((a, f) => a + f.linesRemoved, 0)} lines`;

        return (
            <Box flexDirection="column">
                {/* Header */}
                <Text bold color="black" backgroundColor="yellow"> ▲ relaycode · TRANSACTION DETAILS </Text>
                <Separator />
                
                {/* Modal takeover for Revert */}
                {bodyView === DETAIL_BODY_VIEWS.REVERT_CONFIRM && <RevertModal transactionHash={transaction.hash} />}
                
                {/* Main view */}
                <Box flexDirection="column" display={bodyView === DETAIL_BODY_VIEWS.REVERT_CONFIRM ? 'none' : 'flex'}>
                    {/* Navigator Part A */}
                    <Box flexDirection="column" marginY={1}>
                        <Text><Text color="gray">UUID:</Text> {transaction.id}</Text>
                        <Text><Text color="gray">Git:</Text> {message}</Text>
                        <Text><Text color="gray">Date:</Text> {date} · <Text color="gray">Status:</Text> {status}</Text>
                        <Text><Text color="gray">Stats:</Text> {fileStats}</Text>
                    </Box>
                    
                    {/* Navigator Part B */}
                    {renderNavigator()}
                    
                    <Separator />
                    
                    {/* Body */}
                    <Box marginY={1}>
                        {renderBody()}
                    </Box>
                    
                    <Separator />
                </Box>
                
                {/* Footer */}
                <Box>
                    {renderFooter()}
                </Box>
            </Box>
        );
    };


    export default TransactionDetailScreen;
  src/components/TransactionHistoryScreen.tsx: >-
    import { useMemo } from 'react';

    import { Box, Text } from 'ink';

    import TextInput from 'ink-text-input';

    import Spinner from 'ink-spinner';

    import Separator from './Separator';

    import type { Transaction, FileItem } from '../types/domain.types';

    import { useTransactionHistoryScreen } from
    '../hooks/useTransactionHistoryScreen';

    import { HISTORY_FOOTER_ACTIONS, TRANSACTION_STATUS_UI, FILE_TYPE_MAP,
    BULK_ACTIONS_OPTIONS, HISTORY_VIEW_MODES } from
    '../constants/history.constants';

    import ActionFooter from './ActionFooter';


    // --- Sub-components ---


    const ContentRow = ({ title, content, isSelected, isExpanded, isLoading }: {
        title: string;
        content: string;
        isSelected: boolean;
        isExpanded: boolean;
        isLoading: boolean;
    }) => {
        const icon = isExpanded ? '▾' : '▸';
        return (
            <Box flexDirection="column" paddingLeft={6}>
                <Text color={isSelected ? 'cyan' : undefined}>
                    {isSelected ? '> ' : '  '}{icon} {title}
                </Text>
                {isLoading && <Box paddingLeft={8}><Spinner type="dots" /></Box>}
                {isExpanded && !isLoading && (
                    <Box paddingLeft={8} flexDirection="column">
                        {(content || '').split('\n').map((line, i) => <Text key={i}>{line || ' '}</Text>)}
                    </Box>
                )}
            </Box>
        );
    };


    const DiffPreview = ({ diff }: { diff: string }) => {
        const lines = diff.split('\n');
        const previewLines = lines.slice(0, 5);
        const hiddenLines = lines.length > 5 ? lines.length - 5 : 0;

        return (
            <Box flexDirection="column" paddingLeft={8}>
                {previewLines.map((line, i) => {
                    let color = 'white';
                    if (line.startsWith('+')) color = 'green';
                    if (line.startsWith('-')) color = 'red';
                    if (line.startsWith('@@')) color = 'cyan';
                    return <Text key={i} color={color}>{line}</Text>;
                })}
                {hiddenLines > 0 && <Text color="gray">... {hiddenLines} lines hidden ...</Text>}
            </Box>
        );
    };


    const FileRow = ({ file, isSelected, isExpanded, isLoading }: {
        file: FileItem;
        isSelected: boolean;
        isExpanded: boolean;
        isLoading: boolean;
    }) => {
        const icon = isExpanded ? '▾' : '▸';

        return (
            <Box flexDirection="column" paddingLeft={6}>
                <Text color={isSelected ? 'cyan' : undefined}>
                    {isSelected ? '> ' : '  '}{' '}
                    {icon} {FILE_TYPE_MAP[file.type]} {file.path}
                </Text>
                {isLoading && <Box paddingLeft={8}><Spinner type="dots" /></Box>}
                {isExpanded && !isLoading && <DiffPreview diff={file.diff} />}
            </Box>
        );
    };


    const TransactionRow = ({
        tx,
        isSelected,
        isExpanded,
        isSelectedForAction,
        hasSelection,
    }: {
        tx: Transaction;
        isSelected: boolean;
        isExpanded: boolean;
        isSelectedForAction: boolean;
        hasSelection: boolean;
    }) => {
        const icon = isExpanded ? '▾' : '▸';
        const uiStatus = TRANSACTION_STATUS_UI[tx.status as keyof typeof TRANSACTION_STATUS_UI] || { text: tx.status, color: 'white' };

        const date = new Date(tx.timestamp).toISOString().split('T')[0];
        const selectionIndicator = isSelectedForAction ? '[x] ' : '[ ] ';
        
        return (
            <Box flexDirection="column" marginBottom={isExpanded ? 1 : 0}>
                <Text color={isSelected ? 'cyan' : undefined}>
                    {isSelected ? '> ' : '  '}
                    {hasSelection && selectionIndicator}
                    {icon} <Text color={uiStatus.color}>{uiStatus.text}</Text> · <Text color="gray">{tx.hash}</Text> · {date} ·{' '}
                    {tx.message}
                </Text>
                {isExpanded && (
                    <Box flexDirection="column" paddingLeft={8}>
                        {tx.stats && (
                            <Text color="gray">
                                Stats: {tx.stats.files} files, +{tx.stats.linesAdded}/-{tx.stats.linesRemoved}
                            </Text>
                        )}
                        <Text>Files:</Text>
                    </Box>
                )}
            </Box>
        );
    };


    const BulkActionsMode = ({ selectedForActionCount }: {
    selectedForActionCount: number }) => {
        return (
            <Box flexDirection="column" marginY={1}>
                <Text bold color="yellow">PERFORM BULK ACTION ON {selectedForActionCount} SELECTED ITEMS</Text>
                <Box marginY={1}>
                    <Text>This action is often irreversible. Are you sure?</Text>
                </Box>
                {BULK_ACTIONS_OPTIONS.map(opt => <Text key={opt}>{opt}</Text>)}
            </Box>
        );
    };


    // --- Main Component ---


    const TransactionHistoryScreen = () => {
        const {
            mode,
            filterQuery,
            selectedForAction,
            selectedItemPath,
            expandedIds,
            loadingPaths,
            actions,
            transactions,
            itemsInView,
            filterStatus,
            showingStatus,
            statsStatus,
            hasSelection,
        } = useTransactionHistoryScreen();

        const transactionsById = useMemo(() => new Map(transactions.map(tx => [tx.id, tx])), [transactions]);

        const renderFooter = () => {
            if (mode === HISTORY_VIEW_MODES.FILTER) {
                return <ActionFooter actions={HISTORY_FOOTER_ACTIONS.FILTER_MODE} />;
            }
            if (mode === HISTORY_VIEW_MODES.BULK_ACTIONS) {
                return <Text>{HISTORY_FOOTER_ACTIONS.BULK_MODE.text}</Text>;
            }
            
            const openActionLabel = selectedItemPath.includes('/file/') ? 'Open File' : 'Open YAML';
            return <ActionFooter actions={HISTORY_FOOTER_ACTIONS.LIST_MODE(openActionLabel, hasSelection)} />;
        };

        return (
            <Box flexDirection="column">
                <Text bold color="black" backgroundColor="yellow"> ▲ relaycode · TRANSACTION HISTORY </Text>
                <Separator />

                <Box>
                    <Text>Filter: </Text>
                    {mode === HISTORY_VIEW_MODES.FILTER ? (
                        <TextInput value={filterQuery} onChange={actions.setFilterQuery} />
                    ) : (
                        <Text>{filterStatus}</Text>
                    )}
                    <Text> · {showingStatus}</Text>
                    {statsStatus && <Text> · <Text color="magenta">{statsStatus}</Text></Text>}
                </Box>

                <Box flexDirection="column" marginY={1}>
                    {mode === HISTORY_VIEW_MODES.BULK_ACTIONS && <BulkActionsMode selectedForActionCount={selectedForAction.size} />}

                    {mode === HISTORY_VIEW_MODES.LIST && itemsInView.map(path => {
                        const txId = path.split('/')[0]!;
                        const tx = transactionsById.get(txId);
                        if (!tx) return <Text key={path}>Error: Missing TX {txId}</Text>;

                        // Is a transaction row
                        if (path === tx.id) {
                            return (
                                <TransactionRow
                                    key={path}
                                    tx={tx}
                                    isSelected={selectedItemPath === path}
                                    isExpanded={expandedIds.has(path)}
                                    isSelectedForAction={selectedForAction.has(tx.id)}
                                    hasSelection={hasSelection}
                                />
                            );
                        }

                        // Is a child row
                        const itemType = path.split('/')[1]!;
                        const isSelected = selectedItemPath === path;
                        const isExpanded = expandedIds.has(path);
                        const isLoading = loadingPaths.has(path);

                        if (itemType === 'file') {
                            const fileId = path.split('/')[2]!;
                            const file = tx.files?.find(f => f.id === fileId);
                            if (!file) return null;
                            return (
                                <FileRow
                                    key={path} file={file} isSelected={isSelected}
                                    isExpanded={isExpanded} isLoading={isLoading}
                                />
                            );
                        }

                        const contentMap = {
                            message: { title: 'Commit Message', content: tx.message || '' },
                            prompt: { title: 'Prompt', content: tx.prompt || '' },
                            reasoning: { title: 'Reasoning', content: tx.reasoning || '' },
                        };

                        const item = contentMap[itemType as keyof typeof contentMap];
                        if (!item) return null;

                        return (
                            <ContentRow
                                key={path}
                                {...item}
                                isSelected={isSelected}
                                isExpanded={isExpanded}
                                isLoading={isLoading}
                            />
                        );
                    })}
                </Box>

                <Separator />
                {renderFooter()}
            </Box>
        );
    };


    export default TransactionHistoryScreen;
  src/stores/log.store.ts: |-
    import { create } from 'zustand';
    import type { LogEntry, LogLevel } from '../types/log.types';

    interface LogState {
        logs: LogEntry[];
        actions: {
            addLog: (level: LogLevel, message: string) => void;
            clearLogs: () => void;
        };
    }

    const MAX_LOGS = 200;

    export const useLogStore = create<LogState>((set) => ({
        logs: [],
        actions: {
            addLog: (level, message) => {
                set(state => {
                    const newLog: LogEntry = {
                        level,
                        message,
                        timestamp: Date.now(),
                    };
                    // Prepend new log and trim the array to max size
                    const updatedLogs = [newLog, ...state.logs].slice(0, MAX_LOGS);
                    return { logs: updatedLogs };
                });
            },
            clearLogs: () => set({ logs: [] }),
        },
    }));
  src/stores/copy.store.ts: |-
    import { create } from 'zustand';
    import { moveIndex } from './navigation.utils';
    import { useViewStore } from './view.store';
    import { useNotificationStore } from './notification.store';
    import { LoggerService } from '../services/logger.service';
    import { CopyService } from '../services/copy.service';
    import type { CopyItem } from '../types/copy.types';
    import type { Transaction, FileItem } from '../types/domain.types';

    export type { CopyItem };

    interface CopyState {
        title: string;
        items: CopyItem[];
        selectedIndex: number;
        selectedIds: Set<string>;
        lastCopiedMessage: string | null;
        onClose?: () => void;

        actions: {
            open: (title: string, items: CopyItem[], onClose?: () => void) => void;
            close: () => void;
            openForReview: (transaction: Transaction, files: FileItem[], selectedFile?: FileItem) => void;
            openForDetail: (transaction: Transaction, selectedFile?: FileItem) => void;
            openForHistory: (transactions: Transaction[]) => void;
            navigateUp: () => void;
            navigateDown: () => void;
            navigatePageUp: (viewportHeight: number) => void;
            navigatePageDown: (viewportHeight: number) => void;
            toggleSelection: () => void;
            toggleSelectionById: (id: string) => void;
            executeCopy: () => void;
        };
    }

    export const useCopyStore = create<CopyState>((set, get) => ({
        title: '',
        items: [],
        selectedIndex: 0,
        selectedIds: new Set(),
        lastCopiedMessage: null,
        onClose: undefined,

        actions: {
            open: (title, items, onClose) => {
                const defaultSelectedIds = new Set(items.filter(i => i.isDefaultSelected).map(i => i.id));
                useViewStore.getState().actions.setActiveOverlay('copy');
                set({
                    title,
                    items,
                    selectedIndex: 0,
                    selectedIds: defaultSelectedIds,
                    lastCopiedMessage: null,
                    onClose,
                });
            },
            close: () => {
                useViewStore.getState().actions.setActiveOverlay('none');
                get().onClose?.();
                set({ items: [], onClose: undefined });
            },
            openForReview: (transaction, files, selectedFile) => {
                const { actions } = get();
                const title = 'Select data to copy from review:';
                const items = CopyService.getCopyItemsForReview(transaction, files, selectedFile);
                actions.open(title, items);
            },
            openForDetail: (transaction, selectedFile) => {
                const { actions } = get();
                const title = `Select data to copy from transaction ${transaction.hash}:`;
                const items = CopyService.getCopyItemsForDetail(transaction, selectedFile);
                actions.open(title, items);
            },
            openForHistory: (transactions) => {
                const { actions } = get();
                const title = `Select data to copy from ${transactions.length} transactions:`;
                const items = CopyService.getCopyItemsForHistory(transactions);
                actions.open(title, items);
            },
            navigateUp: () => set(state => ({
                selectedIndex: moveIndex(state.selectedIndex, 'up', state.items.length),
            })),
            navigateDown: () => set(state => ({
                selectedIndex: moveIndex(state.selectedIndex, 'down', state.items.length),
            })),
            navigatePageUp: (viewportHeight: number) => set(state => ({
                selectedIndex: Math.max(0, state.selectedIndex - viewportHeight),
            })),
            navigatePageDown: (viewportHeight: number) => set(state => ({
                selectedIndex: Math.min(state.items.length - 1, state.selectedIndex + viewportHeight),
            })),
            toggleSelection: () => set(state => {
                const currentItem = state.items[state.selectedIndex];
                if (!currentItem) return {};
                const newSelectedIds = new Set(state.selectedIds);
                if (newSelectedIds.has(currentItem.id)) {
                    newSelectedIds.delete(currentItem.id);
                } else {
                    newSelectedIds.add(currentItem.id);
                }
                return { selectedIds: newSelectedIds };
            }),
            toggleSelectionById: (id: string) => set(state => {
                const newSelectedIds = new Set(state.selectedIds);
                if (newSelectedIds.has(id)) {
                    newSelectedIds.delete(id);
                } else {
                    newSelectedIds.add(id);
                }
                return { selectedIds: newSelectedIds };
            }),
            executeCopy: async () => {
                const { items, selectedIds } = get();
                const itemsToCopy = items.filter(i => selectedIds.has(i.id));
                if (itemsToCopy.length === 0) return;

                LoggerService.info(`Copying ${itemsToCopy.length} item(s) to clipboard.`);
                const dataPromises = itemsToCopy.map(item => item.getData());
                const resolvedData = await Promise.all(dataPromises);

                const content = itemsToCopy
                    .map((item, index) => `--- ${item.label} ---\n${resolvedData[index]}`)
                    .join('\n\n');
                const message = `Copied ${itemsToCopy.length} item(s) to clipboard.`;
                LoggerService.debug(`[CLIPBOARD MOCK] ${message}\n${content.substring(0, 200)}...`);
                useNotificationStore.getState().actions.show({
                    type: 'success',
                    title: 'Copied to Clipboard',
                    message,
                });
                set({ lastCopiedMessage: message });
            },
        },
    }));
  src/hooks/useCopyScreen.tsx: |-
    import { useInput } from 'ink';
    import { useCopyStore } from '../stores/copy.store';
    import { useViewStore } from '../stores/view.store';
    import { useViewport } from './useViewport';
    import { UI_CONFIG } from '../config/ui.config';
    import { OVERLAYS } from '../constants/view.constants';

    export const useCopyScreen = () => {
        const {
            title, items, selectedIndex, selectedIds, lastCopiedMessage,
            actions,
        } = useCopyStore(state => ({ ...state, actions: state.actions }));
        
        const { viewOffset, viewportHeight } = useViewport({
            selectedIndex,
            itemCount: items.length,
            layoutConfig: UI_CONFIG.layout.copyScreen,
        });

        useInput((input, key) => {
            if (key.escape) {
                actions.close();
                return;
            }
            if (key.upArrow) {
                actions.navigateUp();
                return;
            }
            if (key.downArrow) {
                actions.navigateDown();
                return;
            }
            if (key.pageUp) {
                actions.navigatePageUp(viewportHeight);
                return;
            }
            if (key.pageDown) {
                actions.navigatePageDown(viewportHeight);
                return;
            }
            if (input === ' ') {
                actions.toggleSelection();
                return;
            }
            if (key.return) {
                actions.executeCopy();
                return;
            }
            
            const item = items.find(i => i.key.toLowerCase() === input.toLowerCase());
            if(item) {
                actions.toggleSelectionById(item.id);
            }
        }, { isActive: useViewStore.getState().activeOverlay === OVERLAYS.COPY });

        const itemsInView = items.slice(viewOffset, viewOffset + viewportHeight);

        return {
            title,
            itemsInView,
            selectedIndex,
            selectedIds,
            lastCopiedMessage,
            viewOffset,
        };
    };
  src/hooks/useDebugLogScreen.tsx: |-
    import { useState, useEffect, useMemo } from 'react';
    import { useInput } from 'ink';
    import { useLogStore } from '../stores/log.store';
    import { useViewStore } from '../stores/view.store';
    import { useViewport } from './useViewport';
    import { LoggerService } from '../services/logger.service';
    import { DEBUG_LOG_MODES } from '../constants/log.constants';
    import { OVERLAYS } from '../constants/view.constants';
    import { UI_CONFIG } from '../config/ui.config';
    import { moveIndex } from '../stores/navigation.utils';

    export const useDebugLogScreen = () => {
        const logs = useLogStore(s => s.logs);
        const clearLogs = useLogStore(s => s.actions.clearLogs);
        const setActiveOverlay = useViewStore(s => s.actions.setActiveOverlay);

        const [selectedIndex, setSelectedIndex] = useState(0);
        const [mode, setMode] = useState<keyof typeof DEBUG_LOG_MODES>('LIST');
        const [filterQuery, setFilterQuery] = useState('');

        const filteredLogs = useMemo(() => logs.filter(log =>
            log.message.toLowerCase().includes(filterQuery.toLowerCase()),
        ), [logs, filterQuery]);

        // Reset index to top when filter changes
        useEffect(() => {
            setSelectedIndex(0);
        }, [filterQuery]);

        // Clamp index if it's out of bounds after logs change for other reasons
        useEffect(() => {
            if (selectedIndex >= filteredLogs.length) {
                setSelectedIndex(Math.max(0, filteredLogs.length - 1));
            }
        }, [filteredLogs.length, selectedIndex]);

        // Header, borders, footer, filter line
        const { viewOffset, viewportHeight } = useViewport({
            selectedIndex,
            itemCount: filteredLogs.length,
            layoutConfig: UI_CONFIG.layout.debugLog,
        });

        useInput((input, key) => { 
            if (mode === DEBUG_LOG_MODES.FILTER) {
                if (key.escape || key.return) {
                    setMode(DEBUG_LOG_MODES.LIST);
                }
                return;
            }

            if (key.escape) {
                setActiveOverlay(OVERLAYS.NONE);
                return;
            }
            if (key.upArrow) {
                setSelectedIndex(i => moveIndex(i, 'up', filteredLogs.length));
                return;
            }
            if (key.downArrow) {
                setSelectedIndex(i => moveIndex(i, 'down', filteredLogs.length));
                return;
            }
            if (key.pageUp) {
                setSelectedIndex(i => Math.max(0, i - viewportHeight));
                return;
            }
            if (key.pageDown) {
                setSelectedIndex(i => Math.min(filteredLogs.length - 1, i + viewportHeight));
                return;
            }
            if (input.toLowerCase() === 'c') {
                clearLogs();
                setFilterQuery('');
                setSelectedIndex(0);
                return;
            }
            if (input.toLowerCase() === 'f') {
                setMode(DEBUG_LOG_MODES.FILTER);
            }
        }, { isActive: useViewStore.getState().activeOverlay === OVERLAYS.LOG });

        useEffect(() => {
            LoggerService.startSimulator();
            return () => {
                LoggerService.stopSimulator();
            };
        }, []);

        const logsInView = filteredLogs.slice(viewOffset, viewOffset + viewportHeight);

        return {
            logsInView,
            logCount: logs.length,
            filteredLogCount: filteredLogs.length,
            selectedIndex,
            mode,
            filterQuery,
            setFilterQuery,
            viewOffset,
        };
    };
  src/hooks/useDebugMenu.tsx: >-
    import { useState } from 'react';

    import { useInput } from 'ink';

    import { useAppStore } from '../stores/app.store';

    import { useViewStore } from '../stores/view.store';

    import { useDashboardStore } from '../stores/dashboard.store';

    import { useReviewStore } from '../stores/review.store';

    import { useDetailStore } from '../stores/detail.store';

    import { useHistoryStore } from '../stores/history.store';

    import { useInitStore } from '../stores/init.store';

    import { useNotificationStore } from '../stores/notification.store';

    import { useCommitStore } from '../stores/commit.store';

    import { useCopyStore } from '../stores/copy.store';

    import { CopyService } from '../services/copy.service';

    import type { MenuItem } from '../types/debug.types';

    import { useTransactionStore, selectTransactionsByStatus } from
    '../stores/transaction.store';

    import { moveIndex } from '../stores/navigation.utils';

    import { ClipboardService } from '../services/clipboard.service';

    import { UI_CONFIG } from '../config/ui.config';

    import { OVERLAYS } from '../constants/view.constants';

    import { useViewport } from './useViewport';

    export type { MenuItem } from '../types/debug.types';


    const useDebugMenuActions = () => {
        const { actions: appActions } = useAppStore();
        const { actions: initActions } = useInitStore();
        const { actions: notificationActions } = useNotificationStore();
        const { actions: commitActions } = useCommitStore();
        const { actions: dashboardActions } = useDashboardStore();
        const { actions: reviewActions } = useReviewStore();
        const { actions: detailActions } = useDetailStore();
        const { actions: historyActions } = useHistoryStore();

        const menuItems: MenuItem[] = [
            {
                title: 'Simulate Pasting Valid Patch',
                action: () => ClipboardService.processClipboardContent(true),
            },
            {
                title: 'Simulate Pasting Invalid Text',
                action: () => ClipboardService.processClipboardContent(false),
            },
            {
                title: 'View Debug Log',
                action: () => useViewStore.getState().actions.setActiveOverlay(OVERLAYS.LOG),
            },
            {
                title: 'Show Success Notification',
                action: () => notificationActions.show({
                    type: 'success',
                    title: 'Operation Successful',
                    message: 'The requested operation completed without errors.',
                }),
            },
            {
                title: 'Show Error Notification',
                action: () => notificationActions.show({
                    type: 'error',
                    title: 'Operation Failed',
                    message: 'An unexpected error occurred. Check the debug log for details.',
                }),
            },
            {
                title: 'Show Info Notification',
                action: () => notificationActions.show({
                    type: 'info',
                    title: 'Information',
                    message: 'This is an informational message for the user.',
                }),
            },
            {
                title: 'Show Warning Notification',
                action: () => notificationActions.show({
                    type: 'warning',
                    title: 'Warning',
                    message: 'This action may have unintended side effects.',
                }),
            },
            {
                title: 'Splash Screen',
                action: () => appActions.showSplashScreen(),
            },
            {
                title: 'Init: Analyze Phase',
                action: () => {
                    initActions.setPhase('ANALYZE');
                    appActions.showInitScreen();
                },
            },
            {
                title: 'Init: Interactive Phase',
                action: () => {
                    initActions.setPhase('INTERACTIVE');
                    appActions.showInitScreen();
                },
            },
            {
                title: 'Init: Finalize Phase',
                action: () => {
                    initActions.setPhase('FINALIZE');
                    appActions.showInitScreen();
                },
            },
            {
                title: 'Dashboard: Listening',
                action: () => {
                    dashboardActions.setStatus('LISTENING');
                    appActions.showDashboardScreen();
                },
            },
            {
                title: 'Dashboard: Confirm Approve',
                action: () => {
                    dashboardActions.startApproveAll();
                    appActions.showDashboardScreen();
                },
            },
            {
                title: 'Dashboard: Approving',
                action: () => {
                    dashboardActions.setStatus('APPROVING');
                    appActions.showDashboardScreen();
                },
            },
            {
                title: 'Dashboard: Expanded View',
                action: () => {
                    dashboardActions.setStatus('LISTENING');
                    dashboardActions.setExpandedTransactionId('1');
                    appActions.showDashboardScreen();
                },
            },
            {
                title: 'Review: Partial Failure (Default)',
                action: () => {
                    reviewActions.load('1');
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Success',
                action: () => {
                    reviewActions.load('2');
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Diff View',
                action: () => {
                    reviewActions.load('1');
                    reviewActions.setBodyView('diff');
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Reasoning View',
                action: () => {
                    reviewActions.load('1', { bodyView: 'reasoning' });
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Copy Mode',
                action: () => {
                    reviewActions.load('1');
                    appActions.showReviewScreen();
                    const tx = useTransactionStore.getState().transactions.find(t => t.id === '1');
                    if (!tx) return;
                    // On load, selected index is 0, so we can assume the first file.
                    const selectedFile = tx.files && tx.files.length > 0
                        ? tx.files[0]
                        : undefined;
                    useCopyStore.getState().actions.openForReview(tx, tx.files || [], selectedFile);
                },
            },
            {
                title: 'Review: Script Output',
                action: () => {
                    reviewActions.load('2');
                    appActions.showReviewScreen();
                    reviewActions.setBodyView('script_output');
                },
            },
            {
                title: 'Review: Bulk Repair',
                action: () => {
                    reviewActions.load('1', { bodyView: 'bulk_repair' });
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Bulk Repair (Navigable)',
                action: () => {
                    reviewActions.load('1', { bodyView: 'bulk_repair', selectedBulkRepairOptionIndex: 1 });
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Bulk Instruct',
                action: () => {
                    reviewActions.load('2'); // Load success case
                    // Reject some files to enable the workflow
                    reviewActions.toggleFileApproval('2-1');
                    reviewActions.toggleFileApproval('2-2');
                    reviewActions.showBulkInstruct();
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Handoff Confirm',
                action: () => {
                    reviewActions.load('1', { bodyView: 'confirm_handoff' });
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review Processing (Success)',
                action: () => {
                    // Use tx '2' which is the success case in prepareTransactionForReview
                    reviewActions.load('2');
                    reviewActions.startApplySimulation('2', 'success');
                },
            },
            {
                title: 'Review Processing (Failure)',
                action: () => {
                    // Use tx '1' which is the failure case in prepareTransactionForReview
                    reviewActions.load('1');
                    reviewActions.startApplySimulation('1', 'failure');
                },
            },
            {
                title: 'Git Commit Screen',
                action: () => {
                    commitActions.prepareCommitScreen();
                    appActions.showGitCommitScreen();
                },
            },
            {
                title: 'Git Commit Screen (Failure State)',
                action: () => {
                    commitActions.prepareCommitScreen();
                    appActions.showGitCommitScreen();
                    // Fire-and-forget, the UI will update from the store
                    commitActions.commit(true);
                },
            },
            {
                title: 'Git Commit: Copy Mode',
                action: () => {
                    commitActions.prepareCommitScreen();
                    appActions.showGitCommitScreen();
                    const transactionsToCommit = selectTransactionsByStatus('APPLIED')(useTransactionStore.getState());
                    const { finalCommitMessage } = useCommitStore.getState();
                    const items = CopyService.getCopyItemsForCommit(
                        transactionsToCommit,
                        finalCommitMessage,
                    );
                    useCopyStore.getState().actions.open('Select data to copy from commit:', items);
                },
            },
            {
                title: 'Transaction Detail Screen',
                action: () => {
                    // The dashboard store has transactions, we'll just pick one.
                    detailActions.load('3'); // 'feat: implement new dashboard UI'
                    appActions.showTransactionDetailScreen();
                },
            },
            {
                title: 'Detail: Copy Mode',
                action: () => {
                    detailActions.load('3');
                    appActions.showTransactionDetailScreen();
                    const tx = useTransactionStore.getState().transactions.find(t => t.id === '3');
                    if (!tx) return;
                    const selectedFile = tx.files?.[0];
                    useCopyStore.getState().actions.openForDetail(tx, selectedFile);
                },
            },
            {
                title: 'Detail: Diff View (for File Open action)',
                action: () => {
                    detailActions.load('3', {
                        focusedItemPath: 'FILES/3-1',
                        bodyView: 'DIFF_VIEW',
                        expandedItemPaths: new Set(['FILES']),
                    });
                    appActions.showTransactionDetailScreen();
                },
            },
            {
                title: 'Detail: Revert Confirm',
                action: () => {
                    detailActions.load('3', { bodyView: 'REVERT_CONFIRM' });
                    appActions.showTransactionDetailScreen();
                },
            },
            {
                title: 'Transaction History Screen',
                action: () => {
                    historyActions.load();
                    appActions.showTransactionHistoryScreen();
                },
            },
            {
                title: 'History: L1 Drilldown (Content)',
                action: () => {
                    historyActions.prepareDebugState('l1-drill-content');
                    appActions.showTransactionHistoryScreen();
                },
            },
            {
                title: 'History: L2 Drilldown (Reasoning)',
                action: () => {
                    historyActions.prepareDebugState('l2-drill-reasoning');
                    appActions.showTransactionHistoryScreen();
                },
            },
            {
                title: 'History: L2 Drilldown (for File Open action)',
                action: () => {
                    historyActions.prepareDebugState('l2-drill-diff');
                    appActions.showTransactionHistoryScreen();
                },
            },
            {
                title: 'History: Filter Mode',
                action: () => {
                    historyActions.prepareDebugState('filter');
                    appActions.showTransactionHistoryScreen();
                },
            },
            {
                title: 'History: Copy Mode',
                action: () => {
                    historyActions.prepareDebugState('copy');
                    appActions.showTransactionHistoryScreen();
                    const { transactions } = useTransactionStore.getState();
                    const { selectedForAction } = useHistoryStore.getState();
                    const txsToCopy = transactions.filter(tx => selectedForAction.has(tx.id));
                    useCopyStore.getState().actions.openForHistory(txsToCopy);
                },
            },
            {
                title: 'History: Bulk Actions Mode',
                action: () => {
                    historyActions.prepareDebugState('bulk');
                    appActions.showTransactionHistoryScreen();
                },
            },
        ];
        return { menuItems };
    };


    export const useDebugMenu = () => {
        const [selectedIndex, setSelectedIndex] = useState(0);
        const { menuItems } = useDebugMenuActions();

        const { viewOffset, viewportHeight } = useViewport({
            selectedIndex,
            itemCount: menuItems.length,
            layoutConfig: UI_CONFIG.layout.debugMenu,
        });
        
        useInput((input, key) => {
            if (key.upArrow) {
                setSelectedIndex(i => moveIndex(i, 'up', menuItems.length));
                return;
            }
            if (key.downArrow) {
                setSelectedIndex(i => moveIndex(i, 'down', menuItems.length));
                return;
            }
            if (key.pageUp) {
                setSelectedIndex(i => Math.max(0, i - viewportHeight));
                return;
            }
            if (key.pageDown) {
                setSelectedIndex(i => Math.min(menuItems.length - 1, i + viewportHeight));
                return;
            }
            if (key.return) {
                const item = menuItems[selectedIndex];
                if (item) {
                    useViewStore.getState().actions.setActiveOverlay(OVERLAYS.NONE);
                    item.action();
                }
                return;
            }
            if (key.escape) {
                useViewStore.getState().actions.setActiveOverlay(OVERLAYS.NONE);
                return;
            }

            // No ctrl/meta keys for selection shortcuts, and only single characters
            if (key.ctrl || key.meta || input.length !== 1) return;

            if (input >= '1' && input <= '9') {
                const targetIndex = parseInt(input, 10) - 1;
                if (targetIndex < menuItems.length) {
                    setSelectedIndex(targetIndex);
                }
            } else if (input.toLowerCase() >= 'a' && input.toLowerCase() <= 'z') {
                const targetIndex = 9 + (input.toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0));
                if (targetIndex < menuItems.length) {
                    setSelectedIndex(targetIndex);
                }
            }
        }, { isActive: useViewStore.getState().activeOverlay === OVERLAYS.DEBUG });

        const menuItemsInView = menuItems.slice(viewOffset, viewOffset + viewportHeight);

        return {
            selectedIndex,
            menuItems: menuItemsInView,
            viewOffset,
            totalItems: menuItems.length,
        };
    };
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 206
