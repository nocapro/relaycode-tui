uuid: c32eb34d-a513-44f3-80b6-39f5c40026e6
projectId: relaycode-tui
createdAt: '2025-09-22T00:15:34.181Z'
gitCommitMsg: >-
  feat(review): implement live patch application simulation screen

  Introduces a new "APPLYING" state to the review screen workflow, which
  displays a live, step-by-step simulation of the patch application process.

  - Updates `review.store.ts` to manage the application state, including steps,
  statuses, and timings. - Implements an async `startApplySimulation` action to
  drive the UI changes for both success and failure scenarios. - Modifies
  `ReviewScreen.tsx` to render the simulation view when in the "APPLYING" state,
  before transitioning to the interactive review panel. - The simulation view
  accurately reflects the visual style and information described in the
  specification documents. - Added '1' and '2' keybindings to switch between
  success and failure simulations for demonstration purposes.
promptSummary: >-
  Implement the patch application simulation screen as described in the
  documentation.
reasoning:
  - >-
    Here are the modifications to simulate the patch application process in the
    review screen.
  - >-
    I will start by updating the `review.store.ts` to manage the state of the
    live application simulation. This includes defining the steps, their
    statuses, and an action to run the simulation.
  - >-
    Next, I'll update the `ReviewScreen.tsx` component to display the live
    application process before showing the interactive review panel. This new
    view will use the state from the store and render the step-by-step progress.
  - '---'
operations:
  - type: write
    path: src/stores/review.store.ts
    content: >+
      --- src/stores/review.store.ts

      +++ src/stores/review.store.ts

      @@ -1,4 +1,5 @@
       import { create } from 'zustand';
      +import { sleep } from '../utils';
       
       // --- Types ---
       
      @@ -18,7 +19,26 @@
           output: string;
       }
       
      -export type BodyView = 'diff' | 'reasoning' | 'script_output' |
      'copy_mode' | 'bulk_repair' | 'none';

      +export type ApplicationStatus = 'APPLYING' | 'REVIEWING';

      +

      +export interface ApplyStep {

      +    id: string;

      +    title: string;

      +    status: 'pending' | 'active' | 'done' | 'failed' | 'skipped';

      +    details?: string;

      +    substeps?: ApplyStep[];

      +    duration?: number;

      +}

      +

      +const initialApplySteps: ApplyStep[] = [

      +    { id: 'snapshot', title: 'Reading initial file snapshot...', status:
      'pending' },

      +    { id: 'memory', title: 'Applying operations to memory...', status:
      'pending', substeps: [] },

      +    { id: 'post-command', title: 'Running post-command script...',
      status: 'pending', substeps: [] },

      +    { id: 'linter', title: 'Analyzing changes with linter...', status:
      'pending', substeps: [] },

      +];

      +

      +

      +export type BodyView = 'diff' | 'reasoning' | 'script_output' |
      'copy_mode' | 'bulk_repair' | 'none';
       export type PatchStatus = 'SUCCESS' | 'PARTIAL_FAILURE';
       
       interface ReviewState {
      @@ -35,6 +55,8 @@
           scripts: ScriptResult[];
       
           // UI State
      +    applicationStatus: ApplicationStatus;

      +    applySteps: ApplyStep[];
           selectedItemIndex: number; // Can be file or script
           bodyView: BodyView;
           isDiffExpanded: boolean;
      @@ -57,6 +79,7 @@
               expandDiff: () => void;
               approve: () => void;
               simulateSuccessScenario: () => void;
      +        startApplySimulation: (scenario: 'success' | 'failure') => void;
               simulateFailureScenario: () => void;
               
               // Copy Mode Actions
      @@ -154,6 +177,8 @@
           scripts: [], // Empty for partial failure scenario
       
           // UI State
      +    applicationStatus: 'REVIEWING',

      +    applySteps: initialApplySteps,
           selectedItemIndex: 0, // Start with first file
           bodyView: 'none',
           isDiffExpanded: false,
      @@ -215,6 +240,84 @@
               }),
               expandDiff: () => set(state => ({ isDiffExpanded: !state.isDiffExpanded })),
               approve: () => { /* NOP for now, would trigger commit and screen change */ },
      +        startApplySimulation: async (scenario: 'success' | 'failure') =>
      {

      +            set({ applicationStatus: 'APPLYING', applySteps:
      JSON.parse(JSON.stringify(initialApplySteps)) });

      +            

      +            const updateStep = (id: string, status: ApplyStep['status'],
      duration?: number, details?: string) => {

      +                set(state => ({

      +                    applySteps: state.applySteps.map(s => {

      +                        if (s.id === id) {

      +                            const newStep = { ...s, status };

      +                            if (duration !== undefined) newStep.duration
      = duration;

      +                            if (details !== undefined) newStep.details =
      details;

      +                            return newStep;

      +                        }

      +                        return s;

      +                    })

      +                }));

      +            };

      +    

      +            const addSubstep = (parentId: string, substep:
      Omit<ApplyStep, 'substeps'>) => {

      +                 set(state => ({

      +                    applySteps: state.applySteps.map(s => {

      +                        if (s.id === parentId) {

      +                            const newSubsteps = [...(s.substeps || []),
      substep as ApplyStep];

      +                            return { ...s, substeps: newSubsteps };

      +                        }

      +                        return s;

      +                    })

      +                }));

      +            };

      +    

      +            if (scenario === 'success') {

      +               
      useReviewStore.getState().actions.simulateSuccessScenario();

      +                

      +                updateStep('snapshot', 'active'); await sleep(100);

      +                updateStep('snapshot', 'done', 0.1);

      +    

      +                updateStep('memory', 'active'); await sleep(100);

      +                addSubstep('memory', { id: 's1', title: '[✓] write:
      src/core/clipboard.ts (strategy: replace)', status: 'done' });

      +                await sleep(100);

      +                addSubstep('memory', { id: 's2', title: '[✓] write:
      src/utils/shell.ts (strategy: standard-diff)', status: 'done' });

      +                updateStep('memory', 'done', 0.3);

      +    

      +                updateStep('post-command', 'active'); await sleep(1300);

      +                addSubstep('post-command', { id: 's3', title: '`bun run
      test` ... Passed', status: 'done' });

      +                updateStep('post-command', 'done', 2.3);

      +    

      +                updateStep('linter', 'active'); await sleep(1200);

      +                addSubstep('linter', { id: 's4', title: '`bun run lint`
      ... 0 Errors', status: 'done' });

      +                updateStep('linter', 'done', 1.2);

      +    

      +                await sleep(500);

      +    

      +            } else { // failure scenario

      +               
      useReviewStore.getState().actions.simulateFailureScenario();

      +                

      +                updateStep('snapshot', 'active'); await sleep(100);

      +                updateStep('snapshot', 'done', 0.1);

      +    

      +                updateStep('memory', 'active'); await sleep(100);

      +                addSubstep('memory', { id: 'f1', title: '[✓] write:
      src/core/transaction.ts (strategy: replace)', status: 'done' });

      +                await sleep(100);

      +                addSubstep('memory', { id: 'f2', title: '[!] failed:
      src/utils/logger.ts (Hunk #1 failed to apply)', status: 'failed' });

      +                await sleep(100);

      +                addSubstep('memory', { id: 'f3', title: '[!] failed:
      src/commands/apply.ts (Context mismatch at line 92)', status: 'failed' });

      +                updateStep('memory', 'done', 0.5);

      +    

      +                await sleep(100);

      +                updateStep('post-command', 'skipped', undefined, 'Skipped
      due to patch application failure');

      +                await sleep(100);

      +                updateStep('linter', 'skipped', undefined, 'Skipped due
      to patch application failure');

      +                

      +                await sleep(500);

      +            }

      +    

      +            set({ applicationStatus: 'REVIEWING' });

      +        },
               simulateSuccessScenario: () => set(() => ({
                   hash: '4b9d8f03',
                   message: 'refactor: simplify clipboard logic',

    patchStrategy: standard-diff
  - type: write
    path: src/components/ReviewScreen.tsx
    content: >+
      --- src/components/ReviewScreen.tsx

      +++ src/components/ReviewScreen.tsx

      @@ -1,5 +1,5 @@

      -import React, { useMemo } from 'react';

      +import React, { useMemo, useEffect } from 'react';
       import { Box, Text, useInput, useApp } from 'ink';
      -import { useReviewStore, type FileItem, type ScriptResult } from
      '../stores/review.store';

      +import { useReviewStore, type FileItem, type ScriptResult, type ApplyStep
      } from '../stores/review.store';
       import { useAppStore } from '../stores/app.store';
       import Separator from './Separator';
       import DiffScreen from './DiffScreen';
      @@ -88,11 +88,48 @@
           );
       };
       
      +// --- Application simulation components ---

      +

      +const ApplyStepRow = ({ step, isSubstep = false }: { step: ApplyStep,
      isSubstep?: boolean }) => {

      +    if (isSubstep) {

      +        let color;

      +        if (step.status === 'done' && step.title.startsWith('[✓]')) color
      = 'green';

      +        if (step.status === 'failed') color = 'red';

      +

      +        return (

      +            <Text color={color}>

      +                {'     └─ '}{step.title}

      +            </Text>

      +        );

      +    }

      +

      +    let symbol;

      +    let color;

      +    switch (step.status) {

      +        case 'pending': symbol = '( )'; break;

      +        case 'active': symbol = '(●)'; color = 'cyan'; break;

      +        case 'done': symbol = '[✓]'; color = 'green'; break;

      +        case 'failed': symbol = '[!]'; color = 'red'; break;

      +        case 'skipped': symbol = '(-)'; color = 'gray'; break;

      +    }

      +

      +    return (

      +        <Box flexDirection="column">

      +            <Text>

      +                <Text color={color}>{symbol}</Text> {step.title}
      {step.duration && !isSubstep && `(${step.duration}s)`}

      +            </Text>

      +            {step.details && (

      +                <Text color="gray">

      +                    {'     └─ '}{step.details}

      +                </Text>

      +            )}

      +            {step.substeps?.map((sub, i) => (

      +                <ApplyStepRow key={i} step={sub} isSubstep={true} />

      +            ))}

      +        </Box>

      +    );

      +};

      +
       // --- Main Component ---
       
       const ReviewScreen = () => {
      @@ -102,12 +139,13 @@
           const {
               hash, message, prompt, reasoning, files, scripts, patchStatus,
               linesAdded, linesRemoved, duration,
      -        selectedItemIndex, bodyView, isDiffExpanded,

      +        selectedItemIndex, bodyView, isDiffExpanded, applicationStatus,
      applySteps,
               copyModeSelectedIndex, copyModeLastCopied, reasoningScrollIndex, scriptErrorIndex,
           } = store;
           const {
               moveSelectionUp, moveSelectionDown, toggleFileApproval,
               toggleDiffView, toggleReasoningView, toggleScriptView, expandDiff,
      +        startApplySimulation,
               rejectAllFiles, approve,
               toggleCopyMode, moveCopySelectionUp, moveCopySelectionDown, copySelectedItem,
               copyUUID, copyMessage, copyPrompt, copyReasoning, copyFileDiff, copyAllDiffs,
      @@ -118,8 +156,26 @@
           const numFiles = files.length;
           const approvedFilesCount = useMemo(() => files.filter(f => f.status === 'APPROVED').length, [files]);
           const canBeRejected = useMemo(() => files.some(f => f.status === 'APPROVED'), [files]);
      -    

      +

      +    useEffect(() => {

      +        // Start with a failure simulation on mount

      +        startApplySimulation('failure');

      +    }, [startApplySimulation]);

      +
           useInput((input, key) => {
      +        if (applicationStatus === 'REVIEWING') {

      +             // Allow switching between simulations for demo purposes

      +            if (input === '1') {

      +                startApplySimulation('success');

      +                return;

      +            }

      +            if (input === '2') {

      +                startApplySimulation('failure');

      +                return;

      +            }

      +        } else {

      +            return; // Disable input during application

      +        }

      +
               if (input.toLowerCase() === 'q') exit();
       
               // Handle Escape key - context-sensitive behavior
      @@ -434,6 +490,29 @@
               return null;
           };
       
      +    const renderApplyScreen = () => {

      +        const totalDuration = applySteps.reduce((acc, step) => acc +
      (step.duration || 0), 0);

      +        const failureCase = patchStatus === 'PARTIAL_FAILURE';

      +        const footerText = failureCase

      +            ? `Elapsed: ${totalDuration.toFixed(1)}s · Transitioning to
      repair workflow...`

      +            : `Elapsed: ${totalDuration.toFixed(1)}s · Processing...
      Please wait.`;

      +

      +        return (

      +            <Box flexDirection="column">

      +                <Text color="cyan">▲ relaycode apply</Text>

      +                <Separator />

      +                <Box marginY={1}>

      +                    <Text>Applying patch {hash}... ({message})</Text>

      +                    <Box flexDirection="column" marginTop={1} gap={1}>

      +                        {applySteps.map(step => <ApplyStepRow
      key={step.id} step={step} />)}

      +                    </Box>

      +                </Box>

      +                <Separator />

      +                <Text>{footerText}</Text>

      +            </Box>

      +        );

      +    };

      +
           const renderFooter = () => {
               // Contextual footer for body views
               if (bodyView === 'diff') {
      @@ -491,6 +570,10 @@
               return <Text>{actions.join(' · ')}</Text>;
           };
       
      +    if (applicationStatus === 'APPLYING') {

      +        return renderApplyScreen();

      +    }

      +
           return (
               <Box flexDirection="column">
                   {/* Header */}

    patchStrategy: standard-diff
snapshot:
  src/stores/review.store.ts: >-
    import { create } from 'zustand';


    // --- Types ---


    export type FileStatus = 'FAILED' | 'APPROVED' | 'REJECTED';

    export interface FileItem {
        id: string;
        path: string;
        status: FileStatus;
        diff: string;
        linesAdded: number;
        linesRemoved: number;
        error?: string;
        strategy: 'replace' | 'standard-diff';
    }


    export interface ScriptResult {
        command: string;
        success: boolean;
        duration: number;
        summary: string;
        output: string;
    }


    export type BodyView = 'diff' | 'reasoning' | 'script_output' | 'copy_mode'
    | 'bulk_repair' | 'none';

    export type PatchStatus = 'SUCCESS' | 'PARTIAL_FAILURE';


    interface ReviewState {
        // Transaction Info
        hash: string;
        message: string;
        prompt: string;
        reasoning: string;
        linesAdded: number;
        linesRemoved: number;
        duration: number;
        patchStatus: PatchStatus;

        // File & Script Info
        files: FileItem[];
        scripts: ScriptResult[];

        // UI State
        selectedItemIndex: number; // Can be file or script
        bodyView: BodyView;
        isDiffExpanded: boolean;
        
        // Copy Mode State
        copyModeSelectedIndex: number;
        copyModeLastCopied: string | null;
        
        // Reasoning Scroll State
        reasoningScrollIndex: number;
        
        // Script Navigation State
        scriptErrorIndex: number;

        actions: {
            moveSelectionUp: () => void;
            moveSelectionDown: () => void;
            toggleFileApproval: () => void;
            rejectAllFiles: () => void;
            toggleDiffView: () => void;
            toggleReasoningView: () => void;
            toggleScriptView: () => void;
            expandDiff: () => void;
            approve: () => void;
            simulateSuccessScenario: () => void;
            simulateFailureScenario: () => void;
            
            // Copy Mode Actions
            toggleCopyMode: () => void;
            moveCopySelectionUp: () => void;
            moveCopySelectionDown: () => void;
            copySelectedItem: () => void;
            copyUUID: () => void;
            copyMessage: () => void;
            copyPrompt: () => void;
            copyReasoning: () => void;
            copyFileDiff: () => void;
            copyAllDiffs: () => void;
            
            // Repair Actions
            tryRepairFile: () => void;
            showBulkRepair: () => void;
            executeBulkRepairOption: (option: number) => void;
            
            // Navigation Actions
            scrollReasoningUp: () => void;
            scrollReasoningDown: () => void;
            navigateScriptErrorUp: () => void;
            navigateScriptErrorDown: () => void;
        };
    }


    // --- Mock Data ---


    const mockFiles: FileItem[] = [
        { 
            id: '1', 
            path: 'src/core/transaction.ts', 
            status: 'APPROVED', 
            linesAdded: 18, 
            linesRemoved: 5, 
            diff: `--- a/src/core/transaction.ts
    +++ b/src/core/transaction.ts

    @@ -15,7 +15,7 @@ export class Transaction {
       }
     
    -  calculateChanges(): ChangeSet {

    +  computeDelta(): ChangeSet {
         return this.changes;
       }
     }`, 
            strategy: 'replace', 
        },
        { 
            id: '2', 
            path: 'src/utils/logger.ts', 
            status: 'FAILED', 
            linesAdded: 0, 
            linesRemoved: 0, 
            diff: '', 
            error: 'Hunk #1 failed to apply', 
            strategy: 'standard-diff', 
        },
        { 
            id: '3', 
            path: 'src/commands/apply.ts', 
            status: 'FAILED', 
            linesAdded: 0, 
            linesRemoved: 0, 
            diff: '', 
            error: 'Context mismatch at line 92', 
            strategy: 'standard-diff', 
        },
    ];


    const mockScripts: ScriptResult[] = [
        { command: 'bun run test', success: true, duration: 2.3, summary: 'Passed (37 tests)', output: '... test output ...' },
        { command: 'bun run lint', success: false, duration: 1.2, summary: '1 Error, 3 Warnings', output: `src/core/clipboard.ts
      45:12  Error    'clipboardy' is assigned a value but never used. (@typescript-eslint/no-unused-vars)
      88:5   Warning  Unexpected console statement. (no-console)` },
    ];


    const mockReasoning = `1. Identified a potential uncaught exception in the
    \`restoreSnapshot\` function
       if a file operation fails midway through a loop of many files. This could
       leave the project in a partially-reverted, inconsistent state.

    2. Wrapped the file restoration loop in a \`Promise.all\` and added a
    dedicated
       error collection array. This ensures that all file operations are
       attempted and that a comprehensive list of failures is available
       afterward for better error reporting or partial rollback logic.`;

    // --- Store Implementation ---


    export const useReviewStore = create<ReviewState>((set) => ({
        // Transaction Info
        hash: 'e4a7c112',
        message: 'refactor: rename core utility function',
        prompt: 'Rename the `calculateChanges` utility to `computeDelta` across all files and update imports accordingly.',
        reasoning: mockReasoning,
        linesAdded: 18,
        linesRemoved: 5,
        duration: 0.6,
        patchStatus: 'PARTIAL_FAILURE',

        // File & Script Info
        files: mockFiles,
        scripts: [], // Empty for partial failure scenario

        // UI State
        selectedItemIndex: 0, // Start with first file
        bodyView: 'none',
        isDiffExpanded: false,
        
        // Copy Mode State
        copyModeSelectedIndex: 0,
        copyModeLastCopied: null,
        
        // Reasoning Scroll State
        reasoningScrollIndex: 0,
        
        // Script Navigation State
        scriptErrorIndex: 0,

        actions: {
            moveSelectionUp: () => set(state => ({
                selectedItemIndex: Math.max(0, state.selectedItemIndex - 1),
            })),
            moveSelectionDown: () => set(state => ({
                selectedItemIndex: Math.min(state.files.length + state.scripts.length - 1, state.selectedItemIndex + 1),
            })),
            toggleFileApproval: () => set(state => {
                const { selectedItemIndex, files } = state;
                if (selectedItemIndex >= files.length) return {}; // Not a file
                
                const newFiles = [...files];
                const file = newFiles[selectedItemIndex];
                if (file) {
                    if (file.status === 'APPROVED') {
                        file.status = 'REJECTED';
                    } else if (file.status === 'REJECTED') {
                        file.status = 'APPROVED';
                    }
                }
                return { files: newFiles };
            }),
            rejectAllFiles: () => set(state => {
                const newFiles = state.files.map(file => {
                    if (file.status === 'APPROVED') {
                        return { ...file, status: 'REJECTED' as const };
                    }
                    return file;
                });
                return { files: newFiles };
            }),
            toggleDiffView: () => set(state => {
                const { bodyView } = state;
                if (state.selectedItemIndex >= state.files.length) return {}; // Can't show diff for scripts
                return {
                    bodyView: bodyView === 'diff' ? 'none' : 'diff',
                    isDiffExpanded: false, // Always start collapsed
                };
            }),
            toggleReasoningView: () => set(state => {
                const { bodyView } = state;
                return {
                    bodyView: bodyView === 'reasoning' ? 'none' : 'reasoning',
                };
            }),
            toggleScriptView: () => set(state => {
                const { bodyView } = state;
                return {
                    bodyView: bodyView === 'script_output' ? 'none' : 'script_output',
                };
            }),
            expandDiff: () => set(state => ({ isDiffExpanded: !state.isDiffExpanded })),
            approve: () => { /* NOP for now, would trigger commit and screen change */ },
            simulateSuccessScenario: () => set(() => ({
                hash: '4b9d8f03',
                message: 'refactor: simplify clipboard logic',
                prompt: 'Simplify the clipboard logic using an external library...',
                linesAdded: 22,
                linesRemoved: 11,
                duration: 3.9,
                patchStatus: 'SUCCESS' as const,
                files: [
                    { 
                        id: '1', 
                        path: 'src/core/clipboard.ts', 
                        status: 'APPROVED' as const, 
                        linesAdded: 15, 
                        linesRemoved: 8, 
                        diff: `--- a/src/core/clipboard.ts
    +++ b/src/core/clipboard.ts

    @@ -1,5 +1,6 @@
     import { copy as copyToClipboard } from 'clipboardy';`, 
                        strategy: 'replace' as const,
                    },
                    { 
                        id: '2', 
                        path: 'src/utils/shell.ts', 
                        status: 'APPROVED' as const, 
                        linesAdded: 7, 
                        linesRemoved: 3, 
                        diff: `--- a/src/utils/shell.ts
    +++ b/src/utils/shell.ts`, 
                        strategy: 'standard-diff' as const,
                    },
                ],
                scripts: mockScripts,
                selectedItemIndex: 0,
                bodyView: 'none' as const,
            })),
            simulateFailureScenario: () => set(() => ({
                hash: 'e4a7c112',
                message: 'refactor: rename core utility function',
                prompt: 'Rename the `calculateChanges` utility to `computeDelta` across all files and update imports accordingly.',
                linesAdded: 18,
                linesRemoved: 5,
                duration: 0.6,
                patchStatus: 'PARTIAL_FAILURE' as const,
                files: mockFiles,
                scripts: [],
                selectedItemIndex: 0,
                bodyView: 'none' as const,
            })),
            
            // Copy Mode Actions
            toggleCopyMode: () => set(state => ({
                bodyView: state.bodyView === 'copy_mode' ? 'none' : 'copy_mode',
                copyModeSelectedIndex: 0,
                copyModeLastCopied: null,
            })),
            moveCopySelectionUp: () => set(state => ({
                copyModeSelectedIndex: Math.max(0, state.copyModeSelectedIndex - 1),
            })),
            moveCopySelectionDown: () => set(state => ({
                copyModeSelectedIndex: Math.min(5, state.copyModeSelectedIndex + 1), // 6 total options (U,M,P,R,F,A)
            })),
            copySelectedItem: () => set(state => {
                const { copyModeSelectedIndex, hash, message, prompt, reasoning, files, selectedItemIndex } = state;
                let content = '';
                let label = '';
                
                switch (copyModeSelectedIndex) {
                    case 0: // UUID
                        content = `${hash}-a8b3-4f2c-9d1e-8a7c1b9d8f03`;
                        label = 'UUID';
                        break;
                    case 1: // Git Message
                        content = message;
                        label = 'Git Message';
                        break;
                    case 2: // Prompt
                        content = prompt;
                        label = 'Prompt';
                        break;
                    case 3: // Reasoning
                        content = reasoning;
                        label = 'Reasoning';
                        break;
                    case 4: // Diff for current file
                        if (selectedItemIndex < files.length) {
                            content = files[selectedItemIndex].diff;
                            label = `Diff for ${files[selectedItemIndex].path}`;
                        }
                        break;
                    case 5: // All Diffs
                        content = files.map(f => `--- FILE: ${f.path} ---\n${f.diff}`).join('\n\n');
                        label = 'All Diffs';
                        break;
                }
                
                // Mock clipboard operation (TUI environment - no real clipboard)
                console.log(`[CLIPBOARD] Copied ${label}: ${content.substring(0, 100)}...`);
                
                return { copyModeLastCopied: label };
            }),
            copyUUID: () => set(state => {
                const content = `${state.hash}-a8b3-4f2c-9d1e-8a7c1b9d8f03`;
                console.log(`[CLIPBOARD] Copied UUID: ${content}`);
                return { copyModeLastCopied: 'UUID' };
            }),
            copyMessage: () => set(state => {
                console.log(`[CLIPBOARD] Copied Git Message: ${state.message}`);
                return { copyModeLastCopied: 'Git Message' };
            }),
            copyPrompt: () => set(state => {
                console.log(`[CLIPBOARD] Copied Prompt: ${state.prompt.substring(0, 100)}...`);
                return { copyModeLastCopied: 'Prompt' };
            }),
            copyReasoning: () => set(state => {
                console.log(`[CLIPBOARD] Copied Reasoning: ${state.reasoning.substring(0, 100)}...`);
                return { copyModeLastCopied: 'Reasoning' };
            }),
            copyFileDiff: () => set(state => {
                if (state.selectedItemIndex < state.files.length) {
                    const file = state.files[state.selectedItemIndex];
                    console.log(`[CLIPBOARD] Copied diff for: ${file.path}`);
                    return { copyModeLastCopied: `Diff for ${file.path}` };
                }
                return {};
            }),
            copyAllDiffs: () => set(state => {
                const content = state.files.map(f => `--- FILE: ${f.path} ---\n${f.diff}`).join('\n\n');
                console.log(`[CLIPBOARD] Copied all diffs: ${state.files.length} files`);
                return { copyModeLastCopied: 'All Diffs' };
            }),
            
            // Repair Actions
            tryRepairFile: () => set(state => {
                const { selectedItemIndex, files } = state;
                if (selectedItemIndex < files.length) {
                    const file = files[selectedItemIndex];
                    if (file.status === 'FAILED') {
                        // Generate repair prompt and copy to clipboard
                        const repairPrompt = `The patch failed to apply to ${file.path}. Please generate a corrected patch.

    Error: ${file.error}

    Strategy: ${file.strategy}


    ORIGINAL CONTENT:

    ---

    // ... original file content would be here ...

    ---


    FAILED PATCH:

    ---

    ${file.diff || '// ... failed diff would be here ...'}

    ---


    Please provide a corrected patch that addresses the error.`;
                        
                        console.log(`[CLIPBOARD] Copied repair prompt for: ${file.path}`);
                        
                        // Mock: Update file status to show it's being repaired
                        const newFiles = [...files];
                        newFiles[selectedItemIndex] = { ...file, status: 'APPROVED' as const, error: undefined, linesAdded: 5, linesRemoved: 2 };
                        
                        return { files: newFiles, copyModeLastCopied: 'Repair prompt copied to clipboard' };
                    }
                }
                return {};
            }),
            showBulkRepair: () => set(() => ({
                bodyView: 'bulk_repair' as const,
            })),
            executeBulkRepairOption: (option: number) => set(state => {
                switch (option) {
                    case 1: {
                        // Copy Bulk Re-apply Prompt
                        const failedFiles = state.files.filter(f => f.status === 'FAILED');
                        const bulkPrompt = `The previous patch failed to apply to MULTIPLE files. Please generate a new, corrected patch that addresses all the files listed below.

    IMPORTANT: The response MUST contain a complete code block for EACH file
    that needs to be fixed.


    ${failedFiles.map(file => `--- FILE: ${file.path} ---

    Strategy: ${file.strategy}

    Error: ${file.error}


    ORIGINAL CONTENT:

    ---

    // ... original content of ${file.path} ...

    ---


    FAILED PATCH:

    ---

    ${file.diff || '// ... failed diff ...'}

    ---

    `).join('\n')}


    Please analyze all failed files and provide a complete, corrected
    response.`;
                        
                        console.log(`[CLIPBOARD] Copied bulk repair prompt for ${failedFiles.length} files`);
                        return { bodyView: 'none' as const, copyModeLastCopied: 'Bulk repair prompt copied' };
                    }
                        
                    case 2: {
                        // Bulk Change Strategy & Re-apply
                        // Mock: Change all failed files to 'replace' strategy and mark as successful
                        const newFiles = state.files.map(file => 
                            file.status === 'FAILED' 
                                ? { ...file, status: 'APPROVED' as const, strategy: 'replace' as const, error: undefined, linesAdded: 3, linesRemoved: 1 }
                                : file,
                        );
                        return { files: newFiles, bodyView: 'none' as const };
                    }
                        
                    case 3: {
                        // Handoff to External Agent
                        // Mock: Generate handoff prompt
                        const failedFiles = state.files.filter(f => f.status === 'FAILED');
                        const handoffPrompt = `# Relaycode Handoff: Failed Patch Application

    The following files failed to apply and require manual intervention:


    ${failedFiles.map(file => `## ${file.path}

    - Error: ${file.error}

    - Strategy: ${file.strategy}

    `).join('\n')}


    Please resolve these issues and provide updated patches.`;
                        
                        console.log(`[CLIPBOARD] Copied handoff prompt for ${failedFiles.length} files`);
                        return { bodyView: 'none' as const, copyModeLastCopied: 'Handoff prompt copied' };
                    }
                        
                    case 4: {
                        // Bulk Abandon All Failed Files
                        const abandonedFiles = state.files.map(file => 
                            file.status === 'FAILED' 
                                ? { ...file, status: 'REJECTED' as const }
                                : file,
                        );
                        return { files: abandonedFiles, bodyView: 'none' as const };
                    }
                        
                    default:
                        return { bodyView: 'none' as const };
                }
            }),
            
            // Navigation Actions
            scrollReasoningUp: () => set(state => ({
                reasoningScrollIndex: Math.max(0, state.reasoningScrollIndex - 1),
            })),
            scrollReasoningDown: () => set(state => {
                const maxLines = state.reasoning.split('\n').length;
                return { reasoningScrollIndex: Math.min(maxLines - 1, state.reasoningScrollIndex + 1) };
            }),
            navigateScriptErrorUp: () => set(state => ({
                scriptErrorIndex: Math.max(0, state.scriptErrorIndex - 1),
            })),
            navigateScriptErrorDown: () => set(state => {
                const selectedScript = state.scripts[state.selectedItemIndex - state.files.length];
                if (selectedScript && selectedScript.output) {
                    const errorLines = selectedScript.output.split('\n').filter(line => 
                        line.includes('Error') || line.includes('Warning'),
                    );
                    return { scriptErrorIndex: Math.min(errorLines.length - 1, state.scriptErrorIndex + 1) };
                }
                return {};
            }),
        },
    }));
  src/components/ReviewScreen.tsx: >-
    import React, { useMemo } from 'react';

    import { Box, Text, useInput, useApp } from 'ink';

    import { useReviewStore, type FileItem, type ScriptResult } from
    '../stores/review.store';

    import { useAppStore } from '../stores/app.store';

    import Separator from './Separator';

    import DiffScreen from './DiffScreen';

    import ReasonScreen from './ReasonScreen';


    // --- Sub-components ---


    const FileItemRow = ({ file, isSelected }: { file: FileItem, isSelected:
    boolean }) => {
        let icon;
        let iconColor;
        switch (file.status) {
            case 'APPROVED': icon = '[✓]'; iconColor = 'green'; break;
            case 'REJECTED': icon = '[✗]'; iconColor = 'red'; break;
            case 'FAILED': icon = '[!]'; iconColor = 'red'; break;
        }

        const diffStats = `(+${file.linesAdded}/-${file.linesRemoved})`;
        const strategy = file.strategy === 'standard-diff' ? 'diff' : file.strategy;
        const prefix = isSelected ? '> ' : '  ';

        if (file.status === 'FAILED') {
            return (
                <Box>
                    <Text bold={isSelected} color={isSelected ? 'cyan' : undefined}>
                        {prefix}<Text color={iconColor}>{icon} FAILED {file.path}</Text>
                        <Text color="red">    ({file.error})</Text>
                    </Text>
                </Box>
            );
        }

        return (
            <Box>
                <Text bold={isSelected} color={isSelected ? 'cyan' : undefined}>
                    {prefix}<Text color={iconColor}>{icon}</Text> MOD {file.path} {diffStats} [{strategy}]
                </Text>
            </Box>
        );
    };


    const ScriptItemRow = ({
        script,
        isSelected,
        isExpanded,
    }: {
        script: ScriptResult;
        isSelected: boolean;
        isExpanded: boolean;
    }) => {
        const icon = script.success ? '✓' : '✗';
        const iconColor = script.success ? 'green' : 'red';
        const arrow = isExpanded ? '▾' : '▸';
        const prefix = isSelected ? '> ' : '  ';
        
        // Extract script type from command (e.g., "bun run test" -> "Post-Command", "bun run lint" -> "Linter")
        const scriptType = script.command.includes('test') ? 'Post-Command' : 
                          script.command.includes('lint') ? 'Linter' : 
                          'Script';

        return (
            <Box>
                <Text bold={isSelected} color={isSelected ? 'cyan' : undefined}>
                    {prefix}<Text color={iconColor}>{icon}</Text> {scriptType}: `{script.command}` ({script.duration}s) {arrow} {script.summary}
                </Text>
            </Box>
        );
    };


    // --- Main Component ---


    const ReviewScreen = () => {
        const { exit } = useApp();
        const store = useReviewStore();
        const { showDashboardScreen } = useAppStore(s => s.actions);
        const {
            hash, message, prompt, reasoning, files, scripts, patchStatus,
            linesAdded, linesRemoved, duration,
            selectedItemIndex, bodyView, isDiffExpanded,
            copyModeSelectedIndex, copyModeLastCopied, reasoningScrollIndex, scriptErrorIndex,
        } = store;
        const {
            moveSelectionUp, moveSelectionDown, toggleFileApproval,
            toggleDiffView, toggleReasoningView, toggleScriptView, expandDiff,
            rejectAllFiles, approve,
            toggleCopyMode, moveCopySelectionUp, moveCopySelectionDown, copySelectedItem,
            copyUUID, copyMessage, copyPrompt, copyReasoning, copyFileDiff, copyAllDiffs,
            tryRepairFile, showBulkRepair, executeBulkRepairOption,
            scrollReasoningUp, scrollReasoningDown, navigateScriptErrorUp, navigateScriptErrorDown
        } = store.actions;

        const numFiles = files.length;
        const approvedFilesCount = useMemo(() => files.filter(f => f.status === 'APPROVED').length, [files]);
        const canBeRejected = useMemo(() => files.some(f => f.status === 'APPROVED'), [files]);
        
        useInput((input, key) => {
            if (input.toLowerCase() === 'q') exit();

            // Handle Escape key - context-sensitive behavior
            if (key.escape) {
                if (bodyView === 'copy_mode') {
                    toggleCopyMode();
                } else if (bodyView === 'bulk_repair') {
                    showBulkRepair(); // Close bulk repair modal
                } else if (bodyView !== 'none') {
                    if (bodyView === 'diff') toggleDiffView();
                    if (bodyView === 'reasoning') toggleReasoningView();
                    if (bodyView === 'script_output') toggleScriptView();
                } else if (canBeRejected) {
                    rejectAllFiles();
                } else {
                    showDashboardScreen();
                }
                return;
            }

            // Copy Mode Navigation
            if (bodyView === 'copy_mode') {
                if (key.upArrow) moveCopySelectionUp();
                if (key.downArrow) moveCopySelectionDown();
                if (key.return) copySelectedItem();
                
                // Hotkey shortcuts
                if (input.toLowerCase() === 'u') copyUUID();
                if (input.toLowerCase() === 'm') copyMessage();
                if (input.toLowerCase() === 'p') copyPrompt();
                if (input.toLowerCase() === 'r') copyReasoning();
                if (input.toLowerCase() === 'f') copyFileDiff();
                if (input.toLowerCase() === 'a') copyAllDiffs();
                if (input.toLowerCase() === 'c') toggleCopyMode();
                return;
            }

            // Bulk Repair Navigation
            if (bodyView === 'bulk_repair') {
                if (input >= '1' && input <= '4') {
                    executeBulkRepairOption(parseInt(input));
                }
                return;
            }

            // Reasoning Scroll Navigation
            if (bodyView === 'reasoning') {
                if (key.upArrow) scrollReasoningUp();
                if (key.downArrow) scrollReasoningDown();
                if (input.toLowerCase() === 'r') toggleReasoningView();
                return;
            }

            // Script Output Navigation
            if (bodyView === 'script_output') {
                if (input.toLowerCase() === 'j') navigateScriptErrorDown();
                if (input.toLowerCase() === 'k') navigateScriptErrorUp();
                if (key.return) toggleScriptView();
                if (input.toLowerCase() === 'c') {
                    // Copy script output
                    const scriptIndex = selectedItemIndex - numFiles;
                    const selectedScript = scripts[scriptIndex];
                    if (selectedScript) {
                        console.log(`[CLIPBOARD] Copied script output: ${selectedScript.command}`);
                    }
                }
                return;
            }

            // Diff View Navigation
            if (bodyView === 'diff') {
                if (input.toLowerCase() === 'x') expandDiff();
                if (input.toLowerCase() === 'd') toggleDiffView();
                return;
            }

            // Main View Navigation
            if (key.upArrow) moveSelectionUp();
            if (key.downArrow) moveSelectionDown();

            if (input.toLowerCase() === 'r') toggleReasoningView();

            if (input === ' ') {
                if (selectedItemIndex < numFiles) {
                    const file = files[selectedItemIndex];
                    if (file && file.status !== 'FAILED') {
                        toggleFileApproval();
                    }
                }
            }

            if (input.toLowerCase() === 'd') {
                if (selectedItemIndex < numFiles) {
                    toggleDiffView();
                }
            }

            if (key.return) { // Enter key
                 if (selectedItemIndex >= numFiles) { // It's a script
                    toggleScriptView();
                }
            }

            if (input.toLowerCase() === 'a') {
                if (approvedFilesCount > 0) {
                    approve();
                    showDashboardScreen();
                }
            }

            if (input.toLowerCase() === 'c') {
                toggleCopyMode();
            }

            if (input.toLowerCase() === 't') {
                if (selectedItemIndex < numFiles) {
                    const file = files[selectedItemIndex];
                    if (file && file.status === 'FAILED') {
                        tryRepairFile();
                    }
                }
            }

            // Handle Shift+T for bulk repair
            if (key.shift && input.toLowerCase() === 't') {
                const hasFailedFiles = files.some(f => f.status === 'FAILED');
                if (hasFailedFiles) {
                    showBulkRepair();
                }
            }

            if (input.toLowerCase() === 'q') {
                showDashboardScreen();
            }
        });

        const renderBody = () => {
            if (bodyView === 'none') return null;

            if (bodyView === 'reasoning') {
                const reasoningLines = reasoning.split('\n');
                const visibleLines = reasoningLines.slice(reasoningScrollIndex, reasoningScrollIndex + 10);
                return (
                    <Box flexDirection="column">
                        <Text>REASONING DETAILS</Text>
                        <Box marginTop={1}>
                            {visibleLines.map((line, index) => (
                                <Text key={index}>{line}</Text>
                            ))}
                        </Box>
                        {reasoningLines.length > 10 && (
                            <Text color="gray">
                                Showing lines {reasoningScrollIndex + 1}-{Math.min(reasoningScrollIndex + 10, reasoningLines.length)} of {reasoningLines.length}
                            </Text>
                        )}
                    </Box>
                );
            }
            
            if (bodyView === 'diff') {
                const selectedFile = files[selectedItemIndex];
                if (!selectedFile) return null;
                return (
                    <DiffScreen
                        filePath={selectedFile.path}
                        diffContent={selectedFile.diff}
                        isExpanded={isDiffExpanded}
                    />
                );
            }

            if (bodyView === 'script_output') {
                 const scriptIndex = selectedItemIndex - numFiles;
                 const selectedScript = scripts[scriptIndex];
                 if (!selectedScript) return null;
                 
                 const outputLines = selectedScript.output.split('\n');
                 const errorLines = outputLines.filter(line => 
                    line.includes('Error') || line.includes('Warning')
                 );
                 
                 return (
                    <Box flexDirection="column">
                        <Text>{selectedScript.command.includes('lint') ? 'LINTER' : 'SCRIPT'} OUTPUT: `{selectedScript.command}`</Text>
                        <Box marginTop={1}>
                            {outputLines.map((line, index) => {
                                const isError = line.includes('Error');
                                const isWarning = line.includes('Warning');
                                const isHighlighted = errorLines[scriptErrorIndex] === line;
                                
                                return (
                                    <Text 
                                        key={index} 
                                        color={isError ? 'red' : isWarning ? 'yellow' : undefined}
                                        bold={isHighlighted}
                                        backgroundColor={isHighlighted ? 'blue' : undefined}
                                    >
                                        {line}
                                    </Text>
                                );
                            })}
                        </Box>
                        {errorLines.length > 0 && (
                            <Text color="gray">
                                Error {scriptErrorIndex + 1} of {errorLines.length} highlighted
                            </Text>
                        )}
                    </Box>
                 );
            }

            if (bodyView === 'copy_mode') {
                const options = [
                    { key: 'U', label: 'UUID', value: `${hash}-a8b3-4f2c-9d1e-8a7c1b9d8f03` },
                    { key: 'M', label: 'Git Message', value: message },
                    { key: 'P', label: 'Prompt', value: prompt.substring(0, 50) + '...' },
                    { key: 'R', label: 'Reasoning', value: reasoning.substring(0, 50) + '...' },
                    { key: 'F', label: 'Diff for', value: selectedItemIndex < files.length ? files[selectedItemIndex].path : 'N/A' },
                    { key: 'A', label: 'All Diffs', value: `${files.length} files` },
                ];

                return (
                    <Box flexDirection="column">
                        <Text>Select item to copy to clipboard:</Text>
                        <Box marginTop={1} />
                        
                        {options.map((option, index) => (
                            <Text key={option.key} bold={index === copyModeSelectedIndex} color={index === copyModeSelectedIndex ? 'cyan' : undefined}>
                                {index === copyModeSelectedIndex ? '> ' : '  '}
                                [{option.key}] {option.label}: {option.value}
                            </Text>
                        ))}
                        
                        <Box marginTop={1} />
                        {copyModeLastCopied && (
                            <Text color="green">✓ Copied {copyModeLastCopied} to clipboard.</Text>
                        )}
                    </Box>
                );
            }

            if (bodyView === 'bulk_repair') {
                const failedFiles = files.filter(f => f.status === 'FAILED');
                
                return (
                    <Box flexDirection="column">
                        <Text>BULK REPAIR ACTION</Text>
                        <Box marginTop={1} />
                        
                        <Text>The following {failedFiles.length} files failed to apply:</Text>
                        {failedFiles.map(file => (
                            <Text key={file.id}>- {file.path}</Text>
                        ))}
                        
                        <Box marginTop={1} />
                        <Text>How would you like to proceed?</Text>
                        <Box marginTop={1} />
                        
                        <Text>{'> (1) Copy Bulk Re-apply Prompt (for single-shot AI)'}</Text>
                        <Text>  (2) Bulk Change Strategy & Re-apply</Text>
                        <Text>  (3) Handoff to External Agent</Text>
                        <Text>  (4) Bulk Abandon All Failed Files</Text>
                        <Text>  (Esc) Cancel</Text>
                    </Box>
                );
            }
            
            return null;
        };

        const renderFooter = () => {
            // Contextual footer for body views
            if (bodyView === 'diff') {
                return <Text>(↑↓) Nav · (X)pand · (D/Esc) Back</Text>;
            }
            if (bodyView === 'reasoning') {
                return <Text>(↑↓) Scroll · (R/Esc) Back</Text>;
            }
            if (bodyView === 'script_output') {
                return <Text>(↑↓) Nav · (J↓/K↑) Next/Prev Error · (C)opy Output · (Ent/Esc) Back</Text>;
            }
            if (bodyView === 'copy_mode') {
                return <Text>(↑↓) Nav · (Enter) Copy Selected · (U,M,P,R,F,A) Hotkeys · (C, Esc) Exit</Text>;
            }
            if (bodyView === 'bulk_repair') {
                return <Text>Choose an option [1-4, Esc]:</Text>;
            }

            // Main footer
            const actions = ['(↑↓) Nav'];

            const isFileSelected = selectedItemIndex < numFiles;
            const hasFailedFiles = files.some(f => f.status === 'FAILED');
            
            if (isFileSelected) {
                const selectedFile = files[selectedItemIndex];
                if (selectedFile && selectedFile.status !== 'FAILED') {
                    actions.push('(Spc) Toggle');
                }
                actions.push('(D)iff');
                
                // Add repair options for failed files
                if (selectedFile && selectedFile.status === 'FAILED') {
                    actions.push('(T)ry Repair');
                }
            } else { // script selected
                actions.push('(Ent) Expand Details');
            }

            actions.push('(R)easoning');
            
            // Add bulk repair if there are failed files
            if (hasFailedFiles) {
                actions.push('(Shift+T) Bulk Repair');
            }
            
            actions.push('(C)opy');

            if (approvedFilesCount > 0) {
                actions.push('(A)pprove');
            }
            
            actions.push('(Esc) Reject All');
            actions.push('(Q)uit');

            return <Text>{actions.join(' · ')}</Text>;
        };

        return (
            <Box flexDirection="column">
                {/* Header */}
                <Text color="cyan">▲ relaycode review{bodyView === 'copy_mode' ? ' · copy mode' : ''}</Text>
                <Separator />
                
                {/* Navigator Section */}
                <Box flexDirection="column">
                    {/* Transaction summary */}
                    <Box>
                        <Text>{hash} · {message}</Text>
                    </Box>
                    <Box>
                        <Text>(<Text color="green">+{linesAdded}</Text>/<Text color="red">-{linesRemoved}</Text>) · {approvedFilesCount}/{numFiles} Files · {duration}s</Text>
                        {patchStatus === 'PARTIAL_FAILURE' && <Text color="red" bold> · MULTIPLE PATCHES FAILED</Text>}
                        {scripts.length === 0 && patchStatus === 'PARTIAL_FAILURE' && <Text> · Scripts: SKIPPED</Text>}
                    </Box>
                    
                    <Box marginTop={1} />
                    
                    {/* Prompt and Reasoning */}
                    <Text>(P)rompt ▸ {prompt.substring(0, 50)}...</Text>
                    <Text>(R)easoning ({reasoning.split('\n\n').length} steps) {bodyView === 'reasoning' ? '▾' : '▸'} {reasoning.split('\n')[0].substring(0, 50)}...</Text>
                    
                    <Separator/>
                    
                    {/* Script Results (if any) */}
                    {scripts.length > 0 && (
                        <>
                            {scripts.map((script, index) => (
                                <ScriptItemRow 
                                    key={script.command} 
                                    script={script}
                                    isSelected={selectedItemIndex === numFiles + index}
                                    isExpanded={bodyView === 'script_output' && selectedItemIndex === numFiles + index}
                                />
                            ))}
                            <Separator/>
                        </>
                    )}
                    
                    {/* Files Section */}
                    <Text>FILES</Text>
                    {files.map((file, index) => (
                        <FileItemRow 
                            key={file.id} 
                            file={file} 
                            isSelected={selectedItemIndex === index}
                        />
                    ))}
                </Box>
                
                <Separator/>
                
                {/* Body Viewport */}
                {bodyView !== 'none' && (
                    <>
                        <Box marginY={1}>
                            {renderBody()}
                        </Box>
                        <Separator />
                    </>
                )}

                {/* Footer */}
                <Box>
                    {renderFooter()}
                </Box>
            </Box>
        );
    };


    export default ReviewScreen;
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: '2025-09-22T00:48:19.789Z'
status: committed
id: 16
