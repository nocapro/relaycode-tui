uuid: f191dd3e-5264-42b3-a128-444743224b78
projectId: relaycode-tui
createdAt: '2025-09-26T01:21:23.281Z'
gitCommitMsg: >-
  feat(review): enhance review processing screen UI

  - Implemented a live, animated elapsed time counter for a more dynamic user
  experience during patch application. - Updated the display of file processing
  substeps to show individual progress (pending, active, done, failed),
  including a spinner for active tasks, to better reflect parallel operations. -
  Refactored the underlying store and simulation service to support this
  enhanced UI.
promptSummary: >-
  Update Review Processing Screen to have an animated elapsed time and better
  indicators for parallel file processing.
reasoning:
  - Here are the changes to improve the Review Processing Screen.
  - >-
    I've updated the screen to animate the elapsed time counter for a more
    dynamic feel while processing is active. Additionally, the file processing
    substeps now show their individual states (pending, active, done, or failed)
    with appropriate indicators, including a spinner for active tasks, to better
    visualize parallel work.
  - 'This involved:'
  - 1.  Adding a start time to the `review.store` to track processing duration.
  - >-
    2.  Introducing a timer in the `ReviewProcessingScreen` component to display
    a live elapsed time.
  - >-
    3.  Updating the `ApplyStepRow` sub-component to render different symbols
    and colors based on a substep's status.
  - >-
    4.  Enhancing the `runApplySimulation` in `review.service` to simulate a
    more realistic, parallel file processing lifecycle (pending -> active ->
    done/failed).
  - '### `review.store` update'
  - >-
    I'll start by updating `review.store.ts` to support the new features. I'm
    adding `processingStartTime` to the state, a new `UPDATE_SUBSTEP` action
    type, and a corresponding `updateApplySubstep` action to handle individual
    substep state changes.
  - '### Simulation Logic Update'
  - >-
    Next, I'll modify the simulation in `review.service.ts` to emit the new
    substep lifecycle events.
  - '### UI Update'
  - >-
    Finally, I'll update the `ReviewProcessingScreen` to tie everything
    together.
  - >-
    These changes will provide a much-improved user experience on the Review
    Processing screen.
operations:
  - type: write
    path: src/stores/review.store.ts
    content: >+
      --- src/stores/review.store.ts

      +++ src/stores/review.store.ts

      @@ -10,8 +10,9 @@
       export type ReviewBodyView = (typeof REVIEW_BODY_VIEWS)[keyof typeof REVIEW_BODY_VIEWS];
       export type PatchStatus = (typeof PATCH_STATUS)[keyof typeof PATCH_STATUS];
       export type ApplyUpdate =
      -    | { type: 'UPDATE_STEP'; payload: { id: string; status:
      ApplyStep['status']; duration?: number; details?: string } }

      -    | { type: 'ADD_SUBSTEP'; payload: { parentId: string; substep:
      Omit<ApplyStep, 'substeps'> } };

      +    | { type: 'UPDATE_STEP'; payload: { id: string; status:
      ApplyStep['status']; duration?: number; details?: string } }

      +    | { type: 'ADD_SUBSTEP'; payload: { parentId: string; substep:
      Omit<ApplyStep, 'substeps'> } }

      +    | { type: 'UPDATE_SUBSTEP'; payload: { parentId: string; substepId:
      string; status: ApplyStep['status']; title?: string } };
       
       interface ReviewState {
           patchStatus: PatchStatus;
      @@ -21,6 +22,7 @@
           isDiffExpanded: boolean;
           reasoningScrollIndex: number;
           scriptErrorIndex: number;
      +    processingStartTime: number | null;
           fileReviewStates: Map<string, { status: FileReviewStatus; error?: string; details?: string }>;
       
           selectedBulkRepairOptionIndex: number;
      @@ -46,6 +48,7 @@
               navigateScriptErrorDown: () => void;
               updateApplyStep: (id: string, status: ApplyStep['status'], duration?: number, details?: string) => void;
               addApplySubstep: (parentId: string, substep: Omit<ApplyStep, 'substeps'>) => void;
      +        updateApplySubstep: (parentId: string, substepId: string, status:
      ApplyStep['status'], title?: string) => void;
               updateFileReviewStatus: (fileId: string, status: FileReviewStatus, error?: string, details?: string) => void;
               toggleFileApproval: (fileId: string) => void;
               rejectAllFiles: () => void;
      @@ -62,6 +65,7 @@
           isDiffExpanded: false,
           reasoningScrollIndex: 0,
           scriptErrorIndex: 0,
      +    processingStartTime: null,
           fileReviewStates: new Map(),
           selectedBulkRepairOptionIndex: 0,
           selectedBulkInstructOptionIndex: 0,
      @@ -75,6 +79,7 @@
                   set({
                       patchStatus,
                       fileReviewStates,
      +                processingStartTime: null,
                       selectedItemIndex: 0,
                       bodyView: initialState?.bodyView ?? REVIEW_BODY_VIEWS.NONE,
                       isDiffExpanded: false,
      @@ -100,28 +105,37 @@
                   }
               },
               startApplySimulation: async (scenario) => {
                   const { showReviewProcessingScreen, showReviewScreen } = useAppStore.getState().actions;
      -            const { updateApplyStep, addApplySubstep } = get().actions;

      -            set({ applySteps:
      JSON.parse(JSON.stringify(INITIAL_APPLY_STEPS)) });

      +            const { updateApplyStep, addApplySubstep, updateApplySubstep
      } = get().actions;

      +            set({ applySteps:
      JSON.parse(JSON.stringify(INITIAL_APPLY_STEPS)), processingStartTime:
      Date.now() });
                   showReviewProcessingScreen();
                   const simulationGenerator = ReviewService.runApplySimulation(scenario);
                   for await (const update of simulationGenerator) {
                       if (update.type === 'UPDATE_STEP') {
                           updateApplyStep(
      -                        update.payload.id,

      -                        update.payload.status,

      -                        update.payload.duration,

      -                        update.payload.details,

      +                        update.payload.id,

      +                        update.payload.status,

      +                        update.payload.duration,

      +                        update.payload.details,
                           );
                       } else if (update.type === 'ADD_SUBSTEP') {
                           addApplySubstep(update.payload.parentId, update.payload.substep);
      +                } else if (update.type === 'UPDATE_SUBSTEP') {

      +                    updateApplySubstep(

      +                        update.payload.parentId,

      +                        update.payload.substepId,

      +                        update.payload.status,

      +                        update.payload.title,

      +                    );
                       }
                   }
                   // After a brief delay to show the final state, transition to the review screen.
                   // The `patchStatus` from `load` determines which review state to show.
                   await sleep(1000);
      +            set({ processingStartTime: null });
                   showReviewScreen();
               },
               tryRepairFile: (fileId) => {
      @@ -239,6 +253,24 @@
                       }),
                   }));
               },
      +        updateApplySubstep: (parentId, substepId, status, title) => {

      +            set(state => ({

      +                applySteps: state.applySteps.map(s => {

      +                    if (s.id === parentId && s.substeps) {

      +                        const newSubsteps = s.substeps.map(sub => {

      +                            if (sub.id === substepId) {

      +                                const newSub = { ...sub, status };

      +                                if (title) newSub.title = title;

      +                                return newSub;

      +                            }

      +                            return sub;

      +                        });

      +                        return { ...s, substeps: newSubsteps };

      +                    }

      +                    return s;

      +                }),

      +            }));

      +        },
               addApplySubstep: (parentId, substep) => {
                   set(state => ({
                       applySteps: state.applySteps.map(s => {

    patchStrategy: standard-diff
  - type: write
    path: src/services/review.service.ts
    content: >+
      --- src/services/review.service.ts

      +++ src/services/review.service.ts

      @@ -79,15 +79,23 @@
           if (scenario === 'success') {
               yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'active' } }; await sleep(100);
               yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'done', duration: 0.1 } };
       
      -        yield { type: 'UPDATE_STEP', payload: { id: 'memory', status:
      'active' } }; await sleep(100);

      -        yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory',
      substep: { id: 's1', title: '[✓] write: src/core/clipboard.ts (strategy:
      replace)', status: 'done' } } };

      -        await sleep(100);

      -        yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory',
      substep: { id: 's2', title: '[✓] write: src/utils/shell.ts (strategy:
      standard-diff)', status: 'done' } } };

      -        yield { type: 'UPDATE_STEP', payload: { id: 'memory', status:
      'done', duration: 0.3 } };

      +        yield { type: 'UPDATE_STEP', payload: { id: 'memory', status:
      'active' } }; await sleep(100);

      +        yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory',
      substep: { id: 's1', title: 'write: src/core/clipboard.ts (strategy:
      replace)', status: 'pending' } } };

      +        yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory',
      substep: { id: 's2', title: 'write: src/utils/shell.ts (strategy:
      standard-diff)', status: 'pending' } } };

      +        await sleep(50);

      +        yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'memory',
      substepId: 's1', status: 'active' } };

      +        yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'memory',
      substepId: 's2', status: 'active' } };

      +        await sleep(200);

      +        yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'memory',
      substepId: 's1', status: 'done' } };

      +        await sleep(150);

      +        yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'memory',
      substepId: 's2', status: 'done' } };

      +        yield { type: 'UPDATE_STEP', payload: { id: 'memory', status:
      'done', duration: 0.5 } };
       
               yield { type: 'UPDATE_STEP', payload: { id: 'post-command', status: 'active' } }; await sleep(1300);
               yield { type: 'ADD_SUBSTEP', payload: { parentId: 'post-command', substep: { id: 's3', title: '`bun run test` ... Passed', status: 'done' } } };
      @@ -102,13 +110,21 @@
           } else { // failure scenario
               yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'active' } }; await sleep(100);
               yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'done', duration: 0.1 } };
       
      -        yield { type: 'UPDATE_STEP', payload: { id: 'memory', status:
      'active' } }; await sleep(100);

      -        yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory',
      substep: { id: 'f1', title: '[✓] write: src/core/transaction.ts (strategy:
      replace)', status: 'done' } } };

      -        await sleep(100);

      -        yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory',
      substep: { id: 'f2', title: '[!] failed: src/utils/logger.ts (Hunk #1
      failed to apply)', status: 'failed' } } };

      -        await sleep(100);

      -        yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory',
      substep: { id: 'f3', title: '[!] failed: src/commands/apply.ts (Context
      mismatch at line 92)', status: 'failed' } } };

      +        yield { type: 'UPDATE_STEP', payload: { id: 'memory', status:
      'active' } }; await sleep(100);

      +        yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory',
      substep: { id: 'f1', title: 'write: src/core/transaction.ts (strategy:
      replace)', status: 'pending' } } };

      +        yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory',
      substep: { id: 'f2', title: 'write: src/utils/logger.ts', status:
      'pending' } } };

      +        yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory',
      substep: { id: 'f3', title: 'write: src/commands/apply.ts', status:
      'pending' } } };

      +        await sleep(50);

      +        yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'memory',
      substepId: 'f1', status: 'active' } };

      +        yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'memory',
      substepId: 'f2', status: 'active' } };

      +        yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'memory',
      substepId: 'f3', status: 'active' } };

      +        await sleep(150);

      +        yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'memory',
      substepId: 'f1', status: 'done' } };

      +        await sleep(100);

      +        yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'memory',
      substepId: 'f2', status: 'failed', title: 'src/utils/logger.ts (Hunk #1
      failed to apply)' } };

      +        await sleep(100);

      +        yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'memory',
      substepId: 'f3', status: 'failed', title: 'src/commands/apply.ts (Context
      mismatch at line 92)' } };
               yield { type: 'UPDATE_STEP', payload: { id: 'memory', status: 'done', duration: 0.5 } };
       
               await sleep(100);

    patchStrategy: standard-diff
  - type: write
    path: src/components/ReviewProcessingScreen.tsx
    content: >+
      --- src/components/ReviewProcessingScreen.tsx

      +++ src/components/ReviewProcessingScreen.tsx

      @@ -1,19 +1,43 @@
       import { Box, Text } from 'ink';
      +import { useEffect, useState } from 'react';

      +import Spinner from 'ink-spinner';
       import { useTransactionStore } from '../stores/transaction.store';
       import { useViewStore } from '../stores/view.store';
       import { useReviewStore, type ApplyStep } from '../stores/review.store';
       import Separator from './Separator';
       
       const ApplyStepRow = ({ step, isSubstep = false }: { step: ApplyStep; isSubstep?: boolean }) => {
           if (isSubstep) {
      -        let color;

      -        if (step.status === 'done' && step.title.startsWith('[✓]')) color
      = 'green';

      -        if (step.status === 'failed') color = 'red';

      +        let color: string | undefined;

      +        let symbol: React.ReactNode;

      +

      +        switch (step.status) {

      +            case 'pending':

      +                symbol = '○';

      +                color = 'gray';

      +                break;

      +            case 'active':

      +                symbol = <Text color="cyan"><Spinner type="dots"
      /></Text>;

      +                break;

      +            case 'done':

      +                symbol = '✓';

      +                color = 'green';

      +                break;

      +            case 'failed':

      +                symbol = '✗';

      +                color = 'red';

      +                break;

      +            default:

      +                symbol = ' ';

      +        }
       
               return (
                   <Text color={color}>
      -                {'     └─ '}{step.title}

      +                {'     └─ '}{symbol}{' '}{step.title}
                   </Text>
               );
           }
      @@ -46,27 +70,42 @@
       
       const ReviewProcessingScreen = () => {
           const selectedTransactionId = useViewStore(s => s.selectedTransactionId);
      -    const { patchStatus, applySteps } = useReviewStore(state => ({

      +    const { patchStatus, applySteps, processingStartTime } =
      useReviewStore(state => ({
               patchStatus: state.patchStatus,
               applySteps: state.applySteps,
      +        processingStartTime: state.processingStartTime,
           }));
           const transaction = useTransactionStore(s => s.transactions.find(t => t.id === selectedTransactionId));
       
           const isProcessing = applySteps.some(s => s.status === 'pending' || s.status === 'active');
      -    const totalDuration = applySteps.reduce((acc: number, step:
      ApplyStep) => acc + (step.duration || 0), 0);

      +    const [elapsedTime, setElapsedTime] = useState(0);

      +

      +    useEffect(() => {

      +        let timerId: NodeJS.Timeout | undefined;

      +

      +        if (isProcessing && processingStartTime) {

      +            timerId = setInterval(() => {

      +                setElapsedTime((Date.now() - processingStartTime) /
      1000);

      +            }, 50);

      +        } else {

      +            const totalDuration = applySteps.reduce((acc, step) => acc +
      (step.duration || 0), 0);

      +            setElapsedTime(totalDuration);

      +        }

      +

      +        return () => {

      +            if (timerId) clearInterval(timerId);

      +        };

      +    }, [isProcessing, processingStartTime, applySteps]);

      +
           const failureCase = patchStatus === 'PARTIAL_FAILURE';
       
           let footerText;
           if (isProcessing) {
      -        footerText = `Elapsed: ${totalDuration.toFixed(1)}s ·
      Processing... Please wait.`;

      +        footerText = `Elapsed: ${elapsedTime.toFixed(1)}s · Processing...
      Please wait.`;
           } else if (failureCase) {
      -        footerText = `Elapsed: ${totalDuration.toFixed(1)}s ·
      Transitioning to repair workflow...`;

      +        footerText = `Elapsed: ${elapsedTime.toFixed(1)}s · Transitioning
      to repair workflow...`;
           } else {
      -        footerText = `Elapsed: ${totalDuration.toFixed(1)}s · Patch
      applied successfully. Transitioning...`;

      +        footerText = `Elapsed: ${elapsedTime.toFixed(1)}s · Patch applied
      successfully. Transitioning...`;
           }
       
           if (!transaction) {

    patchStrategy: standard-diff
snapshot:
  src/stores/review.store.ts: >-
    import { create } from 'zustand';

    import { useAppStore } from './app.store';

    import { useTransactionStore } from './transaction.store';

    import { useViewStore } from './view.store';

    import { ReviewService } from '../services/review.service';

    import { INITIAL_APPLY_STEPS, PATCH_STATUS, REVIEW_BODY_VIEWS } from
    '../constants/review.constants';

    import { moveIndex } from './navigation.utils';

    import { sleep } from '../utils';

    import type { FileReviewStatus } from '../types/domain.types';


    export interface ApplyStep {
        id: string;
        title: string;
        status: 'pending' | 'active' | 'done' | 'failed' | 'skipped';
        details?: string;
        substeps?: ApplyStep[];
        duration?: number;
    }


    export type ReviewBodyView = (typeof REVIEW_BODY_VIEWS)[keyof typeof
    REVIEW_BODY_VIEWS];

    export type PatchStatus = (typeof PATCH_STATUS)[keyof typeof PATCH_STATUS];

    export type ApplyUpdate =
        | { type: 'UPDATE_STEP'; payload: { id: string; status: ApplyStep['status']; duration?: number; details?: string } }
        | { type: 'ADD_SUBSTEP'; payload: { parentId: string; substep: Omit<ApplyStep, 'substeps'> } };

    interface ReviewState {
        patchStatus: PatchStatus;
        applySteps: ApplyStep[];
        selectedItemIndex: number;
        bodyView: ReviewBodyView;
        isDiffExpanded: boolean;
        reasoningScrollIndex: number;
        scriptErrorIndex: number;
        fileReviewStates: Map<string, { status: FileReviewStatus; error?: string; details?: string }>;

        selectedBulkRepairOptionIndex: number;
        selectedBulkInstructOptionIndex: number;

        actions: {
            load: (transactionId: string, initialState?: Partial<Pick<ReviewState, 'bodyView' | 'selectedBulkRepairOptionIndex'>>) => void;
            moveSelectionUp: (listSize: number) => void;
            moveSelectionDown: (listSize: number) => void;
            expandDiff: () => void;
            toggleBodyView: (view: Extract<
                ReviewBodyView, 'bulk_instruct' |
                'diff' | 'reasoning' | 'script_output' | 'bulk_repair' | 'confirm_handoff'
            >) => void;
            setBodyView: (view: ReviewBodyView) => void;
            approve: () => void;
            startApplySimulation: (scenario: 'success' | 'failure') => void;
            tryRepairFile: (fileId: string) => void;
            showBulkRepair: () => void;
            executeBulkRepairOption: (option: number) => Promise<void>;
            tryInstruct: (fileId: string) => void;
            showBulkInstruct: () => void;
            executeBulkInstructOption: (option: number) => Promise<void>;
            confirmHandoff: () => void;
            scrollReasoningUp: () => void;
            scrollReasoningDown: () => void;
            navigateScriptErrorUp: () => void;
            navigateScriptErrorDown: () => void;
            updateApplyStep: (id: string, status: ApplyStep['status'], duration?: number, details?: string) => void;
            addApplySubstep: (parentId: string, substep: Omit<ApplyStep, 'substeps'>) => void;
            updateFileReviewStatus: (fileId: string, status: FileReviewStatus, error?: string, details?: string) => void;
            toggleFileApproval: (fileId: string) => void;
            rejectAllFiles: () => void;
            navigateBulkRepairUp: () => void;
            navigateBulkRepairDown: () => void;
            navigateBulkInstructUp: () => void;
            navigateBulkInstructDown: () => void;
        };
    }


    export const useReviewStore = create<ReviewState>((set, get) => ({
        patchStatus: PATCH_STATUS.SUCCESS,
        applySteps: INITIAL_APPLY_STEPS,
        selectedItemIndex: 0,
        bodyView: REVIEW_BODY_VIEWS.NONE,
        isDiffExpanded: false,
        reasoningScrollIndex: 0,
        scriptErrorIndex: 0,
        fileReviewStates: new Map(),
        selectedBulkRepairOptionIndex: 0,
        selectedBulkInstructOptionIndex: 0,

        actions: {
            load: (transactionId, initialState) => {
                const transaction = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!transaction) return;
                
                const { patchStatus, fileReviewStates } = ReviewService.prepareTransactionForReview(transaction);

                useViewStore.getState().actions.setSelectedTransactionId(transaction.id);
                set({
                    patchStatus,
                    fileReviewStates,
                    selectedItemIndex: 0,
                    bodyView: initialState?.bodyView ?? REVIEW_BODY_VIEWS.NONE,
                    isDiffExpanded: false,
                    reasoningScrollIndex: 0,
                    scriptErrorIndex: 0,
                    applySteps: JSON.parse(JSON.stringify(INITIAL_APPLY_STEPS)),
                    selectedBulkRepairOptionIndex: 0,
                    selectedBulkInstructOptionIndex: 0,
                    ...initialState,
                });
            },
            moveSelectionUp: (listSize) => set(state => {
                return { selectedItemIndex: moveIndex(state.selectedItemIndex, 'up', listSize) };
            }),
            moveSelectionDown: (listSize) => set(state => {
                return { selectedItemIndex: moveIndex(state.selectedItemIndex, 'down', listSize) };
            }),
            toggleBodyView: (view) => set(state => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                const files = tx?.files || [];
                if (view === 'diff' && state.selectedItemIndex >= files.length) return {};
                return {
                    bodyView: state.bodyView === view ? REVIEW_BODY_VIEWS.NONE : view,
                    isDiffExpanded: false,
                };
            }),
            setBodyView: (view) => set({ bodyView: view }),
            expandDiff: () => set(state => ({ isDiffExpanded: !state.isDiffExpanded })),
            approve: () => {
                const { selectedTransactionId } = useViewStore.getState();
                if (selectedTransactionId) {
                    useTransactionStore.getState().actions.updateTransactionStatus(selectedTransactionId, 'APPLIED');
                    useAppStore.getState().actions.showDashboardScreen();
                }
            },
            startApplySimulation: async (scenario) => {
                const { showReviewProcessingScreen, showReviewScreen } = useAppStore.getState().actions;
                const { updateApplyStep, addApplySubstep } = get().actions;
                set({ applySteps: JSON.parse(JSON.stringify(INITIAL_APPLY_STEPS)) });
                showReviewProcessingScreen();
                const simulationGenerator = ReviewService.runApplySimulation(scenario);
                for await (const update of simulationGenerator) {
                    if (update.type === 'UPDATE_STEP') {
                        updateApplyStep(
                            update.payload.id,
                            update.payload.status,
                            update.payload.duration,
                            update.payload.details,
                        );
                    } else if (update.type === 'ADD_SUBSTEP') {
                        addApplySubstep(update.payload.parentId, update.payload.substep);
                    }
                }
                // After a brief delay to show the final state, transition to the review screen.
                // The `patchStatus` from `load` determines which review state to show.
                await sleep(1000);
                showReviewScreen();
            },
            tryRepairFile: (fileId) => {
                const selectedTransactionId = useViewStore.getState().selectedTransactionId;
                const { fileReviewStates } = get();
                if (!selectedTransactionId) return;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                const file = tx?.files?.find(f => f.id === fileId);
                if (!file) return;

                const { status, error } = fileReviewStates.get(file.id) || {};
                if (status !== 'FAILED') return;
                
                ReviewService.tryRepairFile(file, error);
                get().actions.updateFileReviewStatus(file.id, 'AWAITING');
            },
            tryInstruct: (fileId) => {
                const selectedTransactionId = useViewStore.getState().selectedTransactionId;
                const { fileReviewStates } = get();
                if (!selectedTransactionId) return;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                const file = tx?.files?.find(f => f.id === fileId);
                if (!tx || !file) return;

                const { status } = fileReviewStates.get(file.id) || {};
                if (status !== 'REJECTED') return;
                
                ReviewService.tryInstructFile(file, tx);
                get().actions.updateFileReviewStatus(file.id, 'AWAITING', undefined, 'Instruction prompt copied!');
            },
            showBulkInstruct: () => get().actions.setBodyView('bulk_instruct'),
            executeBulkInstructOption: async (option) => {
                const selectedTransactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                if (!tx?.files) return;

                const rejectedFiles = tx.files.filter(f => get().fileReviewStates.get(f.id)?.status === 'REJECTED');
                if (rejectedFiles.length === 0) {
                    set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                    return;
                }

                switch (option) {
                    case 1:
                        ReviewService.generateBulkInstructPrompt(rejectedFiles, tx);
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                        break;
                    case 2:
                        get().actions.setBodyView('confirm_handoff');
                        break;
                    case 3:
                        rejectedFiles.forEach(file => {
                            get().actions.updateFileReviewStatus(file.id, 'APPROVED');
                        });
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                        break;
                    default:
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                }
            },

            showBulkRepair: () => get().actions.toggleBodyView('bulk_repair'),
            executeBulkRepairOption: async (option) => {
                const selectedTransactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                if (!tx?.files) return;

                const failedFiles = tx.files.filter(f => get().fileReviewStates.get(f.id)?.status === 'FAILED');
                if (failedFiles.length === 0) {
                    set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                    return;
                }

                switch (option) {
                    case 1:
                        ReviewService.generateBulkRepairPrompt(failedFiles);
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                        break;
                    case 2: {
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                        failedFiles.forEach(f => get().actions.updateFileReviewStatus(f.id, 'RE_APPLYING'));
                        const results = await ReviewService.runBulkReapply(failedFiles);
                        results.forEach(result =>
                            get().actions.updateFileReviewStatus(
                                result.id, result.status, result.error,
                            ),
                        );
                        break;
                    }
                    case 3:
                        get().actions.setBodyView('confirm_handoff');
                        break;
                    case 4:
                        failedFiles.forEach(file => {
                            get().actions.updateFileReviewStatus(file.id, 'REJECTED');
                        });
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                        break;
                    default:
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                }
            },
            confirmHandoff: () => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!tx?.files) return;
                const { fileReviewStates } = get();
                ReviewService.generateHandoffPrompt(tx, fileReviewStates);
                ReviewService.performHandoff(tx.hash);
            },
            scrollReasoningUp: () => set(state => ({ reasoningScrollIndex: Math.max(0, state.reasoningScrollIndex - 1) })),
            scrollReasoningDown: () => set(state => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!tx?.reasoning) return {};
                const maxLines = tx.reasoning.split('\n').length;
                return { reasoningScrollIndex: Math.min(maxLines - 1, state.reasoningScrollIndex + 1) };
            }),
            navigateScriptErrorUp: () => set(state => ({ scriptErrorIndex: Math.max(0, state.scriptErrorIndex - 1) })),
            navigateScriptErrorDown: () => set(state => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!tx?.scripts || !tx?.files) return {};
                const selectedScript = tx.scripts[state.selectedItemIndex - tx.files.length];
                if (selectedScript?.output) {
                    const errorLines = selectedScript.output
                        .split('\n')
                        .filter(line => line.includes('Error') || line.includes('Warning'));
                    return { scriptErrorIndex: Math.min(errorLines.length - 1, state.scriptErrorIndex + 1) };
                }
                return {};
            }),
            updateApplyStep: (id, status, duration, details) => {
                set(state => ({
                    applySteps: state.applySteps.map(s => {
                        if (s.id === id) {
                            const newStep = { ...s, status };
                            if (duration !== undefined) newStep.duration = duration;
                            if (details !== undefined) newStep.details = details;
                            return newStep;
                        }
                        return s;
                    }),
                }));
            },
            addApplySubstep: (parentId, substep) => {
                set(state => ({
                    applySteps: state.applySteps.map(s => {
                        if (s.id === parentId) {
                            const newSubsteps = [...(s.substeps || []), substep as ApplyStep];
                            return { ...s, substeps: newSubsteps };
                        }
                        return s;
                    }),
                }));
            },
            updateFileReviewStatus: (fileId, status, error, details) => {
                set(state => {
                    const newStates = new Map(state.fileReviewStates);
                    newStates.set(fileId, { status, error, details });
                    return { fileReviewStates: newStates };
                });
            },
            toggleFileApproval: (fileId) => {
                set(state => {
                    const newStates = new Map(state.fileReviewStates);
                    const current = newStates.get(fileId);
                    if (current) {
                        const newStatus: FileReviewStatus = current.status === 'APPROVED' ? 'REJECTED' : 'APPROVED';
                        newStates.set(fileId, { status: newStatus, error: undefined, details: undefined });
                    }
                    return { fileReviewStates: newStates };
                });
            },
            rejectAllFiles: () => {
                set(state => {
                    const newStates = new Map(state.fileReviewStates);
                    for (const [fileId, reviewState] of newStates.entries()) {
                        if (reviewState.status === 'APPROVED') {
                            newStates.set(fileId, { status: 'REJECTED', error: undefined, details: undefined });
                        }
                    }
                    return { fileReviewStates: newStates };
                });
            },
            navigateBulkRepairUp: () => set(state => ({
                selectedBulkRepairOptionIndex: moveIndex(state.selectedBulkRepairOptionIndex, 'up', 4),
            })),
            navigateBulkRepairDown: () => set(state => ({
                selectedBulkRepairOptionIndex: moveIndex(state.selectedBulkRepairOptionIndex, 'down', 4),
            })),
            navigateBulkInstructUp: () => set(state => ({
                selectedBulkInstructOptionIndex: moveIndex(state.selectedBulkInstructOptionIndex, 'up', 4),
            })),
            navigateBulkInstructDown: () => set(state => ({
                selectedBulkInstructOptionIndex: moveIndex(state.selectedBulkInstructOptionIndex, 'down', 4),
            })),
        },
    }));
  src/services/review.service.ts: >-
    import { useTransactionStore } from '../stores/transaction.store';

    import { useAppStore } from '../stores/app.store';

    import { sleep } from '../utils';

    import type { ApplyUpdate, PatchStatus } from '../stores/review.store';

    import type { Transaction, FileItem, FileReviewStatus } from
    '../types/domain.types';


    const generateBulkRepairPrompt = (failedFiles: FileItem[]): string => {
        return `The previous patch failed to apply to MULTIPLE files. Please generate a new, corrected patch that addresses all the files listed below.

    IMPORTANT: The response MUST contain a complete code block for EACH file
    that needs to be fixed.


    ${failedFiles.map(file => `--- FILE: ${file.path} ---

    Strategy: ${file.strategy}

    Error: Hunk #1 failed to apply // This is a mock error


    ORIGINAL CONTENT:

    ---

    // ... original content of ${file.path} ...

    ---


    FAILED PATCH:

    ---

    ${file.diff || '// ... failed diff ...'}

    ---

    `).join('\n')}


    Please analyze all failed files and provide a complete, corrected
    response.`;

    };


    const generateHandoffPrompt = (
        transaction: Transaction,
        fileReviewStates: Map<
            string, { status: FileReviewStatus; error?: string; details?: string }
        >,
    ): string => {
        const successfulFiles = (transaction.files || []).filter(f => fileReviewStates.get(f.id)?.status === 'APPROVED');
        const failedFiles = (transaction.files || []).filter(f => ['FAILED', 'REJECTED'].includes(fileReviewStates.get(f.id)?.status || ''));

        return `I am handing off a failed automated code transaction to you. Your task is to act as my programming assistant and complete the planned changes.

    The full plan for this transaction is detailed in the YAML file located at:
    .relay/transactions/${transaction.hash}.yml. Please use this file as your
    primary source of truth for the overall goal.


    Here is the current status of the transaction:


    --- TRANSACTION SUMMARY ---

    Goal: ${transaction.message}

    Reasoning:

    ${transaction.reasoning || ''}


    --- CURRENT FILE STATUS ---

    SUCCESSFUL CHANGES (already applied, no action needed):

    ${successfulFiles.map(f => `- MODIFIED: ${f.path}`).join('\n') || ' 
    (None)'}


    FAILED CHANGES (these are the files you need to fix):

    ${failedFiles.map(f => `- FAILED: ${f.path} (Error:
    ${fileReviewStates.get(f.id)?.error})`).join('\n')}


    Your job is to now work with me to fix the FAILED files and achieve the
    original goal of the transaction. Please start by asking me which file you
    should work on first.`;

    };


    const performHandoff = (hash: string) => {
        // This is a bit of a hack to find the right transaction to update in the demo
        const txToUpdate = useTransactionStore.getState().transactions.find(tx => tx.hash === hash);
        if (txToUpdate) {
            useTransactionStore.getState().actions.updateTransactionStatus(txToUpdate.id, 'HANDOFF');
        }

        useAppStore.getState().actions.showDashboardScreen();
    };


    async function* runApplySimulation(scenario: 'success' | 'failure'):
    AsyncGenerator<ApplyUpdate> {
        if (scenario === 'success') {
            yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'active' } }; await sleep(100);
            yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'done', duration: 0.1 } };

            yield { type: 'UPDATE_STEP', payload: { id: 'memory', status: 'active' } }; await sleep(100);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 's1', title: '[✓] write: src/core/clipboard.ts (strategy: replace)', status: 'done' } } };
            await sleep(100);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 's2', title: '[✓] write: src/utils/shell.ts (strategy: standard-diff)', status: 'done' } } };
            yield { type: 'UPDATE_STEP', payload: { id: 'memory', status: 'done', duration: 0.3 } };

            yield { type: 'UPDATE_STEP', payload: { id: 'post-command', status: 'active' } }; await sleep(1300);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'post-command', substep: { id: 's3', title: '`bun run test` ... Passed', status: 'done' } } };
            yield { type: 'UPDATE_STEP', payload: { id: 'post-command', status: 'done', duration: 2.3 } };

            yield { type: 'UPDATE_STEP', payload: { id: 'linter', status: 'active' } }; await sleep(1200);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'linter', substep: { id: 's4', title: '`bun run lint` ... 0 Errors', status: 'done' } } };
            yield { type: 'UPDATE_STEP', payload: { id: 'linter', status: 'done', duration: 1.2 } };

            await sleep(500);

        } else { // failure scenario
            yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'active' } }; await sleep(100);
            yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'done', duration: 0.1 } };

            yield { type: 'UPDATE_STEP', payload: { id: 'memory', status: 'active' } }; await sleep(100);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 'f1', title: '[✓] write: src/core/transaction.ts (strategy: replace)', status: 'done' } } };
            await sleep(100);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 'f2', title: '[!] failed: src/utils/logger.ts (Hunk #1 failed to apply)', status: 'failed' } } };
            await sleep(100);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 'f3', title: '[!] failed: src/commands/apply.ts (Context mismatch at line 92)', status: 'failed' } } };
            yield { type: 'UPDATE_STEP', payload: { id: 'memory', status: 'done', duration: 0.5 } };

            await sleep(100);
            yield { type: 'UPDATE_STEP', payload: { id: 'post-command', status: 'skipped', details: 'Skipped due to patch application failure' } };
            await sleep(100);
            yield { type: 'UPDATE_STEP', payload: { id: 'linter', status: 'skipped', details: 'Skipped due to patch application failure' } };

            await sleep(500);
        }
    }


    const prepareTransactionForReview = (
        transaction: Transaction,
    ): {
        patchStatus: PatchStatus;
        fileReviewStates: Map<string, { status: FileReviewStatus; error?: string }>;
    } => {
        // This simulates the backend determining which files failed or succeeded and sets it ONCE on load.
        // For this demo, tx '1' is the failure case, any other is success.
        const isFailureCase = transaction.id === '1';
        const fileReviewStates = new Map<string, { status: FileReviewStatus; error?: string }>();

        (transaction.files || []).forEach((file, index) => {
            if (isFailureCase) {
                const isFailedFile = index > 0;
                const status = isFailedFile ? 'FAILED' : 'APPROVED';
                const error = isFailedFile ? (index === 1 ? 'Hunk #1 failed to apply' : 'Context mismatch at line 92') : undefined;
                fileReviewStates.set(file.id, { status, error });
            } else {
                fileReviewStates.set(file.id, { status: 'APPROVED' });
            }
        });
        return { patchStatus: isFailureCase ? 'PARTIAL_FAILURE' : 'SUCCESS', fileReviewStates };
    };


    const generateSingleFileRepairPrompt = (file: FileItem, error?: string):
    string => {
        return `The patch failed to apply to ${file.path}. Please generate a corrected patch.

    Error: ${error || 'Unknown error'}

    Strategy: ${file.strategy}


    ORIGINAL CONTENT:

    ---

    // ... original file content would be here ...

    ---


    FAILED PATCH:

    ---

    ${file.diff || '// ... failed diff would be here ...'}

    ---


    Please provide a corrected patch that addresses the error.`;

    };


    const tryRepairFile = (file: FileItem, error?: string): FileItem => {
        const repairPrompt = generateSingleFileRepairPrompt(file, error);
        // In a real app: clipboardy.writeSync(repairPrompt)
        // eslint-disable-next-line no-console
        console.log(`[CLIPBOARD MOCK] Copied repair prompt for: ${file.path}`, repairPrompt);

        return file;
    };


    const generateSingleFileInstructPrompt = (file: FileItem, transaction:
    Transaction): string => {
        return `The user REJECTED the last proposed change for the file \`${file.path}\`.

    The original high-level goal was:

    ---

    ${transaction.prompt || transaction.message}

    ---


    The rejected change was:

    ---

    ${file.diff || '// ... rejected diff would be here ...'}

    ---


    Please provide an alternative solution for \`${file.path}\` that still
    accomplishes the original goal.

    The response MUST be a complete, corrected patch for this file.`;

    };


    const tryInstructFile = (file: FileItem, transaction: Transaction): void =>
    {
        const instructPrompt = generateSingleFileInstructPrompt(file, transaction);
        // In a real app: clipboardy.writeSync(instructPrompt)
        // eslint-disable-next-line no-console
        console.log(`[CLIPBOARD MOCK] Copied instruction prompt for: ${file.path}`, instructPrompt);
    };


    const generateBulkInstructPrompt = (rejectedFiles: FileItem[], transaction:
    Transaction): string => {
        // Mock implementation for demo. In a real scenario, this would generate a more complex prompt.
        const fileList = rejectedFiles.map(f => `- ${f.path}`).join('\n');
        // eslint-disable-next-line no-console
        console.log(`[CLIPBOARD] Copied bulk instruction prompt for ${rejectedFiles.length} files.`);
        return `The user has rejected changes in multiple files for the goal: "${transaction.message}".\n\nThe rejected files are:\n${fileList}\n\nPlease provide an alternative patch for all of them.`;
    };


    const runBulkReapply = async (
        failedFiles: FileItem[],
    ): Promise<{ id: string; status: FileReviewStatus; error?: string }[]> => {
        await sleep(1500); // Simulate re-apply

        // Mock a mixed result
        let first = true;
        return failedFiles.map(file => {
            if (first) {
                first = false;
                return { id: file.id, status: 'APPROVED' as const };
            } else {
                return {
                    id: file.id,
                    status: 'FAILED' as const,
                    error: "'replace' failed: markers not found",
                };
            }
        });
    };


    export const ReviewService = {
        prepareTransactionForReview,
        generateBulkRepairPrompt,
        generateBulkInstructPrompt,
        generateHandoffPrompt,
        performHandoff,
        runApplySimulation,
        generateSingleFileRepairPrompt,
        tryRepairFile,
        generateSingleFileInstructPrompt,
        tryInstructFile,
        runBulkReapply,
    };
  src/components/ReviewProcessingScreen.tsx: >-
    import { Box, Text } from 'ink';

    import { useTransactionStore } from '../stores/transaction.store';

    import { useViewStore } from '../stores/view.store';

    import { useReviewStore, type ApplyStep } from '../stores/review.store';

    import Separator from './Separator';


    const ApplyStepRow = ({ step, isSubstep = false }: { step: ApplyStep;
    isSubstep?: boolean }) => {
        if (isSubstep) {
            let color;
            if (step.status === 'done' && step.title.startsWith('[✓]')) color = 'green';
            if (step.status === 'failed') color = 'red';

            return (
                <Text color={color}>
                    {'     └─ '}{step.title}
                </Text>
            );
        }

        let symbol;
        let color;
        switch (step.status) {
            case 'pending': symbol = '( )'; break;
            case 'active': symbol = '(●)'; color = 'cyan'; break;
            case 'done': symbol = '[✓]'; color = 'green'; break;
            case 'failed': symbol = '[!]'; color = 'red'; break;
            case 'skipped': symbol = '(-)'; color = 'gray'; break;
        }

        return (
            <Box flexDirection="column">
                <Text>
                    <Text color={color}>{symbol}</Text> {step.title} {step.duration && !isSubstep && `(${step.duration}s)`}
                </Text>
                {step.details && (
                    <Text color="gray">
                        {'     └─ '}{step.details}
                    </Text>
                )}
                {step.substeps?.map((sub: ApplyStep, i: number) => (
                    <ApplyStepRow key={i} step={sub} isSubstep={true} />
                ))}
            </Box>
        );
    };


    const ReviewProcessingScreen = () => {
        const selectedTransactionId = useViewStore(s => s.selectedTransactionId);
        const { patchStatus, applySteps } = useReviewStore(state => ({
            patchStatus: state.patchStatus,
            applySteps: state.applySteps,
        }));
        const transaction = useTransactionStore(s => s.transactions.find(t => t.id === selectedTransactionId));

        const isProcessing = applySteps.some(s => s.status === 'pending' || s.status === 'active');
        const totalDuration = applySteps.reduce((acc: number, step: ApplyStep) => acc + (step.duration || 0), 0);
        const failureCase = patchStatus === 'PARTIAL_FAILURE';

        let footerText;
        if (isProcessing) {
            footerText = `Elapsed: ${totalDuration.toFixed(1)}s · Processing... Please wait.`;
        } else if (failureCase) {
            footerText = `Elapsed: ${totalDuration.toFixed(1)}s · Transitioning to repair workflow...`;
        } else {
            footerText = `Elapsed: ${totalDuration.toFixed(1)}s · Patch applied successfully. Transitioning...`;
        }

        if (!transaction) {
            return <Text>Loading...</Text>;
        }

        return (
            <Box flexDirection="column">
                <Text color="cyan">▲ relaycode apply</Text>
                <Separator />
                <Box marginY={1} flexDirection="column">
                    <Text>Applying patch {transaction.hash}... ({transaction.message})</Text>
                    <Box flexDirection="column" marginTop={1} gap={1}>
                        {applySteps.map((step: ApplyStep) => <ApplyStepRow key={step.id} step={step} />)}
                    </Box>
                </Box>
                <Separator />
                <Text>{footerText}</Text>
            </Box>
        );
    };


    export default ReviewProcessingScreen;
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 169
