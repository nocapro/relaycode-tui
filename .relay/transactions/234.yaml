uuid: ffd6f8c4-90aa-457f-b040-ba761dd7de17
projectId: relaycode-tui
createdAt: '2025-09-27T10:58:58.227Z'
gitCommitMsg: >-
  feat(ui): implement dynamic AI processing and settings screens

  - Reworks the AiProcessingScreen to use a more advanced, recursive step
  renderer, matching the animation style of the ReviewProcessingScreen and
  showing durations for all sub-steps. - Expands the `ai.service.ts` simulation
  to process a larger list of files for a more engaging demonstration. -
  Implements a dynamic, searchable dropdown for the AI model selection in the
  SettingsScreen. The list filters models based on user input and supports
  keyboard navigation. - Updates associated hooks and constants to support the
  new settings screen functionality.
promptSummary: >-
  Update AI processing and settings screens to match new borderless, dynamic
  mockups.
reasoning:
  - >-
    Of course. I'll implement the borderless, dynamic UI for the AI processing
    and settings screens, ensuring the animations and interactions match the
    clean aesthetic from the mockups.
  - 'Here are the changes:'
  - >-
    First, I'll enhance the AI processing simulation in `ai.service.ts` to
    iterate over more files, making the screen more engaging as requested.
  - >-
    Next, I'll update the `AiProcessingScreen.tsx` to use the more advanced,
    recursive row component from `ReviewProcessingScreen`. This will render the
    animated steps and sub-steps exactly like the mockup, including durations
    for each item.
  - >-
    To support the dynamic model search, I'll add a list of available AI models
    to the settings constants.
  - >-
    Now, I'll update the `useSettingsScreen` hook with the logic to filter
    models as the user types and handle navigation within the results list.
  - >-
    Finally, I'll update `SettingsScreen.tsx` to render the dynamic, searchable
    dropdown for the AI model, completing the interactive UI from the mockup.
  - >-
    These changes will deliver the requested UI enhancements, creating a more
    fluid and visually appealing experience for AI auto-repair and settings
    configuration.
operations:
  - type: write
    path: src/services/ai.service.ts
    content: >+
      --- src/services/ai.service.ts

      +++ src/services/ai.service.ts

      @@ -2,6 +2,22 @@
       import { sleep } from '../utils';
       import type { Transaction, FileItem } from '../types/domain.types';
       
      +// From review.service.ts to make the simulation more interesting

      +const mockAiFixFiles = [

      +    'src/components/Button.tsx',

      +    'src/components/Input.tsx',

      +    'src/components/Modal.tsx',

      +    'src/hooks/useForm.ts',

      +    'src/hooks/useDebounce.ts',

      +    'src/styles/theme.css',

      +    'src/utils/formatters.ts',

      +    'src/pages/HomePage.tsx',

      +    'src/pages/AboutPage.tsx',

      +    'src/services/api.ts',

      +    'src/stores/user.store.ts',

      +    'src/constants/routes.ts',

      +];

      +
       // Mock function to simulate running an auto-fix with an AI
       export async function* runAutoFix(
           failedFiles: FileItem[],
      @@ -14,15 +30,17 @@
           yield { type: 'UPDATE_STEP', payload: { id: 'prompt', status: 'done', details: `Generated prompts for ${failedFiles.length} files.` } };
       
           yield { type: 'UPDATE_STEP', payload: { id: 'request', status: 'active' } };
      -    yield { type: 'ADD_SUBSTEP', payload: { parentId: 'request', substep:
      { id: failedFiles[0]!.id, title: `Fixing: ${failedFiles[0]!.path}`,
      status: 'active' }}};

      -    await sleep(1500); // Simulate network latency

      -    yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'request',
      substepId: failedFiles[0]!.id, status: 'done' }};

      -    if (failedFiles.length > 1) {

      -        yield { type: 'ADD_SUBSTEP', payload: { parentId: 'request',
      substep: { id: failedFiles[1]!.id, title: `Fixing:
      ${failedFiles[1]!.path}`, status: 'active' }}};

      -        await sleep(1200);

      -        yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'request',
      substepId: failedFiles[1]!.id, status: 'done' }};

      +

      +    // Use a larger list of files for a better demo

      +    const filesToFix: Pick<FileItem, 'id' | 'path'>[] = [

      +        ...failedFiles,

      +        ...mockAiFixFiles.slice(0, 8).map(path => ({ id: path, path })),

      +    ];

      +

      +    for (const file of filesToFix) {

      +        yield { type: 'ADD_SUBSTEP', payload: { parentId: 'request',
      substep: { id: file.id, title: `Fixing: ${file.path}`, status: 'active'
      }}};

      +        await sleep(Math.random() * 500 + 200); // Simulate network
      latency

      +        yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'request',
      substepId: file.id, status: 'done' }};
           }
           yield { type: 'UPDATE_STEP', payload: { id: 'request', status: 'done', details: `Received responses from '${model}'` } };
           
           yield { type: 'UPDATE_STEP', payload: { id: 'patch', status: 'active' } };

    patchStrategy: standard-diff
  - type: write
    path: src/components/AiProcessingScreen.tsx
    content: >+
      --- src/components/AiProcessingScreen.tsx

      +++ src/components/AiProcessingScreen.tsx

      @@ -1,37 +1,65 @@
       import { Box, Text } from 'ink';
       import Spinner from 'ink-spinner';
      -import { type ApplyStep, useReviewStore } from '../stores/review.store';
      // ApplyStep can be reused

      +import { type ApplyStep } from '../stores/review.store'; // ApplyStep can
      be reused
       import ActionFooter from './ActionFooter';
       import { useAiProcessingScreen } from '../hooks/useAiProcessingScreen';
       import Separator from './Separator';
       import ScreenLayout from './layout/ScreenLayout';
       
      -// This component is nearly identical to a row in ReviewProcessingScreen.

      -// In a real app, this could be extracted into a shared component.

      -const ProcessingStepRow = ({ step, now }: {

      +// This component is based on ReviewProcessingScreen's ApplyStepRow,

      +// but adapted to show durations for substeps as well.

      +const ProcessingStepRow = ({ step, isSubstep = false, now }: {
           step: ApplyStep;
      +    isSubstep?: boolean;
           now: number;
       }) => {
      -    let symbol;

      -    let color;

      -    switch (step.status) {

      -        case 'pending': symbol = '( )'; break;

      -        case 'active': symbol = '(●)'; color = 'cyan'; break;

      -        case 'done': symbol = '[✓]'; color = 'green'; break;

      -        case 'failed': symbol = '[!]'; color = 'red'; break;

      -        case 'skipped': symbol = '(-)'; color = 'gray'; break;

      -    }

      -
           let durationText = '';
           if (step.status === 'active' && step.startTime) {
               durationText = ` (${((now - step.startTime) / 1000).toFixed(1)}s)`;
           } else if (step.duration) {
               durationText = ` (${step.duration.toFixed(1)}s)`;
           }
      +

      +    if (isSubstep) {

      +        let color: string | undefined;

      +        let symbol: React.ReactNode;

      +

      +        switch (step.status) {

      +            case 'pending': symbol = '○'; color = 'gray'; break;

      +            case 'active': symbol = <Text color="cyan"><Spinner
      type="dots" /></Text>; break;

      +            case 'done': symbol = '✓'; color = 'green'; break;

      +            case 'failed': symbol = '✗'; color = 'red'; break; // '✗' for
      substep failure

      +            default: symbol = ' ';

      +        }

      +

      +        return (

      +            <Text>

      +                {'     └─ '}<Text color={color}>{symbol}</Text>{'
      '}{step.title}{durationText}

      +            </Text>

      +        );

      +    }

      +

      +    let symbol;

      +    let color;

      +    switch (step.status) {

      +        case 'pending': symbol = '( )'; break;

      +        case 'active': symbol = '(●)'; color = 'cyan'; break;

      +        case 'done': symbol = '[✓]'; color = 'green'; break;

      +        case 'failed': symbol = '[!]'; color = 'red'; break;

      +        case 'skipped': symbol = '(-)'; color = 'gray'; break;

      +    }
       
           return (
               <Box flexDirection="column">
                   <Text>
                       <Text color={color}>{symbol}</Text> {step.title}{durationText}
                   </Text>
                   {step.details && (
                       <Text color="gray">
                           {'     └─ '}{step.details}
                       </Text>
                   )}
                   {step.substeps?.map((sub: ApplyStep, i: number) => (
      -                <Box key={i} paddingLeft={5}>

      -                     <Text color={sub.status === 'done' ? 'green' :
      sub.status === 'failed' ? 'red' : 'gray'}>

      -                        {sub.status === 'active' ? <Text
      color="cyan"><Spinner type="dots" /></Text> : sub.status === 'done' ? '✓'
      : '○'}{' '}{sub.title}

      -                     </Text>

      -                </Box>

      +                <ProcessingStepRow key={i} step={sub} isSubstep={true}
      now={now} />
                   ))}
               </Box>
           );
      @@ -58,18 +86,16 @@
               return <Text>Loading...</Text>;
           }
       
      -    const failedFilesCount = Array.from(

      -        useReviewStore.getState().fileReviewStates.values()

      -    ).filter(s => s.status === 'FAILED').length;

      +    const failedFilesCount = aiProcessingSteps.find(s => s.id ===
      'request')?.substeps?.length || 0;
       
           return (
               <ScreenLayout
                   title="AI AUTO-REPAIR"
                   footer={renderFooter()}
               >
                   <Box flexDirection="column">
      -                <Text>Attempting to auto-repair {failedFilesCount} failed
      files... ({transaction.message})</Text>

      +                <Text>Attempting to auto-repair {failedFilesCount > 0 ?
      `${failedFilesCount} ` : ''}files... ({transaction.message})</Text>
                       <Box flexDirection="column" marginTop={1} gap={1}>
                           {aiProcessingSteps.map((step: ApplyStep) => <ProcessingStepRow key={step.id} step={step} now={now} />)}
                       </Box>

    patchStrategy: standard-diff
  - type: write
    path: src/constants/settings.constants.ts
    content: |+
      --- src/constants/settings.constants.ts
      +++ src/constants/settings.constants.ts
      @@ -13,3 +13,13 @@
           { key: 'Tab', label: 'Next Field' },
           { key: 'Esc', label: 'Close & Save' },
       ] as const;
      +
      +export const AI_MODELS: readonly string[] = [
      +    'meta-llama/llama-3-70b-instruct',
      +    'meta-llama/llama-3-8b-instruct',
      +    'mistralai/mistral-large-latest',
      +    'mistralai/mixtral-8x22b-instruct',
      +    'anthropic/claude-3-opus',
      +    'anthropic/claude-3-sonnet',
      +    'google/gemini-pro-1.5',
      +] as const;

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useSettingsScreen.tsx
    content: >+
      --- src/hooks/useSettingsScreen.tsx

      +++ src/hooks/useSettingsScreen.tsx

      @@ -2,7 +2,7 @@
       import { useInput } from 'ink';
       import { useSettingsStore, type AiProvider } from '../stores/settings.store';
       import { useAppStore } from '../stores/app.store';
      -import { AI_PROVIDERS } from '../constants/settings.constants';

      +import { AI_PROVIDERS, AI_MODELS } from
      '../constants/settings.constants';
       
       type SettingsField = 'provider' | 'apiKey' | 'model';
       
      @@ -16,6 +16,8 @@
           const [providerSelectionIndex, setProviderSelectionIndex] = useState(
               () => AI_PROVIDERS.findIndex(p => p.value === provider)
           );
      +    const [filteredModels, setFilteredModels] = useState<readonly
      string[]>([]);

      +    const [modelSelectionIndex, setModelSelectionIndex] = useState(0);
       
           // Sync local state with global store when component mounts
           useEffect(() => {
      @@ -25,6 +27,18 @@
               setProviderSelectionIndex(AI_PROVIDERS.findIndex(p => p.value === provider));
           }, [provider, apiKey, model]);
       
      +    // Filter models based on input

      +    useEffect(() => {

      +        if (activeField === 'model' && localModel) {

      +            const lowerCaseModel = localModel.toLowerCase();

      +            const filtered = AI_MODELS.filter(m =>
      m.toLowerCase().includes(lowerCaseModel));

      +            setFilteredModels(filtered);

      +            setModelSelectionIndex(0);

      +        } else {

      +            setFilteredModels([]);

      +        }

      +    }, [localModel, activeField]);

      +
           const saveAndExit = () => {
               settingsActions.setProvider(localProvider);
               settingsActions.setApiKey(localApiKey);
      @@ -58,6 +72,23 @@
                       }
                       setActiveField('apiKey');
                   }
      +        } else if (activeField === 'model') {

      +            if (filteredModels.length > 0) {

      +                if (key.upArrow) {

      +                    setModelSelectionIndex(prev => (prev > 0 ? prev - 1 :
      filteredModels.length - 1));

      +                }

      +                if (key.downArrow) {

      +                    setModelSelectionIndex(prev => (prev <
      filteredModels.length - 1 ? prev + 1 : 0));

      +                }

      +            }

      +            if (key.return) {

      +                if (filteredModels.length > 0 &&
      filteredModels[modelSelectionIndex]) {

      +                    setLocalModel(filteredModels[modelSelectionIndex]!);

      +                }

      +                setActiveField('provider'); // Cycle to next field

      +            }
               }
           }, { isActive: true });
       
           // Update localProvider whenever selection index changes
      @@ -76,5 +107,7 @@
               providerSelectionIndex,
               isApiKeyFocused: activeField === 'apiKey',
               isModelFocused: activeField === 'model',
      +        filteredModels,

      +        modelSelectionIndex,
           };
       };

    patchStrategy: standard-diff
  - type: write
    path: src/components/SettingsScreen.tsx
    content: >+
      --- src/components/SettingsScreen.tsx

      +++ src/components/SettingsScreen.tsx

      @@ -13,6 +13,8 @@
               providerSelectionIndex,
               isApiKeyFocused,
               isModelFocused,
      +        filteredModels,

      +        modelSelectionIndex,
           } = useSettingsScreen();
       
           return (
      @@ -56,6 +58,15 @@
                                   focus={isModelFocused}
                               />
                           </Box>
      +                    {isModelFocused && filteredModels.length > 0 && model
      !== (filteredModels[modelSelectionIndex] || '') && (

      +                        <Box flexDirection="column" paddingLeft={4}
      marginTop={1}>

      +                            {filteredModels.map((m, index) => (

      +                                <Text key={m} color={modelSelectionIndex
      === index ? 'cyan' : undefined}>

      +                                    {m}

      +                                </Text>

      +                            ))}

      +                        </Box>

      +                    )}
                       </Box>
                   </Box>
               </ScreenLayout>

    patchStrategy: standard-diff
snapshot:
  src/services/ai.service.ts: |-
    import { useSettingsStore } from '../stores/settings.store';
    import { sleep } from '../utils';
    import type { Transaction, FileItem } from '../types/domain.types';

    // Mock function to simulate running an auto-fix with an AI
    export async function* runAutoFix(
        failedFiles: FileItem[],
        _transaction: Transaction,
    ): AsyncGenerator<any, { newPatch: string }, unknown> {
        const { model } = useSettingsStore.getState();

        yield { type: 'UPDATE_STEP', payload: { id: 'prompt', status: 'active' } };
        await sleep(200);
        // In a real app, you would generate a detailed prompt here.
        yield { type: 'UPDATE_STEP', payload: { id: 'prompt', status: 'done', details: `Generated prompts for ${failedFiles.length} files.` } };

        yield { type: 'UPDATE_STEP', payload: { id: 'request', status: 'active' } };
        yield { type: 'ADD_SUBSTEP', payload: { parentId: 'request', substep: { id: failedFiles[0]!.id, title: `Fixing: ${failedFiles[0]!.path}`, status: 'active' }}};
        await sleep(1500); // Simulate network latency
        yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'request', substepId: failedFiles[0]!.id, status: 'done' }};
        if (failedFiles.length > 1) {
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'request', substep: { id: failedFiles[1]!.id, title: `Fixing: ${failedFiles[1]!.path}`, status: 'active' }}};
            await sleep(1200);
            yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'request', substepId: failedFiles[1]!.id, status: 'done' }};
        }
        yield { type: 'UPDATE_STEP', payload: { id: 'request', status: 'done', details: `Received responses from '${model}'` } };
        
        yield { type: 'UPDATE_STEP', payload: { id: 'patch', status: 'active' } };
        await sleep(500);
        // In a real app, this would be the actual patch from the AI.
        const newPatch = `--- a/src/services/payment.gateway.ts
    +++ b/src/services/payment.gateway.ts
    @@ -10,7 +10,7 @@
      */
     export class PaymentGateway {
     -    private static instance: PaymentGateway;
    +    private static instance: PaymentGateway | null = null;
         private apiKey: string;
     
         private constructor(apiKey: string) {
    `;
        yield { type: 'UPDATE_STEP', payload: { id: 'patch', status: 'done', details: 'Validated and formatted new patch.' } };

        await sleep(500);

        return { newPatch };
    }

    export const AiService = {
        runAutoFix,
    };
  src/components/AiProcessingScreen.tsx: >-
    import { Box, Text } from 'ink';

    import Spinner from 'ink-spinner';

    import { type ApplyStep, useReviewStore } from '../stores/review.store'; //
    ApplyStep can be reused

    import ActionFooter from './ActionFooter';

    import { useAiProcessingScreen } from '../hooks/useAiProcessingScreen';

    import Separator from './Separator';

    import ScreenLayout from './layout/ScreenLayout';


    // This component is nearly identical to a row in ReviewProcessingScreen.

    // In a real app, this could be extracted into a shared component.

    const ProcessingStepRow = ({ step, now }: {
        step: ApplyStep;
        now: number;
    }) => {
        let symbol;
        let color;
        switch (step.status) {
            case 'pending': symbol = '( )'; break;
            case 'active': symbol = '(●)'; color = 'cyan'; break;
            case 'done': symbol = '[✓]'; color = 'green'; break;
            case 'failed': symbol = '[!]'; color = 'red'; break;
            case 'skipped': symbol = '(-)'; color = 'gray'; break;
        }

        let durationText = '';
        if (step.status === 'active' && step.startTime) {
            durationText = ` (${((now - step.startTime) / 1000).toFixed(1)}s)`;
        } else if (step.duration) {
            durationText = ` (${step.duration.toFixed(1)}s)`;
        }

        return (
            <Box flexDirection="column">
                <Text>
                    <Text color={color}>{symbol}</Text> {step.title}{durationText}
                </Text>
                {step.details && (
                    <Text color="gray">
                        {'     └─ '}{step.details}
                    </Text>
                )}
                {step.substeps?.map((sub: ApplyStep, i: number) => (
                    <Box key={i} paddingLeft={5}>
                         <Text color={sub.status === 'done' ? 'green' : sub.status === 'failed' ? 'red' : 'gray'}>
                            {sub.status === 'active' ? <Text color="cyan"><Spinner type="dots" /></Text> : sub.status === 'done' ? '✓' : '○'}{' '}{sub.title}
                         </Text>
                    </Box>
                ))}
            </Box>
        );
    };


    const AiProcessingScreen = () => {
        const {
            transaction,
            aiProcessingSteps,
            isProcessing,
            elapsedTime,
            now,
        } = useAiProcessingScreen();

        const renderFooter = () => {
            if (isProcessing) {
                return (
                    <Box flexDirection="column" gap={1}>
                        <Text>Elapsed: {elapsedTime.toFixed(1)}s · Processing... Please wait.</Text>
                        <Separator />
                        <ActionFooter actions={[{ key: 'Ctrl+C', label: 'Cancel Process' }]} />
                    </Box>
                );
            }
            return <Text>Elapsed: {elapsedTime.toFixed(1)}s · Repair complete. Transitioning...</Text>;
        };

        if (!transaction) {
            return <Text>Loading...</Text>;
        }

        const failedFilesCount = Array.from(
            useReviewStore.getState().fileReviewStates.values()
        ).filter(s => s.status === 'FAILED').length;

        return (
            <ScreenLayout
                title="AI AUTO-REPAIR"
                footer={renderFooter()}
            >
                <Box flexDirection="column">
                    <Text>Attempting to auto-repair {failedFilesCount} failed files... ({transaction.message})</Text>
                    <Box flexDirection="column" marginTop={1} gap={1}>
                        {aiProcessingSteps.map((step: ApplyStep) => <ProcessingStepRow key={step.id} step={step} now={now} />)}
                    </Box>
                </Box>
            </ScreenLayout>
        );
    };


    export default AiProcessingScreen;
  src/constants/settings.constants.ts: |-
    import type { ActionItem } from '../types/actions.types';
    import type { AiProvider } from '../stores/settings.store';

    export const AI_PROVIDERS: { value: AiProvider; label: string }[] = [
        { value: 'openrouter', label: 'OpenRouter' },
        { value: 'groq', label: 'Groq' },
        { value: 'together', label: 'Together AI' },
        { value: 'custom', label: 'Custom (OpenAI compatible)' },
    ];

    export const SETTINGS_FOOTER_ACTIONS: readonly ActionItem[] = [
        { key: '↑↓', label: 'Nav Options' },
        { key: 'Enter', label: 'Select' },
        { key: 'Tab', label: 'Next Field' },
        { key: 'Esc', label: 'Close & Save' },
    ] as const;
  src/hooks/useSettingsScreen.tsx: >-
    import { useState, useEffect } from 'react';

    import { useInput } from 'ink';

    import { useSettingsStore, type AiProvider } from
    '../stores/settings.store';

    import { useAppStore } from '../stores/app.store';

    import { AI_PROVIDERS } from '../constants/settings.constants';


    type SettingsField = 'provider' | 'apiKey' | 'model';


    export const useSettingsScreen = () => {
        const { provider, apiKey, model, actions: settingsActions } = useSettingsStore();
        const { showDashboardScreen } = useAppStore(s => s.actions);

        const [activeField, setActiveField] = useState<SettingsField>('provider');
        const [localProvider, setLocalProvider] = useState<AiProvider>(provider);
        const [localApiKey, setLocalApiKey] = useState<string>(apiKey);
        const [localModel, setLocalModel] = useState<string>(model);
        const [providerSelectionIndex, setProviderSelectionIndex] = useState(
            () => AI_PROVIDERS.findIndex(p => p.value === provider)
        );

        // Sync local state with global store when component mounts
        useEffect(() => {
            setLocalProvider(provider);
            setLocalApiKey(apiKey);
            setLocalModel(model);
            setProviderSelectionIndex(AI_PROVIDERS.findIndex(p => p.value === provider));
        }, [provider, apiKey, model]);

        const saveAndExit = () => {
            settingsActions.setProvider(localProvider);
            settingsActions.setApiKey(localApiKey);
            settingsActions.setModel(localModel);
            showDashboardScreen();
        };

        useInput((_input, key) => {
            if (key.escape) {
                saveAndExit();
                return;
            }

            if (key.tab) {
                setActiveField(current => {
                    if (current === 'provider') return 'apiKey';
                    if (current === 'apiKey') return 'model';
                    return 'provider';
                });
                return;
            }

            if (activeField === 'provider') {
                if (key.upArrow) {
                    setProviderSelectionIndex(prev => (prev - 1 + AI_PROVIDERS.length) % AI_PROVIDERS.length);
                }
                if (key.downArrow) {
                    setProviderSelectionIndex(prev => (prev + 1) % AI_PROVIDERS.length);
                }
                if (key.return) {
                    const selectedProvider = AI_PROVIDERS[providerSelectionIndex];
                    if (selectedProvider) {
                        setLocalProvider(selectedProvider.value);
                    }
                    setActiveField('apiKey');
                }
            }
        }, { isActive: true });

        // Update localProvider whenever selection index changes
        useEffect(() => {
            const selectedProvider = AI_PROVIDERS[providerSelectionIndex];
            if (selectedProvider) {
                setLocalProvider(selectedProvider.value);
            }
        }, [providerSelectionIndex]);

        return {
            activeField,
            provider: localProvider,
            apiKey: localApiKey,
            model: localModel,
            setApiKey: setLocalApiKey,
            setModel: setLocalModel,
            providerSelectionIndex,
            isApiKeyFocused: activeField === 'apiKey',
            isModelFocused: activeField === 'model',
        };
    };
  src/components/SettingsScreen.tsx: >-
    import { Box, Text } from 'ink';

    import TextInput from 'ink-text-input';

    import ScreenLayout from './layout/ScreenLayout';

    import { useSettingsScreen } from '../hooks/useSettingsScreen';

    import { AI_PROVIDERS, SETTINGS_FOOTER_ACTIONS } from
    '../constants/settings.constants';

    import ActionFooter from './ActionFooter';


    const SettingsScreen = () => {
        const {
            activeField,
            apiKey,
            model,
            setApiKey,
            setModel,
            providerSelectionIndex,
            isApiKeyFocused,
            isModelFocused,
        } = useSettingsScreen();

        return (
            <ScreenLayout
                title="SETTINGS"
                footer={<ActionFooter actions={SETTINGS_FOOTER_ACTIONS} />}
            >
                <Box flexDirection="column" gap={1}>
                    <Text>Configure your AI provider. Your API key will be stored locally.</Text>

                    <Box flexDirection="column" marginTop={1}>
                        <Text bold={activeField === 'provider'}>
                            {activeField === 'provider' ? '> ' : '  '}AI Provider:
                        </Text>
                        <Box flexDirection="column" paddingLeft={2}>
                            {AI_PROVIDERS.map((p, index) => (
                                <Text key={p.value} color={providerSelectionIndex === index ? 'cyan' : undefined}>
                                    {p.label}
                                </Text>
                            ))}
                        </Box>
                    </Box>

                    <Box flexDirection="column">
                        <Text bold={isApiKeyFocused}>
                            {isApiKeyFocused ? '> ' : '  '}API Key:
                        </Text>
                        <Box paddingLeft={2}>
                            <TextInput
                                value={apiKey}
                                onChange={setApiKey}
                                onSubmit={() => {}}
                                placeholder="sk-or-v1-..."
                                mask="*"
                                focus={isApiKeyFocused}
                            />
                        </Box>
                    </Box>

                    <Box flexDirection="column">
                        <Text bold={isModelFocused}>
                            {isModelFocused ? '> ' : '  '}Model: (type to search)
                        </Text>
                        <Box paddingLeft={2}>
                             <TextInput
                                value={model}
                                onChange={setModel}
                                onSubmit={() => {}}
                                placeholder="meta-llama/llama-3-8b-instruct"
                                focus={isModelFocused}
                            />
                        </Box>
                    </Box>
                </Box>
            </ScreenLayout>
        );
    };


    export default SettingsScreen;
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 234
