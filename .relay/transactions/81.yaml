uuid: 4268e6f1-3ecf-474c-a117-64058d867c26
projectId: relaycode-tui
createdAt: '2025-09-24T14:42:25.419Z'
gitCommitMsg: >-
  refactor(types): Consolidate core data types for DRYness

  Executes the first phase of a major DRY refactoring by introducing a single
  source of truth for core domain models and UI view types. This change
  eliminates data duplication and lays the groundwork for preventing data
  integrity issues.

  - Created `src/types/domain.types.ts` to house core models like `Transaction`
  and the new unified `FileItem`. - Created `src/types/view.types.ts` for all
  UI-specific state types like `AppScreen`, `DashboardStatus`, etc. - Unified
  `BaseFileItem`, `FileChange`, and `ReviewFileItem` into a single `FileItem`
  interface. - Updated all components, hooks, services, and stores to import
  from and use these new centralized type definitions. - Deleted the
  now-redundant individual type files.
promptSummary: >-
  Execute Part 1 of the DRY refactoring plan to consolidate core data models and
  types.
reasoning:
  - >-
    I will now execute Part 1 of the refactoring plan, which focuses on
    consolidating the core data models and types into a more organized and DRY
    structure.
  - '### 1. Create Consolidated Type Definition Files'
  - >-
    First, I'll create `src/types/domain.types.ts` for core data models and
    `src/types/view.types.ts` for UI-specific types. This centralizes type
    definitions and establishes a single source of truth for the application's
    data structures.
  - '### 2. Update Data Mocks'
  - Next, I'll update the mock data to use the new unified `FileItem` type.
  - '### 3. Update Imports and Type Usage Across the Application'
  - >-
    I will now update all relevant files to use the new centralized types and
    remove references to the old, scattered type definitions.
  - '### 4. Mark Obsolete Type Files for Deletion'
  - Finally, I'll mark all the now-redundant type definition files for deletion.
  - >-
    This completes the first part of the refactoring. I have consolidated the
    data models, updated all references, and prepared the obsolete files for
    deletion. The next stage will focus on refactoring the Zustand stores to use
    this new single source of truth.
operations:
  - type: write
    path: src/types/domain.types.ts
    content: >-
      // --- Core Domain Models ---


      /** The type of change applied to a file. */

      export type FileChangeType = 'MOD' | 'ADD' | 'DEL' | 'REN';


      /** The review status of a file within a transaction. */

      export type FileReviewStatus = 'FAILED' | 'APPROVED' | 'REJECTED' |
      'AWAITING' | 'RE_APPLYING';


      /** The result of a script execution. */

      export interface ScriptResult {
          command: string;
          success: boolean;
          duration: number;
          summary: string;
          output: string;
      }


      /** The unified representation of a file change within a transaction. */

      export interface FileItem {
          id: string;
          path: string;
          diff: string;
          linesAdded: number;
          linesRemoved: number;
          type: FileChangeType;
          strategy?: 'replace' | 'standard-diff';
          // Review-specific, optional properties
          reviewStatus?: FileReviewStatus;
          reviewError?: string;
      }


      /** The lifecycle status of a transaction. */

      export type TransactionStatus =
          | 'PENDING'
          | 'APPLIED'
          | 'COMMITTED'
          | 'FAILED'
          | 'REVERTED'
          | 'IN-PROGRESS'
          | 'HANDOFF';

      /** The central data model for a code modification transaction. */

      export interface Transaction {
          id: string;
          timestamp: number;
          status: TransactionStatus;
          hash: string;
          message: string;
          prompt?: string;
          reasoning?: string;
          error?: string;
          files?: FileItem[];
          scripts?: ScriptResult[];
          stats?: {
              files: number;
              linesAdded: number;
              linesRemoved: number;
          };
      }
    patchStrategy: replace
  - type: write
    path: src/types/view.types.ts
    content: >-
      // --- UI / View-Specific Types ---


      // app.store

      export type AppScreen = 'splash' | 'init' | 'dashboard' | 'review' |
      'review-processing' | 'git-commit' | 'transaction-detail' |
      'transaction-history';


      // dashboard.store

      export type DashboardStatus = 'LISTENING' | 'PAUSED' | 'CONFIRM_APPROVE' |
      'APPROVING';


      // init.store

      export type TaskStatus = 'pending' | 'active' | 'done';

      export type InitPhase = 'ANALYZE' | 'CONFIGURE' | 'INTERACTIVE' |
      'FINALIZE';

      export type GitignoreChoice = 'ignore' | 'share';

      export interface Task {
          id: string;
          title: string;
          subtext?: string;
          status: TaskStatus;
      }


      // review.store

      export interface ApplyStep {
          id: string;
          title: string;
          status: 'pending' | 'active' | 'done' | 'failed' | 'skipped';
          details?: string;
          substeps?: ApplyStep[];
          duration?: number;
      }

      export type ReviewBodyView = 'diff' | 'reasoning' | 'script_output' |
      'bulk_repair' | 'confirm_handoff' | 'none';

      export type PatchStatus = 'SUCCESS' | 'PARTIAL_FAILURE';

      export type ApplyUpdate =
          | { type: 'UPDATE_STEP'; payload: { id: string; status: ApplyStep['status']; duration?: number; details?: string } }
          | { type: 'ADD_SUBSTEP'; payload: { parentId: string; substep: Omit<ApplyStep, 'substeps'> } };


      // transaction-detail.store

      export type NavigatorSection = 'PROMPT' | 'REASONING' | 'FILES';

      export type DetailBodyView = 'PROMPT' | 'REASONING' | 'FILES_LIST' |
      'DIFF_VIEW' | 'REVERT_CONFIRM' | 'NONE';


      // transaction-history.store

      export type HistoryViewMode = 'LIST' | 'FILTER' | 'BULK_ACTIONS';
    patchStrategy: replace
  - type: write
    path: src/data/mocks.ts
    content: >+
      --- src/data/mocks.ts

      +++ src/data/mocks.ts

      @@ -1,4 +1,4 @@

      -import type { Transaction } from '../types/transaction.types';

      +import type { Transaction } from '../types/domain.types';
       
       const mockReasoning1 = `1. Identified a potential uncaught exception in the \`restoreSnapshot\` function
          if a file operation fails midway through a loop of many files. This could
      @@ -19,9 +19,9 @@
               prompt: 'Rename the `calculateChanges` utility to `computeDelta` across all files and update imports accordingly.',
               reasoning: mockReasoning1,
               files: [
      -            { id: '1-1', path: 'src/core/transaction.ts', type: 'MOD',
      linesAdded: 18, linesRemoved: 5, diff: '--- a/src/core/transaction.ts\n+++
      b/src/core/transaction.ts\n@@ -15,7 +15,7 @@ export class Transaction
      {\n   }\n\n-  calculateChanges(): ChangeSet {\n+  computeDelta():
      ChangeSet {\n     return this.changes;\n   }\n }', strategy: 'replace' },

      -            { id: '1-2', path: 'src/utils/logger.ts', type: 'MOD',
      linesAdded: 0, linesRemoved: 0, diff: '', strategy: 'standard-diff' },

      -            { id: '1-3', path: 'src/commands/apply.ts', type: 'MOD',
      linesAdded: 0, linesRemoved: 0, diff: '', strategy: 'standard-diff' },

      +            { id: '1-1', type: 'MOD', path: 'src/core/transaction.ts',
      linesAdded: 18, linesRemoved: 5, diff: '--- a/src/core/transaction.ts\n+++
      b/src/core/transaction.ts\n@@ -15,7 +15,7 @@ export class Transaction
      {\n   }\n\n-  calculateChanges(): ChangeSet {\n+  computeDelta():
      ChangeSet {\n     return this.changes;\n   }\n }', strategy: 'replace' },

      +            { id: '1-2', type: 'MOD', path: 'src/utils/logger.ts',
      linesAdded: 0, linesRemoved: 0, diff: '', strategy: 'standard-diff' },

      +            { id: '1-3', type: 'MOD', path: 'src/commands/apply.ts',
      linesAdded: 0, linesRemoved: 0, diff: '', strategy: 'standard-diff' },
               ],
               stats: { files: 3, linesAdded: 18, linesRemoved: 5 },
           },
      @@ -34,8 +34,8 @@
               prompt: 'Simplify the clipboard logic using an external library...',
               reasoning: 'The existing clipboard logic was complex and platform-dependent. Using the `clipboardy` library simplifies the code and improves reliability across different operating systems.',
               files: [
      -            { id: '2-1', path: 'src/core/clipboard.ts', type: 'MOD',
      linesAdded: 15, linesRemoved: 8, diff: '--- a/src/core/clipboard.ts\n+++
      b/src/core/clipboard.ts\n@@ -1,5 +1,6 @@\n import { copy as
      copyToClipboard } from \'clipboardy\';', strategy: 'replace' },

      -            { id: '2-2', path: 'src/utils/shell.ts', type: 'MOD',
      linesAdded: 7, linesRemoved: 3, diff: '--- a/src/utils/shell.ts\n+++
      b/src/utils/shell.ts', strategy: 'standard-diff' },

      +            { id: '2-1', type: 'MOD', path: 'src/core/clipboard.ts',
      linesAdded: 15, linesRemoved: 8, diff: '--- a/src/core/clipboard.ts\n+++
      b/src/core/clipboard.ts\n@@ -1,5 +1,6 @@\n import { copy as
      copyToClipboard } from \'clipboardy\';', strategy: 'replace' },

      +            { id: '2-2', type: 'MOD', path: 'src/utils/shell.ts',
      linesAdded: 7, linesRemoved: 3, diff: '--- a/src/utils/shell.ts\n+++
      b/src/utils/shell.ts', strategy: 'standard-diff' },
               ],
               stats: { files: 2, linesAdded: 22, linesRemoved: 11 },
               scripts: [
      @@ -51,9 +51,9 @@
               prompt: 'The user requested to add more robust error handling to the `restoreSnapshot` function. Specifically, it should not halt on the first error but instead attempt all file restorations and then report a summary of any failures.',
               reasoning: mockReasoning1,
               files: [
      -            { id: '3-1', path: 'src/core/transaction.ts', type: 'MOD',
      linesAdded: 18, linesRemoved: 5, diff: '... diff ...' },

      -            { id: '3-2', path: 'src/utils/logger.ts', type: 'MOD',
      linesAdded: 7, linesRemoved: 3, diff: '... diff ...' },

      -            { id: '3-3', path: 'src/utils/old-helper.ts', type: 'DEL',
      linesAdded: 0, linesRemoved: 30, diff: '... diff ...' },

      +            { id: '3-1', type: 'MOD', path: 'src/core/transaction.ts',
      linesAdded: 18, linesRemoved: 5, diff: '... diff ...' },

      +            { id: '3-2', type: 'MOD', path: 'src/utils/logger.ts',
      linesAdded: 7, linesRemoved: 3, diff: '... diff ...' },

      +            { id: '3-3', type: 'DEL', path: 'src/utils/old-helper.ts',
      linesAdded: 0, linesRemoved: 30, diff: '... diff ...' },
               ],
               stats: { files: 3, linesAdded: 25, linesRemoved: 38 },
           },

    patchStrategy: standard-diff
  - type: write
    path: src/components/DashboardScreen.tsx
    content: |+
      --- src/components/DashboardScreen.tsx
      +++ src/components/DashboardScreen.tsx
      @@ -2,8 +2,8 @@
       import { Box, Text } from 'ink';
       import Spinner from 'ink-spinner';
       import { type Transaction, type DashboardStatus } from '../stores/dashboard.store';
      -import type { TransactionStatus } from '../types/transaction.types';
       import Separator from './Separator';
      +import type { TransactionStatus } from '../types/domain.types';
       import { useDashboardScreen } from '../hooks/useDashboardScreen';
       
       // --- Sub-components & Helpers ---

    patchStrategy: standard-diff
  - type: write
    path: src/components/InitializationScreen.tsx
    content: |
      --- src/components/InitializationScreen.tsx
      +++ src/components/InitializationScreen.tsx
      @@ -1,6 +1,6 @@
       import React from 'react';
       import { Box, Text } from 'ink';
      -import { type Task } from '../stores/init.store';
      +import type { Task } from '../types/view.types';
       import Separator from './Separator';
       import { useInitializationScreen } from '../hooks/useInitializationScreen';
       
    patchStrategy: standard-diff
  - type: write
    path: src/components/ReviewProcessingScreen.tsx
    content: |+
      --- src/components/ReviewProcessingScreen.tsx
      +++ src/components/ReviewProcessingScreen.tsx
      @@ -1,7 +1,7 @@
       import React from 'react';
       import { Box, Text } from 'ink';
      +import { useTransactionStore } from '../stores/transaction.store';
       import { useReviewStore, type ApplyStep } from '../stores/review.store';
      -import { useTransactionStore } from '../stores/transaction.store';
       import Separator from './Separator';
       
       const ApplyStepRow = ({ step, isSubstep = false }: { step: ApplyStep, isSubstep?: boolean }) => {

    patchStrategy: standard-diff
  - type: write
    path: src/components/ReviewScreen.tsx
    content: >+
      --- src/components/ReviewScreen.tsx

      +++ src/components/ReviewScreen.tsx

      @@ -1,15 +1,15 @@
       import React from 'react';
       import { Box, Text } from 'ink';
      -import { type ReviewFileItem, type ScriptResult } from
      '../stores/review.store';
       import Separator from './Separator';
       import DiffScreen from './DiffScreen';
       import ReasonScreen from './ReasonScreen';
      +import { type ReviewFileItem, type ScriptResult } from
      '../stores/review.store';
       import { useReviewScreen } from '../hooks/useReviewScreen';
       
       // --- Sub-components ---
       
       const FileItemRow = ({ file, isSelected }: { file: ReviewFileItem, isSelected: boolean }) => {
           let icon;
           let iconColor;
      -    switch (file.status) {

      +    switch (file.reviewStatus) {
               case 'APPROVED': icon = '[✓]'; iconColor = 'green'; break;
               case 'REJECTED': icon = '[✗]'; iconColor = 'red'; break;
               case 'FAILED': icon = '[!]'; iconColor = 'red'; break;
      @@ -21,17 +21,17 @@
           const strategy = file.strategy === 'standard-diff' ? 'diff' : file.strategy;
           const prefix = isSelected ? '> ' : '  ';
       
      -    if (file.status === 'FAILED') {

      +    if (file.reviewStatus === 'FAILED') {
               return (
                   <Box>
                       <Text bold={isSelected} color={isSelected ? 'cyan' : undefined}>
                           {prefix}<Text color={iconColor}>{icon} FAILED {file.path}</Text>
      -                    <Text color="red">    ({file.error})</Text>

      +                    <Text color="red">    ({file.reviewError})</Text>
                       </Text>
                   </Box>
               );
           }
       
      -    if (file.status === 'AWAITING') {

      +    if (file.reviewStatus === 'AWAITING') {
               return (
                   <Box>
                       <Text bold={isSelected} color={isSelected ? 'cyan' : undefined}>
      @@ -41,7 +41,7 @@
               );
           }
       
      -    if (file.status === 'RE_APPLYING') {

      +    if (file.reviewStatus === 'RE_APPLYING') {
               return (
                    <Box>
                       <Text bold={isSelected} color={isSelected ? 'cyan' : undefined}>
      @@ -201,7 +201,7 @@
       
               if (bodyView === 'bulk_repair') {
      -            const failedFiles = files.filter(f => f.status === 'FAILED');

      +            const failedFiles = files.filter(f => f.reviewStatus ===
      'FAILED');
                   const repairOptions = [
                       '(1) Copy Bulk Re-apply Prompt (for single-shot AI)',
                       '(2) Bulk Change Strategy & Re-apply',
      @@ -248,15 +248,15 @@
               const actions = ['(↑↓) Nav'];
       
               const isFileSelected = selectedItemIndex < numFiles;
      -        const hasFailedFiles = files.some(f => f.status === 'FAILED');

      +        const hasFailedFiles = files.some(f => f.reviewStatus ===
      'FAILED');
               
               if (isFileSelected) {
                   const selectedFile = files[selectedItemIndex];
      -            if (selectedFile && selectedFile.status !== 'FAILED') {

      +            if (selectedFile && selectedFile.reviewStatus !== 'FAILED') {
                       actions.push('(Spc) Toggle');
                   }
                   actions.push('(D)iff');
                   
                   // Add repair options for failed files
      -            if (selectedFile && selectedFile.status === 'FAILED') {

      +            if (selectedFile && selectedFile.reviewStatus === 'FAILED') {
                       actions.push('(T)ry Repair');
                   }
               } else { // script selected
      @@ -273,7 +273,7 @@
                   actions.push('(A)pprove');
               }
       
      -        if (files.some(f => f.status === 'APPROVED' || f.status ===
      'FAILED')) {

      +        if (files.some(f => f.reviewStatus === 'APPROVED' ||
      f.reviewStatus === 'FAILED')) {
                   actions.push('(Shift+R) Reject All');
               }
               actions.push('(Q)uit');

    patchStrategy: standard-diff
  - type: write
    path: src/components/TransactionDetailScreen.tsx
    content: |+
      --- src/components/TransactionDetailScreen.tsx
      +++ src/components/TransactionDetailScreen.tsx
      @@ -1,10 +1,10 @@
       import React from 'react';
       import { Box, Text } from 'ink';
      -import { type FileChangeType } from '../types/file.types';
       import Separator from './Separator';
       import DiffScreen from './DiffScreen';
       import ReasonScreen from './ReasonScreen';
       import { useTransactionDetailScreen } from '../hooks/useTransactionDetailScreen';
      +import type { FileChangeType } from '../types/domain.types';
       
       const getFileChangeTypeIcon = (type: FileChangeType) => {
           switch (type) {

    patchStrategy: standard-diff
  - type: write
    path: src/components/TransactionHistoryScreen.tsx
    content: |+
      --- src/components/TransactionHistoryScreen.tsx
      +++ src/components/TransactionHistoryScreen.tsx
      @@ -2,8 +2,8 @@
       import { Box, Text } from 'ink';
       import TextInput from 'ink-text-input';
       import { type FileChange } from '../stores/transaction-history.store';
      -import type { Transaction } from '../types/transaction.types';
       import Separator from './Separator';
      +import type { Transaction } from '../types/domain.types';
       import { useTransactionHistoryScreen } from '../hooks/useTransactionHistoryScreen';
       
       // --- Sub-components ---

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useReviewScreen.tsx
    content: >+
      --- src/hooks/useReviewScreen.tsx

      +++ src/hooks/useReviewScreen.tsx

      @@ -2,7 +2,7 @@
       import { useInput, useApp } from 'ink';
       import { useReviewStore } from '../stores/review.store';
       import { useAppStore } from '../stores/app.store';
      -import { useTransactionStore } from '../stores/transaction.store';

      +import { useTransactionStore } from '../stores/transaction.store';
       import { useCopyStore, type CopyItem } from '../stores/copy.store';
       import { CopyService } from '../services/copy.service';
       
      @@ -30,7 +30,7 @@
               approvedLinesRemoved,
           } = useMemo(() => {
      -        const approvedFiles = files.filter(f => f.status === 'APPROVED');

      +        const approvedFiles = files.filter(f => f.reviewStatus ===
      'APPROVED');
               return {
                   numFiles: files.length,
                   approvedFilesCount: approvedFiles.length,
      @@ -140,7 +140,7 @@
               if (input === ' ') {
                   if (selectedItemIndex < numFiles) {
                       const file = files[selectedItemIndex];
      -                if (file && file.status !== 'FAILED') {

      +                if (file && file.reviewStatus !== 'FAILED') {
                           toggleFileApproval();
                       }
                   }
      @@ -170,12 +170,12 @@
               // Handle T for single repair and Shift+T for bulk repair
               if (input.toLowerCase() === 't') {
                   if (key.shift) {
      -                const hasFailedFiles = files.some(f => f.status ===
      'FAILED');

      +                const hasFailedFiles = files.some(f => f.reviewStatus ===
      'FAILED');
                       if (hasFailedFiles) {
                           showBulkRepair();
                       }
                   } else {
      -                if (selectedItemIndex < numFiles) {

      +                if (selectedItemIndex < numFiles) {
                           const file = files[selectedItemIndex];
      -                    if (file && file.status === 'FAILED') {

      +                    if (file && file.reviewStatus === 'FAILED') {
                               tryRepairFile();
                           }
                       }

    patchStrategy: standard-diff
  - type: write
    path: src/services/commit.service.ts
    content: |+
      --- src/services/commit.service.ts
      +++ src/services/commit.service.ts
      @@ -1,4 +1,4 @@
      -import type { Transaction } from '../types/transaction.types';
      +import type { Transaction } from '../types/domain.types';
       import { sleep } from '../utils';
       import { useTransactionStore } from '../stores/transaction.store';
       

    patchStrategy: standard-diff
  - type: write
    path: src/services/copy.service.ts
    content: |+
      --- src/services/copy.service.ts
      +++ src/services/copy.service.ts
      @@ -1,14 +1,13 @@
      -import type { Transaction } from '../types/transaction.types';
      -import type { ReviewFileItem } from '../stores/review.store';
      -import type { FileChange } from '../types/file.types';
      +import type { Transaction, FileItem } from '../types/domain.types';
       import type { CopyItem } from '../types/copy.types';
       import { COPYABLE_ITEMS } from '../types/copy.types';
       
       const getCopyItemsForReview = (
           transaction: Transaction,
      -    files: ReviewFileItem[],
      -    selectedFile?: ReviewFileItem,
      +    files: FileItem[],
      +    selectedFile?: FileItem,
       ): CopyItem[] => {
           return [
               { id: 'uuid', key: 'U', label: COPYABLE_ITEMS.UUID, getData: () => transaction.id },
      @@ -21,7 +20,7 @@
       
       const getCopyItemsForDetail = (
           transaction: Transaction,
      -    selectedFile?: FileChange,
      +    selectedFile?: FileItem,
       ): CopyItem[] => {
           return [
               { id: 'message', key: 'M', label: COPYABLE_ITEMS.MESSAGE, getData: () => transaction.message, isDefaultSelected: true },

    patchStrategy: standard-diff
  - type: write
    path: src/services/init.service.ts
    content: |+
      --- src/services/init.service.ts
      +++ src/services/init.service.ts
      @@ -1,5 +1,5 @@
       import { useInitStore } from '../stores/init.store';
      -import type { Task } from '../types/init.types';
      +import type { Task } from '../types/view.types';
       import { sleep } from '../utils';
       
       const initialAnalyzeTasks: Task[] = [

    patchStrategy: standard-diff
  - type: write
    path: src/services/review.service.ts
    content: >+
      --- src/services/review.service.ts

      +++ src/services/review.service.ts

      @@ -1,13 +1,13 @@

      -import { useReviewStore, type ReviewFileItem } from
      '../stores/review.store';

      +import { useReviewStore } from '../stores/review.store';
       import { useTransactionStore } from '../stores/transaction.store';
       import { useAppStore } from '../stores/app.store';
       import { sleep } from '../utils';
      -import type { ApplyStep, ApplyUpdate, ReviewBodyView } from
      '../types/review.types';

      +import type { ApplyStep, ApplyUpdate, ReviewBodyView } from
      '../types/view.types';

      +import type { FileItem } from '../types/domain.types';
       
      -const generateBulkRepairPrompt = (files: ReviewFileItem[]): string => {

      -    const failedFiles = files.filter(f => f.status === 'FAILED');

      +const generateBulkRepairPrompt = (files: FileItem[]): string => {

      +    const failedFiles = files.filter(f => f.reviewStatus === 'FAILED');
           return `The previous patch failed to apply to MULTIPLE files. Please generate a new, corrected patch that addresses all the files listed below.
       
       IMPORTANT: The response MUST contain a complete code block for EACH file that needs to be fixed.
      @@ -15,7 +15,7 @@
       ${failedFiles.map(file => `--- FILE: ${file.path} ---
       Strategy: ${file.strategy}
      -Error: ${file.error}

      +Error: ${file.reviewError}
       
       ORIGINAL CONTENT:
       ---
      @@ -32,10 +32,10 @@
           hash: string,
           message: string,
           reasoning: string,
      -    files: ReviewFileItem[],

      +    files: FileItem[],
       ): string => {
      -    const successfulFiles = files.filter(f => f.status === 'APPROVED');

      -    const failedFiles = files.filter(f => f.status === 'FAILED');

      +    const successfulFiles = files.filter(f => f.reviewStatus ===
      'APPROVED');

      +    const failedFiles = files.filter(f => f.reviewStatus === 'FAILED');
       
           return `I am handing off a failed automated code transaction to you. Your task is to act as my programming assistant and complete the planned changes.
       
      @@ -52,7 +52,7 @@
       ${successfulFiles.map(f => `- MODIFIED: ${f.path}`).join('\n') || '  (None)'}
       
       FAILED CHANGES (these are the files you need to fix):
      -${failedFiles.map(f => `- FAILED: ${f.path} (Error:
      ${f.error})`).join('\n')}

      +${failedFiles.map(f => `- FAILED: ${f.path} (Error:
      ${f.reviewError})`).join('\n')}
       
       Your job is to now work with me to fix the FAILED files and achieve the original goal of the transaction. Please start by asking me which file you should work on first.`;
       };
      @@ -112,10 +112,10 @@
           useReviewStore.getState().actions.load(transactionId, initialState);
       };
       
      -const generateSingleFileRepairPrompt = (file: ReviewFileItem): string =>
      {

      +const generateSingleFileRepairPrompt = (file: FileItem): string => {
           return `The patch failed to apply to ${file.path}. Please generate a corrected patch.
       
      -Error: ${file.error}

      +Error: ${file.reviewError}
       Strategy: ${file.strategy}
       
       ORIGINAL CONTENT:
      @@ -128,21 +128,21 @@
       Please provide a corrected patch that addresses the error.`;
       };
       
      -const tryRepairFile = (file: ReviewFileItem): ReviewFileItem => {

      +const tryRepairFile = (file: FileItem): FileItem => {
           const repairPrompt = generateSingleFileRepairPrompt(file);
           // In a real app: clipboardy.writeSync(repairPrompt)
           // eslint-disable-next-line no-console
           console.log(`[CLIPBOARD] Copied repair prompt for: ${file.path}`);
       
           // Mock: return the updated file
      -    return { ...file, status: 'APPROVED' as const, error: undefined,
      linesAdded: 5, linesRemoved: 2 };

      +    return { ...file, reviewStatus: 'APPROVED' as const, reviewError:
      undefined, linesAdded: 5, linesRemoved: 2 };
       };
       
      -const runBulkReapply = async (files: ReviewFileItem[]):
      Promise<ReviewFileItem[]> => {

      -    const failedFileIds = new Set(files.filter(f => f.status ===
      'FAILED').map(f => f.id));

      +const runBulkReapply = async (files: FileItem[]): Promise<FileItem[]> =>
      {

      +    const failedFileIds = new Set(files.filter(f => f.reviewStatus ===
      'FAILED').map(f => f.id));
           if (failedFileIds.size === 0) {
               return files;
           }
      @@ -156,9 +156,9 @@
                   if (first) {
                       first = false;
                       // The file coming in already has the 'RE_APPLYING' status from the store action
      -                return { ...file, status: 'APPROVED' as const, strategy:
      'replace' as const, error: undefined, linesAdded: 9, linesRemoved: 2 };

      +                return { ...file, reviewStatus: 'APPROVED' as const,
      strategy: 'replace' as const, reviewError: undefined, linesAdded: 9,
      linesRemoved: 2 };
                   }
      -            return { ...file, status: 'FAILED' as const, error:
      "'replace' failed: markers not found" };

      +            return { ...file, reviewStatus: 'FAILED' as const,
      reviewError: "'replace' failed: markers not found" };
               }
               return file;
           });

    patchStrategy: standard-diff
  - type: write
    path: src/services/transaction.service.ts
    content: |+
      --- src/services/transaction.service.ts
      +++ src/services/transaction.service.ts
      @@ -1,5 +1,5 @@
       import { createMockTransactions } from '../data/mocks';
      -import type { Transaction } from '../types/transaction.types';
      +import type { Transaction } from '../types/domain.types';
       
       const revertTransaction = (transactionId: string) => {
           // In a real app, this would perform the revert operation (e.g., API call).

    patchStrategy: standard-diff
  - type: write
    path: src/stores/app.store.ts
    content: |+
      --- src/stores/app.store.ts
      +++ src/stores/app.store.ts
      @@ -1,5 +1,5 @@
       import { create } from 'zustand';
      -import type { AppScreen } from '../types/app.types';
      +import type { AppScreen } from '../types/view.types';
       
       interface AppState {
           isHelpOpen: boolean;

    patchStrategy: standard-diff
  - type: write
    path: src/stores/commit.store.ts
    content: |+
      --- src/stores/commit.store.ts
      +++ src/stores/commit.store.ts
      @@ -1,5 +1,5 @@
       import { create } from 'zustand';
      -import type { Transaction } from '../types/transaction.types';
      +import type { Transaction } from '../types/domain.types';
       import { CommitService } from '../services/commit.service';
       import { useTransactionStore } from './transaction.store';
       

    patchStrategy: standard-diff
  - type: write
    path: src/stores/dashboard.store.ts
    content: >+
      --- src/stores/dashboard.store.ts

      +++ src/stores/dashboard.store.ts

      @@ -1,11 +1,11 @@
       import { create } from 'zustand';
       import { DashboardService } from '../services/dashboard.service';
      -import { useTransactionStore, type Transaction } from
      './transaction.store';

      -import type { DashboardStatus } from '../types/dashboard.types';

      +import { useTransactionStore } from './transaction.store';

      +import type { DashboardStatus } from '../types/view.types';

      +import type { Transaction } from '../types/domain.types';
       import { moveIndex } from './navigation.utils';
       
      -export type { Transaction } from '../types/transaction.types';

      -export type { DashboardStatus } from '../types/dashboard.types';

      +export type { Transaction, DashboardStatus };
       
       // --- Store Interface ---
       interface DashboardState {

    patchStrategy: standard-diff
  - type: write
    path: src/stores/init.store.ts
    content: >+
      --- src/stores/init.store.ts

      +++ src/stores/init.store.ts

      @@ -1,8 +1,8 @@
       import { create } from 'zustand';
      -import type { Task, TaskStatus, InitPhase, GitignoreChoice } from
      '../types/init.types';

      -export type { Task } from '../types/init.types';

      +import type { Task, TaskStatus, InitPhase, GitignoreChoice } from
      '../types/view.types';
       
       // Store Interface
      +export type { Task };
       interface InitState {
           phase: InitPhase;
           analyzeTasks: Task[];

    patchStrategy: standard-diff
  - type: write
    path: src/stores/review.store.ts
    content: >+
      --- src/stores/review.store.ts

      +++ src/stores/review.store.ts

      @@ -2,15 +2,14 @@
       import { sleep } from '../utils';
       import { useAppStore } from './app.store';
       import { ReviewService } from '../services/review.service';
      -import { useTransactionStore, type Transaction } from
      './transaction.store';

      +import { useTransactionStore } from './transaction.store';
       import { moveIndex } from './navigation.utils';
      -import type { ReviewFileItem } from '../types/file.types';

      -import type { ScriptResult, ApplyStep, ReviewBodyView, PatchStatus,
      ApplyUpdate } from '../types/review.types';

      -

      -export type { ReviewFileItem } from '../types/file.types';

      -export type { ScriptResult, ApplyStep } from '../types/review.types';

      -

      +import type { FileItem, ScriptResult } from '../types/domain.types';

      +import type { ApplyStep, ReviewBodyView, PatchStatus, ApplyUpdate } from
      '../types/view.types';

      +

      +export type { FileItem as ReviewFileItem, ScriptResult, ApplyStep };

      +

      +// TODO: Refactor this to not hold a copy of files/scripts.
       export const initialApplySteps: ApplyStep[] = [
           { id: 'snapshot', title: 'Reading initial file snapshot...', status: 'pending' },
           { id: 'memory', title: 'Applying operations to memory...', status: 'pending', substeps: [] },
      @@ -23,7 +22,7 @@
           patchStatus: PatchStatus;
       
           // File & Script Info
      -    files: ReviewFileItem[];

      +    files: FileItem[];
           scripts: ScriptResult[];
       
           // UI State
      @@ -94,18 +93,18 @@
                   if (selectedItemIndex >= files.length) return {}; // Not a file
       
                   const newFiles = [...files];
      -            const file = newFiles[selectedItemIndex];

      +            const file = newFiles[selectedItemIndex]!;
                   if (file) {
      -                if (file.status === 'APPROVED') {

      -                    file.status = 'REJECTED';

      -                } else if (file.status === 'REJECTED') {

      -                    file.status = 'APPROVED';

      +                if (file.reviewStatus === 'APPROVED') {

      +                    file.reviewStatus = 'REJECTED';

      +                } else if (file.reviewStatus === 'REJECTED') {

      +                    file.reviewStatus = 'APPROVED';
                       }
                   }
                   return { files: newFiles };
               }),
               rejectAllFiles: () => set(state => {
      -            const newFiles = state.files.map(file => {

      -                if (file.status === 'APPROVED') {

      -                    return { ...file, status: 'REJECTED' as const };

      +            const newFiles = state.files.map(file => {

      +                if (file.reviewStatus === 'APPROVED') {

      +                    return { ...file, reviewStatus: 'REJECTED' as const
      };
                       }
                       return file;
                   });
      @@ -147,8 +146,8 @@
                       if (selectedItemIndex >= files.length) return {};
       
                       const file = files[selectedItemIndex];
      -                if (file?.status === 'FAILED') {

      -                    const updatedFile =
      ReviewService.tryRepairFile(file);

      +                if (file?.reviewStatus === 'FAILED') {

      +                    const updatedFile = ReviewService.tryRepairFile(file
      as FileItem);
                           const newFiles = [...files];
                           newFiles[selectedItemIndex] = updatedFile;
                           return { files: newFiles };
      @@ -162,7 +161,7 @@
       
                   switch (option) {
                       case 1: { // Generate & Copy Bulk Repair Prompt
      -                    const bulkPrompt =
      ReviewService.generateBulkRepairPrompt(files);

      +                    const bulkPrompt =
      ReviewService.generateBulkRepairPrompt(files as FileItem[]);
                           const failedFiles = files.filter(f => f.status === 'FAILED');
                           console.log(`[CLIPBOARD] Copied bulk repair prompt for ${failedFiles.length} file(s).`); // eslint-disable-line no-console
                           // In a real app, this would use clipboardy.writeSync(bulkPrompt),
      @@ -181,7 +180,7 @@
                           set(state => ({
                               files: state.files.map(file =>
                                   failedFileIds.has(file.id)
      -                                ? { ...file, status: 'RE_APPLYING' as
      const }

      +                                ? { ...file, reviewStatus: 'RE_APPLYING'
      as const }
                                       : file
                               ),
                           }));
      @@ -197,8 +196,8 @@
                       case 4: { // Reject All Failed
                           set(state => ({
                               files: state.files.map(file =>
      -                            file.status === 'FAILED'

      -                                ? { ...file, status: 'REJECTED' as const
      }

      +                            file.reviewStatus === 'FAILED'

      +                                ? { ...file, reviewStatus: 'REJECTED' as
      const }
                                       : file,
                               ),
                               bodyView: 'none' as const,
      @@ -214,7 +213,7 @@
                   const transaction = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                   if (!transaction) return;
       
      -            const handoffPrompt =
      ReviewService.generateHandoffPrompt(transaction.hash, transaction.message,
      transaction.reasoning || '', files);

      +            const handoffPrompt =
      ReviewService.generateHandoffPrompt(transaction.hash, transaction.message,
      transaction.reasoning || '', files as FileItem[]);
       
                   // eslint-disable-next-line no-console
                   console.log('[CLIPBOARD] Copied Handoff Prompt.'); // In real app: clipboardy.writeSync(handoffPrompt)
      @@ -253,19 +252,19 @@
                   // This simulates the backend determining which files failed or succeeded.
                   // For this demo, tx '1' is the failure case, any other is success.
                   const isFailureCase = transaction.id === '1';
      -            const patchStatus = isFailureCase ? 'PARTIAL_FAILURE' :
      'SUCCESS';

      -

      -            const reviewFiles: ReviewFileItem[] = (transaction.files ||
      []).map((file, index) => {

      +            const patchStatus = isFailureCase ? 'PARTIAL_FAILURE' :
      ('SUCCESS' as PatchStatus);

      +

      +            const reviewFiles: FileItem[] = (transaction.files ||
      []).map((file, index) => {
                       if (isFailureCase) {
                           return {
                               ...file,
      -                        status: index === 0 ? 'APPROVED' : 'FAILED',

      -                        error: index > 0 ? (index === 1 ? 'Hunk #1 failed
      to apply' : 'Context mismatch at line 92') : undefined,

      +                        reviewStatus: index === 0 ? 'APPROVED' :
      'FAILED',

      +                        reviewError: index > 0 ? (index === 1 ? 'Hunk #1
      failed to apply' : 'Context mismatch at line 92') : undefined,
                               strategy: file.strategy || 'standard-diff',
                           };
                       }
      -                return { ...file, status: 'APPROVED', strategy:
      file.strategy || 'standard-diff' };

      +                return { ...file, reviewStatus: 'APPROVED', strategy:
      file.strategy || 'standard-diff' };
                   });
       
                   set({

    patchStrategy: standard-diff
  - type: write
    path: src/stores/transaction-detail.store.ts
    content: >+
      --- src/stores/transaction-detail.store.ts

      +++ src/stores/transaction-detail.store.ts

      @@ -2,8 +2,7 @@
       import { TransactionService } from '../services/transaction.service';
       import { useTransactionStore } from './transaction.store';
      -import type { FileChangeType } from '../types/file.types';

      -import type { NavigatorSection, DetailBodyView } from
      '../types/transaction-detail.types';

      +import type { NavigatorSection, DetailBodyView } from
      '../types/view.types';
       
       interface TransactionDetailState {
           // Data

    patchStrategy: standard-diff
  - type: write
    path: src/stores/transaction-history.store.ts
    content: >+
      --- src/stores/transaction-history.store.ts

      +++ src/stores/transaction-history.store.ts

      @@ -1,11 +1,10 @@
       import { create } from 'zustand';
      -import type { Transaction } from '../types/transaction.types';

      -import type { FileChange } from '../types/file.types';

      -import type { HistoryViewMode } from
      '../types/transaction-history.types';

      +import type { Transaction, FileItem } from '../types/domain.types';

      +import type { HistoryViewMode } from '../types/view.types';
       import { useTransactionStore } from './transaction.store';
       
      -export type { FileChange } from '../types/file.types';

      -

      +export type { FileItem as FileChange };

      + 
       // Omit 'actions' from state type for partial updates
       type HistoryStateData = Omit<TransactionHistoryState, 'actions'>;
       

    patchStrategy: standard-diff
  - type: write
    path: src/stores/transaction.store.ts
    content: >+
      --- src/stores/transaction.store.ts

      +++ src/stores/transaction.store.ts

      @@ -1,8 +1,8 @@
       import { create } from 'zustand';
       import { TransactionService } from '../services/transaction.service';
      -import type { Transaction, TransactionStatus } from
      '../types/transaction.types';

      +import type { Transaction, TransactionStatus } from
      '../types/domain.types';
       
      -export type { Transaction } from '../types/transaction.types';

      +export type { Transaction };
       
       interface TransactionState {
           transactions: Transaction[];

    patchStrategy: standard-diff
  - type: delete
    path: src/types/app.types.ts
  - type: delete
    path: src/types/dashboard.types.ts
  - type: delete
    path: src/types/file.types.ts
  - type: delete
    path: src/types/init.types.ts
  - type: delete
    path: src/types/review.types.ts
  - type: delete
    path: src/types/transaction-detail.types.ts
  - type: delete
    path: src/types/transaction-history.types.ts
  - type: delete
    path: src/types/transaction.types.ts
snapshot:
  src/types/domain.types.ts: null
  src/types/view.types.ts: null
  src/data/mocks.ts: >-
    import type { Transaction } from '../types/transaction.types';


    const mockReasoning1 = `1. Identified a potential uncaught exception in the
    \`restoreSnapshot\` function
       if a file operation fails midway through a loop of many files. This could
       leave the project in a partially-reverted, inconsistent state.

    2. Wrapped the file restoration loop in a \`Promise.all\` and added a
    dedicated
       error collection array. This ensures that all file operations are
       attempted and that a comprehensive list of failures is available
       afterward for better error reporting or partial rollback logic.
    `;


    export const allMockTransactions: Transaction[] = [
        {
            id: '1',
            timestamp: Date.now() - 10 * 1000,
            status: 'PENDING',
            hash: 'e4a7c112',
            message: 'fix: add missing error handling',
            prompt: 'Rename the `calculateChanges` utility to `computeDelta` across all files and update imports accordingly.',
            reasoning: mockReasoning1,
            files: [
                { id: '1-1', path: 'src/core/transaction.ts', type: 'MOD', linesAdded: 18, linesRemoved: 5, diff: '--- a/src/core/transaction.ts\n+++ b/src/core/transaction.ts\n@@ -15,7 +15,7 @@ export class Transaction {\n   }\n\n-  calculateChanges(): ChangeSet {\n+  computeDelta(): ChangeSet {\n     return this.changes;\n   }\n }', strategy: 'replace' },
                { id: '1-2', path: 'src/utils/logger.ts', type: 'MOD', linesAdded: 0, linesRemoved: 0, diff: '', strategy: 'standard-diff' },
                { id: '1-3', path: 'src/commands/apply.ts', type: 'MOD', linesAdded: 0, linesRemoved: 0, diff: '', strategy: 'standard-diff' },
            ],
            stats: { files: 3, linesAdded: 18, linesRemoved: 5 },
        },
        {
            id: '2',
            timestamp: Date.now() - 15 * 1000,
            status: 'PENDING',
            hash: '4b9d8f03',
            message: 'refactor: simplify clipboard logic',
            prompt: 'Simplify the clipboard logic using an external library...',
            reasoning: 'The existing clipboard logic was complex and platform-dependent. Using the `clipboardy` library simplifies the code and improves reliability across different operating systems.',
            files: [
                { id: '2-1', path: 'src/core/clipboard.ts', type: 'MOD', linesAdded: 15, linesRemoved: 8, diff: '--- a/src/core/clipboard.ts\n+++ b/src/core/clipboard.ts\n@@ -1,5 +1,6 @@\n import { copy as copyToClipboard } from \'clipboardy\';', strategy: 'replace' },
                { id: '2-2', path: 'src/utils/shell.ts', type: 'MOD', linesAdded: 7, linesRemoved: 3, diff: '--- a/src/utils/shell.ts\n+++ b/src/utils/shell.ts', strategy: 'standard-diff' },
            ],
            stats: { files: 2, linesAdded: 22, linesRemoved: 11 },
            scripts: [
                { command: 'bun run test', success: true, duration: 2.3, summary: 'Passed (37 tests)', output: '... test output ...' },
                { command: 'bun run lint', success: false, duration: 1.2, summary: '1 Error, 3 Warnings', output: 'src/core/clipboard.ts\n  45:12  Error    \'clipboardy\' is assigned a value but never used. (@typescript-eslint/no-unused-vars)\n  88:5   Warning  Unexpected console statement. (no-console)' },
            ],
        },
        {
            id: '3',
            timestamp: Date.now() - 5 * 60 * 1000,
            status: 'APPLIED',
            hash: '8a3f21b8',
            message: 'feat: implement new dashboard UI',
            prompt: 'The user requested to add more robust error handling to the `restoreSnapshot` function. Specifically, it should not halt on the first error but instead attempt all file restorations and then report a summary of any failures.',
            reasoning: mockReasoning1,
            files: [
                { id: '3-1', path: 'src/core/transaction.ts', type: 'MOD', linesAdded: 18, linesRemoved: 5, diff: '... diff ...' },
                { id: '3-2', path: 'src/utils/logger.ts', type: 'MOD', linesAdded: 7, linesRemoved: 3, diff: '... diff ...' },
                { id: '3-3', path: 'src/utils/old-helper.ts', type: 'DEL', linesAdded: 0, linesRemoved: 30, diff: '... diff ...' },
            ],
            stats: { files: 3, linesAdded: 25, linesRemoved: 38 },
        },
        { id: '4', timestamp: Date.now() - 8 * 60 * 1000, status: 'REVERTED', hash: 'b2c9e04d', message: 'Reverting transaction 9c2e1a05' },
        { id: '5', timestamp: Date.now() - 9 * 60 * 1000, status: 'FAILED', hash: '9c2e1a05', message: 'style: update button component (Linter errors: 5)' },
        { id: '6', timestamp: Date.now() - 12 * 60 * 1000, status: 'COMMITTED', hash: 'c7d6b5e0', message: 'docs: update readme with TUI spec' },
    ];


    /**
     * Creates a deep copy of the mock transactions to prevent state mutations.
     */
    export const createMockTransactions = (): Transaction[] => {
        return JSON.parse(JSON.stringify(allMockTransactions));
    };
  src/components/DashboardScreen.tsx: "import React from 'react';\nimport { Box, Text } from 'ink';\nimport Spinner from 'ink-spinner';\nimport { type Transaction, type DashboardStatus } from '../stores/dashboard.store';\nimport type { TransactionStatus } from '../types/transaction.types';\nimport Separator from './Separator';\nimport { useDashboardScreen } from '../hooks/useDashboardScreen';\n\n// --- Sub-components & Helpers ---\n\nconst getStatusIcon = (status: TransactionStatus) => {\n    switch (status) {\n        case 'PENDING': return <Text color=\"yellow\">?</Text>;\n        case 'APPLIED': return <Text color=\"green\">✓</Text>;\n        case 'COMMITTED': return <Text color=\"blue\">→</Text>;\n        case 'HANDOFF': return <Text color=\"magenta\">→</Text>;\n        case 'FAILED': return <Text color=\"red\">✗</Text>;\n        case 'REVERTED': return <Text color=\"gray\">↩</Text>;\n        case 'IN-PROGRESS': return <Spinner type=\"dots\" />;\n        default: return <Text> </Text>;\n    }\n};\n\nconst formatTimeAgo = (timestamp: number) => {\n    const seconds = Math.floor((Date.now() - timestamp) / 1000);\n    if (seconds < 60) return `-${seconds}s`;\n    const minutes = Math.floor(seconds / 60);\n    return `-${minutes}m`;\n};\n\nconst EventStreamItem = ({ transaction, isSelected }: { transaction: Transaction, isSelected: boolean }) => {\n    const icon = getStatusIcon(transaction.status);\n    const time = formatTimeAgo(transaction.timestamp).padEnd(5, ' ');\n    const statusText = transaction.status.padEnd(11, ' ');\n    \n    const messageNode = transaction.status === 'IN-PROGRESS'\n        ? <Text color=\"cyan\">{transaction.message}</Text>\n        : transaction.message;\n    \n    const content = (\n        <Text>\n            {time} {icon} {statusText} <Text color=\"gray\">{transaction.hash}</Text> · {messageNode}\n        </Text>\n    );\n\n    return isSelected ? <Text bold color=\"cyan\">{'> '}{content}</Text> : <Text>{'  '}{content}</Text>;\n};\n\nconst ConfirmationContent = ({\n    transactionsToConfirm,\n}: {\n    transactionsToConfirm: Transaction[];\n}) => {\n    const actionText = 'APPROVE';\n    \n    return (\n        <Box flexDirection=\"column\" marginY={1} paddingLeft={2}>\n            <Text bold color=\"yellow\">{actionText} ALL PENDING TRANSACTIONS?</Text>\n            <Text>\n                The following {transactionsToConfirm.length} transaction(s) will be approved:\n            </Text>\n            <Box flexDirection=\"column\" paddingLeft={1} marginTop={1}>\n                {transactionsToConfirm.map(tx => (\n                    <Text key={tx.id}>- {tx.hash}: {tx.message}</Text>\n                ))}\n            </Box>\n        </Box>\n    );\n};\n\n// --- Main Component ---\n\nconst DashboardScreen = () => {\n    const {\n        status,\n        transactions,\n        selectedTransactionIndex,\n        pendingApprovals,\n        pendingCommits,\n        isModal,\n        isProcessing,\n        viewOffset,\n        viewportHeight,\n        transactionsToConfirm,\n    } = useDashboardScreen();\n\n    const renderStatusBar = () => {\n        let statusText: string;\n        let statusIcon: React.ReactNode;\n        switch (status) {\n            case 'LISTENING': statusText = 'LISTENING'; statusIcon = <Text color=\"green\">●</Text>; break;\n            case 'PAUSED': statusText = 'PAUSED'; statusIcon = <Text color=\"yellow\">||</Text>; break;\n            case 'APPROVING': statusText = 'APPROVING...'; statusIcon = <Text color=\"cyan\"><Spinner type=\"dots\"/></Text>; break;\n            default: statusText = 'LISTENING'; statusIcon = <Text color=\"green\">●</Text>;\n        }\n\n        let approvalStr: React.ReactNode = String(pendingApprovals).padStart(2, '0');\n        const commitStr: React.ReactNode = String(pendingCommits).padStart(2, '0');\n\n        if (status === 'APPROVING') approvalStr = <Text color=\"cyan\">(<Spinner type=\"dots\"/>)</Text>;\n        if (status === 'CONFIRM_APPROVE') {\n            approvalStr = <Text bold color=\"yellow\">┌ {approvalStr} ┐</Text>;\n        }\n        \n        return (\n            <Text>\n                STATUS: {statusIcon} {statusText} · APPROVALS: {approvalStr} · COMMITS: {commitStr}\n            </Text>\n        );\n    };\n\n    const renderFooter = () => {\n        if (isModal) return (\n            <Text>\n                (<Text color=\"cyan\" bold>Enter</Text>) Confirm      (<Text color=\"cyan\" bold>Esc</Text>) Cancel\n            </Text>\n        );\n        if (isProcessing) return <Text>Processing... This may take a moment.</Text>;\n\n        const pauseAction = status === 'PAUSED'\n\t\t\t? <Text>(<Text color=\"cyan\" bold>R</Text>)esume</Text>\n\t\t\t: <Text>(<Text color=\"cyan\" bold>P</Text>)ause</Text>;\n\t\treturn (\n            <Text color=\"gray\">\n                (<Text color=\"cyan\" bold>↑↓</Text>) Nav · (<Text color=\"cyan\" bold>Enter</Text>) Review · (<Text color=\"cyan\" bold>L</Text>)og · (<Text color=\"cyan\" bold>A</Text>)pprove All · (<Text color=\"cyan\" bold>C</Text>)ommit All · {pauseAction} · (<Text color=\"cyan\" bold>Q</Text>)uit\n            </Text>\n        );\n    };\n    \n    return (\n        <Box flexDirection=\"column\" height=\"100%\">\n            <Text color=\"cyan\">▲ relaycode dashboard</Text>\n            <Separator />\n            <Box marginY={1}>\n                {renderStatusBar()}\n            </Box>\n            \n            {isModal && (\n                <>\n                    <ConfirmationContent transactionsToConfirm={transactionsToConfirm} />\n                    <Separator />\n                </>\n            )}\n            \n            <Text bold underline> EVENT STREAM (Last 15 minutes)</Text>\n            <Box flexDirection=\"column\" marginTop={1}>\n                {transactions.slice(viewOffset, viewOffset + viewportHeight).map((tx, index) => {\n                    const actualIndex = viewOffset + index;\n                    return (\n                        <EventStreamItem\n                            key={tx.id}\n                            transaction={tx}\n                            isSelected={!isModal && actualIndex === selectedTransactionIndex}\n                        />\n                    );\n                })}\n            </Box>\n\n            <Box marginTop={1}><Separator /></Box>\n            {renderFooter()}\n        </Box>\n    );\n};\n\nexport default DashboardScreen;"
  src/components/InitializationScreen.tsx: "import React from 'react';\nimport { Box, Text } from 'ink';\nimport { type Task } from '../stores/init.store';\nimport Separator from './Separator';\nimport { useInitializationScreen } from '../hooks/useInitializationScreen';\n\nconst TaskItem = ({ task, doneSymbol = '✓' }: { task: Task; doneSymbol?: string }) => {\n\tlet symbol: React.ReactNode;\n\tswitch (task.status) {\n\t\tcase 'pending': symbol = '( )'; break;\n\t\tcase 'active': symbol = <Text color=\"cyan\">(●)</Text>; break;\n\t\tcase 'done': symbol = <Text color=\"green\">{doneSymbol}</Text>; break;\n\t}\n\n\tconst title = task.status === 'done' && doneSymbol?.startsWith('[✓]') ? `Created ${task.title.split(' ')[1]}` : task.title;\n\n\treturn (\n\t\t<Box flexDirection=\"column\">\n\t\t\t<Text>\n\t\t\t\t{symbol} {title}\n\t\t\t</Text>\n\t\t\t{task.subtext && task.status !== 'done' && (\n\t\t\t\t<Text italic color=\"gray\">\n\t\t\t\t\t{'     └─ '}{task.subtext}\n\t\t\t\t</Text>\n\t\t\t)}\n\t\t</Box>\n\t);\n};\n\nconst InitializationScreen = () => {\n    const {\n        phase,\n        analyzeTasks,\n        configureTasks,\n        interactiveChoice,\n        projectId,\n        footerText,\n    } = useInitializationScreen();\n\n    const renderAnalyze = () => (\n        <Box flexDirection=\"column\">\n            <Text bold color=\"cyan\">PHASE 1: ANALYZE</Text>\n            <Box flexDirection=\"column\" marginTop={1} gap={1}>\n                {analyzeTasks.map(t => <TaskItem key={t.id} task={t} />)}\n            </Box>\n        </Box>\n    );\n\n    const renderContext = () => (\n        <Box flexDirection=\"column\" marginBottom={1}>\n            <Text bold color=\"cyan\">CONTEXT</Text>\n            <Text>  <Text color=\"green\">✓</Text> Project ID: {projectId}</Text>\n            <Text>  <Text color=\"green\">✓</Text> Gitignore:  Found at ./</Text>\n        </Box>\n    );\n\n    const renderConfigure = () => (\n        <Box flexDirection=\"column\">\n            {renderContext()}\n            <Text bold color=\"cyan\">PHASE 2: CONFIGURE</Text>\n            <Box flexDirection=\"column\" marginTop={1} gap={1}>\n                {configureTasks.map(t => <TaskItem key={t.id} task={t} doneSymbol='[✓]' />)}\n            </Box>\n        </Box>\n    );\n\n    const renderInteractive = () => (\n        <Box flexDirection=\"column\">\n            {renderContext()}\n            <Text bold color=\"cyan\">PHASE 2: CONFIGURE</Text>\n            <Box flexDirection=\"column\" marginTop={1}>\n                {configureTasks.slice(0, 2).map(t => <TaskItem key={t.id} task={t} doneSymbol='[✓]' />)}\n                <Box flexDirection=\"column\" marginTop={1}>\n                    <Text><Text color=\"cyan\">&gt;</Text> The .relay/ directory is usually ignored by git.</Text>\n                    <Text>  Do you want to share its state with your team by committing it?</Text>\n                </Box>\n            </Box>\n        </Box>\n    );\n\n    const renderFinalize = () => {\n        const stateText = interactiveChoice === 'share'\n            ? '.relay/ directory initialized. It will be committed to git.'\n            : '.relay/ directory initialized and added to .gitignore.';\n        const stateSubText = interactiveChoice === 'share'\n            ? undefined\n            : 'Local transaction history will be stored here.';\n        \n        return (\n            <Box flexDirection=\"column\">\n                <Text bold color=\"green\"> SYSTEM READY</Text>\n                <Box flexDirection=\"column\" marginTop={1} paddingLeft={2} gap={1}>\n                    <Box flexDirection=\"column\">\n                        <Text><Text color=\"green\">✓</Text> Config:   relay.config.json created.</Text>\n                        <Text color=\"gray\" italic>          › Edit this file to tune linters, git integration, etc.</Text>\n                    </Box>\n                    <Box flexDirection=\"column\">\n                        <Text><Text color=\"green\">✓</Text> State:    {stateText}</Text>\n                        {stateSubText && <Text color=\"gray\" italic>          › {stateSubText}</Text>}\n                    </Box>\n                    <Box flexDirection=\"column\">\n                        <Text><Text color=\"green\">✓</Text> Prompt:   System prompt generated at .relay/prompts/system-prompt.md.</Text>\n                        <Text color=\"gray\" italic>          › Copied to clipboard. Paste into your AI&apos;s custom instructions.</Text>\n                    </Box>\n                </Box>\n            </Box>\n        );\n    };\n\n    const renderPhase = () => {\n        switch (phase) {\n            case 'ANALYZE': return renderAnalyze();\n            case 'CONFIGURE': return renderConfigure();\n            case 'INTERACTIVE': return renderInteractive();\n            case 'FINALIZE': return renderFinalize();\n        }\n    };\n\n    return (\n        <Box flexDirection=\"column\">\n            <Text color=\"cyan\">{phase === 'FINALIZE' ? '▲ relaycode bootstrap complete' : '▲ relaycode bootstrap'}</Text>\n            <Separator />\n            <Box marginY={1}>{renderPhase()}</Box>\n            <Separator />\n            {typeof footerText === 'string' ? <Text>{footerText}</Text> : footerText}\n        </Box>\n    );\n};\n\nexport default InitializationScreen;"
  src/components/ReviewProcessingScreen.tsx: >-
    import React from 'react';

    import { Box, Text } from 'ink';

    import { useReviewStore, type ApplyStep } from '../stores/review.store';

    import { useTransactionStore } from '../stores/transaction.store';

    import Separator from './Separator';


    const ApplyStepRow = ({ step, isSubstep = false }: { step: ApplyStep,
    isSubstep?: boolean }) => {
        if (isSubstep) {
            let color;
            if (step.status === 'done' && step.title.startsWith('[✓]')) color = 'green';
            if (step.status === 'failed') color = 'red';

            return (
                <Text color={color}>
                    {'     └─ '}{step.title}
                </Text>
            );
        }

        let symbol;
        let color;
        switch (step.status) {
            case 'pending': symbol = '( )'; break;
            case 'active': symbol = '(●)'; color = 'cyan'; break;
            case 'done': symbol = '[✓]'; color = 'green'; break;
            case 'failed': symbol = '[!]'; color = 'red'; break;
            case 'skipped': symbol = '(-)'; color = 'gray'; break;
        }

        return (
            <Box flexDirection="column">
                <Text>
                    <Text color={color}>{symbol}</Text> {step.title} {step.duration && !isSubstep && `(${step.duration}s)`}
                </Text>
                {step.details && (
                    <Text color="gray">
                        {'     └─ '}{step.details}
                    </Text>
                )}
                {step.substeps?.map((sub, i) => (
                    <ApplyStepRow key={i} step={sub} isSubstep={true} />
                ))}
            </Box>
        );
    };


    const ReviewProcessingScreen = () => {
        const { transactionId, patchStatus, applySteps } = useReviewStore(state => ({
            transactionId: state.transactionId,
            patchStatus: state.patchStatus,
            applySteps: state.applySteps,
        }));
        const transaction = useTransactionStore(s => s.transactions.find(t => t.id === transactionId));

        const totalDuration = applySteps.reduce((acc, step) => acc + (step.duration || 0), 0);
        const failureCase = patchStatus === 'PARTIAL_FAILURE';
        const footerText = failureCase
            ? `Elapsed: ${totalDuration.toFixed(1)}s · Transitioning to repair workflow...`
            : `Elapsed: ${totalDuration.toFixed(1)}s · Processing... Please wait.`;

        if (!transaction) {
            return <Text>Loading...</Text>;
        }

        return (
            <Box flexDirection="column">
                <Text color="cyan">▲ relaycode apply</Text>
                <Separator />
                <Box marginY={1} flexDirection="column">
                    <Text>Applying patch {transaction.hash}... ({transaction.message})</Text>
                    <Box flexDirection="column" marginTop={1} gap={1}>
                        {applySteps.map(step => <ApplyStepRow key={step.id} step={step} />)}
                    </Box>
                </Box>
                <Separator />
                <Text>{footerText}</Text>
            </Box>
        );
    };


    export default ReviewProcessingScreen;
  src/components/ReviewScreen.tsx: >-
    import React from 'react';

    import { Box, Text } from 'ink';

    import { type ReviewFileItem, type ScriptResult } from
    '../stores/review.store';

    import Separator from './Separator';

    import DiffScreen from './DiffScreen';

    import ReasonScreen from './ReasonScreen';

    import { useReviewScreen } from '../hooks/useReviewScreen';


    // --- Sub-components ---


    const FileItemRow = ({ file, isSelected }: { file: ReviewFileItem,
    isSelected: boolean }) => {
        let icon;
        let iconColor;
        switch (file.status) {
            case 'APPROVED': icon = '[✓]'; iconColor = 'green'; break;
            case 'REJECTED': icon = '[✗]'; iconColor = 'red'; break;
            case 'FAILED': icon = '[!]'; iconColor = 'red'; break;
            case 'AWAITING': icon = '[●]'; iconColor = 'yellow'; break;
            case 'RE_APPLYING': icon = '[●]'; iconColor = 'cyan'; break;
        }

        const diffStats = `(+${file.linesAdded}/-${file.linesRemoved})`;
        const strategy = file.strategy === 'standard-diff' ? 'diff' : file.strategy;
        const prefix = isSelected ? '> ' : '  ';

        if (file.status === 'FAILED') {
            return (
                <Box>
                    <Text bold={isSelected} color={isSelected ? 'cyan' : undefined}>
                        {prefix}<Text color={iconColor}>{icon} FAILED {file.path}</Text>
                        <Text color="red">    ({file.error})</Text>
                    </Text>
                </Box>
            );
        }

        if (file.status === 'AWAITING') {
            return (
                <Box>
                    <Text bold={isSelected} color={isSelected ? 'cyan' : undefined}>
                        {prefix}<Text color={iconColor}>{icon} AWAITING {file.path}</Text>
                        <Text color="yellow">    (Bulk re-apply prompt copied!)</Text>
                    </Text>
                </Box>
            );
        }

        if (file.status === 'RE_APPLYING') {
            return (
                 <Box>
                    <Text bold={isSelected} color={isSelected ? 'cyan' : undefined}>
                        {prefix}<Text color={iconColor}>{icon} RE-APPLYING... {file.path}</Text>
                        <Text color="cyan"> (using &apos;replace&apos; strategy)</Text>
                    </Text>
                </Box>
            );
        }

        return (
            <Box>
                <Text bold={isSelected} color={isSelected ? 'cyan' : undefined}>
                    {prefix}<Text color={iconColor}>{icon}</Text> MOD {file.path} {diffStats} [{strategy}]
                </Text>
            </Box>
        );
    };


    const ScriptItemRow = ({
        script,
        isSelected,
        isExpanded,
    }: {
        script: ScriptResult;
        isSelected: boolean;
        isExpanded: boolean;
    }) => {
        const icon = script.success ? '✓' : '✗';
        const iconColor = script.success ? 'green' : 'red';
        const arrow = isExpanded ? '▾' : '▸';
        const prefix = isSelected ? '> ' : '  ';
        
        // Extract script type from command (e.g., "bun run test" -> "Post-Command", "bun run lint" -> "Linter")
        const scriptType = script.command.includes('test') ? 'Post-Command' : 
                          script.command.includes('lint') ? 'Linter' : 
                          'Script';

        return (
            <Box>
                <Text bold={isSelected} color={isSelected ? 'cyan' : undefined}>
                    {prefix}<Text color={iconColor}>{icon}</Text> {scriptType}: `{script.command}` ({script.duration}s) {arrow}{' '}
                    {script.summary}
                </Text>
            </Box>
        );
    };


    // --- Main Component ---


    const ReviewScreen = () => {
        const {
            transaction,
            files,
            scripts,
            patchStatus,
            selectedItemIndex, bodyView, isDiffExpanded, reasoningScrollIndex, scriptErrorIndex,
            numFiles,
            approvedFilesCount,
            approvedLinesAdded,
            approvedLinesRemoved,
        } = useReviewScreen();

        if (!transaction) {
            return <Text>Loading review...</Text>;
        }
        const { hash, message, prompt = '', reasoning = '' } = transaction;

        const renderBody = () => {
            if (bodyView === 'none') return null;

            if (bodyView === 'reasoning') {
                const reasoningLinesCount = (reasoning || '').split('\n').length;
                const visibleLinesCount = 10;
                return (
                    <Box flexDirection="column">
                        <ReasonScreen
                            reasoning={reasoning}
                            scrollIndex={reasoningScrollIndex}
                            visibleLinesCount={visibleLinesCount}
                        />
                        {reasoningLinesCount > visibleLinesCount && (
                            <Text color="gray">
                                Showing lines {reasoningScrollIndex + 1}-{Math.min(reasoningScrollIndex + visibleLinesCount, reasoningLinesCount)}{' '}
                                of {reasoningLinesCount}
                            </Text>
                        )}
                    </Box>
                );
            }
            
            if (bodyView === 'diff') {
                const selectedFile = files[selectedItemIndex];
                if (!selectedFile) return null;
                return (
                    <DiffScreen
                        filePath={selectedFile.path}
                        diffContent={selectedFile.diff}
                        isExpanded={isDiffExpanded}
                    />
                );
            }

            if (bodyView === 'script_output') {
                 const scriptIndex = selectedItemIndex - numFiles;
                 const selectedScript = scripts[scriptIndex];
                 if (!selectedScript) return null;
                 
                 const outputLines = selectedScript.output.split('\n');
                 const errorLines = outputLines.filter(line =>
                    line.includes('Error') || line.includes('Warning'),
                 );
                 
                 return (
                    <Box flexDirection="column">
                        <Text>{selectedScript.command.includes('lint') ? 'LINTER' : 'SCRIPT'} OUTPUT: `{selectedScript.command}`</Text>
                        <Box marginTop={1}>
                            {outputLines.map((line, index) => {
                                const isError = line.includes('Error');
                                const isWarning = line.includes('Warning');
                                const isHighlighted = errorLines[scriptErrorIndex] === line;
                                
                                return (
                                    <Text 
                                        key={index} 
                                        color={isError ? 'red' : isWarning ? 'yellow' : undefined}
                                        bold={isHighlighted}
                                        backgroundColor={isHighlighted ? 'blue' : undefined}
                                    >
                                        {line}
                                    </Text>
                                );
                            })}
                        </Box>
                        {errorLines.length > 0 && (
                            <Text color="gray">
                                Error {scriptErrorIndex + 1} of {errorLines.length} highlighted
                            </Text>
                        )}
                    </Box>
                 );
            }

            if (bodyView === 'confirm_handoff') {
                return (
                    <Box flexDirection="column" gap={1}>
                        <Text bold>HANDOFF TO EXTERNAL AGENT</Text>
                        <Box flexDirection="column">
                            <Text>This action will:</Text>
                            <Text>1. Copy a detailed prompt to your clipboard for an agentic AI.</Text>
                            <Text>2. Mark the current transaction as &apos;Handoff&apos; and close this review.</Text>
                            <Text>3. Assume that you and the external agent will complete the work.</Text>
                        </Box>
                        <Text>Relaycode will NOT wait for a new patch. This is a final action.</Text>
                        <Text bold color="yellow">Are you sure you want to proceed?</Text>
                    </Box>
                );
            }

            if (bodyView === 'bulk_repair') {
                const failedFiles = files.filter(f => f.status === 'FAILED');
                const repairOptions = [
                    '(1) Copy Bulk Re-apply Prompt (for single-shot AI)',
                    '(2) Bulk Change Strategy & Re-apply',
                    '(3) Handoff to External Agent',
                    '(4) Bulk Abandon All Failed Files',
                    '(Esc) Cancel',
                ];

                return (
                    <Box flexDirection="column" gap={1}>
                        <Text bold>BULK REPAIR ACTION</Text>

                        <Box flexDirection="column">
                            <Text>The following {failedFiles.length} files failed to apply:</Text>
                            {failedFiles.map(file => (
                                <Text key={file.id}>- {file.path}</Text>
                            ))}
                        </Box>

                        <Text>How would you like to proceed?</Text>

                        <Box flexDirection="column">
                            {repairOptions.map((opt, i) => (
                                <Text key={i}>
                                    {i === 0 ? '> ' : '  '}
                                    {opt}
                                </Text>
                            ))}
                        </Box>
                    </Box>
                );
            }

            return null;
        };

        const renderFooter = () => {
            // Contextual footer for body views
            if (bodyView === 'diff') {
                return <Text>(↑↓) Nav · (X)pand · (D/Esc) Back</Text>;
            }
            if (bodyView === 'reasoning') {
                return <Text>(↑↓) Scroll Text · (R)Collapse View · (C)opy Mode</Text>;
            }
            if (bodyView === 'script_output') {
                return (
                    <Text>(↑↓) Nav · (J↓/K↑) Next/Prev Error · (C)opy Output · (Ent/Esc) Back</Text>
                );
            }
            if (bodyView === 'bulk_repair') {
                return <Text>Choose an option [1-4, Esc]:</Text>;
            }
            if (bodyView === 'confirm_handoff') {
                return <Text>(Enter) Confirm Handoff      (Esc) Cancel</Text>;
            }

            // Main footer
            const actions = ['(↑↓) Nav'];

            const isFileSelected = selectedItemIndex < numFiles;
            const hasFailedFiles = files.some(f => f.status === 'FAILED');
            
            if (isFileSelected) {
                const selectedFile = files[selectedItemIndex];
                if (selectedFile && selectedFile.status !== 'FAILED') {
                    actions.push('(Spc) Toggle');
                }
                actions.push('(D)iff');
                
                // Add repair options for failed files
                if (selectedFile && selectedFile.status === 'FAILED') {
                    actions.push('(T)ry Repair');
                }
            } else { // script selected
                actions.push('(Ent) Expand Details');
            }

            actions.push('(R)easoning');
            
            // Add bulk repair if there are failed files
            if (hasFailedFiles) {
                actions.push('(Shift+T) Bulk Repair');
            }
            
            actions.push('(C)opy');

            if (approvedFilesCount > 0) {
                actions.push('(A)pprove');
            }

            if (files.some(f => f.status === 'APPROVED' || f.status === 'FAILED')) {
                actions.push('(Shift+R) Reject All');
            }
            actions.push('(Q)uit');

            return <Text>{actions.join(' · ')}</Text>;
        };

        return (
            <Box flexDirection="column">
                {/* Header */}
                <Text color="cyan">▲ relaycode review</Text>
                <Separator />
                
                {/* Navigator Section */}
                <Box flexDirection="column" marginY={1}>
                    <Box flexDirection="column">
                        <Text>{hash} · {message}</Text>
                        <Text>
                            (<Text color="green">+{approvedLinesAdded}</Text>/<Text color="red">-{approvedLinesRemoved}</Text>) · {approvedFilesCount}/{numFiles} Files
                            {patchStatus === 'PARTIAL_FAILURE' && scripts.length === 0 && <Text> · Scripts: SKIPPED</Text>}
                            {patchStatus === 'PARTIAL_FAILURE' && <Text color="red" bold> · MULTIPLE PATCHES FAILED</Text>}
                        </Text>
                    </Box>

                    <Box flexDirection="column" marginTop={1}>
                        <Text>
                            (P)rompt ▸ {(prompt || '').substring(0, 60)}...
                        </Text>
                        <Text>
                            (R)easoning ({(reasoning || '').split('\n\n').length} steps) {bodyView === 'reasoning' ? '▾' : '▸'}{' '}
                            {((reasoning || '').split('\n')[0] ?? '').substring(0, 50)}...
                        </Text>
                    </Box>
                </Box>

                <Separator/>

                {/* Script Results (if any) */}
                {scripts.length > 0 && (
                    <>
                        <Box flexDirection="column" marginY={1}>
                            {scripts.map((script, index) => (
                                <ScriptItemRow
                                    key={script.command}
                                    script={script}
                                    isSelected={selectedItemIndex === numFiles + index}
                                    isExpanded={bodyView === 'script_output' && selectedItemIndex === numFiles + index}
                                />
                            ))}
                        </Box>
                        <Separator/>
                    </>
                )}

                {/* Files Section */}
                <Box flexDirection="column" marginY={1}>
                    <Text bold>FILES</Text>
                    {files.map((file, index) => (
                        <FileItemRow
                            key={file.id}
                            file={file}
                            isSelected={selectedItemIndex === index}
                        />
                    ))}
                </Box>
                
                <Separator/>
                
                {/* Body Viewport */}
                {bodyView !== 'none' && (
                    <>
                        <Box marginY={1}>
                            {renderBody()}
                        </Box>
                        <Separator />
                    </>
                )}

                {/* Footer */}
                <Box>
                    {renderFooter()}
                </Box>
            </Box>
        );
    };


    export default ReviewScreen;
  src/components/TransactionDetailScreen.tsx: >-
    import React from 'react';

    import { Box, Text } from 'ink';

    import { type FileChangeType } from '../types/file.types';

    import Separator from './Separator';

    import DiffScreen from './DiffScreen';

    import ReasonScreen from './ReasonScreen';

    import { useTransactionDetailScreen } from
    '../hooks/useTransactionDetailScreen';


    const getFileChangeTypeIcon = (type: FileChangeType) => {
        switch (type) {
            case 'MOD': return '[MOD]';
            case 'ADD': return '[ADD]';
            case 'DEL': return '[DEL]';
            case 'REN': return '[REN]';
        }
    };


    const RevertModal = ({ transactionHash }: { transactionHash: string }) => {
        return (
            <Box 
                borderStyle="round"
                borderColor="yellow"
                flexDirection="column"
                paddingX={2}
                width="80%"
                alignSelf='center'
            >
                <Text bold color="yellow" wrap="wrap" >REVERT THIS TRANSACTION?</Text>
                <Box height={1} />
                <Text wrap="wrap">This will create a NEW transaction that reverses all changes made by {transactionHash}. The original transaction record will be preserved.</Text>
                <Box height={1} />
                <Text wrap="wrap">Are you sure?</Text>
            </Box>
        );
    };


    const TransactionDetailScreen = () => {
        const {
            transaction, files,
            navigatorFocus, expandedSection, selectedFileIndex, bodyView,
        } = useTransactionDetailScreen();

        if (!transaction) {
            return <Text>Loading transaction...</Text>;
        }

        const renderNavigator = () => {
            const isPromptFocused = navigatorFocus === 'PROMPT';
            const isReasoningFocused = navigatorFocus === 'REASONING';
            const isFilesFocused = navigatorFocus === 'FILES' || navigatorFocus === 'FILES_LIST';
            
            const isPromptExpanded = expandedSection === 'PROMPT';
            const isReasoningExpanded = expandedSection === 'REASONING';
            const isFilesExpanded = expandedSection === 'FILES';
            
            return (
                <Box flexDirection="column">
                    <Text color={isPromptFocused && !isFilesFocused ? 'cyan' : undefined}>
                        {isPromptFocused && !isFilesFocused ? '> ' : '  '}
                        {isPromptExpanded ? '▾' : '▸'} (P)rompt
                    </Text>
                    <Text color={isReasoningFocused && !isFilesFocused ? 'cyan' : undefined}>
                        {isReasoningFocused && !isFilesFocused ? '> ' : '  '}
                        {isReasoningExpanded ? '▾' : '▸'} (R)easoning ({transaction.reasoning?.split('\n\n').length || 0} steps)
                    </Text>
                    <Text color={isFilesFocused ? 'cyan' : undefined}>
                        {isFilesFocused && navigatorFocus !== 'FILES_LIST' ? '> ' : '  '}
                        {isFilesExpanded ? '▾' : '▸'} (F)iles ({files.length})
                    </Text>
                    {isFilesExpanded && (
                        <Box flexDirection="column" paddingLeft={2}>
                            {files.map((file, index) => {
                                 const isFileSelected = navigatorFocus === 'FILES_LIST' && selectedFileIndex === index;
                                 const stats = file.type === 'DEL' ? '' : ` (+${file.linesAdded}/-${file.linesRemoved})`;
                                 return (
                                    <Text key={file.id} color={isFileSelected ? 'cyan' : undefined}>
                                        {isFileSelected ? '> ' : '  '}
                                        {`${getFileChangeTypeIcon(file.type)} ${file.path}${stats}`}
                                    </Text>
                                );
                            })}
                        </Box>
                    )}
                </Box>
            );
        };

        const renderBody = () => {
            if (bodyView === 'NONE') {
                return <Text color="gray">(Press → to expand a section and view its contents)</Text>;
            }
            if (bodyView === 'PROMPT') {
                return (
                    <Box flexDirection="column">
                        <Text>PROMPT</Text>
                        <Box marginTop={1}><Text>{transaction.prompt}</Text></Box>
                    </Box>
                );
            }
            if (bodyView === 'REASONING') {
                if (!transaction.reasoning) return <Text color="gray">No reasoning provided.</Text>;
                return <ReasonScreen reasoning={transaction.reasoning} />;
            }
            if (bodyView === 'FILES_LIST') {
                 return <Text color="gray">(Select a file and press → to view the diff)</Text>;
            }
            if (bodyView === 'DIFF_VIEW') {
                const file = files[selectedFileIndex];
                if (!file) return null;
                return <DiffScreen filePath={file.path} diffContent={file.diff} isExpanded={true} />;
            }
            return null;
        };

        const renderFooter = () => {
            if (bodyView === 'REVERT_CONFIRM') {
                return <Text>(Enter) Confirm Revert      (Esc) Cancel</Text>;
            }
            
            if (navigatorFocus === 'FILES_LIST') {
                if (bodyView === 'DIFF_VIEW') {
                    return <Text>(↑↓) Nav Files · (←) Back to Files · (C)opy Mode · (U)ndo · (Q)uit</Text>;
                }
                return <Text>(↑↓) Nav Files · (→) View Diff · (←) Back to Sections · (C)opy Mode · (Q)uit</Text>;
            }
            
            if (expandedSection) {
                return <Text>(↑↓) Nav/Scroll · (←) Collapse · (C)opy Mode · (U)ndo · (Q)uit</Text>;
            }
            
            return <Text>(↑↓) Nav · (→) Expand · (C)opy Mode · (U)ndo · (Q)uit</Text>;
        };

        const { message, timestamp, status } = transaction;
        const date = new Date(timestamp).toISOString().replace('T', ' ').substring(0, 19);
        const fileStats = `${files.length} Files · +${files.reduce((a, f) => a + f.linesAdded, 0)} lines, -${files.reduce((a, f) => a + f.linesRemoved, 0)} lines`;

        return (
            <Box flexDirection="column">
                {/* Header */}
                <Text>▲ relaycode transaction details</Text>
                <Separator />
                
                {/* Modal takeover for Revert */}
                {bodyView === 'REVERT_CONFIRM' && <RevertModal transactionHash={transaction.hash} />}
                
                {/* Main view */}
                <Box flexDirection="column" display={bodyView === 'REVERT_CONFIRM' ? 'none' : 'flex'}>
                    {/* Navigator Part A */}
                    <Box flexDirection="column" marginY={1}>
                        <Text>UUID: {transaction.id}</Text>
                        <Text>Git: {message}</Text>
                        <Text>Date: {date} · Status: {status}</Text>
                        <Text>Stats: {fileStats}</Text>
                    </Box>
                    
                    {/* Navigator Part B */}
                    {renderNavigator()}
                    
                    <Separator />
                    
                    {/* Body */}
                    <Box marginY={1}>
                        {renderBody()}
                    </Box>
                    
                    <Separator />
                </Box>
                
                {/* Footer */}
                <Box>
                    {renderFooter()}
                </Box>
            </Box>
        );
    };


    export default TransactionDetailScreen;
  src/components/TransactionHistoryScreen.tsx: >-
    import React from 'react';

    import { Box, Text } from 'ink';

    import TextInput from 'ink-text-input';

    import { type FileChange } from '../stores/transaction-history.store';

    import type { Transaction } from '../types/transaction.types';

    import Separator from './Separator';

    import { useTransactionHistoryScreen } from
    '../hooks/useTransactionHistoryScreen';


    // --- Sub-components ---


    const DiffPreview = ({ diff }: { diff: string }) => {
        const lines = diff.split('\n');
        const previewLines = lines.slice(0, 5);
        const hiddenLines = lines.length > 5 ? lines.length - 5 : 0;

        return (
            <Box flexDirection="column" paddingLeft={8}>
                {previewLines.map((line, i) => {
                    let color = 'white';
                    if (line.startsWith('+')) color = 'green';
                    if (line.startsWith('-')) color = 'red';
                    if (line.startsWith('@@')) color = 'cyan';
                    return <Text key={i} color={color}>{line}</Text>;
                })}
                {hiddenLines > 0 && <Text color="gray">... {hiddenLines} lines hidden ...</Text>}
            </Box>
        );
    };


    const FileRow = ({ file, isSelected, isExpanded }: { file: FileChange,
    isSelected: boolean, isExpanded: boolean }) => {
        const icon = isExpanded ? '▾' : '▸';
        const typeMap = { MOD: '[MOD]', ADD: '[ADD]', DEL: '[DEL]', REN: '[REN]' };
        
        return (
            <Box flexDirection="column" paddingLeft={6}>
                <Text color={isSelected ? 'cyan' : undefined}>
                    {isSelected ? '> ' : '  '}
                    {icon} {typeMap[file.type]} {file.path}
                </Text>
                {isExpanded && <DiffPreview diff={file.diff} />}
            </Box>
        );
    };


    const TransactionRow = ({
        tx,
        isSelected,
        isExpanded,
        isSelectedForAction,
    }: {
        tx: Transaction,
        isSelected: boolean,
        isExpanded: boolean,
        isSelectedForAction: boolean,
    }) => {
        const icon = isExpanded ? '▾' : '▸';
        const statusMap = {
            COMMITTED: <Text color="green">✓ Committed</Text>,
            HANDOFF: <Text color="magenta">→ Handoff</Text>,
            REVERTED: <Text color="gray">↩ Reverted</Text>,
        };
        const date = new Date(tx.timestamp).toISOString().split('T')[0];
        const selectionIndicator = isSelectedForAction ? '[x]' : '[ ]';
        
        return (
            <Box flexDirection="column" marginBottom={isExpanded ? 1 : 0}>
                <Text color={isSelected ? 'cyan' : undefined}>
                    {isSelected ? '> ' : '  '}
                    {selectionIndicator} {icon} {statusMap[tx.status as keyof typeof statusMap] || tx.status} · {tx.hash} · {date} · {tx.message}
                </Text>
                {isExpanded && (
                    <Box flexDirection="column" paddingLeft={8}>
                        {tx.stats && <Text color="gray">Stats: {tx.stats.files} files, +{tx.stats.linesAdded}/-{tx.stats.linesRemoved}</Text>}
                        <Text>Files:</Text>
                    </Box>
                )}
            </Box>
        );
    };


    const BulkActionsMode = ({ selectedForActionCount }: {
    selectedForActionCount: number }) => {
        return (
            <Box flexDirection="column" marginY={1}>
                <Text bold color="yellow">PERFORM BULK ACTION ON {selectedForActionCount} SELECTED ITEMS</Text>
                <Box marginY={1}>
                    <Text>This action is often irreversible. Are you sure?</Text>
                </Box>
                <Text>(1) Revert Selected Transactions</Text>
                <Text>(2) Mark as &apos;Git Committed&apos;</Text>
                <Text>(3) Delete Selected Transactions (from Relaycode history)</Text>
                <Text>(Esc) Cancel</Text>
            </Box>
        );
    };


    // --- Main Component ---


    const TransactionHistoryScreen = () => {
        const {
            store,
            itemsInView,
            transactionsInView,
            pathsInViewSet,
            filterStatus,
            showingStatus,
        } = useTransactionHistoryScreen();

        const renderFooter = () => {
            if (store.mode === 'FILTER') return <Text>(Enter) Apply Filter & Return      (Esc) Cancel</Text>; 
            if (store.mode === 'BULK_ACTIONS') return <Text>Choose an option [1-3, Esc]:</Text>;
            
            const actions = ['(↑↓) Nav', '(→) Expand', '(←) Collapse', '(Spc) Select', '(Ent) Details', '(F)ilter'];
            if (store.selectedForAction.size > 0) {
                actions.push('(C)opy', '(B)ulk');
            }
            return <Text>{actions.join(' · ')}</Text>;
        };

        return (
            <Box flexDirection="column">
                <Text color="cyan">▲ relaycode transaction history</Text>
                <Separator />

                <Box>
                    <Text>Filter: </Text>
                    {store.mode === 'FILTER' ? (
                        <TextInput value={store.filterQuery} onChange={store.actions.setFilterQuery} />
                    ) : (
                        <Text>{filterStatus}</Text>
                    )}
                    <Text> · {showingStatus} ({store.transactions.length} txns)</Text>
                </Box>

                <Box flexDirection="column" marginY={1}>
                    {store.mode === 'BULK_ACTIONS' && <BulkActionsMode selectedForActionCount={store.selectedForAction.size} />}

                    {store.mode === 'LIST' && store.transactions.map(tx => {
                        const isTxSelected = store.selectedItemPath.startsWith(tx.id);
                        const isTxExpanded = store.expandedIds.has(tx.id);
                        const isSelectedForAction = store.selectedForAction.has(tx.id);

                        const showTxRow = pathsInViewSet.has(tx.id);

                        return (
                            <Box flexDirection="column" key={tx.id}>
                                {showTxRow && (
                                    <TransactionRow
                                        tx={tx}
                                        isSelected={isTxSelected && !store.selectedItemPath.includes('/')}
                                        isExpanded={isTxExpanded}
                                        isSelectedForAction={isSelectedForAction}
                                    />
                                )}
                                {isTxExpanded && tx.files?.map(file => {
                                    if (!pathsInViewSet.has(`${tx.id}/${file.id}`)) return null;
                                    const filePath = `${tx.id}/${file.id}`;
                                    const isFileSelected = store.selectedItemPath === filePath;
                                    const isFileExpanded = store.expandedIds.has(filePath);
                                    return (
                                        <FileRow
                                            key={file.id}
                                            file={file}
                                            isSelected={isFileSelected}
                                            isExpanded={isFileExpanded}
                                        />
                                    );
                                })}
                            </Box>
                        );
                    })}
                </Box>

                <Separator />
                {renderFooter()}
            </Box>
        );
    };


    export default TransactionHistoryScreen;
  src/hooks/useReviewScreen.tsx: |-
    import { useMemo } from 'react';
    import { useInput, useApp } from 'ink';
    import { useReviewStore } from '../stores/review.store';
    import { useAppStore } from '../stores/app.store';
    import { useTransactionStore } from '../stores/transaction.store';
    import { useCopyStore, type CopyItem } from '../stores/copy.store';
    import { CopyService } from '../services/copy.service';

    export const useReviewScreen = () => {
        const { exit } = useApp();
        const store = useReviewStore();
        const { transactionId } = store;
        const transaction = useTransactionStore(s => s.transactions.find(t => t.id === transactionId));
        const { showDashboardScreen } = useAppStore(s => s.actions);
        const {
            files, scripts, patchStatus,
            selectedItemIndex, bodyView,
        } = store;
        const {
            moveSelectionUp, moveSelectionDown, toggleFileApproval, expandDiff,
            toggleBodyView, setBodyView,
            startApplySimulation, rejectAllFiles, approve,
            tryRepairFile, showBulkRepair, executeBulkRepairOption, confirmHandoff,
            scrollReasoningUp, scrollReasoningDown, navigateScriptErrorUp, navigateScriptErrorDown,
        } = store.actions;

        const {
            numFiles,
            approvedFilesCount,
            approvedLinesAdded,
            approvedLinesRemoved,
        } = useMemo(() => {
            const approvedFiles = files.filter(f => f.status === 'APPROVED');
            return {
                numFiles: files.length,
                approvedFilesCount: approvedFiles.length,
                approvedLinesAdded: approvedFiles.reduce((sum, f) => sum + f.linesAdded, 0),
                approvedLinesRemoved: approvedFiles.reduce((sum, f) => sum + f.linesRemoved, 0),
            };
        }, [files]);

        const openCopyMode = () => {
            if (!transaction) return;
            const title = 'Select data to copy from review:';
            const selectedFile = selectedItemIndex < files.length ? files[selectedItemIndex] : undefined;
            const items = CopyService.getCopyItemsForReview(transaction, files, selectedFile);
            useCopyStore.getState().actions.open(title, items);
        };

        useInput((input, key) => {
            // For demo purposes: Pressing 1 or 2 triggers the processing screen simulation.
            if (input === '1') {
                startApplySimulation('success');
                return;
            }
            if (input === '2') {
                // The store's default is failure, but to re-trigger the processing screen
                startApplySimulation('failure');
                return;
            }

            if (input.toLowerCase() === 'q') exit();

            // Handle Escape key - context-sensitive behavior
            if (key.escape) {
                if (bodyView === 'bulk_repair' || bodyView === 'confirm_handoff') {
                    toggleBodyView(bodyView); // Close modal
                } else if (bodyView !== 'none') {
                    setBodyView('none');
                } else {
                    showDashboardScreen();
                }
                return;
            }

            // Handoff Confirmation
            if (bodyView === 'confirm_handoff') {
                if (key.return) {
                    confirmHandoff();
                }
                return;
            }

            // Bulk Repair Navigation
            if (bodyView === 'bulk_repair') {
                if (input >= '1' && input <= '4') {
                    executeBulkRepairOption(parseInt(input));
                }
                return;
            }

            // Reasoning Scroll Navigation
            if (bodyView === 'reasoning') {
                if (key.upArrow) scrollReasoningUp();
                if (key.downArrow) scrollReasoningDown();
                if (input.toLowerCase() === 'r') toggleBodyView('reasoning');
                return;
            }

            // Script Output Navigation
            if (bodyView === 'script_output') {
                if (input.toLowerCase() === 'j') navigateScriptErrorDown();
                if (input.toLowerCase() === 'k') navigateScriptErrorUp();
                if (key.return) toggleBodyView('script_output');
                if (input.toLowerCase() === 'c') {
                    // Copy script output
                    const scriptIndex = selectedItemIndex - numFiles;
                    const selectedScript = scripts[scriptIndex];
                    if (selectedScript) {
                        // eslint-disable-next-line no-console
                        console.log(`[CLIPBOARD] Copied script output: ${selectedScript.command}`);
                    }
                }
                return;
            }

            // Diff View Navigation
            if (bodyView === 'diff') {
                if (input.toLowerCase() === 'x') expandDiff();
                if (input.toLowerCase() === 'd') toggleBodyView('diff');
                return;
            }

            // Handle Shift+R for reject all
            if (key.shift && input.toLowerCase() === 'r') {
                if (approvedFilesCount > 0) {
                    rejectAllFiles();
                }
                return;
            }

            // Main View Navigation
            if (key.upArrow) moveSelectionUp();
            if (key.downArrow) moveSelectionDown();

            if (input.toLowerCase() === 'r') toggleBodyView('reasoning');

            if (input === ' ') {
                if (selectedItemIndex < numFiles) {
                    const file = files[selectedItemIndex];
                    if (file && file.status !== 'FAILED') {
                        toggleFileApproval();
                    }
                }
            }

            if (input.toLowerCase() === 'd') {
                if (selectedItemIndex < numFiles) {
                    toggleBodyView('diff');
                }
            }

            if (key.return) { // Enter key
                 if (selectedItemIndex >= numFiles) { // It's a script
                    toggleBodyView('script_output');
                }
            }

            if (input.toLowerCase() === 'a') {
                if (approvedFilesCount > 0) {
                    approve();
                    showDashboardScreen();
                }
            }

            if (input.toLowerCase() === 'c') {
                openCopyMode();
            }

            // Handle T for single repair and Shift+T for bulk repair
            if (input.toLowerCase() === 't') {
                if (key.shift) {
                    const hasFailedFiles = files.some(f => f.status === 'FAILED');
                    if (hasFailedFiles) {
                        showBulkRepair();
                    }
                } else {
                    if (selectedItemIndex < numFiles) {
                        const file = files[selectedItemIndex];
                        if (file && file.status === 'FAILED') {
                            tryRepairFile();
                        }
                    }
                }
            }

            if (input.toLowerCase() === 'q') {
                showDashboardScreen();
            }
        });

        return {
            ...store,
            transaction,
            numFiles,
            approvedFilesCount,
            approvedLinesAdded,
            approvedLinesRemoved,
        };
    };
  src/services/commit.service.ts: >-
    import type { Transaction } from '../types/transaction.types';

    import { sleep } from '../utils';

    import { useTransactionStore } from '../stores/transaction.store';


    const generateCommitMessage = (transactions: Transaction[]): string => {
        if (transactions.length === 0) {
            return '';
        }
        // Using a more complex aggregation for better demo, based on the readme
        const title = 'feat: implement new dashboard and clipboard logic';
        const bodyPoints = [
            '- Adds error handling to the core transaction module to prevent uncaught exceptions during snapshot restoration.',
            '- Refactors the clipboard watcher for better performance and cross-platform compatibility, resolving issue #42.',
        ];

        if (transactions.length === 1 && transactions[0]) {
            return transactions[0].message;
        }

        return `${title}\n\n${bodyPoints.join('\n\n')}`;
    };


    const commit = async (transactionsToCommit: Transaction[]): Promise<void> =>
    {
        // In a real app, this would run git commands.
        // For simulation, we'll just update the transaction store.
        const { updateTransactionStatus } = useTransactionStore.getState().actions;

        const txIds = transactionsToCommit.map(tx => tx.id);

        // A bit of simulation
        await sleep(500);

        txIds.forEach(id => {
            updateTransactionStatus(id, 'COMMITTED');
        });
    };


    export const CommitService = {
        generateCommitMessage,
        commit,
    };
  src/services/copy.service.ts: |-
    import type { Transaction } from '../types/transaction.types';
    import type { ReviewFileItem } from '../stores/review.store';
    import type { FileChange } from '../types/file.types';
    import type { CopyItem } from '../types/copy.types';
    import { COPYABLE_ITEMS } from '../types/copy.types';

    const getCopyItemsForReview = (
        transaction: Transaction,
        files: ReviewFileItem[],
        selectedFile?: ReviewFileItem,
    ): CopyItem[] => {
        return [
            { id: 'uuid', key: 'U', label: COPYABLE_ITEMS.UUID, getData: () => transaction.id },
            { id: 'message', key: 'M', label: COPYABLE_ITEMS.MESSAGE, getData: () => transaction.message },
            { id: 'prompt', key: 'P', label: COPYABLE_ITEMS.PROMPT, getData: () => transaction.prompt || '' },
            { id: 'reasoning', key: 'R', label: COPYABLE_ITEMS.REASONING, getData: () => transaction.reasoning || '' },
            { id: 'file_diff', key: 'F', label: `${COPYABLE_ITEMS.FILE_DIFF}${selectedFile ? `: ${selectedFile.path}` : ''}`, getData: () => selectedFile?.diff || 'No file selected' },
            { id: 'all_diffs', key: 'A', label: COPYABLE_ITEMS.ALL_DIFFS, getData: () => files.map(f => `--- FILE: ${f.path} ---\n${f.diff}`).join('\n\n') },
        ];
    };

    const getCopyItemsForDetail = (
        transaction: Transaction,
        selectedFile?: FileChange,
    ): CopyItem[] => {
        return [
            { id: 'message', key: 'M', label: COPYABLE_ITEMS.MESSAGE, getData: () => transaction.message, isDefaultSelected: true },
            { id: 'prompt', key: 'P', label: COPYABLE_ITEMS.PROMPT, getData: () => transaction.prompt || '' },
            { id: 'reasoning', key: 'R', label: COPYABLE_ITEMS.REASONING, getData: () => transaction.reasoning || '', isDefaultSelected: true },
            { id: 'all_diffs', key: 'A', label: `${COPYABLE_ITEMS.ALL_DIFFS} (${transaction.files?.length || 0} files)`, getData: () => transaction.files?.map(f => `--- FILE: ${f.path} ---\n${f.diff}`).join('\n\n') || '' },
            { id: 'file_diff', key: 'F', label: `${COPYABLE_ITEMS.FILE_DIFF}: ${selectedFile?.path || 'No file selected'}`, getData: () => selectedFile?.diff || 'No file selected' },
            { id: 'uuid', key: 'U', label: COPYABLE_ITEMS.UUID, getData: () => transaction.id },
            { id: 'yaml', key: 'Y', label: COPYABLE_ITEMS.FULL_YAML, getData: () => '... YAML representation ...' }, // Mocking this
        ];
    };

    const getCopyItemsForHistory = (
        transactions: Transaction[],
    ): CopyItem[] => {
        if (transactions.length === 0) return [];
        
        return [
            { id: 'messages', key: 'M', label: COPYABLE_ITEMS.MESSAGES, getData: () => transactions.map(tx => tx.message).join('\n'), isDefaultSelected: true },
            { id: 'prompts', key: 'P', label: COPYABLE_ITEMS.PROMPTS, getData: () => transactions.map(tx => tx.prompt || '').join('\n\n---\n\n'), isDefaultSelected: false },
            { id: 'reasonings', key: 'R', label: COPYABLE_ITEMS.REASONINGS, getData: () => transactions.map(tx => tx.reasoning || '').join('\n\n---\n\n'), isDefaultSelected: true },
            { id: 'diffs', key: 'D', label: COPYABLE_ITEMS.DIFFS, getData: () => transactions.flatMap(tx => tx.files?.map(f => `--- TX: ${tx.hash}, FILE: ${f.path} ---\n${f.diff}`)).join('\n\n') },
            { id: 'uuids', key: 'U', label: COPYABLE_ITEMS.UUIDS, getData: () => transactions.map(tx => tx.id).join('\n') },
            { id: 'yaml', key: 'Y', label: COPYABLE_ITEMS.FULL_YAML, getData: () => '... YAML representation ...' },
        ];
    };

    export const CopyService = {
        getCopyItemsForReview,
        getCopyItemsForDetail,
        getCopyItemsForHistory,
    };
  src/services/init.service.ts: |-
    import { useInitStore } from '../stores/init.store';
    import type { Task } from '../types/init.types';
    import { sleep } from '../utils';

    const initialAnalyzeTasks: Task[] = [
        { id: 'scan', title: 'Scanning project structure...', subtext: 'Finding package.json', status: 'pending' },
        { id: 'project-id', title: 'Determining Project ID', status: 'pending' },
        { id: 'gitignore', title: 'Checking for existing .gitignore', status: 'pending' },
    ];

    const initialConfigureTasks: Task[] = [
        { id: 'config', title: 'Creating relay.config.json', subtext: 'Writing default configuration with Project ID', status: 'pending' },
        { id: 'state-dir', title: 'Initializing .relay state directory', status: 'pending' },
        { id: 'prompt', title: 'Generating system prompt template', status: 'pending' },
    ];

    const runInitializationProcess = async () => {
        const { actions } = useInitStore.getState();
        actions.resetInit();
        actions.setTasks(initialAnalyzeTasks, initialConfigureTasks);

        actions.setPhase('ANALYZE');
        for (const task of initialAnalyzeTasks) {
            actions.updateAnalyzeTask(task.id, 'active');
            await sleep(800);
            actions.updateAnalyzeTask(task.id, 'done');
        }
        actions.setAnalysisResults('relaycode (from package.json)', true);
        await sleep(500);

        actions.setPhase('CONFIGURE');
        const configTasksUntilInteractive = initialConfigureTasks.slice(0, 2);
        for (const task of configTasksUntilInteractive) {
            actions.updateConfigureTask(task.id, 'active');
            await sleep(800);
            actions.updateConfigureTask(task.id, 'done');
        }
        await sleep(500);

        actions.setPhase('INTERACTIVE');
    };

    const resumeInitializationProcess = async () => {
        const { actions } = useInitStore.getState();
        
        actions.setPhase('CONFIGURE');
        const lastTask = initialConfigureTasks[2];
        if (lastTask) {
            actions.updateConfigureTask(lastTask.id, 'active');
            await sleep(800);
            actions.updateConfigureTask(lastTask.id, 'done');
            await sleep(500);

            actions.setPhase('FINALIZE');
        }
    };

    export const InitService = {
        runInitializationProcess,
        resumeInitializationProcess,
    };
  src/services/review.service.ts: >-
    import { useReviewStore, type ReviewFileItem } from
    '../stores/review.store';

    import { useTransactionStore } from '../stores/transaction.store';

    import { useAppStore } from '../stores/app.store';

    import { sleep } from '../utils';

    import type { ApplyStep, ApplyUpdate, ReviewBodyView } from
    '../types/review.types';


    const generateBulkRepairPrompt = (files: ReviewFileItem[]): string => {
        const failedFiles = files.filter(f => f.status === 'FAILED');
        return `The previous patch failed to apply to MULTIPLE files. Please generate a new, corrected patch that addresses all the files listed below.

    IMPORTANT: The response MUST contain a complete code block for EACH file
    that needs to be fixed.


    ${failedFiles.map(file => `--- FILE: ${file.path} ---

    Strategy: ${file.strategy}

    Error: ${file.error}


    ORIGINAL CONTENT:

    ---

    // ... original content of ${file.path} ...

    ---


    FAILED PATCH:

    ---

    ${file.diff || '// ... failed diff ...'}

    ---

    `).join('\n')}


    Please analyze all failed files and provide a complete, corrected
    response.`;

    };


    const generateHandoffPrompt = (
        hash: string,
        message: string,
        reasoning: string,
        files: ReviewFileItem[],
    ): string => {
        const successfulFiles = files.filter(f => f.status === 'APPROVED');
        const failedFiles = files.filter(f => f.status === 'FAILED');

        return `I am handing off a failed automated code transaction to you. Your task is to act as my programming assistant and complete the planned changes.

    The full plan for this transaction is detailed in the YAML file located at:
    .relay/transactions/${hash}.yml. Please use this file as your primary source
    of truth for the overall goal.


    Here is the current status of the transaction:


    --- TRANSACTION SUMMARY ---

    Goal: ${message}

    Reasoning:

    ${reasoning}


    --- CURRENT FILE STATUS ---

    SUCCESSFUL CHANGES (already applied, no action needed):

    ${successfulFiles.map(f => `- MODIFIED: ${f.path}`).join('\n') || ' 
    (None)'}


    FAILED CHANGES (these are the files you need to fix):

    ${failedFiles.map(f => `- FAILED: ${f.path} (Error:
    ${f.error})`).join('\n')}


    Your job is to now work with me to fix the FAILED files and achieve the
    original goal of the transaction. Please start by asking me which file you
    should work on first.`;

    };


    const performHandoff = (hash: string) => {
        // This is a bit of a hack to find the right transaction to update in the demo
        const txToUpdate = useTransactionStore.getState().transactions.find(tx => tx.hash === hash);
        if (txToUpdate) {
            useTransactionStore.getState().actions.updateTransactionStatus(txToUpdate.id, 'HANDOFF');
        }

        useAppStore.getState().actions.showDashboardScreen();
    };


    async function* runApplySimulation(scenario: 'success' | 'failure'):
    AsyncGenerator<ApplyUpdate> {
        if (scenario === 'success') {
            yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'active' } }; await sleep(100);
            yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'done', duration: 0.1 } };

            yield { type: 'UPDATE_STEP', payload: { id: 'memory', status: 'active' } }; await sleep(100);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 's1', title: '[✓] write: src/core/clipboard.ts (strategy: replace)', status: 'done' } } };
            await sleep(100);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 's2', title: '[✓] write: src/utils/shell.ts (strategy: standard-diff)', status: 'done' } } };
            yield { type: 'UPDATE_STEP', payload: { id: 'memory', status: 'done', duration: 0.3 } };

            yield { type: 'UPDATE_STEP', payload: { id: 'post-command', status: 'active' } }; await sleep(1300);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'post-command', substep: { id: 's3', title: '`bun run test` ... Passed', status: 'done' } } };
            yield { type: 'UPDATE_STEP', payload: { id: 'post-command', status: 'done', duration: 2.3 } };

            yield { type: 'UPDATE_STEP', payload: { id: 'linter', status: 'active' } }; await sleep(1200);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'linter', substep: { id: 's4', title: '`bun run lint` ... 0 Errors', status: 'done' } } };
            yield { type: 'UPDATE_STEP', payload: { id: 'linter', status: 'done', duration: 1.2 } };

            await sleep(500);

        } else { // failure scenario
            yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'active' } }; await sleep(100);
            yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'done', duration: 0.1 } };

            yield { type: 'UPDATE_STEP', payload: { id: 'memory', status: 'active' } }; await sleep(100);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 'f1', title: '[✓] write: src/core/transaction.ts (strategy: replace)', status: 'done' } } };
            await sleep(100);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 'f2', title: '[!] failed: src/utils/logger.ts (Hunk #1 failed to apply)', status: 'failed' } } };
            await sleep(100);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 'f3', title: '[!] failed: src/commands/apply.ts (Context mismatch at line 92)', status: 'failed' } } };
            yield { type: 'UPDATE_STEP', payload: { id: 'memory', status: 'done', duration: 0.5 } };

            await sleep(100);
            yield { type: 'UPDATE_STEP', payload: { id: 'post-command', status: 'skipped', details: 'Skipped due to patch application failure' } };
            await sleep(100);
            yield { type: 'UPDATE_STEP', payload: { id: 'linter', status: 'skipped', details: 'Skipped due to patch application failure' } };

            await sleep(500);
        }
    }


    const loadTransactionForReview = (transactionId: string, initialState?: {
    bodyView: ReviewBodyView }) => {
        useReviewStore.getState().actions.load(transactionId, initialState);
    };


    const generateSingleFileRepairPrompt = (file: ReviewFileItem): string => {
        return `The patch failed to apply to ${file.path}. Please generate a corrected patch.

    Error: ${file.error}

    Strategy: ${file.strategy}


    ORIGINAL CONTENT:

    ---

    // ... original file content would be here ...

    ---


    FAILED PATCH:

    ---

    ${file.diff || '// ... failed diff would be here ...'}

    ---


    Please provide a corrected patch that addresses the error.`;

    };


    const tryRepairFile = (file: ReviewFileItem): ReviewFileItem => {
        const repairPrompt = generateSingleFileRepairPrompt(file);
        // In a real app: clipboardy.writeSync(repairPrompt)
        // eslint-disable-next-line no-console
        console.log(`[CLIPBOARD] Copied repair prompt for: ${file.path}`);

        // Mock: return the updated file
        return { ...file, status: 'APPROVED' as const, error: undefined, linesAdded: 5, linesRemoved: 2 };
    };


    const runBulkReapply = async (files: ReviewFileItem[]):
    Promise<ReviewFileItem[]> => {
        const failedFileIds = new Set(files.filter(f => f.status === 'FAILED').map(f => f.id));
        if (failedFileIds.size === 0) {
            return files;
        }

        await sleep(1500); // Simulate re-apply

        // Mock a mixed result
        let first = true;
        return files.map(file => {
            if (failedFileIds.has(file.id)) {
                if (first) {
                    first = false;
                    // The file coming in already has the 'RE_APPLYING' status from the store action
                    return { ...file, status: 'APPROVED' as const, strategy: 'replace' as const, error: undefined, linesAdded: 9, linesRemoved: 2 };
                }
                return { ...file, status: 'FAILED' as const, error: "'replace' failed: markers not found" };
            }
            return file;
        });
    };


    export const ReviewService = {
        loadTransactionForReview,
        generateBulkRepairPrompt,
        generateHandoffPrompt,
        performHandoff,
        runApplySimulation,
        generateSingleFileRepairPrompt,
        tryRepairFile,
        runBulkReapply,
    };
  src/services/transaction.service.ts: |-
    import { createMockTransactions } from '../data/mocks';
    import type { Transaction } from '../types/transaction.types';

    const revertTransaction = (transactionId: string) => {
        // In a real app, this would perform the revert operation (e.g., API call).
        // The state update is now handled by the calling store.
        // This is a no-op for the simulation, we just need the id.
    };

    export const TransactionService = {
        revertTransaction,
        getAllTransactions: (): Transaction[] => createMockTransactions(),
    };
  src/stores/app.store.ts: |-
    import { create } from 'zustand';
    import type { AppScreen } from '../types/app.types';

    interface AppState {
        isHelpOpen: boolean;
        isDebugMenuOpen: boolean;
        currentScreen: AppScreen;
        actions: {
            showInitScreen: () => void;
            showReviewProcessingScreen: () => void;
            showDashboardScreen: () => void;
            showReviewScreen: () => void;
            showGitCommitScreen: () => void;
            showSplashScreen: () => void;
            showTransactionHistoryScreen: () => void;
            showTransactionDetailScreen: () => void;
            toggleDebugMenu: () => void;
            toggleHelp: () => void;
        };
    }

    export const useAppStore = create<AppState>((set) => ({
        isHelpOpen: false,
        isDebugMenuOpen: false,
        currentScreen: 'splash',
        actions: {
            showInitScreen: () => set({ currentScreen: 'init' }),
            showReviewProcessingScreen: () => set({ currentScreen: 'review-processing' }),
            showDashboardScreen: () => set({ currentScreen: 'dashboard' }),
            showReviewScreen: () => set({ currentScreen: 'review' }),
            showGitCommitScreen: () => set({ currentScreen: 'git-commit' }),
            showSplashScreen: () => set({ currentScreen: 'splash' }),
            showTransactionHistoryScreen: () => set({ currentScreen: 'transaction-history' }),
            showTransactionDetailScreen: () => set({ currentScreen: 'transaction-detail' }),
            toggleDebugMenu: () => set(state => ({ isDebugMenuOpen: !state.isDebugMenuOpen })),
            toggleHelp: () => set(state => ({ isHelpOpen: !state.isHelpOpen })),
        },
    }));
  src/stores/commit.store.ts: |-
    import { create } from 'zustand';
    import type { Transaction } from '../types/transaction.types';
    import { CommitService } from '../services/commit.service';
    import { useTransactionStore } from './transaction.store';

    interface CommitState {
        finalCommitMessage: string;
        isCommitting: boolean;
        actions: {
            prepareCommitScreen: () => void;
            commit: () => Promise<void>;
        }
    }

    export const useCommitStore = create<CommitState>((set, get) => ({
        finalCommitMessage: '',
        isCommitting: false,
        actions: {
            prepareCommitScreen: () => {
                const { transactions } = useTransactionStore.getState();
                const appliedTransactions = transactions.filter(tx => tx.status === 'APPLIED');
                const finalCommitMessage = CommitService.generateCommitMessage(appliedTransactions);
                set({ finalCommitMessage });
            },
            commit: async () => {
                set({ isCommitting: true });
                const { transactions } = useTransactionStore.getState();
                const appliedTransactions = transactions.filter(tx => tx.status === 'APPLIED');
                await CommitService.commit(appliedTransactions);
                set({ isCommitting: false });
            },
        },
    }));
  src/stores/dashboard.store.ts: |-
    import { create } from 'zustand';
    import { DashboardService } from '../services/dashboard.service';
    import { useTransactionStore, type Transaction } from './transaction.store';
    import type { DashboardStatus } from '../types/dashboard.types';
    import { moveIndex } from './navigation.utils';

    export type { Transaction } from '../types/transaction.types';
    export type { DashboardStatus } from '../types/dashboard.types';

    // --- Store Interface ---
    interface DashboardState {
        status: DashboardStatus;
        previousStatus: DashboardStatus; // To handle cancel from confirmation
        selectedTransactionIndex: number;
        actions: {
            togglePause: () => void;
            moveSelectionUp: () => void;
            moveSelectionDown: () => void;
            startApproveAll: () => void;
            confirmAction: () => Promise<void>;
            cancelAction: () => void;
            setStatus: (status: DashboardStatus) => void; // For debug menu
        };
    }

    // --- Store Implementation ---
    export const useDashboardStore = create<DashboardState>((set, get) => ({
        status: 'LISTENING',
        previousStatus: 'LISTENING',
        selectedTransactionIndex: 0,
        actions: {
            togglePause: () => set(state => ({
                status: state.status === 'LISTENING' ? 'PAUSED' : 'LISTENING',
            })),
            moveSelectionUp: () => set(state => {
                const { transactions } = useTransactionStore.getState();
                return { selectedTransactionIndex: moveIndex(state.selectedTransactionIndex, 'up', transactions.length) };
            }),
            moveSelectionDown: () => set(state => {
                const { transactions } = useTransactionStore.getState();
                return { selectedTransactionIndex: moveIndex(state.selectedTransactionIndex, 'down', transactions.length) };
            }),
            startApproveAll: () => set(state => ({
                status: 'CONFIRM_APPROVE',
                previousStatus: state.status,
            })),
            cancelAction: () => set(state => ({ status: state.previousStatus })),
            setStatus: (status) => set({ status }),

            confirmAction: async () => {
                const { status, previousStatus } = get();
                if (status === 'CONFIRM_APPROVE') {
                    set({ status: 'APPROVING' });

                    await DashboardService.approveAll();

                    set({ status: previousStatus });
                }
            },
        },
    }));
  src/stores/init.store.ts: >-
    import { create } from 'zustand';

    import type { Task, TaskStatus, InitPhase, GitignoreChoice } from
    '../types/init.types';

    export type { Task } from '../types/init.types';


    // Store Interface

    interface InitState {
        phase: InitPhase;
        analyzeTasks: Task[];
        projectId: string | null;
        gitignoreFound: boolean | null;
        configureTasks: Task[];
        interactiveChoice: GitignoreChoice | null;

        actions: {
            setPhase: (_phase: InitPhase) => void;
            setTasks: (analyzeTasks: Task[], configureTasks: Task[]) => void;
            updateAnalyzeTask: (_id: string, _status: TaskStatus) => void;
            setAnalysisResults: (_projectId: string, _gitignoreFound: boolean) => void;
            updateConfigureTask: (_id: string, _status: TaskStatus) => void;
            setInteractiveChoice: (_choice: GitignoreChoice) => void;
            resetInit: () => void;
        };
    }


    // Create the store

    export const useInitStore = create<InitState>((set) => ({
        phase: 'ANALYZE',
        analyzeTasks: [],
        projectId: null,
        gitignoreFound: null,
        configureTasks: [],
        interactiveChoice: null,

        actions: {
            setPhase: (phase) => set({ phase }),
            setTasks: (analyzeTasks, configureTasks) => set({
                analyzeTasks: JSON.parse(JSON.stringify(analyzeTasks)),
                configureTasks: JSON.parse(JSON.stringify(configureTasks)),
            }),
            updateAnalyzeTask: (id, status) => set(state => ({
                analyzeTasks: state.analyzeTasks.map(t => t.id === id ? { ...t, status } : t),
            })),
            setAnalysisResults: (projectId, gitignoreFound) => set({ projectId, gitignoreFound }),
            updateConfigureTask: (id, status) => set(state => ({
                configureTasks: state.configureTasks.map(t => t.id === id ? { ...t, status } : t),
            })),
            setInteractiveChoice: (choice) => set({ interactiveChoice: choice }),
            resetInit: () => set({
                phase: 'ANALYZE',
                analyzeTasks: [],
                projectId: null,
                gitignoreFound: null,
                configureTasks: [],
                interactiveChoice: null,
            }),
        },
    }));
  src/stores/review.store.ts: >-
    import { create } from 'zustand';

    import { sleep } from '../utils';

    import { useAppStore } from './app.store';

    import { ReviewService } from '../services/review.service';

    import { useTransactionStore, type Transaction } from './transaction.store';

    import { moveIndex } from './navigation.utils';

    import type { ReviewFileItem } from '../types/file.types';

    import type { ScriptResult, ApplyStep, ReviewBodyView, PatchStatus,
    ApplyUpdate } from '../types/review.types';


    export type { ReviewFileItem } from '../types/file.types';

    export type { ScriptResult, ApplyStep } from '../types/review.types';


    export const initialApplySteps: ApplyStep[] = [
        { id: 'snapshot', title: 'Reading initial file snapshot...', status: 'pending' },
        { id: 'memory', title: 'Applying operations to memory...', status: 'pending', substeps: [] },
        { id: 'post-command', title: 'Running post-command script...', status: 'pending', substeps: [] },
        { id: 'linter', title: 'Analyzing changes with linter...', status: 'pending', substeps: [] },
    ];


    interface ReviewState {
        // Transaction Info
        transactionId: string | null;
        patchStatus: PatchStatus;

        // File & Script Info
        files: ReviewFileItem[];
        scripts: ScriptResult[];

        // UI State
        applySteps: ApplyStep[];
        selectedItemIndex: number; // Can be file or script
        bodyView: ReviewBodyView;
        isDiffExpanded: boolean;

        // Reasoning Scroll State
        reasoningScrollIndex: number;

        // Script Navigation State
        scriptErrorIndex: number;

        actions: {
            moveSelectionUp: () => void;
            moveSelectionDown: () => void;
            toggleFileApproval: () => void;
            rejectAllFiles: () => void;
            expandDiff: () => void;
            toggleBodyView: (view: Extract<ReviewBodyView, 'diff' | 'reasoning' | 'script_output' | 'bulk_repair' | 'confirm_handoff'>) => void;
            setBodyView: (view: ReviewBodyView) => void;
            approve: () => void;
            startApplySimulation: (scenario: 'success' | 'failure') => void;

            // Repair Actions
            tryRepairFile: () => void;
            showBulkRepair: () => void;
            executeBulkRepairOption: (option: number) => Promise<void>;
            confirmHandoff: () => void;

            // Navigation Actions
            scrollReasoningUp: () => void;
            scrollReasoningDown: () => void;
            navigateScriptErrorUp: () => void;
            navigateScriptErrorDown: () => void;

            // "Private" actions for service layer
            load: (transactionId: string, initialState?: { bodyView: ReviewBodyView }) => void;
            _updateApplyStep: (id: string, status: ApplyStep['status'], duration?: number, details?: string) => void;
            _addApplySubstep: (parentId: string, substep: Omit<ApplyStep, 'substeps'>) => void;
        };
    }


    export const useReviewStore = create<ReviewState>((set, get) => ({
        // Transaction Info
        transactionId: null,
        patchStatus: 'SUCCESS', // This will be set on load

        // File & Script Info
        files: [],
        scripts: [],

        // UI State
        applySteps: initialApplySteps,
        selectedItemIndex: 0,
        bodyView: 'none' as const,
        isDiffExpanded: false,

        // Reasoning Scroll State
        reasoningScrollIndex: 0,

        // Script Navigation State
        scriptErrorIndex: 0,

        actions: {
            moveSelectionUp: () => set(state => ({
                selectedItemIndex: moveIndex(state.selectedItemIndex, 'up', state.files.length + state.scripts.length),
            })),
            moveSelectionDown: () => set(state => ({
                selectedItemIndex: moveIndex(state.selectedItemIndex, 'down', state.files.length + state.scripts.length),
            })),
            toggleFileApproval: () => set(state => {
                const { selectedItemIndex, files } = state;
                if (selectedItemIndex >= files.length) return {}; // Not a file

                const newFiles = [...files];
                const file = newFiles[selectedItemIndex];
                if (file) {
                    if (file.status === 'APPROVED') {
                        file.status = 'REJECTED';
                    } else if (file.status === 'REJECTED') {
                        file.status = 'APPROVED';
                    }
                }
                return { files: newFiles };
            }),
            rejectAllFiles: () => set(state => {
                const newFiles = state.files.map(file => {
                    if (file.status === 'APPROVED') {
                        return { ...file, status: 'REJECTED' as const };
                    }
                    return file;
                });
                return { files: newFiles };
            }),
            toggleBodyView: (view) => set(state => {
                if (view === 'diff' && state.selectedItemIndex >= state.files.length) return {}; // Can't show diff for scripts
                return {
                    bodyView: state.bodyView === view ? 'none' : view,
                    isDiffExpanded: false, // Always start collapsed
                };
            }),
            setBodyView: (view) => set({ bodyView: view }),
            expandDiff: () => set(state => ({ isDiffExpanded: !state.isDiffExpanded })),
            approve: () => {
                const { transactionId } = get();
                if (transactionId) {
                    // Update transaction status to COMMITTED
                    useTransactionStore.getState().actions.updateTransactionStatus(transactionId, 'COMMITTED');
                    // Navigate back to dashboard
                    useAppStore.getState().actions.showDashboardScreen();
                }
            },
            startApplySimulation: async (scenario: 'success' | 'failure') => {
                const { showReviewProcessingScreen, showReviewScreen } = useAppStore.getState().actions;
                const { _updateApplyStep, _addApplySubstep } = get().actions;

                set({ applySteps: JSON.parse(JSON.stringify(initialApplySteps)) });
                showReviewProcessingScreen();

                const simulationGenerator = ReviewService.runApplySimulation(scenario);
                for await (const update of simulationGenerator) {
                    switch (update.type) {
                        case 'UPDATE_STEP':
                            _updateApplyStep(update.payload.id, update.payload.status, update.payload.duration, update.payload.details);
                            break;
                        case 'ADD_SUBSTEP':
                            _addApplySubstep(update.payload.parentId, update.payload.substep);
                            break;
                    }
                }

                showReviewScreen();
            },

            // Repair Actions
            tryRepairFile: () => {
                set(state => {
                    const { selectedItemIndex, files } = state;
                    if (selectedItemIndex >= files.length) return {};

                    const file = files[selectedItemIndex];
                    if (file?.status === 'FAILED') {
                        const updatedFile = ReviewService.tryRepairFile(file);
                        const newFiles = [...files];
                        newFiles[selectedItemIndex] = updatedFile;
                        return { files: newFiles };
                    }
                    return {};
                });
            },
            showBulkRepair: () => get().actions.toggleBodyView('bulk_repair'),
            executeBulkRepairOption: async (option: number) => {
                const { files } = get();

                switch (option) {
                    case 1: { // Generate & Copy Bulk Repair Prompt
                        const bulkPrompt = ReviewService.generateBulkRepairPrompt(files);
                        const failedFiles = files.filter(f => f.status === 'FAILED');
                        console.log(`[CLIPBOARD] Copied bulk repair prompt for ${failedFiles.length} file(s).`); // eslint-disable-line no-console
                        // In a real app, this would use clipboardy.writeSync(bulkPrompt),
                        set({ bodyView: 'none' as const });
                        break;
                    }

                    case 2: { // Attempt Bulk Re-apply
                        set({ bodyView: 'none' as const });

                        const failedFileIds = new Set(files.filter(f => f.status === 'FAILED').map(f => f.id));
                        if (failedFileIds.size === 0) {
                            break;
                        }

                        // Set intermediate state
                        set(state => ({
                            files: state.files.map(file =>
                                failedFileIds.has(file.id)
                                    ? { ...file, status: 'RE_APPLYING' as const }
                                    : file
                            ),
                        }));

                        const finalFiles = await ReviewService.runBulkReapply(get().files);
                        set({ files: finalFiles });
                        break;
                    }

                    case 3: { // Handoff to Human
                        get().actions.setBodyView('confirm_handoff');
                        break;
                    }

                    case 4: { // Reject All Failed
                        set(state => ({
                            files: state.files.map(file =>
                                file.status === 'FAILED'
                                    ? { ...file, status: 'REJECTED' as const }
                                    : file,
                            ),
                            bodyView: 'none' as const,
                        }));
                        break;
                    }

                    default: // Close modal
                        set({ bodyView: 'none' as const });
                }
            },
            confirmHandoff: () => {
                const { transactionId, files } = get();
                const transaction = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!transaction) return;

                const handoffPrompt = ReviewService.generateHandoffPrompt(transaction.hash, transaction.message, transaction.reasoning || '', files);

                // eslint-disable-next-line no-console
                console.log('[CLIPBOARD] Copied Handoff Prompt.'); // In real app: clipboardy.writeSync(handoffPrompt)
                ReviewService.performHandoff(transaction.hash);
            },

            // Navigation Actions
            scrollReasoningUp: () => set(state => ({
                reasoningScrollIndex: Math.max(0, state.reasoningScrollIndex - 1),
            })),
            scrollReasoningDown: () => set(state => {
                const { transactionId } = state;
                if (!transactionId) return {};

                const transaction = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!transaction?.reasoning) return {};

                const maxLines = transaction.reasoning.split('\n').length;
                return { reasoningScrollIndex: Math.min(maxLines - 1, state.reasoningScrollIndex + 1) };
            }),
            navigateScriptErrorUp: () => set(state => ({
                scriptErrorIndex: Math.max(0, state.scriptErrorIndex - 1),
            })),
            navigateScriptErrorDown: () => set(state => {
                const selectedScript = state.scripts[state.selectedItemIndex - state.files.length];
                if (selectedScript && selectedScript.output) {
                    const errorLines = selectedScript.output.split('\n').filter(line =>
                        line.includes('Error') || line.includes('Warning'),
                    );
                    return { scriptErrorIndex: Math.min(errorLines.length - 1, state.scriptErrorIndex + 1) };
                }
                return {};
            }),

            // "Private" actions for service layer
            load: (transactionId, initialState) => {
                const transaction = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!transaction) return;

                // This simulates the backend determining which files failed or succeeded.
                // For this demo, tx '1' is the failure case, any other is success.
                const isFailureCase = transaction.id === '1';
                const patchStatus = isFailureCase ? 'PARTIAL_FAILURE' : 'SUCCESS';

                const reviewFiles: ReviewFileItem[] = (transaction.files || []).map((file, index) => {
                    if (isFailureCase) {
                        return {
                            ...file,
                            status: index === 0 ? 'APPROVED' : 'FAILED',
                            error: index > 0 ? (index === 1 ? 'Hunk #1 failed to apply' : 'Context mismatch at line 92') : undefined,
                            strategy: file.strategy || 'standard-diff',
                        };
                    }
                    return { ...file, status: 'APPROVED', strategy: file.strategy || 'standard-diff' };
                });

                set({
                    transactionId: transaction.id,
                    patchStatus,
                    files: reviewFiles,
                    scripts: transaction.scripts || [],
                    selectedItemIndex: 0,
                    bodyView: initialState?.bodyView ?? 'none',
                    isDiffExpanded: false,
                    reasoningScrollIndex: 0,
                    scriptErrorIndex: 0,
                    applySteps: JSON.parse(JSON.stringify(initialApplySteps)), // Reset apply steps
                });
            },
            _updateApplyStep: (id, status, duration, details) => {
                set(state => ({
                    applySteps: state.applySteps.map(s => {
                        if (s.id === id) {
                            const newStep = { ...s, status };
                            if (duration !== undefined) newStep.duration = duration;
                            if (details !== undefined) newStep.details = details;
                            return newStep;
                        }
                        return s;
                    }),
                }));
            },
            _addApplySubstep: (parentId, substep) => {
                 set(state => ({
                    applySteps: state.applySteps.map(s => {
                        if (s.id === parentId) {
                            const newSubsteps = [...(s.substeps || []), substep as ApplyStep];
                            return { ...s, substeps: newSubsteps };
                        }
                        return s;
                    }),
                }));
            },
        },
    }));
  src/stores/transaction-detail.store.ts: >-
    import { create } from 'zustand';

    import { TransactionService } from '../services/transaction.service';

    import { useTransactionStore } from './transaction.store';

    import type { FileChangeType } from '../types/file.types';

    import type { NavigatorSection, DetailBodyView } from
    '../types/transaction-detail.types';


    interface TransactionDetailState {
        // Data
        transactionId: string | null;

        // UI State
        navigatorFocus: NavigatorSection | 'FILES_LIST';
        expandedSection: NavigatorSection | null;
        selectedFileIndex: number;
        bodyView: DetailBodyView;

        // Actions
        actions: {
            loadTransaction: (transactionId: string) => void;
            navigateUp: () => void;
            navigateDown: () => void;
            handleEnterOrRight: () => void;
            handleEscapeOrLeft: () => void;
            toggleRevertConfirm: () => void;
            confirmRevert: () => void;
        }
    }


    const navigatorOrder: NavigatorSection[] = ['PROMPT', 'REASONING', 'FILES'];


    export const useTransactionDetailStore =
    create<TransactionDetailState>((set, get) => ({
        transactionId: null,

        navigatorFocus: 'PROMPT',
        expandedSection: null,
        selectedFileIndex: 0,
        bodyView: 'NONE',

        actions: {
            loadTransaction: (transactionId) => set({
                transactionId,
                // Reset UI state
                navigatorFocus: 'PROMPT',
                expandedSection: null,
                selectedFileIndex: 0,
                bodyView: 'NONE',
            }),
            navigateUp: () => {
                const { navigatorFocus, selectedFileIndex } = get();
                if (navigatorFocus === 'FILES_LIST') {
                    set({ selectedFileIndex: Math.max(0, selectedFileIndex - 1) });
                } else {
                    const currentIndex = navigatorOrder.indexOf(navigatorFocus as NavigatorSection);
                    if (currentIndex > 0) {
                        set({ navigatorFocus: navigatorOrder[currentIndex - 1] });
                    }
                }
            },
            navigateDown: () => {
                const { navigatorFocus, selectedFileIndex } = get();
                const transaction = useTransactionStore.getState().transactions.find(tx => tx.id === get().transactionId);
                const files = transaction?.files || [];

                if (navigatorFocus === 'FILES_LIST') {
                    set({ selectedFileIndex: Math.min(files.length - 1, selectedFileIndex + 1) });
                } else {
                    const currentIndex = navigatorOrder.indexOf(navigatorFocus as NavigatorSection);
                    if (currentIndex < navigatorOrder.length - 1) {
                        set({ navigatorFocus: navigatorOrder[currentIndex + 1]! });
                    }
                }
            },
            handleEnterOrRight: () => {
                const { navigatorFocus, expandedSection } = get();

                if (navigatorFocus === 'FILES_LIST') {
                    // Already in file list, now show diff
                    set({ bodyView: 'DIFF_VIEW' });
                    return;
                }

                if (expandedSection === navigatorFocus) {
                    // Section is already expanded, handle nested navigation
                    if (navigatorFocus === 'FILES') {
                        set({ navigatorFocus: 'FILES_LIST', bodyView: 'FILES_LIST' });
                    }
                    return;
                }

                // Expand the focused section
                set({ expandedSection: navigatorFocus });

                switch(navigatorFocus) {
                    case 'PROMPT':
                        set({ bodyView: 'PROMPT' });
                        break;
                    case 'REASONING':
                        set({ bodyView: 'REASONING' });
                        break;
                    case 'FILES':
                        set({ bodyView: 'FILES_LIST' });
                        break;
                }
            },
            handleEscapeOrLeft: () => {
                const { navigatorFocus, expandedSection, bodyView } = get();

                if (bodyView === 'DIFF_VIEW') {
                    set({ bodyView: 'FILES_LIST' }); // Go back from diff to file list
                    return;
                }

                if (navigatorFocus === 'FILES_LIST') {
                    set({ navigatorFocus: 'FILES', bodyView: 'NONE' }); // Go back from file list to files section
                    return;
                }

                // If a section is expanded, collapse it
                if (expandedSection) {
                    set({ expandedSection: null, bodyView: 'NONE' });
                    return;
                }
            },
            toggleRevertConfirm: () => set(state => ({
                bodyView: state.bodyView === 'REVERT_CONFIRM' ? 'NONE' : 'REVERT_CONFIRM',
            })),
            confirmRevert: () => {
                const { transactionId } = get();
                if (!transactionId) return;
                TransactionService.revertTransaction(transactionId);
                useTransactionStore.getState().actions.updateTransactionStatus(transactionId, 'REVERTED');
                set({ bodyView: 'NONE' });
            },
        },
    }));
  src/stores/transaction-history.store.ts: >-
    import { create } from 'zustand';

    import type { Transaction } from '../types/transaction.types';

    import type { FileChange } from '../types/file.types';

    import type { HistoryViewMode } from '../types/transaction-history.types';

    import { useTransactionStore } from './transaction.store';


    export type { FileChange } from '../types/file.types';


    // Omit 'actions' from state type for partial updates

    type HistoryStateData = Omit<TransactionHistoryState, 'actions'>;


    interface TransactionHistoryState {
        mode: HistoryViewMode;
        selectedItemPath: string; // e.g. "tx-1" or "tx-1/file-2"
        expandedIds: Set<string>; // holds ids of expanded items
        filterQuery: string;
        selectedForAction: Set<string>; // set of transaction IDs
        transactions: Transaction[];

        actions: {
            load: (initialState?: Partial<HistoryStateData>) => void;
            navigateDown: () => void;
            navigateUp: () => void;
            expandOrDrillDown: () => void;
            collapseOrBubbleUp: () => void;
            toggleSelection: () => void;
            setMode: (mode: HistoryViewMode) => void;
            setFilterQuery: (query: string) => void;
            applyFilter: () => void;
            prepareDebugState: (stateName: 'l1-drill' | 'l2-drill' | 'filter' | 'copy' | 'bulk') => void;
        }
    }


    export const getVisibleItemPaths = (transactions: Transaction[],
    expandedIds: Set<string>): string[] => {
        const paths: string[] = [];
        for (const tx of transactions) {
            paths.push(tx.id);
            if (expandedIds.has(tx.id) && tx.files) {
                for (const file of tx.files) {
                    paths.push(`${tx.id}/${file.id}`);
                }
            }
        }
        return paths;
    };


    // --- Store ---

    export const useTransactionHistoryStore =
    create<TransactionHistoryState>((set, get) => ({
        mode: 'LIST',
        selectedItemPath: '',
        expandedIds: new Set(),
        filterQuery: '',
        selectedForAction: new Set(),
        transactions: [],

        actions: {
            load: (initialState) => {
                const { transactions } = useTransactionStore.getState();
                set({
                    selectedItemPath: transactions[0]?.id || '',
                    mode: 'LIST',
                    expandedIds: new Set(),
                    selectedForAction: new Set(),
                    filterQuery: '',
                    transactions,
                    ...initialState,
                });
            },
            navigateUp: () => {
                const { expandedIds, selectedItemPath, transactions } = get();
                const visibleItems = getVisibleItemPaths(transactions, expandedIds);
                const currentIndex = visibleItems.indexOf(selectedItemPath);
                if (currentIndex > 0) {
                    set({ selectedItemPath: visibleItems[currentIndex - 1]! });
                }
            },
            navigateDown: () => {
                const { expandedIds, selectedItemPath, transactions } = get();
                const visibleItems = getVisibleItemPaths(transactions, expandedIds);
                const currentIndex = visibleItems.indexOf(selectedItemPath);
                if (currentIndex < visibleItems.length - 1) {
                    set({ selectedItemPath: visibleItems[currentIndex + 1]! });
                }
            },
            expandOrDrillDown: () => set(state => {
                const { selectedItemPath, expandedIds } = state;
                const newExpandedIds = new Set(expandedIds);
                if (!newExpandedIds.has(selectedItemPath)) {
                    newExpandedIds.add(selectedItemPath);
                }
                return { expandedIds: newExpandedIds };
            }),
            collapseOrBubbleUp: () => set(state => {
                const { selectedItemPath, expandedIds } = state;
                const newExpandedIds = new Set(expandedIds);
                if (newExpandedIds.has(selectedItemPath)) {
                    // If it's expanded, collapse it
                    newExpandedIds.delete(selectedItemPath);
                    
                    // Also collapse children
                    for (const id of newExpandedIds) {
                        if (id.startsWith(`${selectedItemPath}/`)) {
                            newExpandedIds.delete(id);
                        }
                    }

                    return { expandedIds: newExpandedIds };
                } else if (selectedItemPath.includes('/')) {
                    // If it's a file, move selection to parent transaction
                    const parentId = selectedItemPath.split('/')[0];
                    return { selectedItemPath: parentId || '' };
                }
                return {};
            }),
            toggleSelection: () => set(state => {
                const { selectedItemPath, selectedForAction } = state;
                const txId = selectedItemPath.split('/')[0];
                if (!txId) return {};

                const newSelection = new Set(selectedForAction);
                if (newSelection.has(txId)) {
                    newSelection.delete(txId);
                } else {
                    newSelection.add(txId);
                }
                return { selectedForAction: newSelection };
            }),
            setMode: (mode) => set({ mode }),
            setFilterQuery: (query) => set({ filterQuery: query }),
            applyFilter: () => {
                // In a real app, this would filter `transactions`.
                // For the demo, we just go back to LIST mode.
                set({ mode: 'LIST' });
            },
            prepareDebugState: (stateName) => {
                switch (stateName) {
                    case 'l1-drill':
                        get().actions.load({ expandedIds: new Set(['3']), selectedItemPath: '3' });
                        break;
                    case 'l2-drill':
                        get().actions.load({ expandedIds: new Set(['3', '3-1']), selectedItemPath: '3-1' });
                        break;
                    case 'filter':
                        get().actions.load({ mode: 'FILTER', filterQuery: 'logger.ts status:committed' });
                        break;
                    case 'copy':
                        get().actions.load({
                            selectedForAction: new Set(['3', '6']),
                        });
                        break;
                    case 'bulk':
                        get().actions.load({ mode: 'BULK_ACTIONS', selectedForAction: new Set(['3', '6']) });
                        break;
                }
            },
        },
    }));
  src/stores/transaction.store.ts: >
    import { create } from 'zustand';

    import { TransactionService } from '../services/transaction.service';

    import type { Transaction, TransactionStatus } from
    '../types/transaction.types';


    export type { Transaction } from '../types/transaction.types';


    interface TransactionState {
        transactions: Transaction[];
        actions: {
            loadTransactions: () => void;
            updateTransactionStatus: (id: string, status: TransactionStatus) => void;
        };
    }


    export const useTransactionStore = create<TransactionState>((set, get) => ({
        transactions: [],
        actions: {
            loadTransactions: () => {
                const transactions = TransactionService.getAllTransactions();
                set({ transactions });
            },
            updateTransactionStatus: (id, status) => {
                set(state => ({
                    transactions: state.transactions.map(tx =>
                        tx.id === id ? { ...tx, status, timestamp: Date.now() } : tx,
                    ),
                }));
            },
        },
    }));
  src/types/app.types.ts: >-
    export type AppScreen = 'splash' | 'init' | 'dashboard' | 'review' |
    'review-processing' | 'git-commit' | 'transaction-detail' |
    'transaction-history';
  src/types/dashboard.types.ts: >-
    export type DashboardStatus = 'LISTENING' | 'PAUSED' | 'CONFIRM_APPROVE' |
    'APPROVING';
  src/types/file.types.ts: >-
    // Common interface for file-based items

    export interface BaseFileItem {
        id: string;
        path: string;
        diff: string;
        linesAdded: number;
        linesRemoved: number;
    }


    // From transaction-detail.store.ts and transaction-history.store.ts

    export type FileChangeType = 'MOD' | 'ADD' | 'DEL' | 'REN';

    export interface FileChange extends BaseFileItem {
        type: FileChangeType;
        strategy?: 'replace' | 'standard-diff';
    }


    // From review.store.ts

    export type FileReviewStatus = 'FAILED' | 'APPROVED' | 'REJECTED' |
    'AWAITING' | 'RE_APPLYING';

    export interface ReviewFileItem extends BaseFileItem {
        status: FileReviewStatus;
        error?: string;
        strategy: 'replace' | 'standard-diff';
    }
  src/types/init.types.ts: >-
    export type TaskStatus = 'pending' | 'active' | 'done';

    export type InitPhase = 'ANALYZE' | 'CONFIGURE' | 'INTERACTIVE' |
    'FINALIZE';

    export type GitignoreChoice = 'ignore' | 'share';


    export interface Task {
        id: string;
        title: string;
        subtext?: string;
        status: TaskStatus;
    }
  src/types/review.types.ts: >-
    export interface ScriptResult {
        command: string;
        success: boolean;
        duration: number;
        summary: string;
        output: string;
    }


    export interface ApplyStep {
        id: string;
        title: string;
        status: 'pending' | 'active' | 'done' | 'failed' | 'skipped';
        details?: string;
        substeps?: ApplyStep[];
        duration?: number;
    }


    export type ReviewBodyView = 'diff' | 'reasoning' | 'script_output' |
    'bulk_repair' | 'confirm_handoff' | 'none';

    export type PatchStatus = 'SUCCESS' | 'PARTIAL_FAILURE';


    export type ApplyUpdate =
        | { type: 'UPDATE_STEP'; payload: { id: string; status: ApplyStep['status']; duration?: number; details?: string } }
        | { type: 'ADD_SUBSTEP'; payload: { parentId: string; substep: Omit<ApplyStep, 'substeps'> } };
  src/types/transaction-detail.types.ts: >-
    export type NavigatorSection = 'PROMPT' | 'REASONING' | 'FILES';

    export type DetailBodyView = 'PROMPT' | 'REASONING' | 'FILES_LIST' |
    'DIFF_VIEW' | 'REVERT_CONFIRM' | 'NONE';
  src/types/transaction-history.types.ts: export type HistoryViewMode = 'LIST' | 'FILTER' | 'BULK_ACTIONS';
  src/types/transaction.types.ts: |-
    import type { FileChange } from './file.types';
    import type { ScriptResult } from './review.types';

    export type TransactionStatus =
        | 'PENDING'
        | 'APPLIED'
        | 'COMMITTED'
        | 'FAILED'
        | 'REVERTED'
        | 'IN-PROGRESS'
        | 'HANDOFF';

    export interface Transaction {
        id: string;
        timestamp: number;
        status: TransactionStatus;
        hash: string;
        message: string;
        prompt?: string;
        reasoning?: string;
        error?: string;
        // Fields for history/detail view
        files?: FileChange[];
        scripts?: ScriptResult[];
        stats?: {
            files: number;
            linesAdded: number;
            linesRemoved: number;
        };
    }
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 81
