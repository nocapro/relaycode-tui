uuid: c257008a-241f-4a0b-967f-44a30e84b3e5
projectId: relaycode-tui
createdAt: '2025-09-27T10:47:55.934Z'
gitCommitMsg: >-
  fix(ts): Resolve unused variable errors

  Addresses TypeScript compiler errors by prefixing unused variables with an
  underscore in `useSettingsScreen.tsx`, `ai.service.ts`, and `review.store.ts`
  to satisfy linter rules.
promptSummary: >-
  Fixing TypeScript errors related to unused variables after implementing the AI
  auto-fix feature.
reasoning:
  - >-
    Of course. It looks like the linter is catching some unused variables from
    the new implementation. Those are easy fixes. Here are the patches to
    resolve the TypeScript errors.
  - I'll address the unused `input` parameter in `useSettingsScreen.tsx`.
  - >-
    Next, I'll fix the unused `transaction` parameter in the mock
    `ai.service.ts`.
  - >-
    Finally, I'll resolve the unused `autoFixResult` in `review.store.ts`, as
    the mock implementation doesn't use the return value yet.
  - >-
    These changes should clear up all the TypeScript errors and allow the
    application to build successfully.
operations:
  - type: write
    path: src/hooks/useSettingsScreen.tsx
    content: |+
      --- src/hooks/useSettingsScreen.tsx
      +++ src/hooks/useSettingsScreen.tsx
      @@ -33,7 +33,7 @@
               showDashboardScreen();
           };
       
      -    useInput((input, key) => {
      +    useInput((_input, key) => {
               if (key.escape) {
                   saveAndExit();
                   return;

    patchStrategy: standard-diff
  - type: write
    path: src/services/ai.service.ts
    content: |+
      --- src/services/ai.service.ts
      +++ src/services/ai.service.ts
      @@ -5,7 +5,7 @@
       // Mock function to simulate running an auto-fix with an AI
       export async function* runAutoFix(
           failedFiles: FileItem[],
      -    transaction: Transaction,
      +    _transaction: Transaction,
       ): AsyncGenerator<any, { newPatch: string }, unknown> {
           const { model } = useSettingsStore.getState();
       

    patchStrategy: standard-diff
  - type: write
    path: src/stores/review.store.ts
    content: |+
      --- src/stores/review.store.ts
      +++ src/stores/review.store.ts
      @@ -254,12 +254,12 @@
                   showAiProcessingScreen();
       
                   const autoFixGenerator = AiService.runAutoFix(failedFiles, tx);
      -            let autoFixResult: { newPatch: string };
      +            let _autoFixResult: { newPatch: string };
       
                   const iterator = autoFixGenerator[Symbol.asyncIterator]();
                   while (true) {
                       const { value, done } = await iterator.next();
                       if (done) {
      -                    autoFixResult = value as { newPatch: string };
      +                    _autoFixResult = value as { newPatch: string };
                           break;
                       }
                       const update = value;

    patchStrategy: standard-diff
snapshot:
  src/hooks/useSettingsScreen.tsx: >-
    import { useState, useEffect } from 'react';

    import { useInput } from 'ink';

    import { useSettingsStore, type AiProvider } from
    '../stores/settings.store';

    import { useAppStore } from '../stores/app.store';

    import { AI_PROVIDERS } from '../constants/settings.constants';


    type SettingsField = 'provider' | 'apiKey' | 'model';


    export const useSettingsScreen = () => {
        const { provider, apiKey, model, actions: settingsActions } = useSettingsStore();
        const { showDashboardScreen } = useAppStore(s => s.actions);

        const [activeField, setActiveField] = useState<SettingsField>('provider');
        const [localProvider, setLocalProvider] = useState<AiProvider>(provider);
        const [localApiKey, setLocalApiKey] = useState<string>(apiKey);
        const [localModel, setLocalModel] = useState<string>(model);
        const [providerSelectionIndex, setProviderSelectionIndex] = useState(
            () => AI_PROVIDERS.findIndex(p => p.value === provider)
        );

        // Sync local state with global store when component mounts
        useEffect(() => {
            setLocalProvider(provider);
            setLocalApiKey(apiKey);
            setLocalModel(model);
            setProviderSelectionIndex(AI_PROVIDERS.findIndex(p => p.value === provider));
        }, [provider, apiKey, model]);

        const saveAndExit = () => {
            settingsActions.setProvider(localProvider);
            settingsActions.setApiKey(localApiKey);
            settingsActions.setModel(localModel);
            showDashboardScreen();
        };

        useInput((input, key) => {
            if (key.escape) {
                saveAndExit();
                return;
            }

            if (key.tab) {
                setActiveField(current => {
                    if (current === 'provider') return 'apiKey';
                    if (current === 'apiKey') return 'model';
                    return 'provider';
                });
                return;
            }

            if (activeField === 'provider') {
                if (key.upArrow) {
                    setProviderSelectionIndex(prev => (prev - 1 + AI_PROVIDERS.length) % AI_PROVIDERS.length);
                }
                if (key.downArrow) {
                    setProviderSelectionIndex(prev => (prev + 1) % AI_PROVIDERS.length);
                }
                if (key.return) {
                    const selectedProvider = AI_PROVIDERS[providerSelectionIndex];
                    if (selectedProvider) {
                        setLocalProvider(selectedProvider.value);
                    }
                    setActiveField('apiKey');
                }
            }
        }, { isActive: true });

        // Update localProvider whenever selection index changes
        useEffect(() => {
            const selectedProvider = AI_PROVIDERS[providerSelectionIndex];
            if (selectedProvider) {
                setLocalProvider(selectedProvider.value);
            }
        }, [providerSelectionIndex]);

        return {
            activeField,
            provider: localProvider,
            apiKey: localApiKey,
            model: localModel,
            setApiKey: setLocalApiKey,
            setModel: setLocalModel,
            providerSelectionIndex,
            isApiKeyFocused: activeField === 'apiKey',
            isModelFocused: activeField === 'model',
        };
    };
  src/stores/review.store.ts: >-
    import { create } from 'zustand';

    import { useAppStore } from './app.store';

    import { useTransactionStore } from './transaction.store';

    import { useViewStore } from './view.store';

    import { AiService } from '../services/ai.service';

    import { ReviewService, type SimulationResult } from
    '../services/review.service';

    import { INITIAL_APPLY_STEPS, PATCH_STATUS, REVIEW_BODY_VIEWS,
    BULK_INSTRUCT_OPTIONS, BULK_REPAIR_OPTIONS, INITIAL_AI_PROCESSING_STEPS }
    from '../constants/review.constants';

    import { sleep } from '../utils';

    import type { FileReviewStatus } from '../types/domain.types';


    export interface ApplyStep {
        id: string;
        title: string;
        status: 'pending' | 'active' | 'done' | 'failed' | 'skipped';
        details?: string;
        substeps?: ApplyStep[];
        startTime?: number;
        duration?: number;
    }


    export type ReviewBodyView = (typeof REVIEW_BODY_VIEWS)[keyof typeof
    REVIEW_BODY_VIEWS];

    export type PatchStatus = (typeof PATCH_STATUS)[keyof typeof PATCH_STATUS];

    export type ApplyUpdate =
        | { type: 'UPDATE_STEP'; payload: { id: string; status: ApplyStep['status']; duration?: number; details?: string } }
        | { type: 'ADD_SUBSTEP'; payload: { parentId: string; substep: Omit<ApplyStep, 'substeps'> } }
        | { type: 'UPDATE_SUBSTEP'; payload: { parentId: string; substepId: string; status: ApplyStep['status']; title?: string } };

    interface ReviewState {
        patchStatus: PatchStatus;
        applySteps: ApplyStep[];
        selectedItemIndex: number;
        bodyView: ReviewBodyView;
        scriptErrorIndex: number;
        processingStartTime: number | null;
        fileReviewStates: Map<string, { status: FileReviewStatus; error?: string; details?: string }>;

        selectedBulkRepairOptionIndex: number;
        selectedBulkInstructOptionIndex: number;
        isCancelling: boolean;
        isSkipping: boolean;

        // AI auto-repair state
        aiProcessingSteps: ApplyStep[];
        aiProcessingStartTime: number | null;

        actions: {
            load: (transactionId: string, initialState?: Partial<Pick<ReviewState, 'bodyView' | 'selectedBulkRepairOptionIndex'>>) => void;
            setSelectedItemIndex: (index: number) => void;
            toggleBodyView: (view: Extract<
                ReviewBodyView, 'prompt' | 'bulk_instruct' | 'commit_message' |
                'diff' | 'reasoning' | 'script_output' | 'bulk_repair' | 'confirm_handoff'
            >) => void;
            setBodyView: (view: ReviewBodyView) => void;
            approve: () => void;
            rejectTransaction: () => void;
            startApplySimulation: (transactionId: string, scenario: 'success' | 'failure') => void;
            tryRepairFile: (fileId: string) => void;
            showBulkRepair: () => void;
            executeBulkRepairOption: (option: number) => Promise<void>;
            skipCurrentStep: () => void;
            resetSkip: () => void;
            tryInstruct: (fileId: string) => void;
            cancelProcessing: () => void;
            startAiAutoFix: () => void;
            showBulkInstruct: () => void;
            executeBulkInstructOption: (option: number) => Promise<void>;
            confirmHandoff: () => void;
            navigateScriptErrorUp: () => void;
            navigateScriptErrorDown: () => void;
            updateApplyStep: (id: string, status: ApplyStep['status'], details?: string) => void;
            addApplySubstep: (parentId: string, substep: Omit<ApplyStep, 'substeps'>) => void;
            updateApplySubstep: (parentId: string, substepId: string, status: ApplyStep['status'], title?: string) => void;
            updateAiProcessingStep: (id: string, status: ApplyStep['status'], details?: string) => void;
            addAiProcessingSubstep: (parentId: string, substep: Omit<ApplyStep, 'substeps'>) => void;
            updateAiProcessingSubstep: (parentId: string, substepId: string, status: ApplyStep['status'], title?: string) => void;
            updateFileReviewStatus: (fileId: string, status: FileReviewStatus, error?: string, details?: string) => void;
            toggleFileApproval: (fileId: string) => void;
            rejectAllFiles: () => void;
            navigateBulkRepairUp: () => void;
            navigateBulkRepairDown: () => void;
            navigateBulkInstructUp: () => void;
            navigateBulkInstructDown: () => void;
        };
    }


    export const useReviewStore = create<ReviewState>((set, get) => ({
        patchStatus: PATCH_STATUS.SUCCESS,
        applySteps: INITIAL_APPLY_STEPS,
        selectedItemIndex: 0,
        bodyView: REVIEW_BODY_VIEWS.NONE,
        scriptErrorIndex: 0,
        processingStartTime: null,
        fileReviewStates: new Map(),
        selectedBulkRepairOptionIndex: 0,
        selectedBulkInstructOptionIndex: 0,
        isCancelling: false,
        isSkipping: false,
        aiProcessingSteps: [],
        aiProcessingStartTime: null,

        actions: {
            load: (transactionId, initialState) => {
                const transaction = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!transaction) return;

                // This logic is preserved from the deleted `prepareTransactionForReview`
                // to allow debug screens to jump directly to a pre-populated review state
                // without running the full simulation.
                const isFailureCase = transaction.id === '1';
                const fileReviewStates = new Map<string, { status: FileReviewStatus; error?: string }>();
                (transaction.files || []).forEach((file, index) => {
                    if (isFailureCase) {
                        const isFailedFile = index > 0;
                        const status = isFailedFile ? 'FAILED' : 'APPROVED';
                        const error = isFailedFile ? (index === 1 ? 'Hunk #1 failed to apply' : 'Context mismatch at line 92') : undefined;
                        fileReviewStates.set(file.id, { status, error });
                    } else {
                        fileReviewStates.set(file.id, { status: 'APPROVED' });
                    }
                });
                const patchStatus = isFailureCase ? 'PARTIAL_FAILURE' : 'SUCCESS';
                useViewStore.getState().actions.setSelectedTransactionId(transaction.id);
                set({
                    patchStatus,
                    fileReviewStates,
                    processingStartTime: null,
                    selectedItemIndex: 0,
                    bodyView: initialState?.bodyView ?? REVIEW_BODY_VIEWS.NONE,
                    scriptErrorIndex: 0,
                    applySteps: JSON.parse(JSON.stringify(INITIAL_APPLY_STEPS)),
                    selectedBulkRepairOptionIndex: 0,
                    selectedBulkInstructOptionIndex: 0,
                    ...initialState,
                });
            },
            setSelectedItemIndex: (index) => set({ selectedItemIndex: index }),
            toggleBodyView: (view) => set(state => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                const files = tx?.files || [];
                if (view === 'diff' && state.selectedItemIndex >= files.length) return {};
                return {
                    bodyView: state.bodyView === view ? REVIEW_BODY_VIEWS.NONE : view,
                };
            }),
            setBodyView: (view) => set({ bodyView: view }),
            approve: () => {
                const { selectedTransactionId } = useViewStore.getState();
                if (selectedTransactionId) {
                    useTransactionStore.getState().actions.updateTransactionStatus(selectedTransactionId, 'APPLIED');
                    useAppStore.getState().actions.showDashboardScreen();
                }
            },
            rejectTransaction: () => {
                const { selectedTransactionId } = useViewStore.getState();
                if (selectedTransactionId) {
                    useTransactionStore.getState().actions.updateTransactionStatus(selectedTransactionId, 'REJECTED');
                    useAppStore.getState().actions.showDashboardScreen();
                }
            },
            startApplySimulation: async (transactionId, scenario) => {
                const transaction = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!transaction?.files) return;

                const { showReviewProcessingScreen, showReviewScreen } = useAppStore.getState().actions;
                const { updateApplyStep, addApplySubstep, updateApplySubstep } = get().actions;

                useViewStore.getState().actions.setSelectedTransactionId(transaction.id);
                set({
                    applySteps: JSON.parse(JSON.stringify(INITIAL_APPLY_STEPS)),
                    processingStartTime: Date.now(),
                    isCancelling: false,
                    isSkipping: false,
                    fileReviewStates: new Map(), // Clear previous states
                });

                showReviewProcessingScreen();
                const simulationGenerator = ReviewService.runApplySimulation(transaction.files, scenario);
                let simulationResult: SimulationResult;

                // Manually iterate to get the return value from the async generator
                const iterator = simulationGenerator[Symbol.asyncIterator]();
                while (true) {
                    const { value, done } = await iterator.next();
                    if (done) {
                        simulationResult = value as SimulationResult;
                        break;
                    }
                    const update = value;
                    if (update.type === 'UPDATE_STEP') {
                        updateApplyStep(update.payload.id, update.payload.status, update.payload.details);
                    } else if (update.type === 'ADD_SUBSTEP') {
                        addApplySubstep(update.payload.parentId, update.payload.substep);
                    } else if (update.type === 'UPDATE_SUBSTEP') {
                        updateApplySubstep(update.payload.parentId, update.payload.substepId, update.payload.status, update.payload.title);
                    }
                }

                await sleep(1000);
                set({
                    processingStartTime: null,
                    fileReviewStates: simulationResult.fileReviewStates,
                    patchStatus: simulationResult.patchStatus,
                });
                showReviewScreen();
            },
            tryRepairFile: (fileId) => {
                const selectedTransactionId = useViewStore.getState().selectedTransactionId;
                const { fileReviewStates } = get();
                if (!selectedTransactionId) return;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                const file = tx?.files?.find(f => f.id === fileId);
                if (!file) return;

                const { status, error } = fileReviewStates.get(file.id) || {};
                if (status !== 'FAILED') return;
                
                ReviewService.tryRepairFile(file, error);
                get().actions.updateFileReviewStatus(file.id, 'AWAITING');
            },
            tryInstruct: (fileId) => {
                const selectedTransactionId = useViewStore.getState().selectedTransactionId;
                const { fileReviewStates } = get();
                if (!selectedTransactionId) return;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                const file = tx?.files?.find(f => f.id === fileId);
                if (!tx || !file) return;

                const { status } = fileReviewStates.get(file.id) || {};
                if (status !== 'REJECTED') return;
                
                ReviewService.tryInstructFile(file, tx);
                get().actions.updateFileReviewStatus(file.id, 'AWAITING', undefined, 'Instruction prompt copied!');
            },
            showBulkInstruct: () => get().actions.setBodyView('bulk_instruct'),
            cancelProcessing: () => set({ isCancelling: true }),
            startAiAutoFix: async () => {
                const { selectedTransactionId } = useViewStore.getState();
                const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                if (!tx || !tx.files) return;

                const failedFiles = tx.files.filter(f => get().fileReviewStates.get(f.id)?.status === 'FAILED');
                if (failedFiles.length === 0) return;

                const { showAiProcessingScreen, showReviewScreen } = useAppStore.getState().actions;
                const { updateAiProcessingStep, addAiProcessingSubstep, updateAiProcessingSubstep } = get().actions;

                set({
                    bodyView: REVIEW_BODY_VIEWS.NONE,
                    aiProcessingSteps: JSON.parse(JSON.stringify(INITIAL_AI_PROCESSING_STEPS)),
                    aiProcessingStartTime: Date.now(),
                });

                showAiProcessingScreen();

                const autoFixGenerator = AiService.runAutoFix(failedFiles, tx);
                let autoFixResult: { newPatch: string };

                const iterator = autoFixGenerator[Symbol.asyncIterator]();
                while (true) {
                    const { value, done } = await iterator.next();
                    if (done) {
                        autoFixResult = value as { newPatch: string };
                        break;
                    }
                    const update = value;
                    if (update.type === 'UPDATE_STEP') {
                        updateAiProcessingStep(update.payload.id, update.payload.status, update.payload.details);
                    } else if (update.type === 'ADD_SUBSTEP') {
                        addAiProcessingSubstep(update.payload.parentId, update.payload.substep);
                    } else if (update.type === 'UPDATE_SUBSTEP') {
                        updateAiProcessingSubstep(update.payload.parentId, update.payload.substepId, update.payload.status, update.payload.title);
                    }
                }

                await sleep(1500); // Give user time to see final state
                set({ aiProcessingStartTime: null });
                showReviewScreen();
            },
            skipCurrentStep: () => set({ isSkipping: true }),
            resetSkip: () => set({ isSkipping: false }),
            executeBulkInstructOption: async (option) => {
                const selectedTransactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                if (!tx?.files) return;

                const rejectedFiles = tx.files.filter(
                    f => get().fileReviewStates.get(f.id)?.status === 'REJECTED',
                );
                if (rejectedFiles.length === 0) {
                    set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                    return;
                }

                switch (option) {
                    case 1:
                        ReviewService.generateBulkInstructPrompt(rejectedFiles, tx);
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                        break;
                    case 2:
                        get().actions.setBodyView('confirm_handoff');
                        break;
                    case 3:
                        rejectedFiles.forEach(file => {
                            get().actions.updateFileReviewStatus(file.id, 'APPROVED');
                        });
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                        break;
                    case 5:
                        get().actions.startAiAutoFix();
                        break;
                    default:
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                }
            },

            showBulkRepair: () => get().actions.toggleBodyView('bulk_repair'),
            executeBulkRepairOption: async (option) => {
                const selectedTransactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                if (!tx?.files) return;

                const failedFiles = tx.files.filter(
                    f => get().fileReviewStates.get(f.id)?.status === 'FAILED',
                );
                if (failedFiles.length === 0) {
                    set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                    return;
                }

                switch (option) {
                    case 1:
                        ReviewService.generateBulkRepairPrompt(failedFiles);
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                        break;
                    case 2: {
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                        failedFiles.forEach(f => get().actions.updateFileReviewStatus(f.id, 'RE_APPLYING'));
                        const results = await ReviewService.runBulkReapply(failedFiles);
                        results.forEach(result => {
                            get().actions.updateFileReviewStatus(
                                result.id, result.status, result.error,
                            );
                        });
                        break;
                    }
                    case 3:
                        get().actions.setBodyView('confirm_handoff');
                        break;
                    case 4:
                        failedFiles.forEach(file => {
                            get().actions.updateFileReviewStatus(file.id, 'REJECTED');
                        });
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                        break;
                    default:
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                }
            },
            confirmHandoff: () => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!tx?.files) return;
                const { fileReviewStates } = get();
                ReviewService.generateHandoffPrompt(tx, fileReviewStates);
                ReviewService.performHandoff(tx.hash);
            },
            navigateScriptErrorUp: () => set(state => ({ scriptErrorIndex: Math.max(0, state.scriptErrorIndex - 1) })),
            navigateScriptErrorDown: () => set(state => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!tx?.scripts || !tx?.files) return {};
                const selectedScript = tx.scripts[state.selectedItemIndex - tx.files.length];
                if (selectedScript?.output) {
                    const errorLines = selectedScript.output
                        .split('\n')
                        .filter(line => line.includes('Error') || line.includes('Warning'));
                    return { scriptErrorIndex: Math.min(errorLines.length - 1, state.scriptErrorIndex + 1) };
                }
                return {};
            }),
            updateApplyStep: (id, status, details) => {
                set(state => {
                    const newSteps = state.applySteps.map(s => {
                        if (s.id === id) {
                            const newStep: ApplyStep = { ...s, status };
                            if (status === 'active') {
                                newStep.startTime = Date.now();
                            } else if ((status === 'done' || status === 'failed' || status === 'skipped') && s.startTime) {
                                newStep.duration = (Date.now() - s.startTime) / 1000;
                            }
                            if (details !== undefined) newStep.details = details;
                            return newStep;
                        }
                        return s;
                    });
                    return { applySteps: newSteps };
                });
            },
            updateApplySubstep: (parentId, substepId, status, title) => {
                set(state => ({
                    applySteps: state.applySteps.map(s => {
                        if (s.id === parentId && s.substeps) {
                            const newSubsteps = s.substeps.map(sub => {
                                if (sub.id === substepId) {
                                    const newSub: ApplyStep = { ...sub, status };
                                    if (status === 'active') {
                                        newSub.startTime = Date.now();
                                    } else if ((status === 'done' || status === 'failed') && sub.startTime) {
                                        newSub.duration = (Date.now() - sub.startTime) / 1000;
                                    }
                                    if (title) newSub.title = title;
                                    return newSub;
                                }
                                return sub;
                            });
                            return { ...s, substeps: newSubsteps };
                        }
                        return s;
                    }),
                }));
            },
            addApplySubstep: (parentId, substep) => {
                set(state => ({
                    applySteps: state.applySteps.map(s => {
                        if (s.id === parentId) {
                            const newSubsteps = [...(s.substeps || []), substep as ApplyStep];
                            return { ...s, substeps: newSubsteps };
                        }
                        return s;
                    }),
                }));
            },
            updateAiProcessingStep: (id, status, details) => {
                set(state => {
                    const newSteps = state.aiProcessingSteps.map(s => {
                        if (s.id === id) {
                            const newStep: ApplyStep = { ...s, status };
                            if (status === 'active') {
                                newStep.startTime = Date.now();
                            } else if ((status === 'done' || status === 'failed' || status === 'skipped') && s.startTime) {
                                newStep.duration = (Date.now() - s.startTime) / 1000;
                            }
                            if (details !== undefined) newStep.details = details;
                            return newStep;
                        }
                        return s;
                    });
                    return { aiProcessingSteps: newSteps };
                });
            },
            updateAiProcessingSubstep: (parentId, substepId, status, title) => {
                set(state => ({
                    aiProcessingSteps: state.aiProcessingSteps.map(s => {
                        if (s.id === parentId && s.substeps) {
                            const newSubsteps = s.substeps.map(sub => {
                                if (sub.id === substepId) {
                                    const newSub: ApplyStep = { ...sub, status };
                                    if (status === 'active') {
                                        newSub.startTime = Date.now();
                                    } else if ((status === 'done' || status === 'failed') && sub.startTime) {
                                        newSub.duration = (Date.now() - sub.startTime) / 1000;
                                    }
                                    if (title) newSub.title = title;
                                    return newSub;
                                }
                                return sub;
                            });
                            return { ...s, substeps: newSubsteps };
                        }
                        return s;
                    }),
                }));
            },
            addAiProcessingSubstep: (parentId, substep) => {
                set(state => ({
                    aiProcessingSteps: state.aiProcessingSteps.map(s => {
                        if (s.id === parentId) {
                            const newSubsteps = [...(s.substeps || []), substep as ApplyStep];
                            return { ...s, substeps: newSubsteps };
                        }
                        return s;
                    }),
                }));
            },
            updateFileReviewStatus: (fileId, status, error, details) => {
                set(state => {
                    const newStates = new Map(state.fileReviewStates);
                    newStates.set(fileId, { status, error, details });
                    return { fileReviewStates: newStates };
                });
            },
            toggleFileApproval: (fileId) => {
                set(state => {
                    const newStates = new Map(state.fileReviewStates);
                    const current = newStates.get(fileId);
                    if (current) {
                        const newStatus: FileReviewStatus = current.status === 'APPROVED' ? 'REJECTED' : 'APPROVED';
                        newStates.set(fileId, { status: newStatus, error: undefined, details: undefined });
                    }
                    return { fileReviewStates: newStates };
                });
            },
            rejectAllFiles: () => {
                set(state => {
                    const newStates = new Map(state.fileReviewStates);
                    for (const [fileId, reviewState] of newStates.entries()) {
                        if (reviewState.status === 'APPROVED') {
                            newStates.set(fileId, { status: 'REJECTED', error: undefined, details: undefined });
                        }
                    }
                    return { fileReviewStates: newStates };
                });
            },
            navigateBulkRepairUp: () => set(state => ({
                selectedBulkRepairOptionIndex: (state.selectedBulkRepairOptionIndex - 1 + BULK_REPAIR_OPTIONS.length) % BULK_REPAIR_OPTIONS.length,
            })),
            navigateBulkRepairDown: () => set(state => ({
                selectedBulkRepairOptionIndex: (state.selectedBulkRepairOptionIndex + 1) % BULK_REPAIR_OPTIONS.length,
            })),
            navigateBulkInstructUp: () => set(state => ({
                selectedBulkInstructOptionIndex: (state.selectedBulkInstructOptionIndex - 1 + BULK_INSTRUCT_OPTIONS.length) % BULK_INSTRUCT_OPTIONS.length,
            })),
            navigateBulkInstructDown: () => set(state => ({
                selectedBulkInstructOptionIndex: (state.selectedBulkInstructOptionIndex + 1) % BULK_INSTRUCT_OPTIONS.length,
            })),
        },
    }));
  src/services/ai.service.ts: |-
    import { useSettingsStore } from '../stores/settings.store';
    import { sleep } from '../utils';
    import type { Transaction, FileItem } from '../types/domain.types';

    // Mock function to simulate running an auto-fix with an AI
    export async function* runAutoFix(
        failedFiles: FileItem[],
        transaction: Transaction,
    ): AsyncGenerator<any, { newPatch: string }, unknown> {
        const { model } = useSettingsStore.getState();

        yield { type: 'UPDATE_STEP', payload: { id: 'prompt', status: 'active' } };
        await sleep(200);
        // In a real app, you would generate a detailed prompt here.
        yield { type: 'UPDATE_STEP', payload: { id: 'prompt', status: 'done', details: `Generated prompts for ${failedFiles.length} files.` } };

        yield { type: 'UPDATE_STEP', payload: { id: 'request', status: 'active' } };
        yield { type: 'ADD_SUBSTEP', payload: { parentId: 'request', substep: { id: failedFiles[0]!.id, title: `Fixing: ${failedFiles[0]!.path}`, status: 'active' }}};
        await sleep(1500); // Simulate network latency
        yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'request', substepId: failedFiles[0]!.id, status: 'done' }};
        if (failedFiles.length > 1) {
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'request', substep: { id: failedFiles[1]!.id, title: `Fixing: ${failedFiles[1]!.path}`, status: 'active' }}};
            await sleep(1200);
            yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'request', substepId: failedFiles[1]!.id, status: 'done' }};
        }
        yield { type: 'UPDATE_STEP', payload: { id: 'request', status: 'done', details: `Received responses from '${model}'` } };
        
        yield { type: 'UPDATE_STEP', payload: { id: 'patch', status: 'active' } };
        await sleep(500);
        // In a real app, this would be the actual patch from the AI.
        const newPatch = `--- a/src/services/payment.gateway.ts
    +++ b/src/services/payment.gateway.ts
    @@ -10,7 +10,7 @@
      */
     export class PaymentGateway {
     -    private static instance: PaymentGateway;
    +    private static instance: PaymentGateway | null = null;
         private apiKey: string;
     
         private constructor(apiKey: string) {
    `;
        yield { type: 'UPDATE_STEP', payload: { id: 'patch', status: 'done', details: 'Validated and formatted new patch.' } };

        await sleep(500);

        return { newPatch };
    }

    export const AiService = {
        runAutoFix,
    };
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 232
