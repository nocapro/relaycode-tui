uuid: c822dd9e-c80f-488b-a430-81f13887d297
projectId: relaycode-tui
createdAt: '2025-09-22T15:11:07.365Z'
gitCommitMsg: >-
  refactor: Centralize transaction state and make features data-driven

  This major refactor establishes a single source of truth for all transaction
  data by introducing a central `transaction.store.ts`. All other features and
  stores (Dashboard, Commit, Detail, History, Review) have been modified to
  consume data from this central store rather than maintaining their own
  separate, redundant state.

  Key changes include: - Created `transaction.store.ts` to manage the global
  transaction list. - Decoupled UI state stores (e.g., `dashboard.store.ts`)
  from data management. - Made the Review screen fully data-driven, loading its
  state from a selected transaction instead of using hardcoded mocks. -
  Consolidated all "copy to clipboard" logic into a single, generic
  `CopyService.open()` method, removing significant code duplication across
  multiple hooks and the debug menu. - Updated services to interact with the new
  central store, ensuring consistent state updates across the application. -
  Refactored the debug menu and CLI entry points to correctly initialize and use
  the new centralized state architecture.
promptSummary: >-
  The user requested a radical refactor to eliminate redundancy (DRYness) and
  centralize state management to improve data integrity.
reasoning:
  - >-
    Here is the step-by-step implementation of the DRYness and state
    centralization refactor.
  - '### 1. Establish Single Source of Truth'
  - >-
    First, I'll create a new central store for all transaction data. This will
    become the single source of truth.
  - >-
    Next, I'll update the mock data to better support the new data-driven review
    screen. I'll remove the redundant `mockReviewFiles` and
    `mockReviewReasoning`, and make the first two transactions the `PENDING`
    ones for the failure and success scenarios, respectively.
  - >-
    Now, I'll refactor the Dashboard store and related files to use this central
    store.
  - '### 2. Refactor Dependent Stores and Services'
  - >-
    Now, I'll update other stores and services that were dependent on the old
    `dashboard.store.ts` to use `transaction.store.ts`.
  - '### 3. Make Review Screen Data-Driven'
  - >-
    This is a key part of the refactor. I'll connect the review screen to the
    central transaction store.
  - '### 4. Consolidate Copy Logic'
  - >-
    This is a major DRYness improvement, centralizing all copy-related logic
    into a single service method.
  - '### 5. Final Integration and Cleanup'
  - >-
    Finally, I'll update the main entry point to correctly initialize the state
    for debug mode and add `scripts` to the `Transaction` type.
  - >-
    I have completed all the planned refactoring steps. The application now has
    a centralized state for transactions, data-driven screens, and consolidated
    service logic, significantly improving its architecture and maintainability.
operations:
  - type: write
    path: src/stores/transaction.store.ts
    content: >-
      import { create } from 'zustand';

      import { TransactionService } from '../services/transaction.service';

      import type { Transaction, TransactionStatus } from
      '../types/transaction.types';


      interface TransactionState {
          transactions: Transaction[];
          actions: {
              loadTransactions: () => void;
              updateTransactionStatus: (id: string, status: TransactionStatus) => void;
          };
      }


      export const useTransactionStore = create<TransactionState>((set, get) =>
      ({
          transactions: [],
          actions: {
              loadTransactions: () => {
                  const transactions = TransactionService.getAllTransactions();
                  set({ transactions });
              },
              updateTransactionStatus: (id, status) => {
                  set(state => ({
                      transactions: state.transactions.map(tx =>
                          tx.id === id ? { ...tx, status, timestamp: Date.now() } : tx
                      ),
                  }));
              },
          },
      }));


      // Initialize the store with data on load.

      useTransactionStore.getState().actions.loadTransactions();
    patchStrategy: replace
  - type: write
    path: src/data/mocks.ts
    content: >
      --- src/data/mocks.ts

      +++ src/data/mocks.ts

      @@ ... @@
       2. Wrapped the file restoration loop in a \`Promise.all\` and added a dedicated
          error collection array. This ensures that all file operations are
          attempted and that a comprehensive list of failures is available
      -   afterward for better error reporting or partial rollback logic.`;

      -

      -const mockReasoning2 = `1. The primary goal was to make the rollback
      functionality in \`restoreSnapshot\` more robust. The previous
      implementation used a simple for-loop which would halt on the first error,
      leaving the project in a partially restored state.

      -

      -2. I opted for a \`Promise.all\` approach to run file restorations in
      parallel. This improves performance slightly but, more importantly,
      ensures all restoration attempts are completed, even if some fail.

      -

      -3. An \`restoreErrors\` array was introduced to collect any exceptions
      that occur during the process. If this array is not empty after the
      \`Promise.all\` completes, a comprehensive error is thrown, informing the
      user exactly which files failed to restore. This provides much better
      diagnostics.`;

      +   afterward for better error reporting or partial rollback logic.

      +`;
       
       export const allMockTransactions: Transaction[] = [
           {
               id: '1',
      -        timestamp: Date.now() - 15 * 1000,

      +        timestamp: Date.now() - 10 * 1000,
               status: 'PENDING',
               hash: 'e4a7c112',
               message: 'fix: add missing error handling',
               prompt: 'Rename the `calculateChanges` utility to `computeDelta` across all files and update imports accordingly.',
               reasoning: mockReasoning1,
               files: [
      -            { id: '1-1', path: 'src/core/transaction.ts', type: 'MOD',
      linesAdded: 18, linesRemoved: 5, diff: '... diff ...' },

      +            { id: '1-1', path: 'src/core/transaction.ts', type: 'MOD',
      linesAdded: 18, linesRemoved: 5, diff: `--- a/src/core/transaction.ts\n+++
      b/src/core/transaction.ts\n@@ -15,7 +15,7 @@ export class Transaction
      {\n   }\n \n-  calculateChanges(): ChangeSet {\n+  computeDelta():
      ChangeSet {\n     return this.changes;\n   }\n }`, strategy: 'replace' },

      +            { id: '1-2', path: 'src/utils/logger.ts', type: 'MOD',
      linesAdded: 0, linesRemoved: 0, diff: '', strategy: 'standard-diff' },

      +            { id: '1-3', path: 'src/commands/apply.ts', type: 'MOD',
      linesAdded: 0, linesRemoved: 0, diff: '', strategy: 'standard-diff' },
               ],
      -        stats: { files: 1, linesAdded: 18, linesRemoved: 5 },

      +        stats: { files: 3, linesAdded: 18, linesRemoved: 5 },
           },
           {
               id: '2',
      -        timestamp: Date.now() - 2 * 60 * 1000,

      -        status: 'APPLIED',

      +        timestamp: Date.now() - 15 * 1000,

      +        status: 'PENDING',
               hash: '4b9d8f03',
               message: 'refactor: simplify clipboard logic',
               prompt: 'Simplify the clipboard logic using an external library...',
               reasoning: 'The existing clipboard logic was complex and platform-dependent. Using the `clipboardy` library simplifies the code and improves reliability across different operating systems.',
               files: [
      -            { id: '2-1', path: 'src/core/clipboard.ts', type: 'MOD',
      linesAdded: 15, linesRemoved: 8, diff: '... diff ...' },

      -            { id: '2-2', path: 'src/utils/shell.ts', type: 'MOD',
      linesAdded: 7, linesRemoved: 3, diff: '... diff ...' },

      +            { id: '2-1', path: 'src/core/clipboard.ts', type: 'MOD',
      linesAdded: 15, linesRemoved: 8, diff: `--- a/src/core/clipboard.ts\n+++
      b/src/core/clipboard.ts\n@@ -1,5 +1,6 @@\n import { copy as
      copyToClipboard } from 'clipboardy';`, strategy: 'replace' },

      +            { id: '2-2', path: 'src/utils/shell.ts', type: 'MOD',
      linesAdded: 7, linesRemoved: 3, diff: `--- a/src/utils/shell.ts\n+++
      b/src/utils/shell.ts`, strategy: 'standard-diff' },
               ],
               stats: { files: 2, linesAdded: 22, linesRemoved: 11 },
      +        scripts: [

      +            { command: 'bun run test', success: true, duration: 2.3,
      summary: 'Passed (37 tests)', output: '... test output ...' },

      +            { command: 'bun run lint', success: false, duration: 1.2,
      summary: '1 Error, 3 Warnings', output: `src/core/clipboard.ts\n  45:12 
      Error    'clipboardy' is assigned a value but never used.
      (@typescript-eslint/no-unused-vars)\n  88:5   Warning  Unexpected console
      statement. (no-console)` },

      +        ],
           },
           {
               id: '3',
               timestamp: Date.now() - 5 * 60 * 1000,
      -        status: 'COMMITTED',

      +        status: 'APPLIED',
               hash: '8a3f21b8',
               message: 'feat: implement new dashboard UI',
               prompt: 'The user requested to add more robust error handling to the `restoreSnapshot` function. Specifically, it should not halt on the first error but instead attempt all file restorations and then report a summary of any failures.',
      -        reasoning: mockReasoning2,

      +        reasoning: mockReasoning1,
               files: [
                   { id: '3-1', path: 'src/core/transaction.ts', type: 'MOD', linesAdded: 18, linesRemoved: 5, diff: '... diff ...' },
                   { id: '3-2', path: 'src/utils/logger.ts', type: 'MOD', linesAdded: 7, linesRemoved: 3, diff: '... diff ...' },
      @@ ... @@
       export const createMockTransactions = (): Transaction[] => {
           return JSON.parse(JSON.stringify(allMockTransactions));
       };
      -

      -

      -// From review.store.ts

      -export const mockReviewFiles: ReviewFileItem[] = [

      -    {

      -        id: '1',

      -        path: 'src/core/transaction.ts',

      -        status: 'APPROVED',

      -        linesAdded: 18,

      -        linesRemoved: 5,

      -        diff: `--- a/src/core/transaction.ts

      -+++ b/src/core/transaction.ts

      -@@ -15,7 +15,7 @@ export class Transaction {

      -   }

      -

      --  calculateChanges(): ChangeSet {

      -+  computeDelta(): ChangeSet {

      -     return this.changes;

      -   }

      - }`,

      -        strategy: 'replace',

      -    },

      -    {

      -        id: '2',

      -        path: 'src/utils/logger.ts',

      -        status: 'FAILED',

      -        linesAdded: 0,

      -        linesRemoved: 0,

      -        diff: '',

      -        error: 'Hunk #1 failed to apply',

      -        strategy: 'standard-diff',

      -    },

      -    {

      -        id: '3',

      -        path: 'src/commands/apply.ts',

      -        status: 'FAILED',

      -        linesAdded: 0,

      -        linesRemoved: 0,

      -        diff: '',

      -        error: 'Context mismatch at line 92',

      -        strategy: 'standard-diff',

      -    },

      -];

      -

      -export const mockReviewScripts: ScriptResult[] = [

      -    { command: 'bun run test', success: true, duration: 2.3, summary:
      'Passed (37 tests)', output: '... test output ...' },

      -    { command: 'bun run lint', success: false, duration: 1.2, summary: '1
      Error, 3 Warnings', output: `src/core/clipboard.ts

      -  45:12  Error    'clipboardy' is assigned a value but never used.
      (@typescript-eslint/no-unused-vars)

      -  88:5   Warning  Unexpected console statement. (no-console)` },

      -];

      -

      -export const mockReviewReasoning = `1. Identified a potential uncaught
      exception in the \`restoreSnapshot\` function

      -   if a file operation fails midway through a loop of many files. This
      could

      -   leave the project in a partially-reverted, inconsistent state.

      -

      -2. Wrapped the file restoration loop in a \`Promise.all\` and added a
      dedicated

      -   error collection array. This ensures that all file operations are

      -   attempted and that a comprehensive list of failures is available

      -   afterward for better error reporting or partial rollback logic.`;
    patchStrategy: standard-diff
  - type: write
    path: src/stores/dashboard.store.ts
    content: >
      --- src/stores/dashboard.store.ts

      +++ src/stores/dashboard.store.ts

      @@ -1,7 +1,6 @@
       import { create } from 'zustand';
       import { DashboardService } from '../services/dashboard.service';
      -import { TransactionService } from '../services/transaction.service';

      -import type { Transaction, TransactionStatus } from
      '../types/transaction.types';

      +import { useTransactionStore, type Transaction } from
      './transaction.store';
       import type { DashboardStatus } from '../types/dashboard.types';
       import { moveIndex } from './navigation.utils';
       
      @@ -12,7 +11,6 @@
       interface DashboardState {
           status: DashboardStatus;
           previousStatus: DashboardStatus; // To handle cancel from confirmation
      -    transactions: Transaction[];
           selectedTransactionIndex: number;
           showHelp: boolean;
           actions: {
      @@ -23,8 +21,6 @@
               cancelAction: () => void;
               toggleHelp: () => void;
               setStatus: (status: DashboardStatus) => void; // For debug menu
      -        updateTransactionStatus: (id: string, status: TransactionStatus)
      => void;
           };
       }
       
      @@ ... @@
       export const useDashboardStore = create<DashboardState>((set, get) => ({
           status: 'LISTENING',
           previousStatus: 'LISTENING',
      -    transactions: TransactionService.getAllTransactions(),
           selectedTransactionIndex: 0,
           showHelp: false,
           actions: {
      @@ ... @@
               togglePause: () => set(state => ({
                   status: state.status === 'LISTENING' ? 'PAUSED' : 'LISTENING',
               })),
      -        moveSelectionUp: () => set(state => ({

      -            selectedTransactionIndex:
      moveIndex(state.selectedTransactionIndex, 'up',
      state.transactions.length),

      -        })),

      -        moveSelectionDown: () => set(state => ({

      -            selectedTransactionIndex:
      moveIndex(state.selectedTransactionIndex, 'down',
      state.transactions.length),

      -        })),

      +        moveSelectionUp: () => set(state => {

      +            const { transactions } = useTransactionStore.getState();

      +            return { selectedTransactionIndex:
      moveIndex(state.selectedTransactionIndex, 'up', transactions.length) };

      +        }),

      +        moveSelectionDown: () => set(state => {

      +            const { transactions } = useTransactionStore.getState();

      +            return { selectedTransactionIndex:
      moveIndex(state.selectedTransactionIndex, 'down', transactions.length) };

      +        }),
               startApproveAll: () => set(state => ({
                   status: 'CONFIRM_APPROVE',
                   previousStatus: state.status,
      @@ ... @@
               cancelAction: () => set(state => ({ status: state.previousStatus })),
               toggleHelp: () => set(state => ({ showHelp: !state.showHelp })),
               setStatus: (status) => set({ status }),
      -        updateTransactionStatus: (id, status) => {

      -            set(state => ({

      -                transactions: state.transactions.map(tx =>

      -                    tx.id === id ? { ...tx, status, timestamp: Date.now()
      } : tx,

      -                ),

      -            }));

      -            // After updating, move selection to the updated transaction

      -            const index = get().transactions.findIndex(tx => tx.id ===
      id);

      -            if (index !== -1) set({ selectedTransactionIndex: index });

      -        },
       
               confirmAction: async () => {
                   const { status, previousStatus } = get();
    patchStrategy: standard-diff
  - type: write
    path: src/services/dashboard.service.ts
    content: >
      --- src/services/dashboard.service.ts

      +++ src/services/dashboard.service.ts

      @@ ... @@
       import { useDashboardStore } from '../stores/dashboard.store';
       import { sleep } from '../utils';
      +import { useTransactionStore } from '../stores/transaction.store';
       
       const approveAll = async () => {
           // Find pending transactions and mark them as in-progress
           const pendingTxIds: string[] = [];
      -    useDashboardStore.setState(state => {

      -        const newTxs = state.transactions.map(tx => {

      -            if (tx.status === 'PENDING') {

      -                pendingTxIds.push(tx.id);

      -                return { ...tx, status: 'IN-PROGRESS' as const };

      -            }

      -            return tx;

      -        });

      -        return { transactions: newTxs };

      +    const { updateTransactionStatus } =
      useTransactionStore.getState().actions;

      +    useTransactionStore.getState().transactions.forEach(tx => {

      +        if (tx.status === 'PENDING') {

      +            pendingTxIds.push(tx.id);

      +            updateTransactionStatus(tx.id, 'IN-PROGRESS');

      +        }
           });
       
           await sleep(2000); // Simulate approval process
       
           // Mark them as applied
      -    useDashboardStore.setState(state => {

      -        const newTxs = state.transactions.map(tx => {

      -            if (pendingTxIds.includes(tx.id)) {

      -                return { ...tx, status: 'APPLIED' as const };

      -            }

      -            return tx;

      -        });

      -        return { transactions: newTxs };

      -    });

      +    pendingTxIds.forEach(id => updateTransactionStatus(id, 'APPLIED'));
       };
       
       export const DashboardService = {
    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useDashboardScreen.tsx
    content: >
      --- src/hooks/useDashboardScreen.tsx

      +++ src/hooks/useDashboardScreen.tsx

      @@ ... @@
       import { useDashboardStore } from '../stores/dashboard.store';
       import { useAppStore } from '../stores/app.store';
       import { useCommitStore } from '../stores/commit.store';
      +import { useTransactionStore } from '../stores/transaction.store';
       import { useTransactionDetailStore } from '../stores/transaction-detail.store';
       import { useTransactionHistoryStore } from '../stores/transaction-history.store';
       import { useStdoutDimensions } from '../utils';
      +import { ReviewService } from '../services/review.service';
       
       export const useDashboardScreen = () => {
           const [, rows] = useStdoutDimensions();
           const [viewOffset, setViewOffset] = useState(0);
           const NON_EVENT_STREAM_HEIGHT = 9; // Header, separators, status, footer, etc.
           const viewportHeight = Math.max(1, rows - NON_EVENT_STREAM_HEIGHT);
      -    const { status, transactions, selectedTransactionIndex, showHelp } =
      useDashboardStore();

      +    const { status, selectedTransactionIndex, showHelp } =
      useDashboardStore();

      +    const transactions = useTransactionStore(s => s.transactions);
           const {
               togglePause,
               moveSelectionUp,
      @@ ... @@
           const detailActions = useTransactionDetailStore(s => s.actions);
           const historyActions = useTransactionHistoryStore(s => s.actions);
       
      -    const pendingApprovals = useMemo(() => transactions.filter(t =>
      t.status === 'PENDING').length, [transactions]);

      -    const pendingCommits = useMemo(() => transactions.filter(t =>
      t.status === 'APPLIED').length, [transactions]);

      +    const pendingApprovals = useMemo(() => transactions.filter(t =>
      t.status === 'PENDING').length, [transactions]); 

      +    const pendingCommits = useMemo(() => transactions.filter(t =>
      t.status === 'APPLIED').length, [transactions]); 
       
           const isModal = status === 'CONFIRM_APPROVE';
           const isProcessing = status === 'APPROVING';
      @@ ... @@
               if (key.downArrow) moveSelectionDown();
               
               if (key.return) {
      -            const selectedTx = transactions[selectedTransactionIndex];

      +            const selectedTx = transactions[selectedTransactionIndex]; 
                   if (selectedTx?.status === 'PENDING') {
                       // For PENDING transactions, we still go to the review screen.
      +                ReviewService.loadTransactionForReview(selectedTx.id);
                       appActions.showReviewScreen();
                   } else if (selectedTx) {
                       detailActions.loadTransaction(selectedTx.id);
    patchStrategy: standard-diff
  - type: write
    path: src/stores/commit.store.ts
    content: |
      --- src/stores/commit.store.ts
      +++ src/stores/commit.store.ts
      @@ ... @@
       import { create } from 'zustand';
      -import { useDashboardStore } from './dashboard.store';
       import type { Transaction } from '../types/transaction.types';
       import { CommitService } from '../services/commit.service';
      +import { useTransactionStore } from './transaction.store';
       
       interface CommitState {
           transactionsToCommit: Transaction[];
      @@ ... @@
           isCommitting: false,
           actions: {
               prepareCommitScreen: () => {
      -            const { transactions } = useDashboardStore.getState();
      +            const { transactions } = useTransactionStore.getState();
                   const appliedTransactions = transactions.filter(tx => tx.status === 'APPLIED');
                   
                   const finalCommitMessage = CommitService.generateCommitMessage(appliedTransactions);
    patchStrategy: standard-diff
  - type: write
    path: src/services/commit.service.ts
    content: >
      --- src/services/commit.service.ts

      +++ src/services/commit.service.ts

      @@ ... @@

      -import { useDashboardStore } from '../stores/dashboard.store';
       import type { Transaction } from '../types/transaction.types';
       import { sleep } from '../utils';
      +import { useTransactionStore } from '../stores/transaction.store';
       
       const generateCommitMessage = (transactions: Transaction[]): string => {
           if (transactions.length === 0) {
      @@ ... @@
       const commit = async (transactionsToCommit: Transaction[]): Promise<void> => {
           // In a real app, this would run git commands.
           // For simulation, we'll just update the dashboard store.
      -    const { updateTransactionStatus } =
      useDashboardStore.getState().actions;

      +    const { updateTransactionStatus } =
      useTransactionStore.getState().actions;
       
           const txIds = transactionsToCommit.map(tx => tx.id);
           
    patchStrategy: standard-diff
  - type: write
    path: src/stores/transaction-detail.store.ts
    content: >
      --- src/stores/transaction-detail.store.ts

      +++ src/stores/transaction-detail.store.ts

      @@ ... @@

      -import { useDashboardStore } from './dashboard.store';
       import { TransactionService } from '../services/transaction.service';
      -import type { Transaction } from '../types/transaction.types';

      -import type { FileChange as FileDetail } from '../types/file.types';

      +import { useTransactionStore } from './transaction.store';
       export type { FileChangeType } from '../types/file.types';
       import type { NavigatorSection, DetailBodyView } from '../types/transaction-detail.types';
       
       interface TransactionDetailState {
           // Data
      -    transaction: Transaction | null;

      -    files: FileDetail[];

      +    transactionId: string | null;
       
           // UI State
           navigatorFocus: NavigatorSection | 'FILES_LIST';
      @@ ... @@
       
       const navigatorOrder: NavigatorSection[] = ['PROMPT', 'REASONING', 'FILES'];
       
       export const useTransactionDetailStore = create<TransactionDetailState>((set, get) => ({
      -    transaction: null,

      -    files: [],

      +    transactionId: null,
       
           navigatorFocus: 'PROMPT',
           expandedSection: null,
      @@ ... @@
           bodyView: 'NONE',
       
           actions: {
      -        loadTransaction: (transactionId) => {

      -            const { transactions } = useDashboardStore.getState();

      -            const transaction = transactions.find(tx => tx.id ===
      transactionId);

      -            if (transaction) {

      -                set({

      -                    transaction,

      -                    files: transaction.files || [],

      -                    // Reset UI state

      -                    navigatorFocus: 'PROMPT',

      -                    expandedSection: null,

      -                    selectedFileIndex: 0,

      -                    bodyView: 'NONE',

      -                });

      -            }

      +        loadTransaction: (transactionId) => set({

      +            transactionId,

      +            // Reset UI state

      +            navigatorFocus: 'PROMPT',

      +            expandedSection: null,

      +            selectedFileIndex: 0,

      +            bodyView: 'NONE',

      +        }),

      +        navigateUp: () => {

      +            const { navigatorFocus, selectedFileIndex } = get();

      +            if (navigatorFocus === 'FILES_LIST') {

      +                set({ selectedFileIndex: Math.max(0, selectedFileIndex -
      1) });

      +            } else {

      +                const currentIndex =
      navigatorOrder.indexOf(navigatorFocus as NavigatorSection);

      +                if (currentIndex > 0) {

      +                    set({ navigatorFocus: navigatorOrder[currentIndex -
      1]! });

      +                }

      +            }
               },
      -        navigateUp: () => {

      -            const { navigatorFocus, selectedFileIndex } = get();

      -            if (navigatorFocus === 'FILES_LIST') {

      -                set({ selectedFileIndex: Math.max(0, selectedFileIndex -
      1) });

      -            } else {

      -                const currentIndex =
      navigatorOrder.indexOf(navigatorFocus as NavigatorSection);

      -                if (currentIndex > 0) {

      -                    set({ navigatorFocus: navigatorOrder[currentIndex -
      1] });

      -                }

      -            }

      -        },
               navigateDown: () => {
      -            const { navigatorFocus, selectedFileIndex, files } = get();

      +            const { navigatorFocus, selectedFileIndex } = get();

      +            const transaction =
      useTransactionStore.getState().transactions.find(tx => tx.id ===
      get().transactionId);

      +            const files = transaction?.files || [];

      +
                   if (navigatorFocus === 'FILES_LIST') {
                       set({ selectedFileIndex: Math.min(files.length - 1, selectedFileIndex + 1) });
                   } else {
                       const currentIndex = navigatorOrder.indexOf(navigatorFocus as NavigatorSection);
                       if (currentIndex < navigatorOrder.length - 1) {
      -                    set({ navigatorFocus: navigatorOrder[currentIndex +
      1] });

      +                    set({ navigatorFocus: navigatorOrder[currentIndex +
      1]! });
                       }
                   }
               },
      @@ ... @@
               toggleRevertConfirm: () => set(state => ({
                   bodyView: state.bodyView === 'REVERT_CONFIRM' ? 'NONE' : 'REVERT_CONFIRM',
               })),
               confirmRevert: () => {
      -            const { transaction } = get();

      -            if (!transaction) return;

      -            TransactionService.revertTransaction(transaction.id);

      -           
      useDashboardStore.getState().actions.updateTransactionStatus(transaction.id,
      'REVERTED');

      +            const { transactionId } = get();

      +            if (!transactionId) return;

      +            TransactionService.revertTransaction(transactionId);

      +           
      useTransactionStore.getState().actions.updateTransactionStatus(transactionId,
      'REVERTED');
                   set({ bodyView: 'NONE' });
               },
           },
    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useTransactionDetailScreen.tsx
    content: >
      --- src/hooks/useTransactionDetailScreen.tsx

      +++ src/hooks/useTransactionDetailScreen.tsx

      @@ ... @@
       import { useTransactionDetailStore } from '../stores/transaction-detail.store';
       import { useAppStore } from '../stores/app.store';
       import { CopyService } from '../services/copy.service';
      +import { useTransactionStore } from '../stores/transaction.store';

      +import { useMemo } from 'react';
       
       export const useTransactionDetailScreen = () => {
           const { showDashboardScreen } = useAppStore(s => s.actions);
           const store = useTransactionDetailStore();
      -    const {

      -        transaction,

      -        files,

      -        bodyView,

      -    } = store;

      +    const { bodyView } = store;

      +    

      +    const transaction = useTransactionStore(s => s.transactions.find(tx
      => tx.id === store.transactionId));

      +    const files = useMemo(() => transaction?.files || [], [transaction]);
       
           const {
               // Main nav
      @@ ... @@
           const openCopyMode = () => {
      -        const { transaction, files, selectedFileIndex } = store;

      +        const { selectedFileIndex } = store;
               if (!transaction) return;
               const selectedFile = files[selectedFileIndex];
      -        CopyService.openCopyForTransactionDetail(transaction,
      selectedFile);

      +        CopyService.open('TRANSACTION_DETAIL', { transaction,
      selectedFile });
           };
       
           useInput((input, key) => {
      @@ ... @@
           });
       
           return {
      +        transaction,

      +        files,
               ...store,
               actions: {
                   ...store.actions,
    patchStrategy: standard-diff
  - type: write
    path: src/stores/transaction-history.store.ts
    content: >
      --- src/stores/transaction-history.store.ts

      +++ src/stores/transaction-history.store.ts

      @@ ... @@

      -import { TransactionService } from '../services/transaction.service';
       import type { Transaction } from '../types/transaction.types';
       import type { FileChange } from '../types/file.types';
       import type { HistoryViewMode } from '../types/transaction-history.types';
      +import { useTransactionStore } from './transaction.store';
       
       export type { Transaction as HistoryTransaction } from '../types/transaction.types';
       export type { FileChange } from '../types/file.types';
      @@ ... @@
       type HistoryStateData = Omit<TransactionHistoryState, 'actions'>;
       
       interface TransactionHistoryState {
      -    transactions: Transaction[];
           mode: HistoryViewMode;
           selectedItemPath: string; // e.g. "tx-1" or "tx-1/file-2"
           expandedIds: Set<string>; // holds ids of expanded items
      @@ ... @@
       
       // --- Store ---
       export const useTransactionHistoryStore = create<TransactionHistoryState>((set, get) => ({
      -    transactions: [],
           mode: 'LIST',
      -    selectedItemPath: 'tx-0',

      +    selectedItemPath: '',
           expandedIds: new Set(),
           filterQuery: '',
           selectedForAction: new Set(),
      @@ ... @@
           actions: {
               load: (initialState) => {
      -            const transactions = TransactionService.getAllTransactions();

      +            const { transactions } = useTransactionStore.getState();
                   set({
      -                transactions,
                       selectedItemPath: transactions[0]?.id || '',
                       mode: 'LIST',
                       expandedIds: new Set(),
      @@ ... @@
                   });
               },
               navigateUp: () => {
      -            const { transactions, expandedIds, selectedItemPath } =
      get();

      +            const { expandedIds, selectedItemPath } = get();

      +            const { transactions } = useTransactionStore.getState();
                   const visibleItems = getVisibleItemPaths(transactions, expandedIds);
                   const currentIndex = visibleItems.indexOf(selectedItemPath);
                   if (currentIndex > 0) {
      @@ ... @@

      -                set({ selectedItemPath: visibleItems[currentIndex - 1]
      });

      +                set({ selectedItemPath: visibleItems[currentIndex - 1]!
      });
                   }
               },
               navigateDown: () => {
      -            const { transactions, expandedIds, selectedItemPath } =
      get();

      +            const { expandedIds, selectedItemPath } = get();

      +            const { transactions } = useTransactionStore.getState();
                   const visibleItems = getVisibleItemPaths(transactions, expandedIds);
                   const currentIndex = visibleItems.indexOf(selectedItemPath);
                   if (currentIndex < visibleItems.length - 1) {
      -                set({ selectedItemPath: visibleItems[currentIndex + 1]
      });

      +                set({ selectedItemPath: visibleItems[currentIndex + 1]!
      });
                   }
               },
               expandOrDrillDown: () => set(state => {
      @@ ... @@
               prepareDebugState: (stateName) => {
                   switch (stateName) {
                       case 'l1-drill':
      -                    get().actions.load({ expandedIds: new Set(['tx-0']),
      selectedItemPath: 'tx-0' });

      +                    get().actions.load({ expandedIds: new Set(['3']),
      selectedItemPath: '3' });
                           break;
                       case 'l2-drill':
      -                    get().actions.load({ expandedIds: new Set(['tx-0',
      'tx-0/0-1']), selectedItemPath: 'tx-0/0-1' });

      +                    get().actions.load({ expandedIds: new Set(['3',
      '3-1']), selectedItemPath: '3-1' });
                           break;
                       case 'filter':
                           get().actions.load({ mode: 'FILTER', filterQuery: 'logger.ts status:committed' });
                           break;
                       case 'copy':
                           get().actions.load({
      -                        selectedForAction: new Set(['tx-0', 'tx-2']),

      +                        selectedForAction: new Set(['3', '6']),
                           });
                           break;
                       case 'bulk':
      -                    get().actions.load({ mode: 'BULK_ACTIONS',
      selectedForAction: new Set(['tx-0', 'tx-2']) });

      +                    get().actions.load({ mode: 'BULK_ACTIONS',
      selectedForAction: new Set(['3', '6']) });
                           break;
                   }
               },
    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useTransactionHistoryScreen.tsx
    content: >
      --- src/hooks/useTransactionHistoryScreen.tsx

      +++ src/hooks/useTransactionHistoryScreen.tsx

      @@ ... @@
       import { useTransactionHistoryStore, getVisibleItemPaths } from '../stores/transaction-history.store';
       import { useAppStore } from '../stores/app.store';
       import { useStdoutDimensions } from '../utils';
       import { CopyService } from '../services/copy.service';
      +import { useTransactionStore } from '../stores/transaction.store';
       
       export const useTransactionHistoryScreen = () => {
           const [, rows] = useStdoutDimensions();
           const store = useTransactionHistoryStore();
           const { showDashboardScreen } = useAppStore(s => s.actions);
      +    const transactions = useTransactionStore(s => s.transactions);
       
           const [viewOffset, setViewOffset] = useState(0);
           
           const visibleItemPaths = useMemo(
      -        () => getVisibleItemPaths(store.transactions, store.expandedIds),

      -        [store.transactions, store.expandedIds],

      +        () => getVisibleItemPaths(transactions, store.expandedIds),

      +        [transactions, store.expandedIds],
           );
           const selectedIndex = visibleItemPaths.indexOf(store.selectedItemPath);
       
      @@ ... @@
           }, [selectedIndex, viewOffset, viewportHeight]);
       
           const openCopyMode = () => {
      -        const { transactions, selectedForAction } = store;

      +        const { selectedForAction } = store;
               const selectedTxs = transactions.filter(tx => selectedForAction.has(tx.id));
       
               if (selectedTxs.length === 0) return;
      -        CopyService.openCopyForTransactionHistory(selectedTxs);

      +        CopyService.open('TRANSACTION_HISTORY', { transactions:
      selectedTxs });
           };
       
           useInput((input, key) => {
      @@ ... @@
           const txIdsInView = useMemo(() => new Set(itemsInView.map(p => p.split('/')[0])), [itemsInView]);
           const transactionsInView = useMemo(
      -        () => store.transactions.filter(tx => txIdsInView.has(tx.id)),

      -        [store.transactions, txIdsInView],

      +        () => transactions.filter(tx => txIdsInView.has(tx.id)),

      +        [transactions, txIdsInView],
           );
           const pathsInViewSet = useMemo(() => new Set(itemsInView), [itemsInView]);
       
           const filterStatus = store.filterQuery ? store.filterQuery : '(none)';
           const showingStatus = `Showing ${viewOffset + 1}-${viewOffset + itemsInView.length} of ${visibleItemPaths.length} items`;
           
           return {
      +        transactions,
               store,
               viewOffset,
               itemsInView,
    patchStrategy: standard-diff
  - type: write
    path: src/components/TransactionHistoryScreen.tsx
    content: >
      --- src/components/TransactionHistoryScreen.tsx

      +++ src/components/TransactionHistoryScreen.tsx

      @@ ... @@
       // --- Main Component ---
       
       const TransactionHistoryScreen = () => {
           const {
      +        transactions,
               store,
               itemsInView,
               transactionsInView,
      @@ ... @@
                       ) : (
                           <Text>{filterStatus}</Text>
                       )}
      -                <Text> · {showingStatus} ({store.transactions.length}
      txns)</Text>

      +                <Text> · {showingStatus} ({transactions.length}
      txns)</Text>
                   </Box>
       
                   <Box flexDirection="column" marginY={1}>
    patchStrategy: standard-diff
  - type: write
    path: src/services/review.service.ts
    content: >
      --- src/services/review.service.ts

      +++ src/services/review.service.ts

      @@ ... @@

      -import { useReviewStore } from '../stores/review.store';

      -import { useDashboardStore } from '../stores/dashboard.store';

      +import { useReviewStore, type ReviewFileItem } from
      '../stores/review.store';

      +import { useTransactionStore } from '../stores/transaction.store';
       import { useAppStore } from '../stores/app.store';
       import { sleep } from '../utils';
       import type { ApplyStep } from '../types/review.types';
      -import type { ReviewFileItem } from '../types/file.types';
       
       const generateBulkRepairPrompt = (files: ReviewFileItem[]): string => {
           const failedFiles = files.filter(f => f.status === 'FAILED');
      @@ ... @@
       };
       
       const performHandoff = (hash: string) => {
           // This is a bit of a hack to find the right transaction to update in the demo
      -    const txToUpdate = useDashboardStore.getState().transactions.find(tx
      => tx.hash === hash);

      +    const txToUpdate =
      useTransactionStore.getState().transactions.find(tx => tx.hash === hash);
           if (txToUpdate) {
      -       
      useDashboardStore.getState().actions.updateTransactionStatus(txToUpdate.id,
      'HANDOFF');

      +       
      useTransactionStore.getState().actions.updateTransactionStatus(txToUpdate.id,
      'HANDOFF');
           }
       
           useAppStore.getState().actions.showDashboardScreen();
      @@ ... @@
           const { actions } = useReviewStore.getState();
      -    const { _updateApplyStep, _addApplySubstep, simulateSuccessScenario,
      simulateFailureScenario } = actions;

      +    const { _updateApplyStep, _addApplySubstep } = actions;
       
           if (scenario === 'success') {
      -        simulateSuccessScenario();

      -        
               _updateApplyStep('snapshot', 'active'); await sleep(100);
               _updateApplyStep('snapshot', 'done', 0.1);
       
      @@ ... @@
               await sleep(500);
       
           } else { // failure scenario
      -        simulateFailureScenario();

      -        
               _updateApplyStep('snapshot', 'active'); await sleep(100);
               _updateApplyStep('snapshot', 'done', 0.1);
       
      @@ ... @@

      +const loadTransactionForReview = (transactionId: string) => {

      +    const tx = useTransactionStore.getState().transactions.find(t => t.id
      === transactionId);

      +    if (!tx) return;

      +

      +    // This simulates the backend determining which files failed or
      succeeded.

      +    // For this demo, tx '1' is the failure case, any other is success.

      +    const isFailureCase = tx.id === '1';

      +

      +    const reviewFiles: ReviewFileItem[] = (tx.files || []).map((file,
      index) => {

      +        if (isFailureCase) {

      +            return {

      +                ...file,

      +                status: index === 0 ? 'APPROVED' : 'FAILED',

      +                error: index > 0 ? (index === 1 ? 'Hunk #1 failed to
      apply' : 'Context mismatch at line 92') : undefined,

      +            };

      +        }

      +        return { ...file, status: 'APPROVED' };

      +    });

      +

      +    useReviewStore.getState().actions.load(tx, reviewFiles, isFailureCase
      ? 'PARTIAL_FAILURE' : 'SUCCESS');

      +};

      +
       const generateSingleFileRepairPrompt = (file: ReviewFileItem): string => {
           return `The patch failed to apply to ${file.path}. Please generate a corrected patch.
       
      @@ ... @@
       
       export const ReviewService = {
      +    loadTransactionForReview,
           generateBulkRepairPrompt,
           generateHandoffPrompt,
           performHandoff,
    patchStrategy: standard-diff
  - type: write
    path: src/stores/review.store.ts
    content: >
      --- src/stores/review.store.ts

      +++ src/stores/review.store.ts

      @@ ... @@
       import { sleep } from '../utils';
       import { useAppStore } from './app.store';
      -import { useDashboardStore } from './dashboard.store';
       import { ReviewService } from '../services/review.service';
      -import { mockReviewFiles, mockReviewScripts, allMockTransactions } from
      '../data/mocks';

      +import { useTransactionStore, type Transaction } from
      './transaction.store';
       import { moveIndex } from './navigation.utils';
       import type { ReviewFileItem } from '../types/file.types';
      -import type { ScriptResult, ApplyStep, ReviewBodyView, PatchStatus } from
      '../types/review.types'; 

      +import type { ScriptResult, ApplyStep, ReviewBodyView, PatchStatus } from
      '../types/review.types';
       
       export type { ReviewFileItem as FileItem, ReviewFileItem } from '../types/file.types';
       export type { ScriptResult, ApplyStep } from '../types/review.types';
      @@ ... @@
       
       interface ReviewState {
           // Transaction Info
      +    transactionId: string | null;
           hash: string;
           message: string;
           prompt: string;
      @@ ... @@
           toggleBodyView: (view: Extract<ReviewBodyView, 'diff' | 'reasoning' | 'script_output' | 'bulk_repair' | 'confirm_handoff'>) => void;
           setBodyView: (view: ReviewBodyView) => void;
           approve: () => void;
      -    simulateSuccessScenario: () => void;
           startApplySimulation: (scenario: 'success' | 'failure') => void;
      -    simulateFailureScenario: () => void;
       
           // Repair Actions
           tryRepairFile: () => void;
      @@ ... @@
           navigateScriptErrorDown: () => void,
       
           // "Private" actions for service layer
      +    load: (transaction: Transaction, files: ReviewFileItem[],
      patchStatus: PatchStatus) => void;
           _updateApplyStep: (id: string, status: ApplyStep['status'], duration?: number, details?: string) => void;
           _addApplySubstep: (parentId: string, substep: Omit<ApplyStep, 'substeps'>) => void;
           };
       }
      -

      -const initialFailureTx = allMockTransactions[0]!;
       
       export const useReviewStore = create<ReviewState>((set, get) => ({
           // Transaction Info
      -    hash: initialFailureTx.hash,

      -    message: initialFailureTx.message,

      -    prompt: initialFailureTx.prompt!,

      -    reasoning: initialFailureTx.reasoning!,

      -    linesAdded: 18,

      -    linesRemoved: 5,

      -    duration: 0.6,

      -    patchStatus: 'PARTIAL_FAILURE',

      +    transactionId: null,

      +    hash: '',

      +    message: '',

      +    prompt: '',

      +    reasoning: '',

      +    linesAdded: 0,

      +    linesRemoved: 0,

      +    duration: 0,

      +    patchStatus: 'SUCCESS',
       
           // File & Script Info
      -    files: mockReviewFiles,

      -    scripts: [], // Empty for partial failure scenario

      +    files: [],

      +    scripts: [],
       
           // UI State
           applySteps: initialApplySteps,
      @@ ... @@
                   return { files: newFiles };
               }),
               toggleBodyView: (view) => set(state => {
      +            // Don't do anything if we are trying to open a view for
      which we have no content

      +            if (view === 'reasoning' && !state.reasoning) return {};
                   if (view === 'diff' && state.selectedItemIndex >= state.files.length) return {}; // Can't show diff for scripts
                   return {
                       bodyView: state.bodyView === view ? 'none' : view,
      @@ ... @@
               }),
               setBodyView: (view) => set({ bodyView: view }),
               expandDiff: () => set(state => ({ isDiffExpanded: !state.isDiffExpanded })),
      -        approve: () => { /* NOP for now, would trigger commit and screen
      change */ },

      +        approve: () => {

      +            const { transactionId } = get();

      +            if (!transactionId) return;

      +           
      useTransactionStore.getState().actions.updateTransactionStatus(transactionId,
      'APPLIED');

      +        },
               startApplySimulation: async (scenario: 'success' | 'failure') => {
                   const { showReviewProcessingScreen, showReviewScreen } = useAppStore.getState().actions;
       
      @@ ... @@
                   await ReviewService.runApplySimulation(scenario);
       
                   showReviewScreen();
               },
      -        simulateSuccessScenario: () => {

      -            const tx = allMockTransactions[1]!;

      -            set(() => ({

      -            hash: tx.hash,

      -            message: tx.message,

      -            prompt: tx.prompt!,

      -            reasoning: tx.reasoning!,

      -            linesAdded: 22,

      -            linesRemoved: 11,

      -            duration: 3.9,

      -            patchStatus: 'SUCCESS' as const,

      -            files: [

      -                {

      -                    id: '1',

      -                    path: 'src/core/clipboard.ts',

      -                    status: 'APPROVED' as const,

      -                    linesAdded: 15,

      -                    linesRemoved: 8,

      -                    diff: `--- a/src/core/clipboard.ts

      -+++ b/src/core/clipboard.ts

      -@@ -1,5 +1,6 @@

      - import { copy as copyToClipboard } from 'clipboardy';`,

      -                    strategy: 'replace' as const,

      -                },

      -                {

      -                    id: '2',

      -                    path: 'src/utils/shell.ts',

      -                    status: 'APPROVED' as const,

      -                    linesAdded: 7,

      -                    linesRemoved: 3,

      -                    diff: `--- a/src/utils/shell.ts

      -+++ b/src/utils/shell.ts`,

      -                    strategy: 'standard-diff' as const,

      -                },

      -            ],

      -            scripts: mockReviewScripts,

      -            selectedItemIndex: 0,

      -            bodyView: 'none' as const,

      -        }));

      -    },

      -        simulateFailureScenario: () => {

      -            const tx = allMockTransactions[0]!;

      -            set(() => ({

      -            hash: tx.hash,

      -            message: tx.message,

      -            prompt: tx.prompt!,

      -            reasoning: tx.reasoning!,

      -            linesAdded: 18,

      -            linesRemoved: 5,

      -            duration: 0.6,

      -            patchStatus: 'PARTIAL_FAILURE' as const,

      -            files: mockReviewFiles,

      -            scripts: [],

      -            // Reset UI state

      -            bodyView: 'none',

      -            isDiffExpanded: false,

      -            reasoningScrollIndex: 0,

      -            scriptErrorIndex: 0,

      -            selectedItemIndex: 0,

      -        }));

      -    },
       
               // Repair Actions
               tryRepairFile: () => {
      @@ ... @@
                   }
               },
               showBulkRepair: () => get().actions.toggleBodyView('bulk_repair'),
      +        executeBulkRepairOption: async (option: number) => {

      +            const { files } = get();

      +

      +            switch (option) {

      +                case 1: { // Generate & Copy Bulk Repair Prompt

      +                    const bulkPrompt =
      ReviewService.generateBulkRepairPrompt(files);

      +                    const failedFiles = files.filter(f => f.status ===
      'FAILED');

      +                    // eslint-disable-next-line no-console

      +                    console.log(`[CLIPBOARD] Copied bulk repair prompt
      for ${failedFiles.length} files.`);

      +                    // In a real app, this would use
      clipboardy.writeSync(bulkPrompt),

      +                    set({ bodyView: 'none' as const });

      +                    break;

      +                }

      +

      +                case 2: { // Attempt Bulk Re-apply

      +                    set({ bodyView: 'none' as const });

      +                    await ReviewService.runBulkReapply();

      +                    break;

      +                }

      +

      +                case 3: { // Handoff to Human

      +                    get().actions.setBodyView('confirm_handoff');

      +                    break;

      +                }

      +

      +                case 4: { // Reject All Failed

      +                    set(state => ({

      +                        files: state.files.map(file =>

      +                            file.status === 'FAILED'

      +                                ? { ...file, status: 'REJECTED' as const
      }

      +                                : file,

      +                        ),

      +                        bodyView: 'none' as const,

      +                    }));

      +                    break;

      +                }

      +

      +                default: // Close modal

      +                    set({ bodyView: 'none' as const });

      +            }

      +        },

      +        confirmHandoff: () => {

      +            const { hash, message, reasoning, files } = get();

      +            const handoffPrompt =
      ReviewService.generateHandoffPrompt(hash, message, reasoning, files);

      +

      +            // eslint-disable-next-line no-console

      +            console.log('[CLIPBOARD] Copied Handoff Prompt.'); // In real
      app: clipboardy.writeSync(handoffPrompt)

      +            ReviewService.performHandoff(hash);

      +        },

      +

      +        // Navigation Actions

      +        scrollReasoningUp: () => set(state => ({

      +            reasoningScrollIndex: Math.max(0, state.reasoningScrollIndex
      - 1),

      +        })),

      +        scrollReasoningDown: () => set(state => {

      +            const maxLines = state.reasoning.split('\n').length;

      +            return { reasoningScrollIndex: Math.min(maxLines - 1,
      state.reasoningScrollIndex + 1) };

      +        }),

      +        navigateScriptErrorUp: () => set(state => ({

      +            scriptErrorIndex: Math.max(0, state.scriptErrorIndex - 1),

      +        })),

      +        navigateScriptErrorDown: () => set(state => {

      +            const selectedScript = state.scripts[state.selectedItemIndex
      - state.files.length];

      +            if (selectedScript && selectedScript.output) {

      +                const errorLines =
      selectedScript.output.split('\n').filter(line =>

      +                    line.includes('Error') || line.includes('Warning'),

      +                );

      +                return { scriptErrorIndex: Math.min(errorLines.length -
      1, state.scriptErrorIndex + 1) };

      +            }

      +            return {};

      +        }),

      +

      +        // "Private" actions for service layer

      +        load: (transaction, files, patchStatus) => set({

      +            transactionId: transaction.id,

      +            hash: transaction.hash,

      +            message: transaction.message,

      +            prompt: transaction.prompt || '',

      +            reasoning: transaction.reasoning || '',

      +            linesAdded: transaction.stats?.linesAdded || 0,

      +            linesRemoved: transaction.stats?.linesRemoved || 0,

      +            duration: 0.6, // Mocking

      +            patchStatus,

      +            files,

      +            scripts: transaction.scripts || [],

      +            // Reset UI state

      +            bodyView: 'none',

      +            isDiffExpanded: false,

      +            reasoningScrollIndex: 0,

      +            scriptErrorIndex: 0,

      +            selectedItemIndex: 0,

      +        }),

      +        _updateApplyStep: (id, status, duration, details) => {

      +            set(state => ({

      +                applySteps: state.applySteps.map(s => {

      +                    if (s.id === id) {

      +                        const newStep = { ...s, status };

      +                        if (duration !== undefined) newStep.duration =
      duration;

      +                        if (details !== undefined) newStep.details =
      details;

      +                        return newStep;

      +                    }

      +                    return s;

      +                }),

      +            }));

      +        },

      +        _addApplySubstep: (parentId, substep) => {

      +             set(state => ({

      +                applySteps: state.applySteps.map(s => {

      +                    if (s.id === parentId) {

      +                        const newSubsteps = [...(s.substeps || []),
      substep as ApplyStep];

      +                        return { ...s, substeps: newSubsteps };

      +                    }

      +                    return s;

      +                }),

      +            }));

      +        },

      +    },

      +}));
    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useReviewScreen.tsx
    content: >
      --- src/hooks/useReviewScreen.tsx

      +++ src/hooks/useReviewScreen.tsx

      @@ ... @@
               startApplySimulation, rejectAllFiles, approve,
               tryRepairFile, showBulkRepair, executeBulkRepairOption, confirmHandoff,
               scrollReasoningUp, scrollReasoningDown, navigateScriptErrorUp, navigateScriptErrorDown,
      -    } = store.actions;

      +    } = store.actions; 
       
           const {
               numFiles,
      @@ ... @@
           const openCopyMode = () => {
               const { hash, message, prompt, reasoning, files, selectedItemIndex } = store;
               const selectedFile = selectedItemIndex < files.length ? files[selectedItemIndex] : undefined;
      -        CopyService.openCopyForReview({

      -            hash, message, prompt, reasoning,

      -        }, files, selectedFile);

      +        CopyService.open('REVIEW', { txInfo: { hash, message, prompt,
      reasoning }, files, selectedFile });
           };
       
           useInput((input, key) => {
               // For demo purposes: Pressing 1 or 2 triggers the processing screen simulation.
               if (input === '1') {
      -            startApplySimulation('success');

      +            startApplySimulation('success'); 
                   return;
               }
               if (input === '2') {
      -            // The store's default is failure, but to re-trigger the
      processing screen

      -            startApplySimulation('failure');

      +            startApplySimulation('failure'); 
                   return;
               }
       
    patchStrategy: standard-diff
  - type: write
    path: src/types/copy.types.ts
    content: >
      --- src/types/copy.types.ts

      +++ src/types/copy.types.ts

      @@ ... @@
           getData: () => string;
           isDefaultSelected?: boolean;
       }
      +

      +export type CopyContext = 'REVIEW' | 'TRANSACTION_DETAIL' |
      'TRANSACTION_HISTORY' | 'DEBUG_REVIEW' | 'DEBUG_HISTORY';

      +

      +import type { Transaction } from './transaction.types';

      +import type { ReviewFileItem, FileChange } from './file.types';

      +

      +export type ReviewTransactionInfo = Pick<Transaction, 'hash' | 'message'
      | 'prompt' | 'reasoning'>;

      +

      +export type CopyContextData =

      +    | { context: 'REVIEW'; txInfo: ReviewTransactionInfo; files:
      ReviewFileItem[]; selectedFile?: ReviewFileItem }

      +    | { context: 'TRANSACTION_DETAIL'; transaction: Transaction;
      selectedFile?: FileChange }

      +    | { context: 'TRANSACTION_HISTORY'; transactions: Transaction[] };
       
       export const COPYABLE_ITEMS = {
           UUID: 'UUID',
    patchStrategy: standard-diff
  - type: write
    path: src/services/copy.service.ts
    content: >
      --- src/services/copy.service.ts

      +++ src/services/copy.service.ts

      @@ ... @@

      -import { useCopyStore, type CopyItem } from '../stores/copy.store';

      -import { COPYABLE_ITEMS } from '../types/copy.types';

      -import type { Transaction } from '../types/transaction.types';

      -import type { ReviewFileItem, FileChange } from '../types/file.types';

      -

      -// A type for the data that can be passed to the copy service from the
      review screen

      -// since it doesn't have a full transaction object in its state.

      -type ReviewTransactionInfo = Pick<Transaction, 'hash' | 'message' |
      'prompt' | 'reasoning'>;

      -

      -const openCopyForReview = (

      -    txInfo: ReviewTransactionInfo,

      -    files: ReviewFileItem[],

      -    selectedFile: ReviewFileItem | undefined,

      -) => {

      -    const items: CopyItem[] = [

      -        { id: 'uuid', key: 'U', label: COPYABLE_ITEMS.UUID, getData: ()
      => `${txInfo.hash ?? ''}-a8b3-4f2c-9d1e-8a7c1b9d8f03` },

      -        { id: 'message', key: 'M', label: COPYABLE_ITEMS.MESSAGE,
      getData: () => txInfo.message },

      -        { id: 'prompt', key: 'P', label: COPYABLE_ITEMS.PROMPT, getData:
      () => txInfo.prompt || '' },

      -        { id: 'reasoning', key: 'R', label: COPYABLE_ITEMS.REASONING,
      getData: () => txInfo.reasoning || '' },

      -        { id: 'file_diff', key: 'F', label:
      `${COPYABLE_ITEMS.FILE_DIFF}${selectedFile ? `: ${selectedFile.path}` :
      ''}`, getData: () => selectedFile?.diff || 'No file selected' },

      -        { id: 'all_diffs', key: 'A', label: COPYABLE_ITEMS.ALL_DIFFS,
      getData: () => files.map(f => `--- FILE: ${f.path}
      ---\n${f.diff}`).join('\n\n') },

      -    ];

      -    useCopyStore.getState().actions.open('Select data to copy from
      review:', items);

      -};

      -

      -const openCopyForTransactionDetail = (transaction: Transaction,
      selectedFile: FileChange | undefined) => {

      -    const items: CopyItem[] = [

      -        { id: 'message', key: 'M', label: COPYABLE_ITEMS.MESSAGE,
      getData: () => transaction.message, isDefaultSelected: true },

      -        { id: 'prompt', key: 'P', label: COPYABLE_ITEMS.PROMPT, getData:
      () => transaction.prompt || '' },

      -        { id: 'reasoning', key: 'R', label: COPYABLE_ITEMS.REASONING,
      getData: () => transaction.reasoning || '', isDefaultSelected: true },

      -        { id: 'all_diffs', key: 'A', label: `${COPYABLE_ITEMS.ALL_DIFFS}
      (${transaction.files?.length || 0} files)`, getData: () =>
      transaction.files?.map(f => `--- FILE: ${f.path}
      ---\n${f.diff}`).join('\n\n') || '' },

      -        { id: 'file_diff', key: 'F', label: `${COPYABLE_ITEMS.FILE_DIFF}:
      ${selectedFile?.path || 'No file selected'}`, getData: () =>
      selectedFile?.diff || 'No file selected' },

      -        { id: 'uuid', key: 'U', label: COPYABLE_ITEMS.UUID, getData: ()
      => transaction.id },

      -        { id: 'yaml', key: 'Y', label: COPYABLE_ITEMS.FULL_YAML, getData:
      () => '... YAML representation ...' }, // Mocking this

      -    ];

      -    useCopyStore.getState().actions.open(`Select data to copy from
      transaction ${transaction.hash}:`, items);

      -};

      -

      -const openCopyForTransactionHistory = (transactions: Transaction[]) => {

      -    const items: CopyItem[] = [

      -        { id: 'messages', key: 'M', label: COPYABLE_ITEMS.MESSAGES,
      getData: () => transactions.map(tx => tx.message).join('\n'),
      isDefaultSelected: true },

      -        { id: 'prompts', key: 'P', label: COPYABLE_ITEMS.PROMPTS,
      getData: () => transactions.map(tx => tx.prompt ||
      '').join('\n\n---\n\n'), isDefaultSelected: false },

      -        { id: 'reasonings', key: 'R', label: COPYABLE_ITEMS.REASONINGS,
      getData: () => transactions.map(tx => tx.reasoning ||
      '').join('\n\n---\n\n'), isDefaultSelected: true },

      -        { id: 'diffs', key: 'D', label: COPYABLE_ITEMS.DIFFS, getData: ()
      => transactions.flatMap(tx => tx.files?.map(f => `--- TX: ${tx.hash},
      FILE: ${f.path} ---\n${f.diff}`)).join('\n\n') },

      -        { id: 'uuids', key: 'U', label: COPYABLE_ITEMS.UUIDS, getData: ()
      => transactions.map(tx => tx.id).join('\n') },

      -        { id: 'yaml', key: 'Y', label: COPYABLE_ITEMS.FULL_YAML, getData:
      () => '... YAML representation ...' },

      -    ];

      -    useCopyStore.getState().actions.open(`Select data to copy from
      ${transactions.length} transactions:`, items);

      -};

      -

      -

      -export const CopyService = {

      -    openCopyForReview,

      -    openCopyForTransactionDetail,

      -    openCopyForTransactionHistory,

      -};

      +import { useCopyStore, type CopyItem } from '../stores/copy.store';

      +import { COPYABLE_ITEMS, type CopyContextData } from
      '../types/copy.types';

      +

      +const open = (...args: CopyContextData) => {

      +    const data = args[0]; // The tagged union

      +    let title = 'Select data to copy:';

      +    let items: CopyItem[] = [];

      +

      +    switch(data.context) {

      +        case 'REVIEW': {

      +            const { txInfo, files, selectedFile } = data;

      +            title = 'Select data to copy from review:';

      +            items = [

      +                { id: 'uuid', key: 'U', label: COPYABLE_ITEMS.UUID,
      getData: () => `${txInfo.hash ?? ''}-a8b3-4f2c-9d1e-8a7c1b9d8f03` },

      +                { id: 'message', key: 'M', label: COPYABLE_ITEMS.MESSAGE,
      getData: () => txInfo.message },

      +                { id: 'prompt', key: 'P', label: COPYABLE_ITEMS.PROMPT,
      getData: () => txInfo.prompt || '' },

      +                { id: 'reasoning', key: 'R', label:
      COPYABLE_ITEMS.REASONING, getData: () => txInfo.reasoning || '' },

      +                { id: 'file_diff', key: 'F', label:
      `${COPYABLE_ITEMS.FILE_DIFF}${selectedFile ? `: ${selectedFile.path}` :
      ''}`, getData: () => selectedFile?.diff || 'No file selected' },

      +                { id: 'all_diffs', key: 'A', label:
      COPYABLE_ITEMS.ALL_DIFFS, getData: () => files.map(f => `--- FILE:
      ${f.path} ---\n${f.diff}`).join('\n\n') },

      +            ];

      +            break;

      +        }

      +        case 'TRANSACTION_DETAIL': {

      +            const { transaction, selectedFile } = data;

      +            title = `Select data to copy from transaction
      ${transaction.hash}:`;

      +            items = [

      +                { id: 'message', key: 'M', label: COPYABLE_ITEMS.MESSAGE,
      getData: () => transaction.message, isDefaultSelected: true },

      +                { id: 'prompt', key: 'P', label: COPYABLE_ITEMS.PROMPT,
      getData: () => transaction.prompt || '' },

      +                { id: 'reasoning', key: 'R', label:
      COPYABLE_ITEMS.REASONING, getData: () => transaction.reasoning || '',
      isDefaultSelected: true },

      +                { id: 'all_diffs', key: 'A', label:
      `${COPYABLE_ITEMS.ALL_DIFFS} (${transaction.files?.length || 0} files)`,
      getData: () => transaction.files?.map(f => `--- FILE: ${f.path}
      ---\n${f.diff}`).join('\n\n') || '' },

      +                { id: 'file_diff', key: 'F', label:
      `${COPYABLE_ITEMS.FILE_DIFF}: ${selectedFile?.path || 'No file
      selected'}`, getData: () => selectedFile?.diff || 'No file selected' },

      +                { id: 'uuid', key: 'U', label: COPYABLE_ITEMS.UUID,
      getData: () => transaction.id },

      +                { id: 'yaml', key: 'Y', label: COPYABLE_ITEMS.FULL_YAML,
      getData: () => '... YAML representation ...' }, // Mocking this

      +            ];

      +            break;

      +        }

      +        case 'TRANSACTION_HISTORY': {

      +            const { transactions } = data;

      +            title = `Select data to copy from ${transactions.length}
      transactions:`;

      +            items = [

      +                { id: 'messages', key: 'M', label:
      COPYABLE_ITEMS.MESSAGES, getData: () => transactions.map(tx =>
      tx.message).join('\n'), isDefaultSelected: true },

      +                { id: 'prompts', key: 'P', label: COPYABLE_ITEMS.PROMPTS,
      getData: () => transactions.map(tx => tx.prompt ||
      '').join('\n\n---\n\n'), isDefaultSelected: false },

      +                { id: 'reasonings', key: 'R', label:
      COPYABLE_ITEMS.REASONINGS, getData: () => transactions.map(tx =>
      tx.reasoning || '').join('\n\n---\n\n'), isDefaultSelected: true },

      +                { id: 'diffs', key: 'D', label: COPYABLE_ITEMS.DIFFS,
      getData: () => transactions.flatMap(tx => tx.files?.map(f => `--- TX:
      ${tx.hash}, FILE: ${f.path} ---\n${f.diff}`)).join('\n\n') },

      +                { id: 'uuids', key: 'U', label: COPYABLE_ITEMS.UUIDS,
      getData: () => transactions.map(tx => tx.id).join('\n') },

      +                { id: 'yaml', key: 'Y', label: COPYABLE_ITEMS.FULL_YAML,
      getData: () => '... YAML representation ...' },

      +            ];

      +            break;

      +        }

      +    }

      +    

      +    useCopyStore.getState().actions.open(title, items);

      +};

      +

      +export const CopyService = { open };
    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useDebugMenu.tsx
    content: >
      --- src/hooks/useDebugMenu.tsx

      +++ src/hooks/useDebugMenu.tsx

      @@ ... @@
       import { useReviewStore } from '../stores/review.store';
       import { useCommitStore } from '../stores/commit.store';
       import { useTransactionDetailStore } from '../stores/transaction-detail.store';
      -import { useCopyStore } from '../stores/copy.store';

      -import { COPYABLE_ITEMS } from '../types/copy.types';
       import { useTransactionHistoryStore } from '../stores/transaction-history.store';
       import type { MenuItem } from '../types/debug.types';
       import { moveIndex } from '../stores/navigation.utils';
      +import { ReviewService } from '../services/review.service';

      +import { CopyService } from '../services/copy.service';
       export type { MenuItem } from '../types/debug.types';
       
       export const useDebugMenu = () => {
      @@ ... @@
               {
                   title: 'Review: Partial Failure (Default)',
                   action: () => {
      -                reviewActions.simulateFailureScenario();

      +                ReviewService.loadTransactionForReview('1'); // The
      designated failure case
                       appActions.showReviewScreen();
                   },
               },
               {
                   title: 'Review: Success',
                   action: () => {
      -                reviewActions.simulateSuccessScenario();

      +                ReviewService.loadTransactionForReview('2'); // The
      designated success case
                       appActions.showReviewScreen();
                   },
               },
               {
                   title: 'Review: Diff View',
                   action: () => {
      -                reviewActions.simulateFailureScenario();

      +                ReviewService.loadTransactionForReview('1');
                       reviewActions.toggleBodyView('diff');
                       appActions.showReviewScreen();
                   },
      @@ ... @@
               {
                   title: 'Review: Reasoning View',
                   action: () => {
      -                reviewActions.simulateFailureScenario();

      +                ReviewService.loadTransactionForReview('1');
                       reviewActions.toggleBodyView('reasoning');
                       appActions.showReviewScreen();
                   },
      @@ ... @@
               {
                   title: 'Review: Copy Mode',
                   action: () => {
      -                reviewActions.simulateFailureScenario();

      -                // We can't show the screen and then open the modal in
      the same tick.

      -                // We show the review screen, and then programmatically
      open the copy store.

      +                ReviewService.loadTransactionForReview('1');
                       appActions.showReviewScreen();
      -                const { hash, message, prompt, reasoning, files } =
      useReviewStore.getState();

      -                const items = [

      -                    { id: 'uuid', key: 'U', label: COPYABLE_ITEMS.UUID,
      getData: () => `${hash ?? ''}-a8b3-4f2c-9d1e-8a7c1b9d8f03` },

      -                    { id: 'message', key: 'M', label:
      COPYABLE_ITEMS.MESSAGE, getData: () => message },

      -                    { id: 'prompt', key: 'P', label:
      COPYABLE_ITEMS.PROMPT, getData: () => prompt },

      -                    { id: 'reasoning', key: 'R', label:
      COPYABLE_ITEMS.REASONING, getData: () => reasoning },

      -                    { id: 'file_diff', key: 'F', label:
      `${COPYABLE_ITEMS.FILE_DIFF}`, getData: () => files[0]?.diff || '' },

      -                    { id: 'all_diffs', key: 'A', label:
      COPYABLE_ITEMS.ALL_DIFFS, getData: () => files.map(f => `--- FILE:
      ${f.path} ---\n${f.diff}`).join('\n\n') },

      -                ];

      -                useCopyStore.getState().actions.open('Select data to copy
      from review:', items);

      +                

      +                // This needs a slight delay for Ink to render the screen
      first

      +                setTimeout(() => {

      +                    const { hash, message, prompt, reasoning, files } =
      useReviewStore.getState();

      +                    CopyService.open('REVIEW', { txInfo: { hash, message,
      prompt, reasoning }, files, selectedFile: files[0] });

      +                }, 100);
                   },
               },
               {
                   title: 'Review: Script Output',
                   action: () => {
      -                reviewActions.simulateSuccessScenario();

      +                ReviewService.loadTransactionForReview('2');
                       reviewActions.toggleBodyView('script_output');
                       appActions.showReviewScreen();
                   },
      @@ ... @@
               {
                   title: 'Review: Bulk Repair',
                   action: () => {
      -                reviewActions.simulateFailureScenario();

      +                ReviewService.loadTransactionForReview('1');
                       reviewActions.showBulkRepair();
                       appActions.showReviewScreen();
                   },
      @@ ... @@
               {
                   title: 'Review: Handoff Confirm',
                   action: () => {
      -                reviewActions.simulateFailureScenario();

      +                ReviewService.loadTransactionForReview('1');
                       reviewActions.executeBulkRepairOption(3); // Option 3 is Handoff
                       appActions.showReviewScreen();
                   },
               },
               {
                   title: 'Review Processing',
      -            action: () => appActions.showReviewProcessingScreen(),

      +            action: () => {

      +                ReviewService.loadTransactionForReview('1');

      +                appActions.showReviewProcessingScreen();

      +            },
               },
               {
                   title: 'Git Commit Screen',
      @@ ... @@
               {
                   title: 'History: Copy Mode',
                   action: () => {
                       historyActions.prepareDebugState('copy');
      +                appActions.showTransactionHistoryScreen();

      +

      +                setTimeout(() => {

      +                    const { transactions } =
      useTransactionStore.getState();

      +                    const { selectedForAction } =
      useTransactionHistoryStore.getState();

      +                    const selectedTxs = transactions.filter(tx =>
      selectedForAction.has(tx.id));

      +                    CopyService.open('TRANSACTION_HISTORY', {
      transactions: selectedTxs });

      +                }, 100);

      -                const { transactions, selectedForAction } =
      useTransactionHistoryStore.getState();

      -                const selectedTxs = transactions.filter(tx =>
      selectedForAction.has(tx.id));

      -                appActions.showTransactionHistoryScreen();

      -                const items = [

      -                     { id: 'messages', key: 'M', label: 'Git Messages',
      getData: () => selectedTxs.map(tx => tx.message).join('\n'),
      isDefaultSelected: true },

      -                     { id: 'uuids', key: 'U', label: 'UUIDs', getData: ()
      => selectedTxs.map(tx => tx.id).join('\n') },

      -                ];

      -                useCopyStore.getState().actions.open(`Select data to copy
      from ${selectedTxs.length} transactions:`, items);
                   },
               },
           ];
    patchStrategy: standard-diff
  - type: write
    path: index.tsx
    content: >
      --- index.tsx

      +++ index.tsx

      @@ ... @@
       import App from './src/App';
       import { useAppStore } from './src/stores/app.store';
       import { useCommitStore } from './src/stores/commit.store';
      +import { useTransactionStore } from './src/stores/transaction.store';
       import { useReviewStore } from './src/stores/review.store';
       import { useTransactionDetailStore } from './src/stores/transaction-detail.store';
       import { useTransactionHistoryStore } from './src/stores/transaction-history.store';
      +import { ReviewService } from './src/services/review.service';
       
       const main = () => {
           const args = process.argv.slice(2);
      +

      +    // Ensure transactions are loaded for debug mode

      +    useTransactionStore.getState().actions.loadTransactions();
       
           if (args[0] === 'debug-screen' && args[1]) {
               const screenName = args[1].replace(/\.tsx$/, '');
      @@ ... @@
                       appActions.showGitCommitScreen();
                       break;
                   case 'ReviewProcessingScreen':
      -               
      useReviewStore.getState().actions.simulateFailureScenario();

      +                ReviewService.loadTransactionForReview('1');
                       appActions.showReviewProcessingScreen();
                       break;
                   case 'ReviewScreen':
      -               
      useReviewStore.getState().actions.simulateFailureScenario();

      +                ReviewService.loadTransactionForReview('1');
                       appActions.showReviewScreen();
                       break;
                   case 'TransactionDetailScreen':
    patchStrategy: standard-diff
  - type: write
    path: src/types/transaction.types.ts
    content: |
      --- src/types/transaction.types.ts
      +++ src/types/transaction.types.ts
      @@ ... @@
       import type { FileChange } from './file.types';
       
       export type TransactionStatus =
      -    | 'PENDING'
      +    | 'PENDING' 
           | 'APPLIED'
           | 'COMMITTED'
           | 'FAILED'
      @@ ... @@
           prompt?: string;
           reasoning?: string;
           error?: string;
      +    scripts?: import('./review.types').ScriptResult[];
           // Fields for history/detail view
           files?: FileChange[];
           stats?: {
    patchStrategy: standard-diff
  - type: write
    path: src/types/file.types.ts
    content: |
      --- src/types/file.types.ts
      +++ src/types/file.types.ts
      @@ ... @@
           path: string;
           diff: string;
           linesAdded: number;
           linesRemoved: number;
      +    strategy: 'replace' | 'standard-diff';
       }
       
       // From transaction-detail.store.ts and transaction-history.store.ts
      @@ ... @@
       export type FileReviewStatus = 'FAILED' | 'APPROVED' | 'REJECTED' | 'AWAITING' | 'RE_APPLYING';
       export interface ReviewFileItem extends BaseFileItem {
           status: FileReviewStatus;
           error?: string;
      -    strategy: 'replace' | 'standard-diff';
       }
    patchStrategy: standard-diff
snapshot:
  src/stores/transaction.store.ts: null
  src/data/mocks.ts: >-
    import type { Transaction } from '../types/transaction.types';

    import type { ReviewFileItem } from '../types/file.types';

    import type { ScriptResult } from '../types/review.types';


    const mockReasoning1 = `1. Identified a potential uncaught exception in the
    \`restoreSnapshot\` function
       if a file operation fails midway through a loop of many files. This could
       leave the project in a partially-reverted, inconsistent state.

    2. Wrapped the file restoration loop in a \`Promise.all\` and added a
    dedicated
       error collection array. This ensures that all file operations are
       attempted and that a comprehensive list of failures is available
       afterward for better error reporting or partial rollback logic.`;

    const mockReasoning2 = `1. The primary goal was to make the rollback
    functionality in \`restoreSnapshot\` more robust. The previous
    implementation used a simple for-loop which would halt on the first error,
    leaving the project in a partially restored state.


    2. I opted for a \`Promise.all\` approach to run file restorations in
    parallel. This improves performance slightly but, more importantly, ensures
    all restoration attempts are completed, even if some fail.


    3. An \`restoreErrors\` array was introduced to collect any exceptions that
    occur during the process. If this array is not empty after the
    \`Promise.all\` completes, a comprehensive error is thrown, informing the
    user exactly which files failed to restore. This provides much better
    diagnostics.`;


    export const allMockTransactions: Transaction[] = [
        {
            id: '1',
            timestamp: Date.now() - 15 * 1000,
            status: 'PENDING',
            hash: 'e4a7c112',
            message: 'fix: add missing error handling',
            prompt: 'Rename the `calculateChanges` utility to `computeDelta` across all files and update imports accordingly.',
            reasoning: mockReasoning1,
            files: [
                { id: '1-1', path: 'src/core/transaction.ts', type: 'MOD', linesAdded: 18, linesRemoved: 5, diff: '... diff ...' },
            ],
            stats: { files: 1, linesAdded: 18, linesRemoved: 5 },
        },
        {
            id: '2',
            timestamp: Date.now() - 2 * 60 * 1000,
            status: 'APPLIED',
            hash: '4b9d8f03',
            message: 'refactor: simplify clipboard logic',
            prompt: 'Simplify the clipboard logic using an external library...',
            reasoning: 'The existing clipboard logic was complex and platform-dependent. Using the `clipboardy` library simplifies the code and improves reliability across different operating systems.',
            files: [
                { id: '2-1', path: 'src/core/clipboard.ts', type: 'MOD', linesAdded: 15, linesRemoved: 8, diff: '... diff ...' },
                { id: '2-2', path: 'src/utils/shell.ts', type: 'MOD', linesAdded: 7, linesRemoved: 3, diff: '... diff ...' },
            ],
            stats: { files: 2, linesAdded: 22, linesRemoved: 11 },
        },
        {
            id: '3',
            timestamp: Date.now() - 5 * 60 * 1000,
            status: 'COMMITTED',
            hash: '8a3f21b8',
            message: 'feat: implement new dashboard UI',
            prompt: 'The user requested to add more robust error handling to the `restoreSnapshot` function. Specifically, it should not halt on the first error but instead attempt all file restorations and then report a summary of any failures.',
            reasoning: mockReasoning2,
            files: [
                { id: '3-1', path: 'src/core/transaction.ts', type: 'MOD', linesAdded: 18, linesRemoved: 5, diff: '... diff ...' },
                { id: '3-2', path: 'src/utils/logger.ts', type: 'MOD', linesAdded: 7, linesRemoved: 3, diff: '... diff ...' },
                { id: '3-3', path: 'src/utils/old-helper.ts', type: 'DEL', linesAdded: 0, linesRemoved: 30, diff: '... diff ...' },
            ],
            stats: { files: 3, linesAdded: 25, linesRemoved: 38 },
        },
        { id: '4', timestamp: Date.now() - 8 * 60 * 1000, status: 'REVERTED', hash: 'b2c9e04d', message: 'Reverting transaction 9c2e1a05' },
        { id: '5', timestamp: Date.now() - 9 * 60 * 1000, status: 'FAILED', hash: '9c2e1a05', message: 'style: update button component (Linter errors: 5)' },
        { id: '6', timestamp: Date.now() - 12 * 60 * 1000, status: 'COMMITTED', hash: 'c7d6b5e0', message: 'docs: update readme with TUI spec' },
    ];


    /**
     * Creates a deep copy of the mock transactions to prevent state mutations.
     */
    export const createMockTransactions = (): Transaction[] => {
        return JSON.parse(JSON.stringify(allMockTransactions));
    };



    // From review.store.ts

    export const mockReviewFiles: ReviewFileItem[] = [
        {
            id: '1',
            path: 'src/core/transaction.ts',
            status: 'APPROVED',
            linesAdded: 18,
            linesRemoved: 5,
            diff: `--- a/src/core/transaction.ts
    +++ b/src/core/transaction.ts

    @@ -15,7 +15,7 @@ export class Transaction {
       }

    -  calculateChanges(): ChangeSet {

    +  computeDelta(): ChangeSet {
         return this.changes;
       }
     }`,
            strategy: 'replace',
        },
        {
            id: '2',
            path: 'src/utils/logger.ts',
            status: 'FAILED',
            linesAdded: 0,
            linesRemoved: 0,
            diff: '',
            error: 'Hunk #1 failed to apply',
            strategy: 'standard-diff',
        },
        {
            id: '3',
            path: 'src/commands/apply.ts',
            status: 'FAILED',
            linesAdded: 0,
            linesRemoved: 0,
            diff: '',
            error: 'Context mismatch at line 92',
            strategy: 'standard-diff',
        },
    ];


    export const mockReviewScripts: ScriptResult[] = [
        { command: 'bun run test', success: true, duration: 2.3, summary: 'Passed (37 tests)', output: '... test output ...' },
        { command: 'bun run lint', success: false, duration: 1.2, summary: '1 Error, 3 Warnings', output: `src/core/clipboard.ts
      45:12  Error    'clipboardy' is assigned a value but never used. (@typescript-eslint/no-unused-vars)
      88:5   Warning  Unexpected console statement. (no-console)` },
    ];


    export const mockReviewReasoning = `1. Identified a potential uncaught
    exception in the \`restoreSnapshot\` function
       if a file operation fails midway through a loop of many files. This could
       leave the project in a partially-reverted, inconsistent state.

    2. Wrapped the file restoration loop in a \`Promise.all\` and added a
    dedicated
       error collection array. This ensures that all file operations are
       attempted and that a comprehensive list of failures is available
       afterward for better error reporting or partial rollback logic.`;
  src/stores/dashboard.store.ts: >-
    import { create } from 'zustand';

    import { DashboardService } from '../services/dashboard.service';

    import { TransactionService } from '../services/transaction.service';

    import type { Transaction, TransactionStatus } from
    '../types/transaction.types';

    import type { DashboardStatus } from '../types/dashboard.types';

    import { moveIndex } from './navigation.utils';


    export type { Transaction, TransactionStatus } from
    '../types/transaction.types';

    export type { DashboardStatus } from '../types/dashboard.types';


    // --- Store Interface ---

    interface DashboardState {
        status: DashboardStatus;
        previousStatus: DashboardStatus; // To handle cancel from confirmation
        transactions: Transaction[];
        selectedTransactionIndex: number;
        showHelp: boolean;
        actions: {
            togglePause: () => void;
            moveSelectionUp: () => void;
            moveSelectionDown: () => void;
            startApproveAll: () => void;
            confirmAction: () => Promise<void>;
            cancelAction: () => void;
            toggleHelp: () => void;
            setStatus: (status: DashboardStatus) => void; // For debug menu
            updateTransactionStatus: (id: string, status: TransactionStatus) => void;
        };
    }


    // --- Store Implementation ---

    export const useDashboardStore = create<DashboardState>((set, get) => ({
        status: 'LISTENING',
        previousStatus: 'LISTENING',
        transactions: TransactionService.getAllTransactions(),
        selectedTransactionIndex: 0,
        showHelp: false,
        actions: {
            togglePause: () => set(state => ({
                status: state.status === 'LISTENING' ? 'PAUSED' : 'LISTENING',
            })),
            moveSelectionUp: () => set(state => ({
                selectedTransactionIndex: moveIndex(state.selectedTransactionIndex, 'up', state.transactions.length),
            })),
            moveSelectionDown: () => set(state => ({
                selectedTransactionIndex: moveIndex(state.selectedTransactionIndex, 'down', state.transactions.length),
            })),
            startApproveAll: () => set(state => ({
                status: 'CONFIRM_APPROVE',
                previousStatus: state.status,
            })),
            cancelAction: () => set(state => ({ status: state.previousStatus })),
            toggleHelp: () => set(state => ({ showHelp: !state.showHelp })),
            setStatus: (status) => set({ status }),
            updateTransactionStatus: (id, status) => {
                set(state => ({
                    transactions: state.transactions.map(tx =>
                        tx.id === id ? { ...tx, status, timestamp: Date.now() } : tx,
                    ),
                }));
                // After updating, move selection to the updated transaction
                const index = get().transactions.findIndex(tx => tx.id === id);
                if (index !== -1) set({ selectedTransactionIndex: index });
            },

            confirmAction: async () => {
                const { status, previousStatus } = get();
                if (status === 'CONFIRM_APPROVE') {
                    set({ status: 'APPROVING' });

                    await DashboardService.approveAll();

                    set({ status: previousStatus });
                }
            },
        },
    }));
  src/services/dashboard.service.ts: |-
    import { useDashboardStore } from '../stores/dashboard.store';
    import { sleep } from '../utils';

    const approveAll = async () => {
        // Find pending transactions and mark them as in-progress
        const pendingTxIds: string[] = [];
        useDashboardStore.setState(state => {
            const newTxs = state.transactions.map(tx => {
                if (tx.status === 'PENDING') {
                    pendingTxIds.push(tx.id);
                    return { ...tx, status: 'IN-PROGRESS' as const };
                }
                return tx;
            });
            return { transactions: newTxs };
        });

        await sleep(2000); // Simulate approval process

        // Mark them as applied
        useDashboardStore.setState(state => {
            const newTxs = state.transactions.map(tx => {
                if (pendingTxIds.includes(tx.id)) {
                    return { ...tx, status: 'APPLIED' as const };
                }
                return tx;
            });
            return { transactions: newTxs };
        });
    };

    export const DashboardService = {
        approveAll,
    };
  src/hooks/useDashboardScreen.tsx: >-
    import { useMemo, useState, useEffect } from 'react';

    import { useApp, useInput } from 'ink';

    import { useDashboardStore } from '../stores/dashboard.store';

    import { useAppStore } from '../stores/app.store';

    import { useCommitStore } from '../stores/commit.store';

    import { useTransactionDetailStore } from
    '../stores/transaction-detail.store';

    import { useTransactionHistoryStore } from
    '../stores/transaction-history.store';

    import { useStdoutDimensions } from '../utils';


    export const useDashboardScreen = () => {
        const [, rows] = useStdoutDimensions();
        const [viewOffset, setViewOffset] = useState(0);
        const NON_EVENT_STREAM_HEIGHT = 9; // Header, separators, status, footer, etc.
        const viewportHeight = Math.max(1, rows - NON_EVENT_STREAM_HEIGHT);
        const { status, transactions, selectedTransactionIndex, showHelp } = useDashboardStore();
        const {
            togglePause,
            moveSelectionUp,
            moveSelectionDown,
            startApproveAll,
            confirmAction,
            cancelAction,
            toggleHelp,
        } = useDashboardStore(s => s.actions);
        const { exit } = useApp();
        const appActions = useAppStore(s => s.actions);
        const commitActions = useCommitStore(s => s.actions);
        const detailActions = useTransactionDetailStore(s => s.actions);
        const historyActions = useTransactionHistoryStore(s => s.actions);

        const pendingApprovals = useMemo(() => transactions.filter(t => t.status === 'PENDING').length, [transactions]);
        const pendingCommits = useMemo(() => transactions.filter(t => t.status === 'APPLIED').length, [transactions]);

        const isModal = status === 'CONFIRM_APPROVE';
        const isProcessing = status === 'APPROVING';

        useEffect(() => {
            if (selectedTransactionIndex < viewOffset) {
                setViewOffset(selectedTransactionIndex);
            } else if (selectedTransactionIndex >= viewOffset + viewportHeight) {
                setViewOffset(selectedTransactionIndex - viewportHeight + 1);
            }
        }, [selectedTransactionIndex, viewOffset, viewportHeight]);

        useInput((input, key) => {
            if (input === '?') {
                toggleHelp();
                return;
            }

            if (showHelp) {
                if (key.escape || input === '?') toggleHelp();
                return;
            }

            if (isModal) {
                if (key.return) confirmAction();
                if (key.escape) cancelAction();
                return;
            }

            if (isProcessing) return; // No input while processing
            
            if (input.toLowerCase() === 'q') exit();

            if (key.upArrow) moveSelectionUp();
            if (key.downArrow) moveSelectionDown();
            
            if (key.return) {
                const selectedTx = transactions[selectedTransactionIndex];
                if (selectedTx?.status === 'PENDING') {
                    // For PENDING transactions, we still go to the review screen.
                    appActions.showReviewScreen();
                } else if (selectedTx) {
                    detailActions.loadTransaction(selectedTx.id);
                    appActions.showTransactionDetailScreen();
                }
            }
            
            if (input.toLowerCase() === 'p') togglePause();
            if (input.toLowerCase() === 'a' && pendingApprovals > 0) startApproveAll();
            if (input.toLowerCase() === 'c' && pendingCommits > 0) {
                commitActions.prepareCommitScreen();
                appActions.showGitCommitScreen();
            }
            if (input.toLowerCase() === 'l') {
                historyActions.load();
                appActions.showTransactionHistoryScreen();
            }
        });
        
        const transactionsToConfirm = useMemo(() => {
            if (status === 'CONFIRM_APPROVE') return transactions.filter(t => t.status === 'PENDING');
            return [];
        }, [status, transactions]);

        return {
            status,
            transactions,
            selectedTransactionIndex,
            showHelp,
            pendingApprovals,
            pendingCommits,
            isModal,
            isProcessing,
            viewOffset,
            viewportHeight,
            transactionsToConfirm,
        };
    };
  src/stores/commit.store.ts: |-
    import { create } from 'zustand';
    import { useDashboardStore } from './dashboard.store';
    import type { Transaction } from '../types/transaction.types';
    import { CommitService } from '../services/commit.service';

    interface CommitState {
        transactionsToCommit: Transaction[];
        finalCommitMessage: string;
        isCommitting: boolean;
        actions: {
            prepareCommitScreen: () => void;
            commit: () => Promise<void>;
        }
    }

    export const useCommitStore = create<CommitState>((set, get) => ({
        transactionsToCommit: [],
        finalCommitMessage: '',
        isCommitting: false,
        actions: {
            prepareCommitScreen: () => {
                const { transactions } = useDashboardStore.getState();
                const appliedTransactions = transactions.filter(tx => tx.status === 'APPLIED');
                
                const finalCommitMessage = CommitService.generateCommitMessage(appliedTransactions);

                set({
                    transactionsToCommit: appliedTransactions,
                    finalCommitMessage,
                });
            },
            commit: async () => {
                set({ isCommitting: true });
                const { transactionsToCommit } = get();
                await CommitService.commit(transactionsToCommit);
                set({ isCommitting: false });
            },
        },
    }));
  src/services/commit.service.ts: >-
    import { useDashboardStore } from '../stores/dashboard.store';

    import type { Transaction } from '../types/transaction.types';

    import { sleep } from '../utils';


    const generateCommitMessage = (transactions: Transaction[]): string => {
        if (transactions.length === 0) {
            return '';
        }
        // Using a more complex aggregation for better demo, based on the readme
        const title = 'feat: implement new dashboard and clipboard logic';
        const bodyPoints = [
            '- Adds error handling to the core transaction module to prevent uncaught exceptions during snapshot restoration.',
            '- Refactors the clipboard watcher for better performance and cross-platform compatibility, resolving issue #42.',
        ];

        if (transactions.length === 1 && transactions[0]) {
            return transactions[0].message;
        }

        return `${title}\n\n${bodyPoints.join('\n\n')}`;
    };


    const commit = async (transactionsToCommit: Transaction[]): Promise<void> =>
    {
        // In a real app, this would run git commands.
        // For simulation, we'll just update the dashboard store.
        const { updateTransactionStatus } = useDashboardStore.getState().actions;

        const txIds = transactionsToCommit.map(tx => tx.id);
        
        // A bit of simulation
        await sleep(500);

        txIds.forEach(id => {
            updateTransactionStatus(id, 'COMMITTED');
        });
    };


    export const CommitService = {
        generateCommitMessage,
        commit,
    };
  src/stores/transaction-detail.store.ts: >-
    import { create } from 'zustand';

    import { useDashboardStore } from './dashboard.store';

    import { TransactionService } from '../services/transaction.service';

    import type { Transaction } from '../types/transaction.types';

    import type { FileChange as FileDetail } from '../types/file.types';

    export type { FileChangeType } from '../types/file.types';

    import type { NavigatorSection, DetailBodyView } from
    '../types/transaction-detail.types';


    interface TransactionDetailState {
        // Data
        transaction: Transaction | null;
        files: FileDetail[];

        // UI State
        navigatorFocus: NavigatorSection | 'FILES_LIST';
        expandedSection: NavigatorSection | null;
        selectedFileIndex: number;
        bodyView: DetailBodyView;

        // Actions
        actions: {
            loadTransaction: (transactionId: string) => void;
            navigateUp: () => void;
            navigateDown: () => void;
            handleEnterOrRight: () => void;
            handleEscapeOrLeft: () => void;
            toggleRevertConfirm: () => void;
            confirmRevert: () => void;
        }
    }


    const navigatorOrder: NavigatorSection[] = ['PROMPT', 'REASONING', 'FILES'];


    export const useTransactionDetailStore =
    create<TransactionDetailState>((set, get) => ({
        transaction: null,
        files: [],

        navigatorFocus: 'PROMPT',
        expandedSection: null,
        selectedFileIndex: 0,
        bodyView: 'NONE',

        actions: {
            loadTransaction: (transactionId) => {
                const { transactions } = useDashboardStore.getState();
                const transaction = transactions.find(tx => tx.id === transactionId);
                if (transaction) {
                    set({
                        transaction,
                        files: transaction.files || [],
                        // Reset UI state
                        navigatorFocus: 'PROMPT',
                        expandedSection: null,
                        selectedFileIndex: 0,
                        bodyView: 'NONE',
                    });
                }
            },
            navigateUp: () => {
                const { navigatorFocus, selectedFileIndex } = get();
                if (navigatorFocus === 'FILES_LIST') {
                    set({ selectedFileIndex: Math.max(0, selectedFileIndex - 1) });
                } else {
                    const currentIndex = navigatorOrder.indexOf(navigatorFocus as NavigatorSection);
                    if (currentIndex > 0) {
                        set({ navigatorFocus: navigatorOrder[currentIndex - 1] });
                    }
                }
            },
            navigateDown: () => {
                const { navigatorFocus, selectedFileIndex, files } = get();
                if (navigatorFocus === 'FILES_LIST') {
                    set({ selectedFileIndex: Math.min(files.length - 1, selectedFileIndex + 1) });
                } else {
                    const currentIndex = navigatorOrder.indexOf(navigatorFocus as NavigatorSection);
                    if (currentIndex < navigatorOrder.length - 1) {
                        set({ navigatorFocus: navigatorOrder[currentIndex + 1] });
                    }
                }
            },
            handleEnterOrRight: () => {
                const { navigatorFocus, expandedSection } = get();

                if (navigatorFocus === 'FILES_LIST') {
                    // Already in file list, now show diff
                    set({ bodyView: 'DIFF_VIEW' });
                    return;
                }

                if (expandedSection === navigatorFocus) {
                    // Section is already expanded, handle nested navigation
                    if (navigatorFocus === 'FILES') {
                        set({ navigatorFocus: 'FILES_LIST', bodyView: 'FILES_LIST' });
                    }
                    return;
                }

                // Expand the focused section
                set({ expandedSection: navigatorFocus });

                switch(navigatorFocus) {
                    case 'PROMPT':
                        set({ bodyView: 'PROMPT' });
                        break;
                    case 'REASONING':
                        set({ bodyView: 'REASONING' });
                        break;
                    case 'FILES':
                        set({ bodyView: 'FILES_LIST' });
                        break;
                }
            },
            handleEscapeOrLeft: () => {
                const { navigatorFocus, expandedSection, bodyView } = get();

                if (bodyView === 'DIFF_VIEW') {
                    set({ bodyView: 'FILES_LIST' }); // Go back from diff to file list
                    return;
                }

                if (navigatorFocus === 'FILES_LIST') {
                    set({ navigatorFocus: 'FILES', bodyView: 'NONE' }); // Go back from file list to files section
                    return;
                }

                // If a section is expanded, collapse it
                if (expandedSection) {
                    set({ expandedSection: null, bodyView: 'NONE' });
                    return;
                }
            },
            toggleRevertConfirm: () => set(state => ({
                bodyView: state.bodyView === 'REVERT_CONFIRM' ? 'NONE' : 'REVERT_CONFIRM',
            })),
            confirmRevert: () => {
                const { transaction } = get();
                if (!transaction) return;
                TransactionService.revertTransaction(transaction.id);
                useDashboardStore.getState().actions.updateTransactionStatus(transaction.id, 'REVERTED');
                set({ bodyView: 'NONE' });
            },
        },
    }));
  src/hooks/useTransactionHistoryScreen.tsx: >-
    import { useState, useMemo, useEffect } from 'react';

    import { useInput } from 'ink';

    import { useTransactionHistoryStore, getVisibleItemPaths } from
    '../stores/transaction-history.store';

    import { useAppStore } from '../stores/app.store';

    import { useStdoutDimensions } from '../utils';

    import { CopyService } from '../services/copy.service';


    export const useTransactionHistoryScreen = () => {
        const [, rows] = useStdoutDimensions();
        const store = useTransactionHistoryStore();
        const { showDashboardScreen } = useAppStore(s => s.actions);

        const [viewOffset, setViewOffset] = useState(0);
        
        const visibleItemPaths = useMemo(
            () => getVisibleItemPaths(store.transactions, store.expandedIds),
            [store.transactions, store.expandedIds],
        );
        const selectedIndex = visibleItemPaths.indexOf(store.selectedItemPath);

        const NON_CONTENT_HEIGHT = 8; // Header, filter, separators, footer, etc.
        const viewportHeight = Math.max(1, rows - NON_CONTENT_HEIGHT);

        useEffect(() => {
            if (selectedIndex >= 0 && selectedIndex < viewOffset) {
                setViewOffset(selectedIndex);
            } else if (selectedIndex >= viewOffset + viewportHeight) {
                setViewOffset(selectedIndex - viewportHeight + 1);
            }
        }, [selectedIndex, viewOffset, viewportHeight]);

        const openCopyMode = () => {
            const { transactions, selectedForAction } = store;
            const selectedTxs = transactions.filter(tx => selectedForAction.has(tx.id));

            if (selectedTxs.length === 0) return;
            CopyService.openCopyForTransactionHistory(selectedTxs);
        };

        useInput((input, key) => {
            if (store.mode === 'FILTER') {
                if (key.escape) store.actions.setMode('LIST');
                if (key.return) store.actions.applyFilter();
                return;
            }
            if (store.mode === 'BULK_ACTIONS') {
                if (key.escape) store.actions.setMode('LIST');
                // Add number handlers...
                return;
            }

            // LIST mode inputs
            if (key.upArrow) store.actions.navigateUp();
            if (key.downArrow) store.actions.navigateDown();
            if (key.rightArrow) store.actions.expandOrDrillDown();
            if (key.leftArrow) store.actions.collapseOrBubbleUp();
            if (input === ' ') store.actions.toggleSelection();

            if (input.toLowerCase() === 'f') store.actions.setMode('FILTER');
            if (input.toLowerCase() === 'c' && store.selectedForAction.size > 0) openCopyMode();
            if (input.toLowerCase() === 'b' && store.selectedForAction.size > 0) store.actions.setMode('BULK_ACTIONS');
            
            if (key.escape || input.toLowerCase() === 'q') {
                showDashboardScreen();
            }
        });

        const itemsInView = visibleItemPaths.slice(viewOffset, viewOffset + viewportHeight);
        const txIdsInView = useMemo(() => new Set(itemsInView.map(p => p.split('/')[0])), [itemsInView]);
        const transactionsInView = useMemo(
            () => store.transactions.filter(tx => txIdsInView.has(tx.id)),
            [store.transactions, txIdsInView],
        );
        const pathsInViewSet = useMemo(() => new Set(itemsInView), [itemsInView]);

        const filterStatus = store.filterQuery ? store.filterQuery : '(none)';
        const showingStatus = `Showing ${viewOffset + 1}-${viewOffset + itemsInView.length} of ${visibleItemPaths.length} items`;
        
        return {
            store,
            viewOffset,
            itemsInView,
            transactionsInView,
            pathsInViewSet,
            filterStatus,
            showingStatus,
            visibleItemPaths,
        };
    };
  src/stores/transaction-history.store.ts: >-
    import { create } from 'zustand';

    import { TransactionService } from '../services/transaction.service';

    import type { Transaction } from '../types/transaction.types';

    import type { FileChange } from '../types/file.types';

    import type { HistoryViewMode } from '../types/transaction-history.types';


    export type { Transaction as HistoryTransaction } from
    '../types/transaction.types';

    export type { FileChange } from '../types/file.types';


    // Omit 'actions' from state type for partial updates

    type HistoryStateData = Omit<TransactionHistoryState, 'actions'>;


    interface TransactionHistoryState {
        transactions: Transaction[];
        mode: HistoryViewMode;
        selectedItemPath: string; // e.g. "tx-1" or "tx-1/file-2"
        expandedIds: Set<string>; // holds ids of expanded items
        filterQuery: string;
        selectedForAction: Set<string>; // set of transaction IDs

        actions: {
            load: (initialState?: Partial<HistoryStateData>) => void;
            navigateDown: () => void;
            navigateUp: () => void;
            expandOrDrillDown: () => void;
            collapseOrBubbleUp: () => void;
            toggleSelection: () => void;
            setMode: (mode: HistoryViewMode) => void;
            setFilterQuery: (query: string) => void;
            applyFilter: () => void; 
            prepareDebugState: (stateName: 'l1-drill' | 'l2-drill' | 'filter' | 'copy' | 'bulk') => void;
        }
    }


    export const getVisibleItemPaths = (transactions: Transaction[],
    expandedIds: Set<string>): string[] => {
        const paths: string[] = [];
        for (const tx of transactions) {
            paths.push(tx.id);
            if (expandedIds.has(tx.id) && tx.files) {
                for (const file of tx.files) {
                    paths.push(`${tx.id}/${file.id}`);
                }
            }
        }
        return paths;
    };


    // --- Store ---

    export const useTransactionHistoryStore =
    create<TransactionHistoryState>((set, get) => ({
        transactions: [],
        mode: 'LIST',
        selectedItemPath: 'tx-0',
        expandedIds: new Set(),
        filterQuery: '',
        selectedForAction: new Set(),

        actions: {
            load: (initialState) => {
                const transactions = TransactionService.getAllTransactions();
                set({
                    transactions,
                    selectedItemPath: transactions[0]?.id || '',
                    mode: 'LIST',
                    expandedIds: new Set(),
                    selectedForAction: new Set(),
                    filterQuery: '',
                    ...initialState,
                });
            },
            navigateUp: () => {
                const { transactions, expandedIds, selectedItemPath } = get();
                const visibleItems = getVisibleItemPaths(transactions, expandedIds);
                const currentIndex = visibleItems.indexOf(selectedItemPath);
                if (currentIndex > 0) {
                    set({ selectedItemPath: visibleItems[currentIndex - 1] });
                }
            },
            navigateDown: () => {
                const { transactions, expandedIds, selectedItemPath } = get();
                const visibleItems = getVisibleItemPaths(transactions, expandedIds);
                const currentIndex = visibleItems.indexOf(selectedItemPath);
                if (currentIndex < visibleItems.length - 1) {
                    set({ selectedItemPath: visibleItems[currentIndex + 1] });
                }
            },
            expandOrDrillDown: () => set(state => {
                const { selectedItemPath, expandedIds } = state;
                const newExpandedIds = new Set(expandedIds);
                if (!newExpandedIds.has(selectedItemPath)) {
                    newExpandedIds.add(selectedItemPath);
                }
                return { expandedIds: newExpandedIds };
            }),
            collapseOrBubbleUp: () => set(state => {
                const { selectedItemPath, expandedIds } = state;
                const newExpandedIds = new Set(expandedIds);
                if (newExpandedIds.has(selectedItemPath)) {
                    // If it's expanded, collapse it
                    newExpandedIds.delete(selectedItemPath);
                    
                    // Also collapse children
                    for (const id of newExpandedIds) {
                        if (id.startsWith(`${selectedItemPath}/`)) {
                            newExpandedIds.delete(id);
                        }
                    }

                    return { expandedIds: newExpandedIds };
                } else if (selectedItemPath.includes('/')) {
                    // If it's a file, move selection to parent transaction
                    const parentId = selectedItemPath.split('/')[0];
                    return { selectedItemPath: parentId || '' };
                }
                return {};
            }),
            toggleSelection: () => set(state => {
                const { selectedItemPath, selectedForAction } = state;
                const txId = selectedItemPath.split('/')[0];
                if (!txId) return {};

                const newSelection = new Set(selectedForAction);
                if (newSelection.has(txId)) {
                    newSelection.delete(txId);
                } else {
                    newSelection.add(txId);
                }
                return { selectedForAction: newSelection };
            }),
            setMode: (mode) => set({ mode }),
            setFilterQuery: (query) => set({ filterQuery: query }),
            applyFilter: () => {
                // In a real app, this would filter `transactions`.
                // For the demo, we just go back to LIST mode.
                set({ mode: 'LIST' });
            },
            prepareDebugState: (stateName) => {
                switch (stateName) {
                    case 'l1-drill':
                        get().actions.load({ expandedIds: new Set(['tx-0']), selectedItemPath: 'tx-0' });
                        break;
                    case 'l2-drill':
                        get().actions.load({ expandedIds: new Set(['tx-0', 'tx-0/0-1']), selectedItemPath: 'tx-0/0-1' });
                        break;
                    case 'filter':
                        get().actions.load({ mode: 'FILTER', filterQuery: 'logger.ts status:committed' });
                        break;
                    case 'copy':
                        get().actions.load({
                            selectedForAction: new Set(['tx-0', 'tx-2']),
                        });
                        break;
                    case 'bulk':
                        get().actions.load({ mode: 'BULK_ACTIONS', selectedForAction: new Set(['tx-0', 'tx-2']) });
                        break;
                }
            },
        },
    }));
  src/hooks/useTransactionDetailScreen.tsx: >-
    import { useInput } from 'ink';

    import { useTransactionDetailStore } from
    '../stores/transaction-detail.store';

    import { useAppStore } from '../stores/app.store';

    import { CopyService } from '../services/copy.service';


    export const useTransactionDetailScreen = () => {
        const { showDashboardScreen } = useAppStore(s => s.actions);
        const store = useTransactionDetailStore();
        const {
            transaction,
            files,
            bodyView,
        } = store;

        const {
            // Main nav
            navigateUp, navigateDown, handleEnterOrRight, handleEscapeOrLeft,
            toggleRevertConfirm,
            // Revert modal nav
            confirmRevert,
        } = store.actions;

        const openCopyMode = () => {
            const { transaction, files, selectedFileIndex } = store;
            if (!transaction) return;
            const selectedFile = files[selectedFileIndex];
            CopyService.openCopyForTransactionDetail(transaction, selectedFile);
        };

        useInput((input, key) => {
            if (bodyView === 'REVERT_CONFIRM') {
                if (key.escape) toggleRevertConfirm();
                if (key.return) confirmRevert();
                return;
            }

            // Main view input
            if (input.toLowerCase() === 'q') {
                showDashboardScreen();
            }
            if (input.toLowerCase() === 'c') {
                openCopyMode();
            }
            if (input.toLowerCase() === 'u') {
                toggleRevertConfirm();
            }

            if (key.upArrow) navigateUp();
            if (key.downArrow) navigateDown();
            if (key.return || key.rightArrow) handleEnterOrRight();
            if (key.escape || key.leftArrow) handleEscapeOrLeft();
        });

        return {
            ...store,
            actions: {
                ...store.actions,
                showDashboardScreen,
            },
        };
    };
  src/hooks/useReviewScreen.tsx: |-
    import { useMemo } from 'react';
    import { useInput, useApp } from 'ink';
    import { useReviewStore } from '../stores/review.store';
    import { useAppStore } from '../stores/app.store';
    import { CopyService } from '../services/copy.service';

    export const useReviewScreen = () => {
        const { exit } = useApp();
        const store = useReviewStore();
        const { showDashboardScreen } = useAppStore(s => s.actions);
        const {
            hash, message, prompt, reasoning, files, scripts, patchStatus,
            selectedItemIndex, bodyView,
        } = store;
        const {
            moveSelectionUp, moveSelectionDown, toggleFileApproval, expandDiff,
            toggleBodyView, setBodyView,
            startApplySimulation, rejectAllFiles, approve,
            tryRepairFile, showBulkRepair, executeBulkRepairOption, confirmHandoff,
            scrollReasoningUp, scrollReasoningDown, navigateScriptErrorUp, navigateScriptErrorDown,
        } = store.actions;

        const {
            numFiles,
            approvedFilesCount,
            approvedLinesAdded,
            approvedLinesRemoved,
        } = useMemo(() => {
            const approvedFiles = files.filter(f => f.status === 'APPROVED');
            return {
                numFiles: files.length,
                approvedFilesCount: approvedFiles.length,
                approvedLinesAdded: approvedFiles.reduce((sum, f) => sum + f.linesAdded, 0),
                approvedLinesRemoved: approvedFiles.reduce((sum, f) => sum + f.linesRemoved, 0),
            };
        }, [files]);

        const openCopyMode = () => {
            const { hash, message, prompt, reasoning, files, selectedItemIndex } = store;
            const selectedFile = selectedItemIndex < files.length ? files[selectedItemIndex] : undefined;
            CopyService.openCopyForReview({
                hash, message, prompt, reasoning,
            }, files, selectedFile);
        };

        useInput((input, key) => {
            // For demo purposes: Pressing 1 or 2 triggers the processing screen simulation.
            if (input === '1') {
                startApplySimulation('success');
                return;
            }
            if (input === '2') {
                // The store's default is failure, but to re-trigger the processing screen
                startApplySimulation('failure');
                return;
            }

            if (input.toLowerCase() === 'q') exit();

            // Handle Escape key - context-sensitive behavior
            if (key.escape) {
                if (bodyView === 'bulk_repair' || bodyView === 'confirm_handoff') {
                    toggleBodyView(bodyView); // Close modal
                } else if (bodyView !== 'none') {
                    setBodyView('none');
                } else {
                    showDashboardScreen();
                }
                return;
            }

            // Handoff Confirmation
            if (bodyView === 'confirm_handoff') {
                if (key.return) {
                    confirmHandoff();
                }
                return;
            }

            // Bulk Repair Navigation
            if (bodyView === 'bulk_repair') {
                if (input >= '1' && input <= '4') {
                    executeBulkRepairOption(parseInt(input));
                }
                return;
            }

            // Reasoning Scroll Navigation
            if (bodyView === 'reasoning') {
                if (key.upArrow) scrollReasoningUp();
                if (key.downArrow) scrollReasoningDown();
                if (input.toLowerCase() === 'r') toggleBodyView('reasoning');
                return;
            }

            // Script Output Navigation
            if (bodyView === 'script_output') {
                if (input.toLowerCase() === 'j') navigateScriptErrorDown();
                if (input.toLowerCase() === 'k') navigateScriptErrorUp();
                if (key.return) toggleBodyView('script_output');
                if (input.toLowerCase() === 'c') {
                    // Copy script output
                    const scriptIndex = selectedItemIndex - numFiles;
                    const selectedScript = scripts[scriptIndex];
                    if (selectedScript) {
                        // eslint-disable-next-line no-console
                        console.log(`[CLIPBOARD] Copied script output: ${selectedScript.command}`);
                    }
                }
                return;
            }

            // Diff View Navigation
            if (bodyView === 'diff') {
                if (input.toLowerCase() === 'x') expandDiff();
                if (input.toLowerCase() === 'd') toggleBodyView('diff');
                return;
            }

            // Handle Shift+R for reject all
            if (key.shift && input.toLowerCase() === 'r') {
                if (approvedFilesCount > 0) {
                    rejectAllFiles();
                }
                return;
            }

            // Main View Navigation
            if (key.upArrow) moveSelectionUp();
            if (key.downArrow) moveSelectionDown();

            if (input.toLowerCase() === 'r') toggleBodyView('reasoning');

            if (input === ' ') {
                if (selectedItemIndex < numFiles) {
                    const file = files[selectedItemIndex];
                    if (file && file.status !== 'FAILED') {
                        toggleFileApproval();
                    }
                }
            }

            if (input.toLowerCase() === 'd') {
                if (selectedItemIndex < numFiles) {
                    toggleBodyView('diff');
                }
            }

            if (key.return) { // Enter key
                 if (selectedItemIndex >= numFiles) { // It's a script
                    toggleBodyView('script_output');
                }
            }

            if (input.toLowerCase() === 'a') {
                if (approvedFilesCount > 0) {
                    approve();
                    showDashboardScreen();
                }
            }

            if (input.toLowerCase() === 'c') {
                openCopyMode();
            }

            // Handle T for single repair and Shift+T for bulk repair
            if (input.toLowerCase() === 't') {
                if (key.shift) {
                    const hasFailedFiles = files.some(f => f.status === 'FAILED');
                    if (hasFailedFiles) {
                        showBulkRepair();
                    }
                } else {
                    if (selectedItemIndex < numFiles) {
                        const file = files[selectedItemIndex];
                        if (file && file.status === 'FAILED') {
                            tryRepairFile();
                        }
                    }
                }
            }

            if (input.toLowerCase() === 'q') {
                showDashboardScreen();
            }
        });

        return { ...store, numFiles, approvedFilesCount, approvedLinesAdded, approvedLinesRemoved };
    };
  src/stores/review.store.ts: >-
    import { create } from 'zustand';

    import { sleep } from '../utils';

    import { useAppStore } from './app.store';

    import { useDashboardStore } from './dashboard.store';

    import { ReviewService } from '../services/review.service';

    import { mockReviewFiles, mockReviewScripts, allMockTransactions } from
    '../data/mocks';

    import { moveIndex } from './navigation.utils';

    import type { ReviewFileItem } from '../types/file.types';

    import type { ScriptResult, ApplyStep, ReviewBodyView, PatchStatus } from
    '../types/review.types'; 


    export type { ReviewFileItem as FileItem, ReviewFileItem } from
    '../types/file.types';

    export type { ScriptResult, ApplyStep } from '../types/review.types';


    export const initialApplySteps: ApplyStep[] = [
        { id: 'snapshot', title: 'Reading initial file snapshot...', status: 'pending' },
        { id: 'memory', title: 'Applying operations to memory...', status: 'pending', substeps: [] },
        { id: 'post-command', title: 'Running post-command script...', status: 'pending', substeps: [] },
        { id: 'linter', title: 'Analyzing changes with linter...', status: 'pending', substeps: [] },
    ];


    interface ReviewState {
        // Transaction Info
        hash: string;
        message: string;
        prompt: string;
        reasoning: string;
        linesAdded: number;
        linesRemoved: number;
        duration: number;
        patchStatus: PatchStatus;

        // File & Script Info
        files: ReviewFileItem[];
        scripts: ScriptResult[];

        // UI State
        applySteps: ApplyStep[];
        selectedItemIndex: number; // Can be file or script
        bodyView: ReviewBodyView;
        isDiffExpanded: boolean;

        // Reasoning Scroll State
        reasoningScrollIndex: number;

        // Script Navigation State
        scriptErrorIndex: number;

        actions: {
            moveSelectionUp: () => void;
            moveSelectionDown: () => void;
            toggleFileApproval: () => void;
            rejectAllFiles: () => void;
            expandDiff: () => void;
            toggleBodyView: (view: Extract<ReviewBodyView, 'diff' | 'reasoning' | 'script_output' | 'bulk_repair' | 'confirm_handoff'>) => void;
            setBodyView: (view: ReviewBodyView) => void;
            approve: () => void;
            simulateSuccessScenario: () => void;
            startApplySimulation: (scenario: 'success' | 'failure') => void;
            simulateFailureScenario: () => void;

            // Repair Actions
            tryRepairFile: () => void;
            showBulkRepair: () => void;
            executeBulkRepairOption: (option: number) => Promise<void>;
            confirmHandoff: () => void;

            // Navigation Actions
            scrollReasoningUp: () => void;
            scrollReasoningDown: () => void;
            navigateScriptErrorUp: () => void;
            navigateScriptErrorDown: () => void,

            // "Private" actions for service layer
            _updateApplyStep: (id: string, status: ApplyStep['status'], duration?: number, details?: string) => void;
            _addApplySubstep: (parentId: string, substep: Omit<ApplyStep, 'substeps'>) => void;
        };
    }


    const initialFailureTx = allMockTransactions[0]!;


    export const useReviewStore = create<ReviewState>((set, get) => ({
        // Transaction Info
        hash: initialFailureTx.hash,
        message: initialFailureTx.message,
        prompt: initialFailureTx.prompt!,
        reasoning: initialFailureTx.reasoning!,
        linesAdded: 18,
        linesRemoved: 5,
        duration: 0.6,
        patchStatus: 'PARTIAL_FAILURE',

        // File & Script Info
        files: mockReviewFiles,
        scripts: [], // Empty for partial failure scenario

        // UI State
        applySteps: initialApplySteps,
        selectedItemIndex: 0, // Start with first file
        bodyView: 'none' as const,
        isDiffExpanded: false,

        // Reasoning Scroll State
        reasoningScrollIndex: 0,

        // Script Navigation State
        scriptErrorIndex: 0,

        actions: {
            moveSelectionUp: () => set(state => ({
                selectedItemIndex: moveIndex(state.selectedItemIndex, 'up', state.files.length + state.scripts.length),
            })),
            moveSelectionDown: () => set(state => ({
                selectedItemIndex: moveIndex(state.selectedItemIndex, 'down', state.files.length + state.scripts.length),
            })),
            toggleFileApproval: () => set(state => {
                const { selectedItemIndex, files } = state;
                if (selectedItemIndex >= files.length) return {}; // Not a file

                const newFiles = [...files];
                const file = newFiles[selectedItemIndex];
                if (file) {
                    if (file.status === 'APPROVED') {
                        file.status = 'REJECTED';
                    } else if (file.status === 'REJECTED') {
                        file.status = 'APPROVED';
                    }
                }
                return { files: newFiles };
            }),
            rejectAllFiles: () => set(state => {
                const newFiles = state.files.map(file => {
                    if (file.status === 'APPROVED') {
                        return { ...file, status: 'REJECTED' as const };
                    }
                    return file;
                });
                return { files: newFiles };
            }),
            toggleBodyView: (view) => set(state => {
                if (view === 'diff' && state.selectedItemIndex >= state.files.length) return {}; // Can't show diff for scripts
                return {
                    bodyView: state.bodyView === view ? 'none' : view,
                    isDiffExpanded: false, // Always start collapsed
                };
            }),
            setBodyView: (view) => set({ bodyView: view }),
            expandDiff: () => set(state => ({ isDiffExpanded: !state.isDiffExpanded })),
            approve: () => { /* NOP for now, would trigger commit and screen change */ },
            startApplySimulation: async (scenario: 'success' | 'failure') => {
                const { showReviewProcessingScreen, showReviewScreen } = useAppStore.getState().actions;

                set({ applySteps: JSON.parse(JSON.stringify(initialApplySteps)) });
                showReviewProcessingScreen();

                await ReviewService.runApplySimulation(scenario);

                showReviewScreen();
            },
            simulateSuccessScenario: () => {
                const tx = allMockTransactions[1]!;
                set(() => ({
                hash: tx.hash,
                message: tx.message,
                prompt: tx.prompt!,
                reasoning: tx.reasoning!,
                linesAdded: 22,
                linesRemoved: 11,
                duration: 3.9,
                patchStatus: 'SUCCESS' as const,
                files: [
                    {
                        id: '1',
                        path: 'src/core/clipboard.ts',
                        status: 'APPROVED' as const,
                        linesAdded: 15,
                        linesRemoved: 8,
                        diff: `--- a/src/core/clipboard.ts
    +++ b/src/core/clipboard.ts

    @@ -1,5 +1,6 @@
     import { copy as copyToClipboard } from 'clipboardy';`,
                        strategy: 'replace' as const,
                    },
                    {
                        id: '2',
                        path: 'src/utils/shell.ts',
                        status: 'APPROVED' as const,
                        linesAdded: 7,
                        linesRemoved: 3,
                        diff: `--- a/src/utils/shell.ts
    +++ b/src/utils/shell.ts`,
                        strategy: 'standard-diff' as const,
                    },
                ],
                scripts: mockReviewScripts,
                selectedItemIndex: 0,
                bodyView: 'none' as const,
            }));
        },
            simulateFailureScenario: () => {
                const tx = allMockTransactions[0]!;
                set(() => ({
                hash: tx.hash,
                message: tx.message,
                prompt: tx.prompt!,
                reasoning: tx.reasoning!,
                linesAdded: 18,
                linesRemoved: 5,
                duration: 0.6,
                patchStatus: 'PARTIAL_FAILURE' as const,
                files: mockReviewFiles,
                scripts: [],
                // Reset UI state
                bodyView: 'none',
                isDiffExpanded: false,
                reasoningScrollIndex: 0,
                scriptErrorIndex: 0,
                selectedItemIndex: 0,
            }));
        },

            // Repair Actions
            tryRepairFile: () => {
                const { selectedItemIndex, files } = get();
                if (selectedItemIndex < files.length) {
                    const file = files[selectedItemIndex];
                    if (file && file.status === 'FAILED') {
                        ReviewService.tryRepairFile(file, selectedItemIndex);
                    }
                }
            },
            showBulkRepair: () => get().actions.toggleBodyView('bulk_repair'),
            executeBulkRepairOption: async (option: number) => {
                const { files } = get();

                switch (option) {
                    case 1: { // Generate & Copy Bulk Repair Prompt
                        const bulkPrompt = ReviewService.generateBulkRepairPrompt(files);
                        const failedFiles = files.filter(f => f.status === 'FAILED');
                        // eslint-disable-next-line no-console
                        console.log(`[CLIPBOARD] Copied bulk repair prompt for ${failedFiles.length} files.`);
                        // In a real app, this would use clipboardy.writeSync(bulkPrompt),
                        set({ bodyView: 'none' as const });
                        break;
                    }

                    case 2: { // Attempt Bulk Re-apply
                        set({ bodyView: 'none' as const });
                        await ReviewService.runBulkReapply();
                        break;
                    }

                    case 3: { // Handoff to Human
                        get().actions.setBodyView('confirm_handoff');
                        break;
                    }

                    case 4: { // Reject All Failed
                        set(state => ({
                            files: state.files.map(file =>
                                file.status === 'FAILED'
                                    ? { ...file, status: 'REJECTED' as const }
                                    : file,
                            ),
                            bodyView: 'none' as const,
                        }));
                        break;
                    }

                    default: // Close modal
                        set({ bodyView: 'none' as const });
                }
            },
            confirmHandoff: () => {
                const { hash, message, reasoning, files } = get();
                const handoffPrompt = ReviewService.generateHandoffPrompt(hash, message, reasoning, files);

                // eslint-disable-next-line no-console
                console.log('[CLIPBOARD] Copied Handoff Prompt.'); // In real app: clipboardy.writeSync(handoffPrompt)
                ReviewService.performHandoff(hash);
            },

            // Navigation Actions
            scrollReasoningUp: () => set(state => ({
                reasoningScrollIndex: Math.max(0, state.reasoningScrollIndex - 1),
            })),
            scrollReasoningDown: () => set(state => {
                const maxLines = state.reasoning.split('\n').length;
                return { reasoningScrollIndex: Math.min(maxLines - 1, state.reasoningScrollIndex + 1) };
            }),
            navigateScriptErrorUp: () => set(state => ({
                scriptErrorIndex: Math.max(0, state.scriptErrorIndex - 1),
            })),
            navigateScriptErrorDown: () => set(state => {
                const selectedScript = state.scripts[state.selectedItemIndex - state.files.length];
                if (selectedScript && selectedScript.output) {
                    const errorLines = selectedScript.output.split('\n').filter(line =>
                        line.includes('Error') || line.includes('Warning'),
                    );
                    return { scriptErrorIndex: Math.min(errorLines.length - 1, state.scriptErrorIndex + 1) };
                }
                return {};
            }),

            // "Private" actions for service layer
            _updateApplyStep: (id, status, duration, details) => {
                set(state => ({
                    applySteps: state.applySteps.map(s => {
                        if (s.id === id) {
                            const newStep = { ...s, status };
                            if (duration !== undefined) newStep.duration = duration;
                            if (details !== undefined) newStep.details = details;
                            return newStep;
                        }
                        return s;
                    }),
                }));
            },
            _addApplySubstep: (parentId, substep) => {
                 set(state => ({
                    applySteps: state.applySteps.map(s => {
                        if (s.id === parentId) {
                            const newSubsteps = [...(s.substeps || []), substep as ApplyStep];
                            return { ...s, substeps: newSubsteps };
                        }
                        return s;
                    }),
                }));
            },
        },
    }));
  src/components/TransactionHistoryScreen.tsx: >-
    import React from 'react';

    import { Box, Text } from 'ink';

    import TextInput from 'ink-text-input';

    import { type HistoryTransaction as Transaction, type FileChange } from
    '../stores/transaction-history.store';

    import Separator from './Separator';

    import { useTransactionHistoryScreen } from
    '../hooks/useTransactionHistoryScreen';


    // --- Sub-components ---


    const DiffPreview = ({ diff }: { diff: string }) => {
        const lines = diff.split('\n');
        const previewLines = lines.slice(0, 5);
        const hiddenLines = lines.length > 5 ? lines.length - 5 : 0;

        return (
            <Box flexDirection="column" paddingLeft={8}>
                {previewLines.map((line, i) => {
                    let color = 'white';
                    if (line.startsWith('+')) color = 'green';
                    if (line.startsWith('-')) color = 'red';
                    if (line.startsWith('@@')) color = 'cyan';
                    return <Text key={i} color={color}>{line}</Text>;
                })}
                {hiddenLines > 0 && <Text color="gray">... {hiddenLines} lines hidden ...</Text>}
            </Box>
        );
    };


    const FileRow = ({ file, isSelected, isExpanded }: { file: FileChange,
    isSelected: boolean, isExpanded: boolean }) => {
        const icon = isExpanded ? '▾' : '▸';
        const typeMap = { MOD: '[MOD]', ADD: '[ADD]', DEL: '[DEL]', REN: '[REN]' };
        
        return (
            <Box flexDirection="column" paddingLeft={6}>
                <Text color={isSelected ? 'cyan' : undefined}>
                    {isSelected ? '> ' : '  '}
                    {icon} {typeMap[file.type]} {file.path}
                </Text>
                {isExpanded && <DiffPreview diff={file.diff} />}
            </Box>
        );
    };


    const TransactionRow = ({
        tx,
        isSelected,
        isExpanded,
        isSelectedForAction,
    }: {
        tx: Transaction,
        isSelected: boolean,
        isExpanded: boolean,
        isSelectedForAction: boolean,
    }) => {
        const icon = isExpanded ? '▾' : '▸';
        const statusMap = {
            COMMITTED: <Text color="green">✓ Committed</Text>,
            HANDOFF: <Text color="magenta">→ Handoff</Text>,
            REVERTED: <Text color="gray">↩ Reverted</Text>,
        };
        const date = new Date(tx.timestamp).toISOString().split('T')[0];
        const selectionIndicator = isSelectedForAction ? '[x]' : '[ ]';
        
        return (
            <Box flexDirection="column" marginBottom={isExpanded ? 1 : 0}>
                <Text color={isSelected ? 'cyan' : undefined}>
                    {isSelected ? '> ' : '  '}
                    {selectionIndicator} {icon} {statusMap[tx.status as keyof typeof statusMap] || tx.status} · {tx.hash} · {date} · {tx.message}
                </Text>
                {isExpanded && (
                    <Box flexDirection="column" paddingLeft={8}>
                        {tx.stats && <Text color="gray">Stats: {tx.stats.files} Files · +{tx.stats.linesAdded} lines, -{tx.stats.linesRemoved} lines</Text>}
                        <Text>Files:</Text>
                    </Box>
                )}
            </Box>
        );
    };


    const BulkActionsMode = ({ selectedForActionCount }: {
    selectedForActionCount: number }) => {
        return (
            <Box flexDirection="column" marginY={1}>
                <Text bold color="yellow">PERFORM BULK ACTION ON {selectedForActionCount} SELECTED ITEMS</Text>
                <Box marginY={1}>
                    <Text>This action is often irreversible. Are you sure?</Text>
                </Box>
                <Text>(1) Revert Selected Transactions</Text>
                <Text>(2) Mark as &apos;Git Committed&apos;</Text>
                <Text>(3) Delete Selected Transactions (from Relaycode history)</Text>
                <Text>(Esc) Cancel</Text>
            </Box>
        );
    };


    // --- Main Component ---


    const TransactionHistoryScreen = () => {
        const {
            store,
            itemsInView,
            transactionsInView,
            pathsInViewSet,
            filterStatus,
            showingStatus,
        } = useTransactionHistoryScreen();

        const renderFooter = () => {
            if (store.mode === 'FILTER') return <Text>(Enter) Apply Filter & Return      (Esc) Cancel</Text>; 
            if (store.mode === 'BULK_ACTIONS') return <Text>Choose an option [1-3, Esc]:</Text>;
            
            const actions = ['(↑↓) Nav', '(→) Expand', '(←) Collapse', '(Spc) Select', '(Ent) Details', '(F)ilter'];
            if (store.selectedForAction.size > 0) {
                actions.push('(C)opy', '(B)ulk');
            }
            return <Text>{actions.join(' · ')}</Text>;
        };

        return (
            <Box flexDirection="column">
                <Text color="cyan">▲ relaycode transaction history</Text>
                <Separator />

                <Box>
                    <Text>Filter: </Text>
                    {store.mode === 'FILTER' ? (
                        <TextInput value={store.filterQuery} onChange={store.actions.setFilterQuery} />
                    ) : (
                        <Text>{filterStatus}</Text>
                    )}
                    <Text> · {showingStatus} ({store.transactions.length} txns)</Text>
                </Box>

                <Box flexDirection="column" marginY={1}>
                    {store.mode === 'BULK_ACTIONS' && <BulkActionsMode selectedForActionCount={store.selectedForAction.size} />}

                    {store.mode === 'LIST' && transactionsInView.map(tx => {
                        const isTxSelected = store.selectedItemPath.startsWith(tx.id);
                        const isTxExpanded = store.expandedIds.has(tx.id);
                        const isSelectedForAction = store.selectedForAction.has(tx.id);

                        const showTxRow = pathsInViewSet.has(tx.id);

                        return (
                            <Box flexDirection="column" key={tx.id}>
                                {showTxRow && (
                                    <TransactionRow
                                        tx={tx}
                                        isSelected={isTxSelected && !store.selectedItemPath.includes('/')}
                                        isExpanded={isTxExpanded}
                                        isSelectedForAction={isSelectedForAction}
                                    />
                                )}
                                {isTxExpanded && tx.files?.map(file => {
                                    if (!pathsInViewSet.has(`${tx.id}/${file.id}`)) return null;
                                    const filePath = `${tx.id}/${file.id}`;
                                    const isFileSelected = store.selectedItemPath === filePath;
                                    const isFileExpanded = store.expandedIds.has(filePath);
                                    return (
                                        <FileRow
                                            key={file.id}
                                            file={file}
                                            isSelected={isFileSelected}
                                            isExpanded={isFileExpanded}
                                        />
                                    );
                                })}
                            </Box>
                        );
                    })}
                </Box>

                <Separator />
                {renderFooter()}
            </Box>
        );
    };


    export default TransactionHistoryScreen;
  src/types/copy.types.ts: |-
    export interface CopyItem {
        id: string;
        key: string;
        label: string;
        getData: () => string;
        isDefaultSelected?: boolean;
    }

    export const COPYABLE_ITEMS = {
        UUID: 'UUID',
        MESSAGE: 'Git Message',
        PROMPT: 'Prompt',
        REASONING: 'Reasoning',
        FILE_DIFF: 'Diff for',
        ALL_DIFFS: 'All Diffs',
        FULL_YAML: 'Full YAML representation',
        // For multi-selection contexts
        MESSAGES: 'Git Messages',
        PROMPTS: 'Prompts',
        REASONINGS: 'Reasonings',
        DIFFS: 'Diffs',
        UUIDS: 'UUIDs',
    } as const;
  src/services/review.service.ts: >-
    import { useReviewStore } from '../stores/review.store';

    import { useDashboardStore } from '../stores/dashboard.store';

    import { useAppStore } from '../stores/app.store';

    import { sleep } from '../utils';

    import type { ApplyStep } from '../types/review.types';

    import type { ReviewFileItem } from '../types/file.types';


    const generateBulkRepairPrompt = (files: ReviewFileItem[]): string => {
        const failedFiles = files.filter(f => f.status === 'FAILED');
        return `The previous patch failed to apply to MULTIPLE files. Please generate a new, corrected patch that addresses all the files listed below.

    IMPORTANT: The response MUST contain a complete code block for EACH file
    that needs to be fixed.


    ${failedFiles.map(file => `--- FILE: ${file.path} ---

    Strategy: ${file.strategy}

    Error: ${file.error}


    ORIGINAL CONTENT:

    ---

    // ... original content of ${file.path} ...

    ---


    FAILED PATCH:

    ---

    ${file.diff || '// ... failed diff ...'}

    ---

    `).join('\n')}


    Please analyze all failed files and provide a complete, corrected
    response.`;

    };


    const generateHandoffPrompt = (
        hash: string,
        message: string,
        reasoning: string,
        files: ReviewFileItem[],
    ): string => {
        const successfulFiles = files.filter(f => f.status === 'APPROVED');
        const failedFiles = files.filter(f => f.status === 'FAILED');

        return `I am handing off a failed automated code transaction to you. Your task is to act as my programming assistant and complete the planned changes.

    The full plan for this transaction is detailed in the YAML file located at:
    .relay/transactions/${hash}.yml. Please use this file as your primary source
    of truth for the overall goal.


    Here is the current status of the transaction:


    --- TRANSACTION SUMMARY ---

    Goal: ${message}

    Reasoning:

    ${reasoning}


    --- CURRENT FILE STATUS ---

    SUCCESSFUL CHANGES (already applied, no action needed):

    ${successfulFiles.map(f => `- MODIFIED: ${f.path}`).join('\n') || ' 
    (None)'}


    FAILED CHANGES (these are the files you need to fix):

    ${failedFiles.map(f => `- FAILED: ${f.path} (Error:
    ${f.error})`).join('\n')}


    Your job is to now work with me to fix the FAILED files and achieve the
    original goal of the transaction. Please start by asking me which file you
    should work on first.`;

    };


    const performHandoff = (hash: string) => {
        // This is a bit of a hack to find the right transaction to update in the demo
        const txToUpdate = useDashboardStore.getState().transactions.find(tx => tx.hash === hash);
        if (txToUpdate) {
            useDashboardStore.getState().actions.updateTransactionStatus(txToUpdate.id, 'HANDOFF');
        }

        useAppStore.getState().actions.showDashboardScreen();
    };


    const runApplySimulation = async (scenario: 'success' | 'failure') => {
        const { actions } = useReviewStore.getState();
        const { _updateApplyStep, _addApplySubstep, simulateSuccessScenario, simulateFailureScenario } = actions;

        if (scenario === 'success') {
            simulateSuccessScenario();
            
            _updateApplyStep('snapshot', 'active'); await sleep(100);
            _updateApplyStep('snapshot', 'done', 0.1);

            _updateApplyStep('memory', 'active'); await sleep(100);
            _addApplySubstep('memory', { id: 's1', title: '[✓] write: src/core/clipboard.ts (strategy: replace)', status: 'done' });
            await sleep(100);
            _addApplySubstep('memory', { id: 's2', title: '[✓] write: src/utils/shell.ts (strategy: standard-diff)', status: 'done' });
            _updateApplyStep('memory', 'done', 0.3);

            _updateApplyStep('post-command', 'active'); await sleep(1300);
            _addApplySubstep('post-command', { id: 's3', title: '`bun run test` ... Passed', status: 'done' });
            _updateApplyStep('post-command', 'done', 2.3);

            _updateApplyStep('linter', 'active'); await sleep(1200);
            _addApplySubstep('linter', { id: 's4', title: '`bun run lint` ... 0 Errors', status: 'done' });
            _updateApplyStep('linter', 'done', 1.2);

            await sleep(500);

        } else { // failure scenario
            simulateFailureScenario();
            
            _updateApplyStep('snapshot', 'active'); await sleep(100);
            _updateApplyStep('snapshot', 'done', 0.1);

            _updateApplyStep('memory', 'active'); await sleep(100);
            _addApplySubstep('memory', { id: 'f1', title: '[✓] write: src/core/transaction.ts (strategy: replace)', status: 'done' });
            await sleep(100);
            _addApplySubstep('memory', { id: 'f2', title: '[!] failed: src/utils/logger.ts (Hunk #1 failed to apply)', status: 'failed' });
            await sleep(100);
            _addApplySubstep('memory', { id: 'f3', title: '[!] failed: src/commands/apply.ts (Context mismatch at line 92)', status: 'failed' });
            _updateApplyStep('memory', 'done', 0.5);

            await sleep(100);
            _updateApplyStep('post-command', 'skipped', undefined, 'Skipped due to patch application failure');
            await sleep(100);
            _updateApplyStep('linter', 'skipped', undefined, 'Skipped due to patch application failure');
            
            await sleep(500);
        }
    };


    const generateSingleFileRepairPrompt = (file: ReviewFileItem): string => {
        return `The patch failed to apply to ${file.path}. Please generate a corrected patch.

    Error: ${file.error}

    Strategy: ${file.strategy}


    ORIGINAL CONTENT:

    ---

    // ... original file content would be here ...

    ---


    FAILED PATCH:

    ---

    ${file.diff || '// ... failed diff would be here ...'}

    ---


    Please provide a corrected patch that addresses the error.`;

    };


    const tryRepairFile = (file: ReviewFileItem, selectedIndex: number): void =>
    {
        const repairPrompt = generateSingleFileRepairPrompt(file);
        // In a real app: clipboardy.writeSync(repairPrompt)
        // eslint-disable-next-line no-console
        console.log(`[CLIPBOARD] Copied repair prompt for: ${file.path}`);

        // Mock: Update file status to show it's being repaired
        useReviewStore.setState(state => {
            const newFiles = [...state.files];
            newFiles[selectedIndex] = { ...file, status: 'APPROVED' as const, error: undefined, linesAdded: 5, linesRemoved: 2 };
            return { files: newFiles, copyModeLastCopied: 'Repair prompt copied to clipboard' };
        });
    };


    const runBulkReapply = async (): Promise<void> => {
        const { files } = useReviewStore.getState();
        const failedFileIds = new Set(files.filter(f => f.status === 'FAILED').map(f => f.id));
        if (failedFileIds.size === 0) {
            return;
        }

        useReviewStore.setState(state => ({
            files: state.files.map(file =>
                failedFileIds.has(file.id)
                    ? { ...file, status: 'RE_APPLYING' as const }
                    : file,
            ),
        }));

        await sleep(1500); // Simulate re-apply

        // Mock a mixed result
        let first = true;
        useReviewStore.setState(state => ({
            files: state.files.map(file => {
                if (failedFileIds.has(file.id)) {
                    if (first) {
                        first = false;
                        return { ...file, status: 'APPROVED' as const, strategy: 'replace' as const, error: undefined, linesAdded: 9, linesRemoved: 2 };
                    }
                    return { ...file, status: 'FAILED' as const, error: "'replace' failed: markers not found" };
                }
                return file;
            }),
        }));
    };


    export const ReviewService = {
        generateBulkRepairPrompt,
        generateHandoffPrompt,
        performHandoff,
        runApplySimulation,
        generateSingleFileRepairPrompt,
        tryRepairFile,
        runBulkReapply,
    };
  src/types/transaction.types.ts: |-
    import type { FileChange } from './file.types';

    export type TransactionStatus =
        | 'PENDING'
        | 'APPLIED'
        | 'COMMITTED'
        | 'FAILED'
        | 'REVERTED'
        | 'IN-PROGRESS'
        | 'HANDOFF';

    export interface Transaction {
        id: string;
        timestamp: number;
        status: TransactionStatus;
        hash: string;
        message: string;
        prompt?: string;
        reasoning?: string;
        error?: string;
        // Fields for history/detail view
        files?: FileChange[];
        stats?: {
            files: number;
            linesAdded: number;
            linesRemoved: number;
        };
    }
  src/types/file.types.ts: >-
    // Common interface for file-based items

    export interface BaseFileItem {
        id: string;
        path: string;
        diff: string;
        linesAdded: number;
        linesRemoved: number;
    }


    // From transaction-detail.store.ts and transaction-history.store.ts

    export type FileChangeType = 'MOD' | 'ADD' | 'DEL' | 'REN';

    export interface FileChange extends BaseFileItem {
        type: FileChangeType;
    }


    // From review.store.ts

    export type FileReviewStatus = 'FAILED' | 'APPROVED' | 'REJECTED' |
    'AWAITING' | 'RE_APPLYING';

    export interface ReviewFileItem extends BaseFileItem {
        status: FileReviewStatus;
        error?: string;
        strategy: 'replace' | 'standard-diff';
    }
  src/services/copy.service.ts: >-
    import { useCopyStore, type CopyItem } from '../stores/copy.store';

    import { COPYABLE_ITEMS } from '../types/copy.types';

    import type { Transaction } from '../types/transaction.types';

    import type { ReviewFileItem, FileChange } from '../types/file.types';


    // A type for the data that can be passed to the copy service from the
    review screen

    // since it doesn't have a full transaction object in its state.

    type ReviewTransactionInfo = Pick<Transaction, 'hash' | 'message' | 'prompt'
    | 'reasoning'>;


    const openCopyForReview = (
        txInfo: ReviewTransactionInfo,
        files: ReviewFileItem[],
        selectedFile: ReviewFileItem | undefined,
    ) => {
        const items: CopyItem[] = [
            { id: 'uuid', key: 'U', label: COPYABLE_ITEMS.UUID, getData: () => `${txInfo.hash ?? ''}-a8b3-4f2c-9d1e-8a7c1b9d8f03` },
            { id: 'message', key: 'M', label: COPYABLE_ITEMS.MESSAGE, getData: () => txInfo.message },
            { id: 'prompt', key: 'P', label: COPYABLE_ITEMS.PROMPT, getData: () => txInfo.prompt || '' },
            { id: 'reasoning', key: 'R', label: COPYABLE_ITEMS.REASONING, getData: () => txInfo.reasoning || '' },
            { id: 'file_diff', key: 'F', label: `${COPYABLE_ITEMS.FILE_DIFF}${selectedFile ? `: ${selectedFile.path}` : ''}`, getData: () => selectedFile?.diff || 'No file selected' },
            { id: 'all_diffs', key: 'A', label: COPYABLE_ITEMS.ALL_DIFFS, getData: () => files.map(f => `--- FILE: ${f.path} ---\n${f.diff}`).join('\n\n') },
        ];
        useCopyStore.getState().actions.open('Select data to copy from review:', items);
    };


    const openCopyForTransactionDetail = (transaction: Transaction,
    selectedFile: FileChange | undefined) => {
        const items: CopyItem[] = [
            { id: 'message', key: 'M', label: COPYABLE_ITEMS.MESSAGE, getData: () => transaction.message, isDefaultSelected: true },
            { id: 'prompt', key: 'P', label: COPYABLE_ITEMS.PROMPT, getData: () => transaction.prompt || '' },
            { id: 'reasoning', key: 'R', label: COPYABLE_ITEMS.REASONING, getData: () => transaction.reasoning || '', isDefaultSelected: true },
            { id: 'all_diffs', key: 'A', label: `${COPYABLE_ITEMS.ALL_DIFFS} (${transaction.files?.length || 0} files)`, getData: () => transaction.files?.map(f => `--- FILE: ${f.path} ---\n${f.diff}`).join('\n\n') || '' },
            { id: 'file_diff', key: 'F', label: `${COPYABLE_ITEMS.FILE_DIFF}: ${selectedFile?.path || 'No file selected'}`, getData: () => selectedFile?.diff || 'No file selected' },
            { id: 'uuid', key: 'U', label: COPYABLE_ITEMS.UUID, getData: () => transaction.id },
            { id: 'yaml', key: 'Y', label: COPYABLE_ITEMS.FULL_YAML, getData: () => '... YAML representation ...' }, // Mocking this
        ];
        useCopyStore.getState().actions.open(`Select data to copy from transaction ${transaction.hash}:`, items);
    };


    const openCopyForTransactionHistory = (transactions: Transaction[]) => {
        const items: CopyItem[] = [
            { id: 'messages', key: 'M', label: COPYABLE_ITEMS.MESSAGES, getData: () => transactions.map(tx => tx.message).join('\n'), isDefaultSelected: true },
            { id: 'prompts', key: 'P', label: COPYABLE_ITEMS.PROMPTS, getData: () => transactions.map(tx => tx.prompt || '').join('\n\n---\n\n'), isDefaultSelected: false },
            { id: 'reasonings', key: 'R', label: COPYABLE_ITEMS.REASONINGS, getData: () => transactions.map(tx => tx.reasoning || '').join('\n\n---\n\n'), isDefaultSelected: true },
            { id: 'diffs', key: 'D', label: COPYABLE_ITEMS.DIFFS, getData: () => transactions.flatMap(tx => tx.files?.map(f => `--- TX: ${tx.hash}, FILE: ${f.path} ---\n${f.diff}`)).join('\n\n') },
            { id: 'uuids', key: 'U', label: COPYABLE_ITEMS.UUIDS, getData: () => transactions.map(tx => tx.id).join('\n') },
            { id: 'yaml', key: 'Y', label: COPYABLE_ITEMS.FULL_YAML, getData: () => '... YAML representation ...' },
        ];
        useCopyStore.getState().actions.open(`Select data to copy from ${transactions.length} transactions:`, items);
    };



    export const CopyService = {
        openCopyForReview,
        openCopyForTransactionDetail,
        openCopyForTransactionHistory,
    };
  index.tsx: >-
    import React from 'react';

    import { render } from 'ink';

    import App from './src/App';

    import { useAppStore } from './src/stores/app.store';

    import { useCommitStore } from './src/stores/commit.store';

    import { useReviewStore } from './src/stores/review.store';

    import { useTransactionDetailStore } from
    './src/stores/transaction-detail.store';

    import { useTransactionHistoryStore } from
    './src/stores/transaction-history.store';


    const main = () => {
        const args = process.argv.slice(2);

        if (args[0] === 'debug-screen' && args[1]) {
            const screenName = args[1].replace(/\.tsx$/, '');
            const { actions: appActions } = useAppStore.getState();

            switch (screenName) {
                case 'DashboardScreen':
                    appActions.showDashboardScreen();
                    break;
                case 'GitCommitScreen':
                    useCommitStore.getState().actions.prepareCommitScreen();
                    appActions.showGitCommitScreen();
                    break;
                case 'ReviewProcessingScreen':
                    useReviewStore.getState().actions.simulateFailureScenario();
                    appActions.showReviewProcessingScreen();
                    break;
                case 'ReviewScreen':
                    useReviewStore.getState().actions.simulateFailureScenario();
                    appActions.showReviewScreen();
                    break;
                case 'TransactionDetailScreen':
                    useTransactionDetailStore.getState().actions.loadTransaction('3');
                    appActions.showTransactionDetailScreen();
                    break;
                case 'TransactionHistoryScreen':
                    useTransactionHistoryStore.getState().actions.load();
                    appActions.showTransactionHistoryScreen();
                    break;
                case 'InitializationScreen':
                     appActions.showInitScreen();
                     break;
                case 'SplashScreen':
                     appActions.showSplashScreen();
                     break;
                default:
                    process.stderr.write(`Unknown debug screen: ${args[1]}\n`);
                    process.exit(1);
            }
        }

        // Check if we're running in an interactive terminal
        if (process.stdin.isTTY && process.stdout.isTTY) {
            render(<App />);
        } else {
            process.stderr.write('Interactive terminal required. Please run in a terminal that supports raw input mode.\n');
            process.exit(1);
        }
    };


    main();
  src/hooks/useDebugMenu.tsx: >-
    import { useState } from 'react';

    import { useInput } from 'ink';

    import { useAppStore } from '../stores/app.store';

    import { useDashboardStore } from '../stores/dashboard.store';

    import { useInitStore } from '../stores/init.store';

    import { useReviewStore } from '../stores/review.store';

    import { useCommitStore } from '../stores/commit.store';

    import { useTransactionDetailStore } from
    '../stores/transaction-detail.store';

    import { useCopyStore } from '../stores/copy.store';

    import { COPYABLE_ITEMS } from '../types/copy.types';

    import { useTransactionHistoryStore } from
    '../stores/transaction-history.store';

    import type { MenuItem } from '../types/debug.types';

    import { moveIndex } from '../stores/navigation.utils';

    export type { MenuItem } from '../types/debug.types';


    export const useDebugMenu = () => {
        const [selectedIndex, setSelectedIndex] = useState(0);
        const appActions = useAppStore(s => s.actions);
        const dashboardActions = useDashboardStore(s => s.actions);
        const initActions = useInitStore(s => s.actions);
        const reviewActions = useReviewStore(s => s.actions);
        const commitActions = useCommitStore(s => s.actions);
        const detailActions = useTransactionDetailStore(s => s.actions);
        const historyActions = useTransactionHistoryStore(s => s.actions);

        const menuItems: MenuItem[] = [
            {
                title: 'Splash Screen',
                action: () => appActions.showSplashScreen(),
            },
            {
                title: 'Init: Analyze Phase',
                action: () => {
                    initActions.setPhase('ANALYZE');
                    appActions.showInitScreen();
                },
            },
            {
                title: 'Init: Interactive Phase',
                action: () => {
                    initActions.setPhase('INTERACTIVE');
                    appActions.showInitScreen();
                },
            },
            {
                title: 'Init: Finalize Phase',
                action: () => {
                    initActions.setPhase('FINALIZE');
                    appActions.showInitScreen();
                },
            },
            {
                title: 'Dashboard: Listening',
                action: () => {
                    dashboardActions.setStatus('LISTENING');
                    appActions.showDashboardScreen();
                },
            },
            {
                title: 'Dashboard: Confirm Approve',
                action: () => {
                    dashboardActions.setStatus('CONFIRM_APPROVE');
                    appActions.showDashboardScreen();
                },
            },
            {
                title: 'Dashboard: Approving',
                action: () => {
                    dashboardActions.setStatus('APPROVING');
                    appActions.showDashboardScreen();
                },
            },
            {
                title: 'Review: Partial Failure (Default)',
                action: () => {
                    reviewActions.simulateFailureScenario();
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Success',
                action: () => {
                    reviewActions.simulateSuccessScenario();
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Diff View',
                action: () => {
                    reviewActions.simulateFailureScenario();
                    reviewActions.toggleBodyView('diff');
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Reasoning View',
                action: () => {
                    reviewActions.simulateFailureScenario();
                    reviewActions.toggleBodyView('reasoning');
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Copy Mode',
                action: () => {
                    reviewActions.simulateFailureScenario();
                    // We can't show the screen and then open the modal in the same tick.
                    // We show the review screen, and then programmatically open the copy store.
                    appActions.showReviewScreen();
                    const { hash, message, prompt, reasoning, files } = useReviewStore.getState();
                    const items = [
                        { id: 'uuid', key: 'U', label: COPYABLE_ITEMS.UUID, getData: () => `${hash ?? ''}-a8b3-4f2c-9d1e-8a7c1b9d8f03` },
                        { id: 'message', key: 'M', label: COPYABLE_ITEMS.MESSAGE, getData: () => message },
                        { id: 'prompt', key: 'P', label: COPYABLE_ITEMS.PROMPT, getData: () => prompt },
                        { id: 'reasoning', key: 'R', label: COPYABLE_ITEMS.REASONING, getData: () => reasoning },
                        { id: 'file_diff', key: 'F', label: `${COPYABLE_ITEMS.FILE_DIFF}`, getData: () => files[0]?.diff || '' },
                        { id: 'all_diffs', key: 'A', label: COPYABLE_ITEMS.ALL_DIFFS, getData: () => files.map(f => `--- FILE: ${f.path} ---\n${f.diff}`).join('\n\n') },
                    ];
                    useCopyStore.getState().actions.open('Select data to copy from review:', items);
                },
            },
            {
                title: 'Review: Script Output',
                action: () => {
                    reviewActions.simulateSuccessScenario();
                    reviewActions.toggleBodyView('script_output');
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Bulk Repair',
                action: () => {
                    reviewActions.simulateFailureScenario();
                    reviewActions.showBulkRepair();
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Handoff Confirm',
                action: () => {
                    reviewActions.simulateFailureScenario();
                    reviewActions.executeBulkRepairOption(3); // Option 3 is Handoff
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review Processing',
                action: () => appActions.showReviewProcessingScreen(),
            },
            {
                title: 'Git Commit Screen',
                action: () => {
                    commitActions.prepareCommitScreen();
                    appActions.showGitCommitScreen();
                },
            },
            {
                title: 'Transaction Detail Screen',
                action: () => {
                    // The dashboard store has transactions, we'll just pick one.
                    detailActions.loadTransaction('3'); // 'feat: implement new dashboard UI'
                    appActions.showTransactionDetailScreen();
                },
            },
            {
                title: 'Transaction History Screen',
                action: () => {
                    historyActions.load();
                    appActions.showTransactionHistoryScreen();
                },
            },
            {
                title: 'History: L1 Drilldown',
                action: () => {
                    historyActions.prepareDebugState('l1-drill');
                    appActions.showTransactionHistoryScreen();
                },
            },
            {
                title: 'History: L2 Drilldown (Diff)',
                action: () => {
                    historyActions.prepareDebugState('l2-drill');
                    appActions.showTransactionHistoryScreen();
                },
            },
            {
                title: 'History: Filter Mode',
                action: () => {
                    historyActions.prepareDebugState('filter');
                    appActions.showTransactionHistoryScreen();
                },
            },
            {
                title: 'History: Copy Mode',
                action: () => {
                    historyActions.prepareDebugState('copy');
                    const { transactions, selectedForAction } = useTransactionHistoryStore.getState();
                    const selectedTxs = transactions.filter(tx => selectedForAction.has(tx.id));
                    appActions.showTransactionHistoryScreen();
                    const items = [
                         { id: 'messages', key: 'M', label: 'Git Messages', getData: () => selectedTxs.map(tx => tx.message).join('\n'), isDefaultSelected: true },
                         { id: 'uuids', key: 'U', label: 'UUIDs', getData: () => selectedTxs.map(tx => tx.id).join('\n') },
                    ];
                    useCopyStore.getState().actions.open(`Select data to copy from ${selectedTxs.length} transactions:`, items);
                },
            },
        ];

        useInput((input, key) => {
            if (key.upArrow) {
                setSelectedIndex(i => moveIndex(i, 'up', menuItems.length));
                return;
            }
            if (key.downArrow) {
                setSelectedIndex(i => moveIndex(i, 'down', menuItems.length));
                return;
            }
            if (key.return) {
                const item = menuItems[selectedIndex];
                if (item) {
                    item.action();
                    appActions.toggleDebugMenu();
                }
                return;
            }
            if (key.escape || (key.ctrl && input === 'b')) {
                appActions.toggleDebugMenu();
                return;
            }

            // No ctrl/meta keys for selection shortcuts, and only single characters
            if (key.ctrl || key.meta || input.length !== 1) return;

            if (input >= '1' && input <= '9') {
                const targetIndex = parseInt(input, 10) - 1;
                if (targetIndex < menuItems.length) {
                    setSelectedIndex(targetIndex);
                }
            } else if (input.toLowerCase() >= 'a' && input.toLowerCase() <= 'z') {
                const targetIndex = 9 + (input.toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0));
                if (targetIndex < menuItems.length) {
                    setSelectedIndex(targetIndex);
                }
            }
        });

        return {
            selectedIndex,
            menuItems,
        };
    };
approved: false
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: undone
id: 66
