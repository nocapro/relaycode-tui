uuid: c4430e38-40a2-4a0b-ae9b-1d7d515a28b0
projectId: relaycode-tui
createdAt: '2025-09-27T23:37:20.318Z'
gitCommitMsg: >-
  feat(clipboard): implement global pause/resume hotkey

  Elevates the clipboard pause/resume functionality to a global 'P' hotkey,
  available from any screen.

  - The hotkey is now handled in `useGlobalHotkeys`. - Toggling pause/resume
  displays a transient status message (e.g., "CLIPBOARD PAUSED") in the main
  header for 3 seconds. - Toggling also copies a pre-defined system prompt to
  the user's clipboard and shows a notification. - State management is
  centralized in `useDashboardStore`, with UI feedback state managed by
  `useViewStore` to ensure decoupling.
promptSummary: >-
  I need to make the clipboard pause/resume hotkey ('P') global. When used, it
  should display a temporary status update in the header of any screen and also
  copy a system prompt to the clipboard.
reasoning:
  - >-
    This refactoring will elevate the clipboard pause/resume functionality to a
    global level. I'll centralize the state management for the clipboard
    watcher's status, wire it up to a global 'P' hotkey, and provide
    non-persistent visual feedback in the main screen layout's header. As
    requested, toggling the watcher will also copy a system prompt to the user's
    clipboard.
  - >-
    First, I'll update `useViewStore` to manage a transient header status
    message.
  - >-
    Next, I'll modify `ClipboardService` to add the system prompt and a function
    to copy it. This will also require adding the `clipboardy` dependency to
    handle the actual copy-to-clipboard action.
  - >-
    Now I will enhance `useDashboardStore`'s `togglePause` action. It will now
    be the central orchestrator, updating its own state, triggering the header
    UI feedback via `useViewStore`, and calling the new `ClipboardService`
    function to copy the prompt.
  - >-
    With the core logic in place, I will move the 'P' hotkey from the
    dashboard-specific hook to the `useGlobalHotkeys` hook.
  - >-
    Consequently, I'll remove the now-redundant local 'P' hotkey from
    `useDashboardScreen`.
  - >-
    Finally, I'll update the `ScreenLayout` component to observe the
    `headerStatus` from `useViewStore` and display the transient message in the
    header.
operations:
  - type: write
    path: src/stores/view.store.ts
    content: "--- src/stores/view.store.ts\n+++ src/stores/view.store.ts\n@@ -3,18 +3,22 @@\n import type { NotificationPayload } from '../types/notification.types';\n \n interface NotificationState {\n-    isVisible: boolean;\n-    notification: NotificationPayload | null;\n-    actions: {\n-        show: (payload: NotificationPayload) => void;\n-        hide: () => void;\n-    };\n+\tisVisible: boolean;\n+\tnotification: NotificationPayload | null;\n+\tactions: {\n+\t\tshow: (payload: NotificationPayload) => void;\n+\t\thide: () => void;\n+\t};\n }\n \n export const useNotificationStore = create<NotificationState>((set) => ({\n-    isVisible: false,\n-    notification: null,\n-    actions: {\n-        show: (payload) => {\n-            set({ isVisible: true, notification: payload });\n-            useViewStore.getState().actions.setActiveOverlay('notification');\n-        },\n-        hide: () => {\n-            set({ isVisible: false, notification: null });\n-            useViewStore.getState().actions.setActiveOverlay('none');\n-        },\n-    },\n+\tisVisible: false,\n+\tnotification: null,\n+\tactions: {\n+\t\tshow: (payload) => {\n+\t\t\tset({ isVisible: true, notification: payload });\n+\t\t\tuseViewStore.getState().actions.setActiveOverlay('notification');\n+\t\t},\n+\t\thide: () => {\n+\t\t\tset({ isVisible: false, notification: null });\n+\t\t\tuseViewStore.getState().actions.setActiveOverlay('none');\n+\t\t},\n+\t},\n }));\n\n"
    patchStrategy: standard-diff
  - type: write
    path: src/services/clipboard.service.ts
    content: >+
      --- src/services/clipboard.service.ts

      +++ src/services/clipboard.service.ts

      @@ -1,7 +1,8 @@
       import { useTransactionStore, type Transaction } from '../stores/transaction.store';
       import { useNotificationStore } from '../stores/notification.store';
       import { useReviewStore } from '../stores/review.store';
       import { LoggerService } from './logger.service';
      +import clipboardy from 'clipboardy';
       
       const MOCK_VALID_PATCH = `diff --git a/src/components/Button.tsx b/src/components/Button.tsx
       index 12345..67890 100644
      @@ -16,6 +17,17 @@
       
       const MOCK_INVALID_TEXT = 'This is just some regular text, not a patch.';
       
      +const MOCK_SYSTEM_PROMPT = `You are an expert AI programmer. To modify a
      file, you MUST use a code block with a specified patch strategy.

      +

      +**Syntax:**

      +\`\`\`typescript // filePath {patchStrategy}

      +... content ...

      +\`\`\`

      +- \`filePath\`: The path to the file. **If the path contains spaces, it
      MUST be enclosed in double quotes.**

      +- \`patchStrategy\`: (Optional) One of \`standard-diff\`,
      \`search-replace\`. If omitted, the entire file is replaced (this is the
      \`replace\` strategy).

      +`;

      +
       const createTransactionFromPatch = (patchContent: string): Transaction => {
           // In a real app, we would parse this. For demo, we'll create a mock.
           const lines = patchContent.split('\n');
      @@ -60,6 +72,29 @@
           };
       };
       
      +const copySystemPrompt = async () => {

      +    try {

      +        await clipboardy.write(MOCK_SYSTEM_PROMPT);

      +        LoggerService.info('System prompt copied to clipboard.');

      +        useNotificationStore.getState().actions.show({

      +            type: 'info',

      +            title: 'Clipboard Updated',

      +            message: 'System prompt has been copied to your clipboard.',

      +            duration: 2,

      +        });

      +    } catch (error) {

      +        const message = error instanceof Error ? error.message :
      String(error);

      +        LoggerService.error(`Failed to copy to clipboard: ${message}`);

      +        useNotificationStore.getState().actions.show({

      +            type: 'error',

      +            title: 'Clipboard Error',

      +            message: 'Could not copy system prompt to clipboard.',

      +            duration: 3,

      +        });

      +        throw error;

      +    }

      +};

      +
       /**
        * Simulates processing the clipboard content.
        * @param forceValidPatch For debug purposes, force the outcome. If undefined, it will be random.
      @@ -102,4 +137,5 @@
       
       export const ClipboardService = {
           processClipboardContent,
      +    copySystemPrompt,
       };

    patchStrategy: standard-diff
  - type: write
    path: src/stores/dashboard.store.ts
    content: >+
      --- src/stores/dashboard.store.ts

      +++ src/stores/dashboard.store.ts

      @@ -1,6 +1,8 @@
       import { create } from 'zustand';
       import { useTransactionStore } from './transaction.store';
       import { DashboardService } from '../services/dashboard.service';
       import { DASHBOARD_STATUS } from '../constants/dashboard.constants';
      +import { useViewStore } from './view.store';

      +import { ClipboardService } from '../services/clipboard.service';
       
       export type DashboardStatus = (typeof DASHBOARD_STATUS)[keyof typeof DASHBOARD_STATUS];
        
      @@ -25,10 +27,20 @@
           selectedTransactionIndex: 0,
           expandedTransactionId: null,
           actions: {
      -        togglePause: () => set(state => ({

      -            status: state.status === DASHBOARD_STATUS.LISTENING ?
      DASHBOARD_STATUS.PAUSED : DASHBOARD_STATUS.LISTENING,

      -        })),

      +        togglePause: () => {

      +            set(state => {

      +                const isListening = state.status ===
      DASHBOARD_STATUS.LISTENING;

      +                const newStatus = isListening ? DASHBOARD_STATUS.PAUSED :
      DASHBOARD_STATUS.LISTENING;

      +                const statusMessage = isListening ? 'CLIPBOARD PAUSED' :
      'CLIPBOARD LISTENING';

      +

      +               
      useViewStore.getState().actions.setHeaderStatus(statusMessage);

      +                ClipboardService.copySystemPrompt().catch(() => { /*
      ignore copy error */ });

      +

      +                return { status: newStatus };

      +            });

      +        },
               startApproveAll: () => set(state => ({
                   status: DASHBOARD_STATUS.CONFIRM_APPROVE,
                   previousStatus: state.status,

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useGlobalHotkeys.tsx
    content: |+
      --- src/hooks/useGlobalHotkeys.tsx
      +++ src/hooks/useGlobalHotkeys.tsx
      @@ -2,6 +2,7 @@
       import { useAppStore } from '../stores/app.store';
       import { useViewStore } from '../stores/view.store';
       import { OVERLAYS } from '../constants/view.constants';
       import { ClipboardService } from '../services/clipboard.service';
      +import { useDashboardStore } from '../stores/dashboard.store';
       
       export const useGlobalHotkeys = ({ isActive }: { isActive: boolean }) => {
           const { exit } = useApp();
      @@ -29,6 +30,11 @@
                   return;
               }
       
      +        if (input.toLowerCase() === 'p') {
      +            useDashboardStore.getState().actions.togglePause();
      +            return;
      +        }
      +
               // If an overlay with its own input is open, stop here.
               if (activeOverlay === OVERLAYS.DEBUG || activeOverlay === OVERLAYS.LOG) {
                   return;

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useDashboardScreen.tsx
    content: |+
      --- src/hooks/useDashboardScreen.tsx
      +++ src/hooks/useDashboardScreen.tsx
      @@ -141,7 +141,6 @@
                       return;
                   }
                   if (key.return) viewDetails();
      -            if (input.toLowerCase() === 'p') togglePause();
                   if (input.toLowerCase() === 'a' && pendingApprovals > 0) startApproveAll();
                   if (input.toLowerCase() === 'c' && pendingCommits > 0) {
                       commitActions.prepareCommitScreen();

    patchStrategy: standard-diff
  - type: write
    path: src/components/layout/ScreenLayout.tsx
    content: >+
      --- src/components/layout/ScreenLayout.tsx

      +++ src/components/layout/ScreenLayout.tsx

      @@ -1,5 +1,7 @@

      +import { useState, useEffect } from 'react';
       import { Box, Text } from 'ink';
       import Separator from '../Separator';
      +import { useViewStore } from '../../stores/view.store';
       
       interface ScreenLayoutProps {
           title: string;
      @@ -9,11 +11,27 @@
       }
       
       const ScreenLayout = ({ title, footer, children, contextInfo }: ScreenLayoutProps) => {
      +    const headerStatus = useViewStore(s => s.headerStatus);

      +    const [visibleStatus, setVisibleStatus] = useState<string |
      null>(null);

      +

      +    useEffect(() => {

      +        if (!headerStatus) return;

      +

      +        setVisibleStatus(headerStatus.message);

      +

      +        const timer = setTimeout(() => {

      +            setVisibleStatus(null);

      +        }, 3000);

      +

      +        return () => clearTimeout(timer);

      +    }, [headerStatus]);

      +
           return (
               <Box flexDirection="column" flexGrow={1}>
                   <Box flexDirection="row">
                       <Text bold color="black" backgroundColor="yellow"> ▲ relaycode · {title} </Text>
                       <Box flexGrow={1} />
      +                {visibleStatus && <Text color="yellow" bold> ·
      {visibleStatus} · </Text>}
                       {contextInfo && <Text color="gray">{contextInfo}</Text>}
                   </Box>
                   <Separator />

    patchStrategy: standard-diff
snapshot:
  src/stores/view.store.ts: |-
    import { create } from 'zustand';
    import { OVERLAYS } from '../constants/view.constants';

    export type Overlay = (typeof OVERLAYS)[keyof typeof OVERLAYS];

    interface ViewState {
        selectedTransactionId: string | null;
        activeOverlay: Overlay;
        actions: {
            setSelectedTransactionId: (id: string | null) => void;
            setActiveOverlay: (overlay: ViewState['activeOverlay']) => void;
        };
    }

    export const useViewStore = create<ViewState>((set) => ({
        selectedTransactionId: null,
        activeOverlay: OVERLAYS.NONE,
        actions: {
            setSelectedTransactionId: (id) => set({ selectedTransactionId: id }),
            setActiveOverlay: (overlay) => set({ activeOverlay: overlay }),
        },
    }));
  src/services/clipboard.service.ts: >-
    import { useTransactionStore, type Transaction } from
    '../stores/transaction.store';

    import { useNotificationStore } from '../stores/notification.store';

    import { useReviewStore } from '../stores/review.store';

    import { LoggerService } from './logger.service';


    const MOCK_VALID_PATCH = `diff --git a/src/components/Button.tsx
    b/src/components/Button.tsx

    index 12345..67890 100644

    --- a/src/components/Button.tsx

    +++ b/src/components/Button.tsx

    @@ -1,5 +1,6 @@

    -import React from 'react';

    +import React, { useState } from 'react';

     const Button = () => <button>Click Me</button>;

     export default Button;
    `;


    const MOCK_INVALID_TEXT = 'This is just some regular text, not a patch.';


    const createTransactionFromPatch = (patchContent: string): Transaction => {
        // In a real app, we would parse this. For demo, we'll create a mock.
        const lines = patchContent.split('\n');
        const linesAdded = lines.filter(l => l.startsWith('+')).length;
        const linesRemoved = lines.filter(l => l.startsWith('-')).length;
        const filePath = lines.find(l => l.startsWith('--- a/'))?.split(' a/')[1] || 'unknown/file.ts';

        return {
            id: (Math.random() * 1000).toFixed(0),
            timestamp: Date.now(),
            status: 'PENDING',
            hash: Math.random().toString(16).substring(2, 10),
            message: 'feat: apply patch from clipboard',
            prompt: 'A patch was manually pasted into the application.',
            reasoning: 'The user pasted clipboard content which was identified as a valid patch and processed into a new transaction.',
            files: [
                {
                    id: `${(Math.random() * 1000).toFixed(0)}-1`,
                    type: 'MOD',
                    path: filePath,
                    linesAdded,
                    linesRemoved,
                    diff: patchContent,
                    strategy: 'standard-diff',
                },
            ],
            stats: {
                files: 1,
                linesAdded,
                linesRemoved,
            },
        };
    };


    /**
     * Simulates processing the clipboard content.
     * @param forceValidPatch For debug purposes, force the outcome. If undefined, it will be random.
     */
    const processClipboardContent = async (forceValidPatch?: boolean) => {
        LoggerService.info('Manual paste detected. Processing clipboard content...');
        
        // Simulate reading from clipboardy
        const isActuallyValid = forceValidPatch === true || (forceValidPatch === undefined && Math.random() > 0.5);
        const clipboardContent = isActuallyValid ? MOCK_VALID_PATCH : MOCK_INVALID_TEXT;

        // Simulate checking if it's a valid patch
        if (clipboardContent.includes('diff --git')) {
            LoggerService.debug('Valid patch detected in clipboard. Creating transaction.');
            const newTransaction = createTransactionFromPatch(clipboardContent);

            // Add to store so it exists for the review process
            useTransactionStore.getState().actions.addTransaction(newTransaction);

            // Immediately start the review simulation
            LoggerService.debug(`Starting apply simulation for new transaction ${newTransaction.id}`);
            // Forcing 'success' scenario for pasted patches. The simulation itself can
            // result in a failure state which is then handled by the review screen.
            useReviewStore.getState().actions.startApplySimulation(newTransaction.id, 'success');

            useNotificationStore.getState().actions.show({
                type: 'info',
                title: 'Processing Pasted Patch',
                message: `Applying new transaction "${newTransaction.hash}"...`,
                duration: 2,
            });
        } else {
            LoggerService.debug('No valid patch detected in clipboard content.');
            useNotificationStore.getState().actions.show({
                type: 'info',
                title: 'Clipboard Ignored',
                message: 'Pasted content was not a valid patch.',
                duration: 3,
            });
        }
    };


    export const ClipboardService = {
        processClipboardContent,
    };
  src/stores/dashboard.store.ts: >-
    import { create } from 'zustand';

    import { useTransactionStore } from './transaction.store';

    import { DashboardService } from '../services/dashboard.service';

    import { DASHBOARD_STATUS } from '../constants/dashboard.constants';


    export type DashboardStatus = (typeof DASHBOARD_STATUS)[keyof typeof
    DASHBOARD_STATUS];
     
    interface DashboardState {
        status: DashboardStatus;
        previousStatus: DashboardStatus;
        selectedTransactionIndex: number;
        expandedTransactionId: string | null;
        actions: {
            togglePause: () => void;
            startApproveAll: () => void;
            confirmAction: () => Promise<void>;
            cancelAction: () => void;
            setStatus: (status: DashboardStatus) => void;
            toggleExpand: () => void;
            setExpandedTransactionId: (id: string | null) => void;
            setSelectedIndex: (index: number) => void;
        };
    }


    export const useDashboardStore = create<DashboardState>((set, get) => ({
        status: DASHBOARD_STATUS.LISTENING,
        previousStatus: DASHBOARD_STATUS.LISTENING,
        selectedTransactionIndex: 0,
        expandedTransactionId: null,
        actions: {
            togglePause: () => set(state => ({
                status: state.status === DASHBOARD_STATUS.LISTENING ? DASHBOARD_STATUS.PAUSED : DASHBOARD_STATUS.LISTENING,
            })),
            startApproveAll: () => set(state => ({
                status: DASHBOARD_STATUS.CONFIRM_APPROVE,
                previousStatus: state.status,
            })),
            cancelAction: () => set(state => ({ status: state.previousStatus })),
            setStatus: (status) => set({ status }),
            confirmAction: async () => { // The `if` is redundant as this is only called from that state.
                const previousStatus = get().previousStatus;
                set({ status: DASHBOARD_STATUS.APPROVING });
                await DashboardService.approveAll();
                set({ status: previousStatus });
            },
            toggleExpand: () => {
                const { selectedTransactionIndex, expandedTransactionId } = get();
                const { transactions } = useTransactionStore.getState();
                const selectedTx = transactions[selectedTransactionIndex];
                if (!selectedTx) return;

                if (expandedTransactionId === selectedTx.id) {
                    set({ expandedTransactionId: null });
                } else {
                    set({ expandedTransactionId: selectedTx.id });
                }
            },
            setExpandedTransactionId: (id) => set({ expandedTransactionId: id }),
            setSelectedIndex: (index) => set({ selectedTransactionIndex: index }),
        },
    }));
  src/hooks/useGlobalHotkeys.tsx: |-
    import { useApp, useInput } from 'ink';
    import { useAppStore } from '../stores/app.store';
    import { useViewStore } from '../stores/view.store';
    import { OVERLAYS } from '../constants/view.constants';
    import { ClipboardService } from '../services/clipboard.service';

    export const useGlobalHotkeys = ({ isActive }: { isActive: boolean }) => {
        const { exit } = useApp();
        const { navigateBack } = useAppStore(s => s.actions);
        const { activeOverlay, setActiveOverlay } = useViewStore(s => ({
            activeOverlay: s.activeOverlay,
            setActiveOverlay: s.actions.setActiveOverlay,
        }));

        useInput((input, key) => {
            // Debug Menu toggle is the highest priority global key
            if (key.ctrl && input === 'b') {
                setActiveOverlay(activeOverlay === OVERLAYS.DEBUG ? OVERLAYS.NONE : OVERLAYS.DEBUG);
                return;
            }
            if (key.ctrl && input === 'l') {
                setActiveOverlay(activeOverlay === OVERLAYS.LOG ? OVERLAYS.NONE : OVERLAYS.LOG);
                return;
            }
            if (key.ctrl && input === 's') {
                // This is a temporary location. In a real app, this might live elsewhere
                // or be disabled on certain screens.
                useAppStore.getState().actions.showSettingsScreen();
            }

            if (key.ctrl && input === 'v') {
                ClipboardService.processClipboardContent();
                return;
            }

            // If an overlay with its own input is open, stop here.
            if (activeOverlay === OVERLAYS.DEBUG || activeOverlay === OVERLAYS.LOG) {
                return;
            }

            // Help screen takes precedence over other keys
            if (activeOverlay === OVERLAYS.HELP) {
                if (key.escape || input === '?') {
                    setActiveOverlay(OVERLAYS.NONE);
                }
                return;
            }

            // --- Global hotkeys when no modal/overlay is open ---
            
            // Open Help
            if (input === '?') {
                setActiveOverlay(OVERLAYS.HELP);
                return;
            }
            
            // Quit from main screens
            if (input.toLowerCase() === 'q' || key.escape) {
                const screenBefore = useAppStore.getState().currentScreen;
                navigateBack();
                const screenAfter = useAppStore.getState().currentScreen;

                // If navigateBack did not change the screen, it means we are on a root screen.
                if (screenBefore === screenAfter) {
                    exit();
                }
            }
        }, { isActive });
    };
  src/hooks/useDashboardScreen.tsx: >-
    import { useState, useEffect, useRef, useMemo } from 'react';

    import { useInput } from 'ink';

    import { useDashboardStore } from '../stores/dashboard.store';

    import { useAppStore } from '../stores/app.store';

    import { useCommitStore } from '../stores/commit.store';

    import { useTransactionStore, selectTransactionsByStatus } from
    '../stores/transaction.store';

    import { useReviewStore } from '../stores/review.store';

    import { useDetailStore } from '../stores/detail.store';

    import { useHistoryStore } from '../stores/history.store';

    import type { LayoutConfig } from './useLayout';

    import { DASHBOARD_STATUS } from '../constants/dashboard.constants';

    import { useViewport } from './useViewport';

    import { useListNavigator } from './useListNavigator';

    import path from 'node:path';

    import { execSync } from 'node:child_process';


    export const useDashboardScreen = ({ layoutConfig }: { layoutConfig:
    LayoutConfig }) => {
        const {
            status,
            selectedTransactionIndex,
            expandedTransactionId,
        } = useDashboardStore();
        const transactions = useTransactionStore(s => s.transactions);
        const [newTransactionIds, setNewTransactionIds] = useState(new Set<string>());
        const prevTransactionIds = useRef(new Set(transactions.map(t => t.id)));

        const pendingTransactions = useTransactionStore(selectTransactionsByStatus('PENDING'));
        const appliedTransactions = useTransactionStore(selectTransactionsByStatus('APPLIED'));

        const { viewOffset, viewportHeight } = useViewport({
            selectedIndex: selectedTransactionIndex,
            itemCount: transactions.length,
            layoutConfig,
        });

        useEffect(() => {
            const currentIds = new Set(transactions.map(t => t.id));
            const newIds = new Set<string>();

            for (const id of currentIds) {
                if (!prevTransactionIds.current.has(id)) {
                    newIds.add(id);
                }
            }

            if (newIds.size > 0) {
                setNewTransactionIds(current => new Set([...current, ...newIds]));
                newIds.forEach(id => {
                    setTimeout(() => {
                        setNewTransactionIds(current => {
                            const next = new Set(current);
                            next.delete(id);
                            return next;
                        });
                    }, 1000);
                });
            }

            prevTransactionIds.current = currentIds;
        }, [transactions]);

        const {
            togglePause,
            startApproveAll,
            confirmAction,
            cancelAction,
            toggleExpand,
        } = useDashboardStore(s => s.actions);
        const appActions = useAppStore(s => s.actions);
        const commitActions = useCommitStore(s => s.actions);

        const pendingApprovals = pendingTransactions.length;
        const pendingCommits = appliedTransactions.length;

        const isModal = status === DASHBOARD_STATUS.CONFIRM_APPROVE;
        const isProcessing = status === DASHBOARD_STATUS.APPROVING;

        const viewDetails = () => {
            const selectedTx = transactions[selectedTransactionIndex];
            if (!selectedTx) return;

            if (selectedTx.status === 'PENDING') {
                useReviewStore.getState().actions.load(selectedTx.id);
                appActions.showReviewScreen();
            } else {
                useDetailStore.getState().actions.load(selectedTx.id);
                appActions.showTransactionDetailScreen();
            }
        };

        useInput((_input, key) => {
            if (key.return) confirmAction();
            if (key.escape) cancelAction();
        }, { isActive: isModal });

        useListNavigator({
            itemCount: transactions.length,
            viewportHeight,
            selectedIndex: selectedTransactionIndex,
            onIndexChange: (index) => {
                useDashboardStore.getState().actions.setSelectedIndex(index);
                useDashboardStore.getState().actions.setExpandedTransactionId(null);
            },
            isActive: !isModal && !isProcessing,
            onKey: (input, key) => {
                if (key.leftArrow) {
                    if (expandedTransactionId) toggleExpand();
                    return;
                }
                if (key.rightArrow) {
                    if (transactions[selectedTransactionIndex]) {
                        if (!expandedTransactionId) toggleExpand();
                        else viewDetails();
                    }
                    return;
                }
                if (key.return) viewDetails();
                if (input.toLowerCase() === 'p') togglePause();
                if (input.toLowerCase() === 'a' && pendingApprovals > 0) startApproveAll();
                if (input.toLowerCase() === 'c' && pendingCommits > 0) {
                    commitActions.prepareCommitScreen();
                    appActions.showGitCommitScreen();
                }
                if (input.toLowerCase() === 'l') {
                    useHistoryStore.getState().actions.load();
                    appActions.showTransactionHistoryScreen();
                }
            },
        });

        const transactionsToConfirm = status === DASHBOARD_STATUS.CONFIRM_APPROVE ? pendingTransactions : [];

        const contextInfo = useMemo(() => {
            try {
                const cwd = process.cwd();
                const parentDir = path.basename(path.dirname(cwd));
                const currentDir = path.basename(cwd);
                const shortCwd = `.../${parentDir}/${currentDir}`;
                const gitBranch = execSync('git rev-parse --abbrev-ref HEAD').toString().trim();
                return `[${shortCwd} @ ${gitBranch}]`;
            } catch (error) {
                return '[Context unavailable]'; // Handle cases where not in a git repo, etc.
            }
        }, []);

        return {
            status,
            transactions,
            selectedTransactionIndex,
            expandedTransactionId,
            pendingApprovals,
            pendingCommits,
            isModal,
            isProcessing,
            newTransactionIds,
            viewOffset,
            viewportHeight,
            transactionsToConfirm,
            contextInfo,
        };
    };
  src/components/layout/ScreenLayout.tsx: >-
    import { Box, Text } from 'ink';

    import Separator from '../Separator';


    interface ScreenLayoutProps {
        title: string;
        footer: React.ReactNode;
        children: React.ReactNode;
        contextInfo?: string;
    }


    const ScreenLayout = ({ title, footer, children, contextInfo }:
    ScreenLayoutProps) => {
        return (
            <Box flexDirection="column" flexGrow={1}>
                <Box flexDirection="row">
                    <Text bold color="black" backgroundColor="yellow"> ▲ relaycode · {title} </Text>
                    <Box flexGrow={1} />
                    {contextInfo && <Text color="gray">{contextInfo}</Text>}
                </Box>
                <Separator />
                <Box flexDirection="column" flexGrow={1} marginY={1}>
                    {children}
                </Box>
                <Separator />
                <Box>
                    {footer}
                </Box>
            </Box>
        );
    };


    export default ScreenLayout;
approved: false
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: undone
id: 240
