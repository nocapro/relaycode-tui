uuid: f1936c34-a3f8-4547-88f1-826f5f9e71ab
projectId: relaycode-tui
createdAt: '2025-09-25T01:48:53.671Z'
gitCommitMsg: >-
  refactor: centralize application constants

  Introduces a new `src/constants` directory to consolidate hardcoded values,
  magic strings, and constant objects from across the application. This change
  improves maintainability and establishes a single source of truth for shared
  values.

  - Creates categorized constant files for app, view, copy, init, review, and
  detail domains. - Updates type definitions to derive string literal types from
  these constants. - Refactors stores, services, components, and hooks to import
  and use the new centralized constants.
promptSummary: >-
  Refactor all constants out of the application code and into dedicated files in
  a new `src/constants` directory.
reasoning:
  - >-
    I will now execute the plan to refactor constants into their dedicated
    files.
  - >-
    First, I will create the new constant files in the `src/constants`
    directory.
  - Next, I will update the type definition files.
  - Now, I will refactor the stores and services to use the new constants.
  - Finally, I will update the components and hooks.
operations:
  - type: write
    path: src/constants/view.constants.ts
    content: |-
      /**
       * UI-related constants for view layers, components, and hooks.
       */
      export const VIEW_CONSTANTS = {
          // DiffScreen
          DIFF_COLLAPSE_THRESHOLD: 20,
          DIFF_COLLAPSE_SHOW_LINES: 8,

          // DashboardScreen
          DASHBOARD_NON_EVENT_STREAM_HEIGHT: 9,

          // TransactionHistoryScreen
          HISTORY_NON_CONTENT_HEIGHT: 8,

          // SplashScreen
          SPLASH_INITIAL_COUNTDOWN: 3,
      } as const;
    patchStrategy: replace
  - type: write
    path: src/constants/app.constants.ts
    content: |-
      /**
       * Application-level screens and navigation constants.
       */
      export const APP_SCREENS = {
          SPLASH: 'splash',
          INIT: 'init',
          DASHBOARD: 'dashboard',
          REVIEW: 'review',
          REVIEW_PROCESSING: 'review-processing',
          GIT_COMMIT: 'git-commit',
          TRANSACTION_DETAIL: 'transaction-detail',
          TRANSACTION_HISTORY: 'transaction-history',
      } as const;

      export const MAIN_SCREENS_FOR_QUIT = [
          APP_SCREENS.DASHBOARD,
          APP_SCREENS.INIT,
      ];
    patchStrategy: replace
  - type: write
    path: src/constants/copy.constants.ts
    content: |-
      /**
       * Constants for the Copy/Clipboard feature.
       */
      export const COPYABLE_ITEMS = {
          UUID: 'UUID',
          MESSAGE: 'Git Message',
          PROMPT: 'Prompt',
          REASONING: 'Reasoning',
          FILE_DIFF: 'Diff for',
          ALL_DIFFS: 'All Diffs',
          FULL_YAML: 'Full YAML representation',
          // For multi-selection contexts
          MESSAGES: 'Git Messages',
          PROMPTS: 'Prompts',
          REASONINGS: 'Reasonings',
          DIFFS: 'Diffs',
          UUIDS: 'UUIDs',
      } as const;
    patchStrategy: replace
  - type: write
    path: src/constants/init.constants.ts
    content: |-
      import type { Task } from '../stores/init.store';

      /**
       * Constants for the Initialization process.
       */
      export const INITIAL_ANALYZE_TASKS: Task[] = [
          { id: 'scan', title: 'Scanning project structure...', subtext: 'Finding package.json', status: 'pending' },
          { id: 'project-id', title: 'Determining Project ID', status: 'pending' },
          { id: 'gitignore', title: 'Checking for existing .gitignore', status: 'pending' },
      ];

      export const INITIAL_CONFIGURE_TASKS: Task[] = [
          { id: 'config', title: 'Creating relay.config.json', subtext: 'Writing default configuration with Project ID', status: 'pending' },
          { id: 'state-dir', title: 'Initializing .relay state directory', status: 'pending' },
          { id: 'prompt', title: 'Generating system prompt template', status: 'pending' },
      ];
    patchStrategy: replace
  - type: write
    path: src/constants/review.constants.ts
    content: |-
      import type { ApplyStep } from '../stores/review.store';

      /**
       * Constants for the Review screen and process.
       */
      export const INITIAL_APPLY_STEPS: ApplyStep[] = [
          { id: 'snapshot', title: 'Reading initial file snapshot...', status: 'pending' },
          { id: 'memory', title: 'Applying operations to memory...', status: 'pending', substeps: [] },
          { id: 'post-command', title: 'Running post-command script...', status: 'pending', substeps: [] },
          { id: 'linter', title: 'Analyzing changes with linter...', status: 'pending', substeps: [] },
      ];
    patchStrategy: replace
  - type: write
    path: src/constants/detail.constants.ts
    content: |-
      /**
       * Constants for the Transaction Detail screen.
       */
      export const NAVIGATOR_SECTIONS = {
          PROMPT: 'PROMPT',
          REASONING: 'REASONING',
          FILES: 'FILES',
      } as const;

      export const DETAIL_BODY_VIEWS = {
          PROMPT: 'PROMPT',
          REASONING: 'REASONING',
          FILES_LIST: 'FILES_LIST',
          DIFF_VIEW: 'DIFF_VIEW',
          REVERT_CONFIRM: 'REVERT_CONFIRM',
          NONE: 'NONE',
      } as const;
    patchStrategy: replace
  - type: write
    path: src/types/copy.types.ts
    content: |-
      export interface CopyItem {
          id: string;
          key: string;
          label: string;
          getData: () => string;
          isDefaultSelected?: boolean;
      }
    patchStrategy: replace
  - type: write
    path: src/types/view.types.ts
    content: |-
      import type { APP_SCREENS } from '../constants/app.constants';

      // --- UI / View-Specific Types ---

      // app.store
      type ObjectValues<T> = T[keyof T];

      export type AppScreen = ObjectValues<typeof APP_SCREENS>;
    patchStrategy: replace
  - type: write
    path: src/services/copy.service.ts
    content: |+
      --- src/services/copy.service.ts
      +++ src/services/copy.service.ts
      @@ -1,6 +1,6 @@
       import type { Transaction, FileItem } from '../types/domain.types';
       import type { CopyItem } from '../types/copy.types';
      -import { COPYABLE_ITEMS } from '../types/copy.types';
      +import { COPYABLE_ITEMS } from '../constants/copy.constants';
       
       const createBaseTransactionCopyItems = (transaction: Transaction): CopyItem[] => [
           { id: 'uuid', key: 'U', label: COPYABLE_ITEMS.UUID, getData: () => transaction.id },

    patchStrategy: standard-diff
  - type: write
    path: src/services/init.service.ts
    content: >+
      --- src/services/init.service.ts

      +++ src/services/init.service.ts

      @@ -1,23 +1,11 @@
       import { useInitStore } from '../stores/init.store';
      -import type { Task } from '../stores/init.store';
       import { sleep } from '../utils';
      -

      -const initialAnalyzeTasks: Task[] = [

      -    { id: 'scan', title: 'Scanning project structure...', subtext:
      'Finding package.json', status: 'pending' },

      -    { id: 'project-id', title: 'Determining Project ID', status:
      'pending' },

      -    { id: 'gitignore', title: 'Checking for existing .gitignore', status:
      'pending' },

      -];

      -

      -const initialConfigureTasks: Task[] = [

      -    { id: 'config', title: 'Creating relay.config.json', subtext:
      'Writing default configuration with Project ID', status: 'pending' },

      -    { id: 'state-dir', title: 'Initializing .relay state directory',
      status: 'pending' },

      -    { id: 'prompt', title: 'Generating system prompt template', status:
      'pending' },

      -];

      +import { INITIAL_ANALYZE_TASKS, INITIAL_CONFIGURE_TASKS } from
      '../constants/init.constants';
       
       const runInitializationProcess = async () => {
           const { actions } = useInitStore.getState();
           actions.resetInit();
      -    actions.setTasks(initialAnalyzeTasks, initialConfigureTasks);

      +    actions.setTasks(INITIAL_ANALYZE_TASKS, INITIAL_CONFIGURE_TASKS);
       
           actions.setPhase('ANALYZE');
      -    for (const task of initialAnalyzeTasks) {

      +    for (const task of INITIAL_ANALYZE_TASKS) {
               actions.updateAnalyzeTask(task.id, 'active');
               await sleep(800);
               actions.updateAnalyzeTask(task.id, 'done');
      @@ -26,7 +14,7 @@
           await sleep(500);
       
           actions.setPhase('CONFIGURE');
      -    const configTasksUntilInteractive = initialConfigureTasks.slice(0,
      2);

      +    const configTasksUntilInteractive = INITIAL_CONFIGURE_TASKS.slice(0,
      2);
           for (const task of configTasksUntilInteractive) {
               actions.updateConfigureTask(task.id, 'active');
               await sleep(800);
      @@ -40,7 +28,7 @@
           const { actions } = useInitStore.getState();
           
           actions.setPhase('CONFIGURE');
      -    const lastTask = initialConfigureTasks[2];

      +    const lastTask = INITIAL_CONFIGURE_TASKS[2];
           if (lastTask) {
               actions.updateConfigureTask(lastTask.id, 'active');
               await sleep(800);

    patchStrategy: standard-diff
  - type: write
    path: src/stores/detail.store.ts
    content: >+
      --- src/stores/detail.store.ts

      +++ src/stores/detail.store.ts

      @@ -2,10 +2,15 @@
       import { useTransactionStore } from './transaction.store';
       import { useViewStore } from './view.store';
       import { TransactionService } from '../services/transaction.service';
      +import { NAVIGATOR_SECTIONS, DETAIL_BODY_VIEWS } from
      '../constants/detail.constants';
       
      -export type NavigatorSection = 'PROMPT' | 'REASONING' | 'FILES';

      -export type DetailBodyView = 'PROMPT' | 'REASONING' | 'FILES_LIST' |
      'DIFF_VIEW' | 'REVERT_CONFIRM' | 'NONE';

      +type ObjectValues<T> = T[keyof T];

      +

      +export type NavigatorSection = ObjectValues<typeof NAVIGATOR_SECTIONS>;

      +export type DetailBodyView = ObjectValues<typeof DETAIL_BODY_VIEWS>;
        
       interface DetailState {
           navigatorFocus: NavigatorSection | 'FILES_LIST';
      @@ -23,32 +28,32 @@
       }
       
       export const useDetailStore = create<DetailState>((set, get) => ({
      -    navigatorFocus: 'PROMPT',

      +    navigatorFocus: NAVIGATOR_SECTIONS.PROMPT,
           expandedSection: null,
           selectedFileIndex: 0,
      -    bodyView: 'NONE',

      +    bodyView: DETAIL_BODY_VIEWS.NONE,
           actions: {
               load: (transactionId) => {
                   useViewStore.getState().actions.setSelectedTransactionId(transactionId);
                   set({
      -                navigatorFocus: 'PROMPT',

      +                navigatorFocus: NAVIGATOR_SECTIONS.PROMPT,
                       expandedSection: null,
                       selectedFileIndex: 0,
      -                bodyView: 'NONE',

      +                bodyView: DETAIL_BODY_VIEWS.NONE,
                   });
               },
               navigateUp: () => {
      -            const navigatorOrder: NavigatorSection[] = ['PROMPT',
      'REASONING', 'FILES'];

      +            const navigatorOrder: NavigatorSection[] =
      [NAVIGATOR_SECTIONS.PROMPT, NAVIGATOR_SECTIONS.REASONING,
      NAVIGATOR_SECTIONS.FILES];
                   const { navigatorFocus, selectedFileIndex } = get();
                   if (navigatorFocus === 'FILES_LIST') {
                       set({ selectedFileIndex: Math.max(0, selectedFileIndex - 1) });
                   } else {
                       const currentIndex = navigatorOrder.indexOf(navigatorFocus as NavigatorSection);
                       if (currentIndex > 0) {
      -                    set({ navigatorFocus: navigatorOrder[currentIndex -
      1] });

      +                    set({ navigatorFocus: navigatorOrder[currentIndex -
      1]! });
                       }
                   }
               },
               navigateDown: () => {
      -            const navigatorOrder: NavigatorSection[] = ['PROMPT',
      'REASONING', 'FILES'];

      +            const navigatorOrder: NavigatorSection[] =
      [NAVIGATOR_SECTIONS.PROMPT, NAVIGATOR_SECTIONS.REASONING,
      NAVIGATOR_SECTIONS.FILES];
                   const { navigatorFocus, selectedFileIndex } = get();
                   const { selectedTransactionId } = useViewStore.getState();
                   const transaction = useTransactionStore.getState().transactions.find(tx => tx.id === selectedTransactionId);
      @@ -64,41 +69,41 @@
               handleEnterOrRight: () => {
                   const { navigatorFocus, expandedSection } = get();
                   if (navigatorFocus === 'FILES_LIST') {
      -                set({ bodyView: 'DIFF_VIEW' });

      +                set({ bodyView: DETAIL_BODY_VIEWS.DIFF_VIEW });
                       return;
                   }
                   if (expandedSection === navigatorFocus) {
      -                if (navigatorFocus === 'FILES') {

      -                    set({ navigatorFocus: 'FILES_LIST', bodyView:
      'FILES_LIST' });

      +                if (navigatorFocus === NAVIGATOR_SECTIONS.FILES) {

      +                    set({ navigatorFocus: 'FILES_LIST', bodyView:
      DETAIL_BODY_VIEWS.FILES_LIST });
                       }
                       return;
                   }
                   set({ expandedSection: navigatorFocus as NavigatorSection });
      -            if (navigatorFocus === 'PROMPT') set({ bodyView: 'PROMPT' });

      -            if (navigatorFocus === 'REASONING') set({ bodyView:
      'REASONING' });

      -            if (navigatorFocus === 'FILES') set({ bodyView: 'FILES_LIST'
      });

      +            if (navigatorFocus === NAVIGATOR_SECTIONS.PROMPT) set({
      bodyView: DETAIL_BODY_VIEWS.PROMPT });

      +            if (navigatorFocus === NAVIGATOR_SECTIONS.REASONING) set({
      bodyView: DETAIL_BODY_VIEWS.REASONING });

      +            if (navigatorFocus === NAVIGATOR_SECTIONS.FILES) set({
      bodyView: DETAIL_BODY_VIEWS.FILES_LIST });
               },
               handleEscapeOrLeft: () => {
                   const { navigatorFocus, expandedSection, bodyView } = get();
      -            if (bodyView === 'DIFF_VIEW') {

      -                set({ bodyView: 'FILES_LIST' });

      +            if (bodyView === DETAIL_BODY_VIEWS.DIFF_VIEW) {

      +                set({ bodyView: DETAIL_BODY_VIEWS.FILES_LIST });
                       return;
                   }
                   if (navigatorFocus === 'FILES_LIST') {
      -                set({ navigatorFocus: 'FILES', bodyView: 'NONE' });

      +                set({ navigatorFocus: NAVIGATOR_SECTIONS.FILES, bodyView:
      DETAIL_BODY_VIEWS.NONE });
                       return;
                   }
                   if (expandedSection) {
      -                set({ expandedSection: null, bodyView: 'NONE' });

      +                set({ expandedSection: null, bodyView:
      DETAIL_BODY_VIEWS.NONE });
                   }
               },
               toggleRevertConfirm: () => set(state => ({
      -            bodyView: state.bodyView === 'REVERT_CONFIRM' ? 'NONE' :
      'REVERT_CONFIRM',

      +            bodyView: state.bodyView === DETAIL_BODY_VIEWS.REVERT_CONFIRM
      ? DETAIL_BODY_VIEWS.NONE : DETAIL_BODY_VIEWS.REVERT_CONFIRM,
               })),
               confirmRevert: () => {
                   const { selectedTransactionId } = useViewStore.getState();
                   if (!selectedTransactionId) return;
                   TransactionService.revertTransaction(selectedTransactionId);
                   useTransactionStore.getState().actions.updateTransactionStatus(selectedTransactionId, 'REVERTED');
      -            set({ bodyView: 'NONE' });

      +            set({ bodyView: DETAIL_BODY_VIEWS.NONE });
               },
           },
       }));

    patchStrategy: standard-diff
  - type: write
    path: src/stores/review.store.ts
    content: >+
      --- src/stores/review.store.ts

      +++ src/stores/review.store.ts

      @@ -4,6 +4,7 @@
       import { useViewStore } from './view.store';
       import { ReviewService } from '../services/review.service';
       import { moveIndex } from './navigation.utils';
      +import { INITIAL_APPLY_STEPS } from '../constants/review.constants';
       import type { FileReviewStatus } from '../types/domain.types';
       
       export interface ApplyStep {
      @@ -19,14 +20,6 @@
       export type ApplyUpdate =
           | { type: 'UPDATE_STEP'; payload: { id: string; status: ApplyStep['status']; duration?: number; details?: string } }
           | { type: 'ADD_SUBSTEP'; payload: { parentId: string; substep: Omit<ApplyStep, 'substeps'> } };
      -

      -export const initialApplySteps: ApplyStep[] = [

      -    { id: 'snapshot', title: 'Reading initial file snapshot...', status:
      'pending' },

      -    { id: 'memory', title: 'Applying operations to memory...', status:
      'pending', substeps: [] },

      -    { id: 'post-command', title: 'Running post-command script...',
      status: 'pending', substeps: [] },

      -    { id: 'linter', title: 'Analyzing changes with linter...', status:
      'pending', substeps: [] },

      -];
       
       interface ReviewState {
           patchStatus: PatchStatus;
      @@ -62,7 +55,7 @@
       
       export const useReviewStore = create<ReviewState>((set, get) => ({
           patchStatus: 'SUCCESS',
      -    applySteps: initialApplySteps,

      +    applySteps: INITIAL_APPLY_STEPS,
           selectedItemIndex: 0,
           bodyView: 'none',
           isDiffExpanded: false,
      @@ -86,7 +79,7 @@
                       isDiffExpanded: false,
                       reasoningScrollIndex: 0,
                       scriptErrorIndex: 0,
      -                applySteps:
      JSON.parse(JSON.stringify(initialApplySteps)),

      +                applySteps:
      JSON.parse(JSON.stringify(INITIAL_APPLY_STEPS)),
                   });
               },
               moveSelectionUp: () => set(state => {
      @@ -120,7 +113,7 @@
               startApplySimulation: async (scenario) => {
                   const { showReviewProcessingScreen, showReviewScreen } = useAppStore.getState().actions;
                   const { updateApplyStep, addApplySubstep } = get().actions;
      -            set({ applySteps:
      JSON.parse(JSON.stringify(initialApplySteps)) });

      +            set({ applySteps:
      JSON.parse(JSON.stringify(INITIAL_APPLY_STEPS)) });
                   showReviewProcessingScreen();
                   const simulationGenerator = ReviewService.runApplySimulation(scenario);
                   for await (const update of simulationGenerator) {

    patchStrategy: standard-diff
  - type: write
    path: src/components/DiffScreen.tsx
    content: |+
      --- src/components/DiffScreen.tsx
      +++ src/components/DiffScreen.tsx
      @@ -1,13 +1,14 @@
       import React from 'react';
       import { Box, Text } from 'ink';
      +import { VIEW_CONSTANTS } from '../constants/view.constants';
       
       interface DiffScreenProps {
           filePath: string;
           diffContent: string;
           isExpanded: boolean;
       }
      -
       const DiffScreen = ({ filePath, diffContent, isExpanded }: DiffScreenProps) => {
           const lines = diffContent.split('\n');
      -    const COLLAPSE_THRESHOLD = 20;
      -    const COLLAPSE_SHOW_LINES = 8;
      +    const COLLAPSE_THRESHOLD = VIEW_CONSTANTS.DIFF_COLLAPSE_THRESHOLD;
      +    const COLLAPSE_SHOW_LINES = VIEW_CONSTANTS.DIFF_COLLAPSE_SHOW_LINES;
       
           const renderContent = () => {
               if (!isExpanded && lines.length > COLLAPSE_THRESHOLD) {

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useDashboardScreen.tsx
    content: >+
      --- src/hooks/useDashboardScreen.tsx

      +++ src/hooks/useDashboardScreen.tsx

      @@ -6,9 +6,10 @@
       import { useReviewStore } from '../stores/review.store';
       import { useDetailStore } from '../stores/detail.store';
       import { useHistoryStore } from '../stores/history.store';
       import { useViewport } from './useViewport';
      +import { VIEW_CONSTANTS } from '../constants/view.constants';
       
       export const useDashboardScreen = () => {
      -    const NON_EVENT_STREAM_HEIGHT = 9; // Header, separators, status,
      footer, etc.

      +    const NON_EVENT_STREAM_HEIGHT =
      VIEW_CONSTANTS.DASHBOARD_NON_EVENT_STREAM_HEIGHT;
           const {
               status,
               selectedTransactionIndex,

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useDebugMenu.tsx
    content: |+
      --- src/hooks/useDebugMenu.tsx
      +++ src/hooks/useDebugMenu.tsx
      @@ -9,7 +9,7 @@
       import { useInitStore } from '../stores/init.store';
       import { useCommitStore } from '../stores/commit.store';
       import { useCopyStore } from '../stores/copy.store';
      -import { COPYABLE_ITEMS } from '../types/copy.types';
      +import { COPYABLE_ITEMS } from '../constants/copy.constants';
       import { CopyService } from '../services/copy.service';
       import type { MenuItem } from '../types/debug.types';
       import { useTransactionStore } from '../stores/transaction.store';

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useGlobalHotkeys.tsx
    content: |+
      --- src/hooks/useGlobalHotkeys.tsx
      +++ src/hooks/useGlobalHotkeys.tsx
      @@ -1,8 +1,7 @@
       import { useApp, useInput } from 'ink';
       import { useAppStore } from '../stores/app.store';
       import { useViewStore } from '../stores/view.store';
      -
      -const MAIN_SCREENS_FOR_QUIT: string[] = ['dashboard', 'init'];
      +import { MAIN_SCREENS_FOR_QUIT } from '../constants/app.constants';
       
       export const useGlobalHotkeys = ({ isActive }: { isActive: boolean }) => {
           const { exit } = useApp();

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useSplashScreen.tsx
    content: >+
      --- src/hooks/useSplashScreen.tsx

      +++ src/hooks/useSplashScreen.tsx

      @@ -1,9 +1,10 @@
       import { useState, useEffect } from 'react';
       import { useInput } from 'ink';
       import { useAppStore } from '../stores/app.store';
      +import { VIEW_CONSTANTS } from '../constants/view.constants';
       
       export const useSplashScreen = () => {
           const showInitScreen = useAppStore(state => state.actions.showInitScreen);
      -    const [countdown, setCountdown] = useState(3);

      +    const [countdown, setCountdown] =
      useState(VIEW_CONSTANTS.SPLASH_INITIAL_COUNTDOWN);
       
           const handleSkip = () => {
               showInitScreen();

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useTransactionHistoryScreen.tsx
    content: >+
      --- src/hooks/useTransactionHistoryScreen.tsx

      +++ src/hooks/useTransactionHistoryScreen.tsx

      @@ -5,6 +5,7 @@
       import { useCopyStore } from '../stores/copy.store';
       import { getVisibleItemPaths } from '../stores/navigation.utils';
       import { useViewport } from './useViewport';
      +import { VIEW_CONSTANTS } from '../constants/view.constants';
       
       export const useTransactionHistoryScreen = () => {
           const store = useHistoryStore();
      @@ -18,7 +19,7 @@
           );
           const selectedIndex = visibleItemPaths.indexOf(selectedItemPath);
       
      -    const NON_CONTENT_HEIGHT = 8; // Header, filter, separators, footer,
      etc.

      +    const NON_CONTENT_HEIGHT = VIEW_CONSTANTS.HISTORY_NON_CONTENT_HEIGHT;
           const { viewOffset, viewportHeight } = useViewport({
               selectedIndex,
               padding: NON_CONTENT_HEIGHT,

    patchStrategy: standard-diff
snapshot:
  src/constants/view.constants.ts: null
  src/constants/copy.constants.ts: null
  src/constants/init.constants.ts: null
  src/constants/app.constants.ts: null
  src/constants/review.constants.ts: null
  src/constants/detail.constants.ts: null
  src/types/copy.types.ts: |-
    export interface CopyItem {
        id: string;
        key: string;
        label: string;
        getData: () => string;
        isDefaultSelected?: boolean;
    }

    export const COPYABLE_ITEMS = {
        UUID: 'UUID',
        MESSAGE: 'Git Message',
        PROMPT: 'Prompt',
        REASONING: 'Reasoning',
        FILE_DIFF: 'Diff for',
        ALL_DIFFS: 'All Diffs',
        FULL_YAML: 'Full YAML representation',
        // For multi-selection contexts
        MESSAGES: 'Git Messages',
        PROMPTS: 'Prompts',
        REASONINGS: 'Reasonings',
        DIFFS: 'Diffs',
        UUIDS: 'UUIDs',
    } as const;
  src/types/view.types.ts: >-
    // --- UI / View-Specific Types ---


    // app.store

    export type AppScreen = 'splash' | 'init' | 'dashboard' | 'review' |
    'review-processing' | 'git-commit' | 'transaction-detail' |
    'transaction-history';
  src/services/copy.service.ts: >-
    import type { Transaction, FileItem } from '../types/domain.types';

    import type { CopyItem } from '../types/copy.types';

    import { COPYABLE_ITEMS } from '../types/copy.types';


    const createBaseTransactionCopyItems = (transaction: Transaction):
    CopyItem[] => [
        { id: 'uuid', key: 'U', label: COPYABLE_ITEMS.UUID, getData: () => transaction.id },
        { id: 'message', key: 'M', label: COPYABLE_ITEMS.MESSAGE, getData: () => transaction.message },
        { id: 'prompt', key: 'P', label: COPYABLE_ITEMS.PROMPT, getData: () => transaction.prompt || '' },
        { id: 'reasoning', key: 'R', label: COPYABLE_ITEMS.REASONING, getData: () => transaction.reasoning || '' },
    ];


    const getCopyItemsForReview = (
        transaction: Transaction,
        files: FileItem[],
        selectedFile?: FileItem,
    ): CopyItem[] => {
        return [
            ...createBaseTransactionCopyItems(transaction),
            { id: 'file_diff', key: 'F', label: `${COPYABLE_ITEMS.FILE_DIFF}${selectedFile ? `: ${selectedFile.path}` : ''}`, getData: () => selectedFile?.diff || 'No file selected' },
            { id: 'all_diffs', key: 'A', label: COPYABLE_ITEMS.ALL_DIFFS, getData: () => files.map(f => `--- FILE: ${f.path} ---\n${f.diff}`).join('\n\n') },
        ];
    };


    const getCopyItemsForDetail = (
        transaction: Transaction,
        selectedFile?: FileItem,
    ): CopyItem[] => {
        const baseItems = createBaseTransactionCopyItems(transaction);
        const messageItem = { ...baseItems.find(i => i.id === 'message')!, isDefaultSelected: true };
        const promptItem = baseItems.find(i => i.id === 'prompt')!;
        const reasoningItem = { ...baseItems.find(i => i.id === 'reasoning')!, isDefaultSelected: true };
        const uuidItem = baseItems.find(i => i.id === 'uuid')!;

        return [
            messageItem,
            promptItem,
            reasoningItem,
            { id: 'all_diffs', key: 'A', label: `${COPYABLE_ITEMS.ALL_DIFFS} (${transaction.files?.length || 0} files)`, getData: () => transaction.files?.map(f => `--- FILE: ${f.path} ---\n${f.diff}`).join('\n\n') || '' },
            { id: 'file_diff', key: 'F', label: `${COPYABLE_ITEMS.FILE_DIFF}: ${selectedFile?.path || 'No file selected'}`, getData: () => selectedFile?.diff || 'No file selected' },
            uuidItem,
            { id: 'yaml', key: 'Y', label: COPYABLE_ITEMS.FULL_YAML, getData: () => '... YAML representation ...' }, // Mocking this
        ];
    };


    const getCopyItemsForHistory = (
        transactions: Transaction[],
    ): CopyItem[] => {
        if (transactions.length === 0) return [];
        
        return [
            { id: 'messages', key: 'M', label: COPYABLE_ITEMS.MESSAGES, getData: () => transactions.map(tx => tx.message).join('\n'), isDefaultSelected: true },
            { id: 'prompts', key: 'P', label: COPYABLE_ITEMS.PROMPTS, getData: () => transactions.map(tx => tx.prompt || '').join('\n\n---\n\n'), isDefaultSelected: false },
            { id: 'reasonings', key: 'R', label: COPYABLE_ITEMS.REASONINGS, getData: () => transactions.map(tx => tx.reasoning || '').join('\n\n---\n\n'), isDefaultSelected: true },
            { id: 'diffs', key: 'D', label: COPYABLE_ITEMS.DIFFS, getData: () => transactions.flatMap(tx => tx.files?.map(f => `--- TX: ${tx.hash}, FILE: ${f.path} ---\n${f.diff}`)).join('\n\n') },
            { id: 'uuids', key: 'U', label: COPYABLE_ITEMS.UUIDS, getData: () => transactions.map(tx => tx.id).join('\n') },
            { id: 'yaml', key: 'Y', label: COPYABLE_ITEMS.FULL_YAML, getData: () => '... YAML representation ...' },
        ];
    };


    export const CopyService = {
        getCopyItemsForReview,
        getCopyItemsForDetail,
        getCopyItemsForHistory,
    };
  src/services/init.service.ts: |-
    import { useInitStore } from '../stores/init.store';
    import type { Task } from '../stores/init.store';
    import { sleep } from '../utils';

    const initialAnalyzeTasks: Task[] = [
        { id: 'scan', title: 'Scanning project structure...', subtext: 'Finding package.json', status: 'pending' },
        { id: 'project-id', title: 'Determining Project ID', status: 'pending' },
        { id: 'gitignore', title: 'Checking for existing .gitignore', status: 'pending' },
    ];

    const initialConfigureTasks: Task[] = [
        { id: 'config', title: 'Creating relay.config.json', subtext: 'Writing default configuration with Project ID', status: 'pending' },
        { id: 'state-dir', title: 'Initializing .relay state directory', status: 'pending' },
        { id: 'prompt', title: 'Generating system prompt template', status: 'pending' },
    ];

    const runInitializationProcess = async () => {
        const { actions } = useInitStore.getState();
        actions.resetInit();
        actions.setTasks(initialAnalyzeTasks, initialConfigureTasks);

        actions.setPhase('ANALYZE');
        for (const task of initialAnalyzeTasks) {
            actions.updateAnalyzeTask(task.id, 'active');
            await sleep(800);
            actions.updateAnalyzeTask(task.id, 'done');
        }
        actions.setAnalysisResults('relaycode (from package.json)', true);
        await sleep(500);

        actions.setPhase('CONFIGURE');
        const configTasksUntilInteractive = initialConfigureTasks.slice(0, 2);
        for (const task of configTasksUntilInteractive) {
            actions.updateConfigureTask(task.id, 'active');
            await sleep(800);
            actions.updateConfigureTask(task.id, 'done');
        }
        await sleep(500);

        actions.setPhase('INTERACTIVE');
    };

    const resumeInitializationProcess = async () => {
        const { actions } = useInitStore.getState();
        
        actions.setPhase('CONFIGURE');
        const lastTask = initialConfigureTasks[2];
        if (lastTask) {
            actions.updateConfigureTask(lastTask.id, 'active');
            await sleep(800);
            actions.updateConfigureTask(lastTask.id, 'done');
            await sleep(500);

            actions.setPhase('FINALIZE');
        }
    };

    export const InitService = {
        runInitializationProcess,
        resumeInitializationProcess,
    };
  src/stores/detail.store.ts: >-
    import { create } from 'zustand';

    import { useTransactionStore } from './transaction.store';

    import { useViewStore } from './view.store';

    import { TransactionService } from '../services/transaction.service';


    export type NavigatorSection = 'PROMPT' | 'REASONING' | 'FILES';

    export type DetailBodyView = 'PROMPT' | 'REASONING' | 'FILES_LIST' |
    'DIFF_VIEW' | 'REVERT_CONFIRM' | 'NONE';
     
    interface DetailState {
        navigatorFocus: NavigatorSection | 'FILES_LIST';
        expandedSection: NavigatorSection | null;
        selectedFileIndex: number;
        bodyView: DetailBodyView;
        actions: {
            load: (transactionId: string) => void;
            navigateUp: () => void;
            navigateDown: () => void;
            handleEnterOrRight: () => void;
            handleEscapeOrLeft: () => void;
            toggleRevertConfirm: () => void;
            confirmRevert: () => void;
        };
    }


    export const useDetailStore = create<DetailState>((set, get) => ({
        navigatorFocus: 'PROMPT',
        expandedSection: null,
        selectedFileIndex: 0,
        bodyView: 'NONE',
        actions: {
            load: (transactionId) => {
                useViewStore.getState().actions.setSelectedTransactionId(transactionId);
                set({
                    navigatorFocus: 'PROMPT',
                    expandedSection: null,
                    selectedFileIndex: 0,
                    bodyView: 'NONE',
                });
            },
            navigateUp: () => {
                const navigatorOrder: NavigatorSection[] = ['PROMPT', 'REASONING', 'FILES'];
                const { navigatorFocus, selectedFileIndex } = get();
                if (navigatorFocus === 'FILES_LIST') {
                    set({ selectedFileIndex: Math.max(0, selectedFileIndex - 1) });
                } else {
                    const currentIndex = navigatorOrder.indexOf(navigatorFocus as NavigatorSection);
                    if (currentIndex > 0) {
                        set({ navigatorFocus: navigatorOrder[currentIndex - 1] });
                    }
                }
            },
            navigateDown: () => {
                const navigatorOrder: NavigatorSection[] = ['PROMPT', 'REASONING', 'FILES'];
                const { navigatorFocus, selectedFileIndex } = get();
                const { selectedTransactionId } = useViewStore.getState();
                const transaction = useTransactionStore.getState().transactions.find(tx => tx.id === selectedTransactionId);
                const files = transaction?.files || [];
                if (navigatorFocus === 'FILES_LIST') {
                    set({ selectedFileIndex: Math.min(files.length - 1, selectedFileIndex + 1) });
                } else {
                    const currentIndex = navigatorOrder.indexOf(navigatorFocus as NavigatorSection);
                    if (currentIndex < navigatorOrder.length - 1) {
                        set({ navigatorFocus: navigatorOrder[currentIndex + 1]! });
                    }
                }
            },
            handleEnterOrRight: () => {
                const { navigatorFocus, expandedSection } = get();
                if (navigatorFocus === 'FILES_LIST') {
                    set({ bodyView: 'DIFF_VIEW' });
                    return;
                }
                if (expandedSection === navigatorFocus) {
                    if (navigatorFocus === 'FILES') {
                        set({ navigatorFocus: 'FILES_LIST', bodyView: 'FILES_LIST' });
                    }
                    return;
                }
                set({ expandedSection: navigatorFocus as NavigatorSection });
                if (navigatorFocus === 'PROMPT') set({ bodyView: 'PROMPT' });
                if (navigatorFocus === 'REASONING') set({ bodyView: 'REASONING' });
                if (navigatorFocus === 'FILES') set({ bodyView: 'FILES_LIST' });
            },
            handleEscapeOrLeft: () => {
                const { navigatorFocus, expandedSection, bodyView } = get();
                if (bodyView === 'DIFF_VIEW') {
                    set({ bodyView: 'FILES_LIST' });
                    return;
                }
                if (navigatorFocus === 'FILES_LIST') {
                    set({ navigatorFocus: 'FILES', bodyView: 'NONE' });
                    return;
                }
                if (expandedSection) {
                    set({ expandedSection: null, bodyView: 'NONE' });
                }
            },
            toggleRevertConfirm: () => set(state => ({
                bodyView: state.bodyView === 'REVERT_CONFIRM' ? 'NONE' : 'REVERT_CONFIRM',
            })),
            confirmRevert: () => {
                const { selectedTransactionId } = useViewStore.getState();
                if (!selectedTransactionId) return;
                TransactionService.revertTransaction(selectedTransactionId);
                useTransactionStore.getState().actions.updateTransactionStatus(selectedTransactionId, 'REVERTED');
                set({ bodyView: 'NONE' });
            },
        },
    }));
  src/stores/review.store.ts: >-
    import { create } from 'zustand';

    import { useAppStore } from './app.store';

    import { useTransactionStore } from './transaction.store';

    import { useViewStore } from './view.store';

    import { ReviewService } from '../services/review.service';

    import { moveIndex } from './navigation.utils';

    import type { FileReviewStatus } from '../types/domain.types';


    export interface ApplyStep {
        id: string;
        title: string;
        status: 'pending' | 'active' | 'done' | 'failed' | 'skipped';
        details?: string;
        substeps?: ApplyStep[];
        duration?: number;
    }

    export type ReviewBodyView = 'diff' | 'reasoning' | 'script_output' |
    'bulk_repair' | 'confirm_handoff' | 'none';

    export type PatchStatus = 'SUCCESS' | 'PARTIAL_FAILURE';

    export type ApplyUpdate =
        | { type: 'UPDATE_STEP'; payload: { id: string; status: ApplyStep['status']; duration?: number; details?: string } }
        | { type: 'ADD_SUBSTEP'; payload: { parentId: string; substep: Omit<ApplyStep, 'substeps'> } };

    export const initialApplySteps: ApplyStep[] = [
        { id: 'snapshot', title: 'Reading initial file snapshot...', status: 'pending' },
        { id: 'memory', title: 'Applying operations to memory...', status: 'pending', substeps: [] },
        { id: 'post-command', title: 'Running post-command script...', status: 'pending', substeps: [] },
        { id: 'linter', title: 'Analyzing changes with linter...', status: 'pending', substeps: [] },
    ];


    interface ReviewState {
        patchStatus: PatchStatus;
        applySteps: ApplyStep[];
        selectedItemIndex: number;
        bodyView: ReviewBodyView;
        isDiffExpanded: boolean;
        reasoningScrollIndex: number;
        scriptErrorIndex: number;
        fileReviewStates: Map<string, { status: FileReviewStatus; error?: string }>;

        actions: {
            load: (transactionId: string, initialState?: { bodyView: ReviewBodyView }) => void;
            moveSelectionUp: () => void;
            moveSelectionDown: () => void;
            expandDiff: () => void;
            toggleBodyView: (
                view: Extract<ReviewBodyView, 'diff' | 'reasoning' | 'script_output' | 'bulk_repair' | 'confirm_handoff'>
            ) => void;
            setBodyView: (view: ReviewBodyView) => void;
            approve: () => void;
            startApplySimulation: (scenario: 'success' | 'failure') => void;
            tryRepairFile: () => void;
            showBulkRepair: () => void;
            executeBulkRepairOption: (option: number) => Promise<void>;
            confirmHandoff: () => void;
            scrollReasoningUp: () => void;
            scrollReasoningDown: () => void;
            navigateScriptErrorUp: () => void;
            navigateScriptErrorDown: () => void;
            updateApplyStep: (id: string, status: ApplyStep['status'], duration?: number, details?: string) => void;
            addApplySubstep: (parentId: string, substep: Omit<ApplyStep, 'substeps'>) => void;
            updateFileReviewStatus: (fileId: string, status: FileReviewStatus, error?: string) => void;
            toggleFileApproval: (fileId: string) => void;
            rejectAllFiles: () => void;
        };
    }


    export const useReviewStore = create<ReviewState>((set, get) => ({
        patchStatus: 'SUCCESS',
        applySteps: initialApplySteps,
        selectedItemIndex: 0,
        bodyView: 'none',
        isDiffExpanded: false,
        reasoningScrollIndex: 0,
        scriptErrorIndex: 0,
        fileReviewStates: new Map(),

        actions: {
            load: (transactionId, initialState) => {
                const transaction = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!transaction) return;
                
                const { patchStatus, fileReviewStates } = ReviewService.prepareTransactionForReview(transaction);

                useViewStore.getState().actions.setSelectedTransactionId(transaction.id);
                set({
                    patchStatus,
                    fileReviewStates,
                    selectedItemIndex: 0,
                    bodyView: initialState?.bodyView ?? 'none',
                    isDiffExpanded: false,
                    reasoningScrollIndex: 0,
                    scriptErrorIndex: 0,
                    applySteps: JSON.parse(JSON.stringify(initialApplySteps)),
                });
            },
            moveSelectionUp: () => set(state => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!tx) return {};
                const listSize = (tx.files?.length || 0) + (tx.scripts?.length || 0);
                return { selectedItemIndex: moveIndex(state.selectedItemIndex, 'up', listSize) };
            }),
            moveSelectionDown: () => set(state => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!tx) return {};
                const listSize = (tx.files?.length || 0) + (tx.scripts?.length || 0);
                return { selectedItemIndex: moveIndex(state.selectedItemIndex, 'down', listSize) };
            }),
            toggleBodyView: (view) => set(state => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                const files = tx?.files || [];
                if (view === 'diff' && state.selectedItemIndex >= files.length) return {};
                return {
                    bodyView: state.bodyView === view ? 'none' : view,
                    isDiffExpanded: false,
                };
            }),
            setBodyView: (view) => set({ bodyView: view }),
            expandDiff: () => set(state => ({ isDiffExpanded: !state.isDiffExpanded })),
            approve: () => {
                const { selectedTransactionId } = useViewStore.getState();
                if (selectedTransactionId) {
                    useTransactionStore.getState().actions.updateTransactionStatus(selectedTransactionId, 'APPLIED');
                    useAppStore.getState().actions.showDashboardScreen();
                }
            },
            startApplySimulation: async (scenario) => {
                const { showReviewProcessingScreen, showReviewScreen } = useAppStore.getState().actions;
                const { updateApplyStep, addApplySubstep } = get().actions;
                set({ applySteps: JSON.parse(JSON.stringify(initialApplySteps)) });
                showReviewProcessingScreen();
                const simulationGenerator = ReviewService.runApplySimulation(scenario);
                for await (const update of simulationGenerator) {
                    if (update.type === 'UPDATE_STEP') {
                        updateApplyStep(
                            update.payload.id,
                            update.payload.status,
                            update.payload.duration,
                            update.payload.details,
                        );
                    } else if (update.type === 'ADD_SUBSTEP') {
                        addApplySubstep(update.payload.parentId, update.payload.substep);
                    }
                }
                showReviewScreen();
            },
            tryRepairFile: () => {
                const selectedTransactionId = useViewStore.getState().selectedTransactionId;
                const { selectedItemIndex, fileReviewStates } = get();
                if (!selectedTransactionId) return;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                const file = tx?.files?.[selectedItemIndex];
                if (!file) return;

                const { status, error } = fileReviewStates.get(file.id) || {};
                if (status !== 'FAILED') return;
                
                ReviewService.tryRepairFile(file, error);
                get().actions.updateFileReviewStatus(file.id, 'AWAITING');
            },
            showBulkRepair: () => get().actions.toggleBodyView('bulk_repair'),
            executeBulkRepairOption: async (option) => {
                const selectedTransactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                if (!tx?.files) return;

                const failedFiles = tx.files.filter(f => get().fileReviewStates.get(f.id)?.status === 'FAILED');
                if (failedFiles.length === 0) {
                    set({ bodyView: 'none' });
                    return;
                }

                switch (option) {
                    case 1:
                        ReviewService.generateBulkRepairPrompt(failedFiles);
                        set({ bodyView: 'none' });
                        break;
                    case 2: {
                        set({ bodyView: 'none' });
                        failedFiles.forEach(f => get().actions.updateFileReviewStatus(f.id, 'RE_APPLYING'));
                        const results = await ReviewService.runBulkReapply(failedFiles);
                        results.forEach(result =>
                            get().actions.updateFileReviewStatus(
                                result.id, result.status, result.error,
                            ),
                        );
                        break;
                    }
                    case 3:
                        get().actions.setBodyView('confirm_handoff');
                        break;
                    case 4:
                        failedFiles.forEach(file => {
                            get().actions.updateFileReviewStatus(file.id, 'REJECTED');
                        });
                        set({ bodyView: 'none' });
                        break;
                    default:
                        set({ bodyView: 'none' });
                }
            },
            confirmHandoff: () => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!tx?.files) return;
                const { fileReviewStates } = get();
                ReviewService.generateHandoffPrompt(tx, fileReviewStates);
                ReviewService.performHandoff(tx.hash);
            },
            scrollReasoningUp: () => set(state => ({ reasoningScrollIndex: Math.max(0, state.reasoningScrollIndex - 1) })),
            scrollReasoningDown: () => set(state => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!tx?.reasoning) return {};
                const maxLines = tx.reasoning.split('\n').length;
                return { reasoningScrollIndex: Math.min(maxLines - 1, state.reasoningScrollIndex + 1) };
            }),
            navigateScriptErrorUp: () => set(state => ({ scriptErrorIndex: Math.max(0, state.scriptErrorIndex - 1) })),
            navigateScriptErrorDown: () => set(state => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!tx?.scripts || !tx?.files) return {};
                const selectedScript = tx.scripts[state.selectedItemIndex - tx.files.length];
                if (selectedScript?.output) {
                    const errorLines = selectedScript.output
                        .split('\n')
                        .filter(line => line.includes('Error') || line.includes('Warning'));
                    return { scriptErrorIndex: Math.min(errorLines.length - 1, state.scriptErrorIndex + 1) };
                }
                return {};
            }),
            updateApplyStep: (id, status, duration, details) => {
                set(state => ({
                    applySteps: state.applySteps.map(s => {
                        if (s.id === id) {
                            const newStep = { ...s, status };
                            if (duration !== undefined) newStep.duration = duration;
                            if (details !== undefined) newStep.details = details;
                            return newStep;
                        }
                        return s;
                    }),
                }));
            },
            addApplySubstep: (parentId, substep) => {
                set(state => ({
                    applySteps: state.applySteps.map(s => {
                        if (s.id === parentId) {
                            const newSubsteps = [...(s.substeps || []), substep as ApplyStep];
                            return { ...s, substeps: newSubsteps };
                        }
                        return s;
                    }),
                }));
            },
            updateFileReviewStatus: (fileId, status, error) => {
                set(state => {
                    const newStates = new Map(state.fileReviewStates);
                    newStates.set(fileId, { status, error });
                    return { fileReviewStates: newStates };
                });
            },
            toggleFileApproval: (fileId) => {
                set(state => {
                    const newStates = new Map(state.fileReviewStates);
                    const current = newStates.get(fileId);
                    if (current) {
                        const newStatus: FileReviewStatus = current.status === 'APPROVED' ? 'REJECTED' : 'APPROVED';
                        newStates.set(fileId, { status: newStatus, error: undefined });
                    }
                    return { fileReviewStates: newStates };
                });
            },
            rejectAllFiles: () => {
                set(state => {
                    const newStates = new Map(state.fileReviewStates);
                    for (const [fileId, reviewState] of newStates.entries()) {
                        if (reviewState.status === 'APPROVED') {
                            newStates.set(fileId, { status: 'REJECTED', error: undefined });
                        }
                    }
                    return { fileReviewStates: newStates };
                });
            },
        },
    }));
  src/components/DiffScreen.tsx: >-
    import React from 'react';

    import { Box, Text } from 'ink';


    interface DiffScreenProps {
        filePath: string;
        diffContent: string;
        isExpanded: boolean;
    }


    const DiffScreen = ({ filePath, diffContent, isExpanded }: DiffScreenProps)
    => {
        const lines = diffContent.split('\n');
        const COLLAPSE_THRESHOLD = 20;
        const COLLAPSE_SHOW_LINES = 8;

        const renderContent = () => {
            if (!isExpanded && lines.length > COLLAPSE_THRESHOLD) {
                const topLines = lines.slice(0, COLLAPSE_SHOW_LINES);
                const bottomLines = lines.slice(lines.length - COLLAPSE_SHOW_LINES);
                const hiddenLines = lines.length - (COLLAPSE_SHOW_LINES * 2);

                return (
                    <>
                        {topLines.map((line, i) => renderLine(line, i))}
                        <Text color="gray">... {hiddenLines} lines hidden ...</Text>
                        {bottomLines.map((line, i) => renderLine(line, i + topLines.length + 1))}
                    </>
                );
            }
            return lines.map((line, i) => renderLine(line, i));
        };

        const renderLine = (line: string, key: number) => {
            let color = 'white';
            if (line.startsWith('+')) color = 'green';
            if (line.startsWith('-')) color = 'red';
            if (line.startsWith('@@')) color = 'cyan';
            return <Text key={key} color={color}>{line}</Text>;
        };

        return (
            <Box flexDirection="column">
                <Text>DIFF: {filePath}</Text>
                <Box flexDirection="column" marginTop={1}>
                    {renderContent()}
                </Box>
            </Box>
        );
    };


    export default DiffScreen;
  src/hooks/useDashboardScreen.tsx: >-
    import { useMemo } from 'react';

    import { useInput } from 'ink';

    import { useDashboardStore } from '../stores/dashboard.store';

    import { useAppStore } from '../stores/app.store';

    import { useCommitStore } from '../stores/commit.store';

    import { useTransactionStore, selectTransactionsByStatus } from
    '../stores/transaction.store';

    import { useReviewStore } from '../stores/review.store';

    import { useDetailStore } from '../stores/detail.store';

    import { useHistoryStore } from '../stores/history.store';

    import { useViewport } from './useViewport';


    export const useDashboardScreen = () => {
        const NON_EVENT_STREAM_HEIGHT = 9; // Header, separators, status, footer, etc.
        const {
            status,
            selectedTransactionIndex,
        } = useDashboardStore();
        const transactions = useTransactionStore(s => s.transactions);
        const pendingTransactions = useTransactionStore(selectTransactionsByStatus('PENDING'));
        const appliedTransactions = useTransactionStore(selectTransactionsByStatus('APPLIED'));

        const { viewOffset, viewportHeight } = useViewport({
            selectedIndex: selectedTransactionIndex,
            padding: NON_EVENT_STREAM_HEIGHT,
        });

        const {
            togglePause,
            moveSelectionUp,
            moveSelectionDown,
            startApproveAll,
            confirmAction,
            cancelAction,
        } = useDashboardStore(s => s.actions);
        const appActions = useAppStore(s => s.actions);
        const commitActions = useCommitStore(s => s.actions);

        const pendingApprovals = pendingTransactions.length;
        const pendingCommits = appliedTransactions.length;

        const isModal = status === 'CONFIRM_APPROVE';
        const isProcessing = status === 'APPROVING';

        useInput((input, key) => {
            if (isModal) {
                if (key.return) confirmAction();
                if (key.escape) cancelAction();
                return;
            }

            if (isProcessing) return; // No input while processing

            if (key.upArrow) moveSelectionUp();
            if (key.downArrow) moveSelectionDown();
            
            if (key.return) {
                const selectedTx = transactions[selectedTransactionIndex];
                if (selectedTx?.status === 'PENDING') {
                    // For PENDING transactions, we still go to the review screen.
                    useReviewStore.getState().actions.load(selectedTx.id);
                    appActions.showReviewScreen();
                } else if (selectedTx) {
                    useDetailStore.getState().actions.load(selectedTx.id);
                    appActions.showTransactionDetailScreen();
                }
            }
            
            if (input.toLowerCase() === 'p') togglePause();
            if (input.toLowerCase() === 'a' && pendingApprovals > 0) startApproveAll();
            if (input.toLowerCase() === 'c' && pendingCommits > 0) {
                commitActions.prepareCommitScreen();
                appActions.showGitCommitScreen();
            }
            if (input.toLowerCase() === 'l') {
                useHistoryStore.getState().actions.load();
                appActions.showTransactionHistoryScreen();
            }
        });
        const transactionsToConfirm = status === 'CONFIRM_APPROVE' ? pendingTransactions : [];

        return {
            status,
            transactions,
            selectedTransactionIndex,
            pendingApprovals,
            pendingCommits,
            isModal,
            isProcessing,
            viewOffset,
            viewportHeight,
            transactionsToConfirm,
        };
    };
  src/hooks/useDebugMenu.tsx: |-
    import { useState } from 'react';
    import { useInput } from 'ink';
    import { useAppStore } from '../stores/app.store';
    import { useViewStore } from '../stores/view.store';
    import { useDashboardStore } from '../stores/dashboard.store';
    import { useReviewStore } from '../stores/review.store';
    import { useDetailStore } from '../stores/detail.store';
    import { useHistoryStore } from '../stores/history.store';
    import { useInitStore } from '../stores/init.store';
    import { useCommitStore } from '../stores/commit.store';
    import { useCopyStore } from '../stores/copy.store';
    import { COPYABLE_ITEMS } from '../types/copy.types';
    import { CopyService } from '../services/copy.service';
    import type { MenuItem } from '../types/debug.types';
    import { useTransactionStore } from '../stores/transaction.store';
    import type { Transaction } from '../types/domain.types';
    import { moveIndex } from '../stores/navigation.utils';
    export type { MenuItem } from '../types/debug.types';

    const useDebugMenuActions = () => {
        const { actions: appActions } = useAppStore();
        const { actions: initActions } = useInitStore();
        const { actions: commitActions } = useCommitStore();
        const { actions: dashboardActions } = useDashboardStore();
        const { actions: reviewActions } = useReviewStore();
        const { actions: detailActions } = useDetailStore();
        const { actions: historyActions } = useHistoryStore();

        const menuItems: MenuItem[] = [
            {
                title: 'Splash Screen',
                action: () => appActions.showSplashScreen(),
            },
            {
                title: 'Init: Analyze Phase',
                action: () => {
                    initActions.setPhase('ANALYZE');
                    appActions.showInitScreen();
                },
            },
            {
                title: 'Init: Interactive Phase',
                action: () => {
                    initActions.setPhase('INTERACTIVE');
                    appActions.showInitScreen();
                },
            },
            {
                title: 'Init: Finalize Phase',
                action: () => {
                    initActions.setPhase('FINALIZE');
                    appActions.showInitScreen();
                },
            },
            {
                title: 'Dashboard: Listening',
                action: () => {
                    dashboardActions.setStatus('LISTENING');
                    appActions.showDashboardScreen();
                },
            },
            {
                title: 'Dashboard: Confirm Approve',
                action: () => {
                    dashboardActions.startApproveAll();
                    appActions.showDashboardScreen();
                },
            },
            {
                title: 'Dashboard: Approving',
                action: () => {
                    dashboardActions.setStatus('APPROVING');
                    appActions.showDashboardScreen();
                },
            },
            {
                title: 'Review: Partial Failure (Default)',
                action: () => {
                    reviewActions.load('1');
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Success',
                action: () => {
                    reviewActions.load('2');
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Diff View',
                action: () => {
                    reviewActions.load('1');
                    reviewActions.setBodyView('diff');
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Reasoning View',
                action: () => {
                    reviewActions.load('1', { bodyView: 'reasoning' });
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Copy Mode',
                action: () => {
                    reviewActions.load('1');
                    appActions.showReviewScreen();
                    const tx = useTransactionStore.getState().transactions.find(t => t.id === '1');
                    if (!tx) return;
                    // On load, selected index is 0, so we can assume the first file.
                    const selectedFile = tx.files && tx.files.length > 0
                        ? tx.files[0]
                        : undefined;
                    const items = CopyService.getCopyItemsForReview(tx, tx.files || [], selectedFile);
                    useCopyStore.getState().actions.open(
                        'Select data to copy from review:', items);
                },
            },
            {
                title: 'Review: Script Output',
                action: () => {
                    reviewActions.load('2');
                    appActions.showReviewScreen();
                    reviewActions.setBodyView('script_output');
                },
            },
            {
                title: 'Review: Bulk Repair',
                action: () => {
                    reviewActions.load('1', { bodyView: 'bulk_repair' });
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Handoff Confirm',
                action: () => {
                    reviewActions.load('1', { bodyView: 'confirm_handoff' });
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review Processing',
                action: () => {
                    reviewActions.load('2'); // Use tx '2' which has scripts
                    appActions.showReviewProcessingScreen();
                },
            },
            {
                title: 'Git Commit Screen',
                action: () => {
                    commitActions.prepareCommitScreen();
                    appActions.showGitCommitScreen();
                },
            },
            {
                title: 'Transaction Detail Screen',
                action: () => {
                    // The dashboard store has transactions, we'll just pick one.
                    detailActions.load('3'); // 'feat: implement new dashboard UI'
                    appActions.showTransactionDetailScreen();
                },
            },
            {
                title: 'Transaction History Screen',
                action: () => {
                    historyActions.load();
                    appActions.showTransactionHistoryScreen();
                },
            },
            {
                title: 'History: L1 Drilldown',
                action: () => {
                    historyActions.prepareDebugState('l1-drill');
                    appActions.showTransactionHistoryScreen();
                },
            },
            {
                title: 'History: L2 Drilldown (Diff)',
                action: () => {
                    historyActions.prepareDebugState('l2-drill');
                    appActions.showTransactionHistoryScreen();
                },
            },
            {
                title: 'History: Filter Mode',
                action: () => {
                    historyActions.prepareDebugState('filter');
                    appActions.showTransactionHistoryScreen();
                },
            },
            {
                title: 'History: Copy Mode',
                action: () => {
                    historyActions.prepareDebugState('copy');
                    appActions.showTransactionHistoryScreen();
                    const allTxs = useTransactionStore.getState().transactions;
                    // The 'copy' debug state sets selectedForAction to ['3', '6']. We'll use that directly.
                    const txsToCopy = allTxs.filter((tx: Transaction) => ['3', '6'].includes(tx.id));
                    const items = CopyService.getCopyItemsForHistory(txsToCopy);
                    useCopyStore.getState().actions.open(
                        `Select data to copy from ${txsToCopy.length} transactions:`, items);
                },
            },
        ];
        return { menuItems, appActions };
    };

    export const useDebugMenu = () => {
        const [selectedIndex, setSelectedIndex] = useState(0);
        const { menuItems, appActions } = useDebugMenuActions();
        
        useInput((input, key) => {
            if (key.upArrow) {
                setSelectedIndex(i => moveIndex(i, 'up', menuItems.length));
                return;
            }
            if (key.downArrow) {
                setSelectedIndex(i => moveIndex(i, 'down', menuItems.length));
                return;
            }
            if (key.return) {
                const item = menuItems[selectedIndex];
                if (item) {
                    item.action();
                    useViewStore.getState().actions.setActiveOverlay('none');
                }
                return;
            }
            if (key.escape) {
                useViewStore.getState().actions.setActiveOverlay('none');
                return;
            }

            // No ctrl/meta keys for selection shortcuts, and only single characters
            if (key.ctrl || key.meta || input.length !== 1) return;

            if (input >= '1' && input <= '9') {
                const targetIndex = parseInt(input, 10) - 1;
                if (targetIndex < menuItems.length) {
                    setSelectedIndex(targetIndex);
                }
            } else if (input.toLowerCase() >= 'a' && input.toLowerCase() <= 'z') {
                const targetIndex = 9 + (input.toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0));
                if (targetIndex < menuItems.length) {
                    setSelectedIndex(targetIndex);
                }
            }
        });

        return {
            selectedIndex,
            menuItems,
        };
    };
  src/hooks/useGlobalHotkeys.tsx: |-
    import { useApp, useInput } from 'ink';
    import { useAppStore } from '../stores/app.store';
    import { useViewStore } from '../stores/view.store';

    const MAIN_SCREENS_FOR_QUIT: string[] = ['dashboard', 'init'];

    export const useGlobalHotkeys = ({ isActive }: { isActive: boolean }) => {
        const { exit } = useApp();
        const { currentScreen } = useAppStore(s => ({
            currentScreen: s.currentScreen,
        }));
        const { activeOverlay, setActiveOverlay } = useViewStore(s => ({
            activeOverlay: s.activeOverlay,
            setActiveOverlay: s.actions.setActiveOverlay,
        }));

        useInput((input, key) => {
            // Debug Menu toggle is the highest priority global key
            if (key.ctrl && input === 'b') {
                setActiveOverlay(activeOverlay === 'debug' ? 'none' : 'debug');
                return;
            }

            // If debug menu is open, it has its own input handler, so we stop here.
            if (activeOverlay === 'debug') {
                return;
            }

            // Help screen takes precedence over other keys
            if (activeOverlay === 'help') {
                if (key.escape || input === '?') {
                    setActiveOverlay('none');
                }
                return;
            }

            // --- Global hotkeys when no modal/overlay is open ---
            
            // Open Help
            if (input === '?') {
                setActiveOverlay('help');
                return;
            }
            
            // Quit from main screens
            if (input.toLowerCase() === 'q' && MAIN_SCREENS_FOR_QUIT.includes(currentScreen)) {
                exit();
            }
        }, { isActive });
    };
  src/hooks/useSplashScreen.tsx: |-
    import { useState, useEffect } from 'react';
    import { useInput } from 'ink';
    import { useAppStore } from '../stores/app.store';

    export const useSplashScreen = () => {
        const showInitScreen = useAppStore(state => state.actions.showInitScreen);
        const [countdown, setCountdown] = useState(3);

        const handleSkip = () => {
            showInitScreen();
        };

        useInput(() => {
            handleSkip();
        });

        useEffect(() => {
            if (countdown === 0) {
                showInitScreen();
                return;
            }

            const timer = setTimeout(() => {
                setCountdown(c => c - 1);
            }, 1000);

            return () => clearTimeout(timer);
        }, [countdown, showInitScreen]);

        return { countdown };
    };
  src/hooks/useTransactionHistoryScreen.tsx: |-
    import { useMemo } from 'react';
    import { useInput, type Key } from 'ink';
    import { useHistoryStore } from '../stores/history.store';
    import { useAppStore } from '../stores/app.store';
    import { useTransactionStore } from '../stores/transaction.store';
    import { useCopyStore } from '../stores/copy.store';
    import { getVisibleItemPaths } from '../stores/navigation.utils';
    import { useViewport } from './useViewport';

    export const useTransactionHistoryScreen = () => {
        const store = useHistoryStore();
        const { mode, selectedItemPath, expandedIds, filterQuery, selectedForAction, actions } = store;
        const { showDashboardScreen } = useAppStore(s => s.actions);
        const transactions = useTransactionStore(s => s.transactions);

        const visibleItemPaths = useMemo(
            () => getVisibleItemPaths(transactions, expandedIds),
            [transactions, expandedIds],
        );
        const selectedIndex = visibleItemPaths.indexOf(selectedItemPath);

        const NON_CONTENT_HEIGHT = 8; // Header, filter, separators, footer, etc.
        const { viewOffset, viewportHeight } = useViewport({
            selectedIndex,
            padding: NON_CONTENT_HEIGHT,
        });

        const openCopyMode = () => {
            const transactionsToCopy = transactions.filter(tx => selectedForAction.has(tx.id));

            if (transactionsToCopy.length === 0) return;
            useCopyStore.getState().actions.openForHistory(transactionsToCopy);
        };

        const handleFilterInput = (_input: string, key: Key): void => {
            if (key.escape) actions.setMode('LIST');
            if (key.return) actions.applyFilter();
        };

        const handleBulkActionsInput = (_input: string, key: Key): void => {
            if (key.escape) actions.setMode('LIST');
            // Add number handlers...
        };

        const handleListInput = (input: string, key: Key): void => {
            if (key.upArrow) actions.navigateUp();
            if (key.downArrow) actions.navigateDown();
            if (key.rightArrow) actions.expandOrDrillDown();
            if (key.leftArrow) actions.collapseOrBubbleUp();
            if (input === ' ') actions.toggleSelection();

            if (input.toLowerCase() === 'f') actions.setMode('FILTER');
            if (input.toLowerCase() === 'c' && selectedForAction.size > 0) openCopyMode();
            if (input.toLowerCase() === 'b' && selectedForAction.size > 0) actions.setMode('BULK_ACTIONS');
            
            if (key.escape || input.toLowerCase() === 'q') {
                showDashboardScreen();
            }
        };

        useInput((input: string, key: Key) => {
            if (mode === 'FILTER') {
                handleFilterInput(input, key);
                return;
            }
            if (mode === 'BULK_ACTIONS') {
                handleBulkActionsInput(input, key);
                return;
            }
            handleListInput(input, key);
        });

        const itemsInView = visibleItemPaths.slice(viewOffset, viewOffset + viewportHeight);
        const txIdsInView = useMemo(() => new Set(itemsInView.map(p => p.split('/')[0])), [itemsInView]);
        const transactionsInView = useMemo(
            () => transactions.filter(tx => txIdsInView.has(tx.id)),
            [transactions, txIdsInView],
        );
        const pathsInViewSet = useMemo(() => new Set(itemsInView), [itemsInView]);

        const filterStatusText = filterQuery ? filterQuery : '(none)';
        const showingStatusText = `Showing ${Math.min(viewOffset + 1, visibleItemPaths.length)}-${Math.min(viewOffset + itemsInView.length, visibleItemPaths.length)} of ${visibleItemPaths.length} items`;
        
        return {
            mode,
            filterQuery,
            selectedForAction,
            selectedItemPath,
            expandedIds,
            actions,
            transactions,
            viewOffset,
            itemsInView,
            transactionsInView,
            pathsInViewSet,
            filterStatus: filterStatusText,
            showingStatus: showingStatusText,
            visibleItemPaths,
        };
    };
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 106
