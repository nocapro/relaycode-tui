uuid: 44031df3-b461-419b-b5a0-539097940b2a
projectId: relaycode-tui
createdAt: '2025-09-25T23:14:41.291Z'
gitCommitMsg: >-
  feat: introduce useLayout and useContentViewport hooks

  This commit adds two foundational hooks as part of a major refactoring of
  vertical scrolling and layout management.

  - `useLayout` provides a declarative way to calculate the available
    vertical space for dynamic content by specifying reserved rows for
    headers, footers, etc.

  - `useContentViewport` encapsulates the state and logic for scrolling a
    block of text content within a given viewport height.

  These hooks will replace scattered manual viewport calculations, making the
  layout more robust, maintainable, and responsive to terminal size changes.
promptSummary: >-
  Create new foundational hooks for layout and scrolling as part of a larger
  refactoring effort.
reasoning:
  - >-
    Excellent. I am now executing Parts 1 and 2 of the master plan. This
    involves creating the two new foundational hooks, `useLayout` and
    `useContentViewport`, which will serve as the basis for the subsequent
    refactoring of all vertical scrolling logic.
  - >-
    First, I will create `useLayout.ts`. This hook is designed to be the single
    source of truth for calculating available screen space by taking a
    declarative configuration of reserved rows. This abstracts away manual
    calculations from consumer hooks.
  - >-
    Next, I will create `useContentViewport.ts`. This hook will encapsulate the
    logic for managing the scroll state (`scrollIndex`) of a dynamic content
    block, such as a diff or a reasoning text. It will receive the viewport
    height from `useLayout` and provide a clean API for scrolling actions.
operations:
  - type: write
    path: src/hooks/useLayout.ts
    content: |-
      import { useMemo } from 'react';
      import { useStdoutDimensions } from '../utils';

      export interface LayoutConfig {
          header?: number;
          footer?: number;
          separators?: number;
          marginsY?: number; // Total vertical margin
          paddingY?: number; // Total vertical padding
          fixedRows?: number; // For any other static rows
          dynamicRows?: {
              count: number;
              lineHeight?: number; // Default to 1
          };
      }

      export interface LayoutInfo {
          totalHeight: number;
          remainingHeight: number;
      }

      /**
       * Calculates available vertical space based on terminal height and a declarative layout config.
       * @param config A declarative object describing static and dynamic rows to reserve.
       * @returns An object with total terminal height and the calculated remaining height for content.
       */
      export const useLayout = (config: LayoutConfig): LayoutInfo => {
          const [, totalHeight] = useStdoutDimensions();

          const reservedHeight = useMemo(() => {
              let reserved = 0;
              reserved += config.header || 0;
              reserved += config.footer || 0;
              reserved += config.separators || 0;
              reserved += config.marginsY || 0;
              reserved += config.paddingY || 0;
              reserved += config.fixedRows || 0;

              if (config.dynamicRows) {
                  reserved += config.dynamicRows.count * (config.dynamicRows.lineHeight || 1);
              }
              return reserved;
          }, [config]);

          const remainingHeight = Math.max(1, totalHeight - reservedHeight);

          return {
              totalHeight,
              remainingHeight,
          };
      };
    patchStrategy: replace
  - type: write
    path: src/hooks/useContentViewport.ts
    content: |-
      import { useState, useEffect, useMemo, useCallback } from 'react';

      interface ContentViewportConfig {
          contentLineCount: number;
          viewportHeight: number;
      }

      export interface ContentViewport {
          scrollIndex: number;
          canScrollUp: boolean;
          canScrollDown: boolean;
          actions: {
              scrollUp: (lines?: number) => void;
              scrollDown: (lines?: number) => void;
              pageUp: () => void;
              pageDown: () => void;
              resetScroll: () => void;
          };
      }

      /**
       * Manages the scrolling state (index) for a block of content within a fixed viewport.
       * @param config Configuration including total content lines and the height of the visible area.
       * @returns State and actions for controlling the scroll position.
       */
      export const useContentViewport = ({
          contentLineCount,
          viewportHeight,
      }: ContentViewportConfig): ContentViewport => {
          const [scrollIndex, setScrollIndex] = useState(0);

          const maxScrollIndex = useMemo(
              () => Math.max(0, contentLineCount - viewportHeight),
              [contentLineCount, viewportHeight],
          );

          // Effect to clamp scrollIndex if content or viewport size changes
          useEffect(() => {
              if (scrollIndex > maxScrollIndex) {
                  setScrollIndex(maxScrollIndex);
              }
          }, [scrollIndex, maxScrollIndex]);

          const canScrollUp = useMemo(() => scrollIndex > 0, [scrollIndex]);
          const canScrollDown = useMemo(() => scrollIndex < maxScrollIndex, [scrollIndex, maxScrollIndex]);

          const scrollUp = useCallback((lines = 1) => {
              setScrollIndex(i => Math.max(0, i - lines));
          }, []);

          const scrollDown = useCallback((lines = 1) => {
              setScrollIndex(i => Math.min(maxScrollIndex, i + lines));
          }, [maxScrollIndex]);

          const pageUp = useCallback(() => {
              setScrollIndex(i => Math.max(0, i - viewportHeight));
          }, [viewportHeight]);

          const pageDown = useCallback(() => {
              setScrollIndex(i => Math.min(maxScrollIndex, i + viewportHeight));
          }, [maxScrollIndex, viewportHeight]);
          
          const resetScroll = useCallback(() => {
              setScrollIndex(0);
          }, []);

          return {
              scrollIndex,
              canScrollUp,
              canScrollDown,
              actions: {
                  scrollUp,
                  scrollDown,
                  pageUp,
                  pageDown,
                  resetScroll,
              },
          };
      };
    patchStrategy: replace
snapshot:
  src/hooks/useLayout.ts: null
  src/hooks/useContentViewport.ts: null
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: '2025-09-25T23:33:49.774Z'
status: committed
id: 159
