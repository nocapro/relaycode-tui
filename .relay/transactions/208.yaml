uuid: c2570020-0d6f-40e1-a083-d93339031c6a
projectId: relaycode-tui
createdAt: '2025-09-26T08:20:58.931Z'
gitCommitMsg: >-
  fix: Resolve TS and ESLint errors after refactor

  This commit addresses a series of TypeScript compilation errors and ESLint
  violations that arose after a recent refactoring session.

  - **Critical Fixes:**
    - Corrected syntax in `dashboard.store.ts` by adding missing commas
      between methods in the actions object.
    - Removed a stray line of JSX in `DashboardScreen.tsx` that was
      causing parsing errors.
    - Fixed a critical logic bug in `copy.store.ts` by removing an
      action that improperly accessed hook state. Updated `useCopyScreen.tsx`
      to use the correct action.

  - **Linting & Formatting:**
    - Removed unused variables and imports across multiple components.
    - Refactored long lines in components and hooks to adhere to the
      max-len rule.
    - Cleaned up formatting issues like multiple blank lines and missing
      trailing commas.
promptSummary: >-
  The user provided a list of TypeScript and ESLint errors after a refactoring
  and asked me to fix them.
reasoning:
  - >-
    I have analyzed the TypeScript and ESLint errors and have prepared a series
    of patches to resolve all of them. The issues stem from syntax errors,
    unused variables, incorrect logic introduced during refactoring, and various
    linting violations like line length and formatting.
  - Here is the step-by-step plan to fix your codebase.
  - '### **Part 1: Fix Critical TypeScript and Logic Errors**'
  - >-
    First, I will address the errors that prevent the code from compiling or
    running correctly.
  - >-
    1.  **`src/stores/dashboard.store.ts`**: The methods within the `actions`
    object were missing trailing commas, causing a cascade of parsing errors. I
    will add the required commas to fix the object syntax.
  - >-
    2.  **`src/components/DashboardScreen.tsx`**: A stray line of JSX was left
    outside of any component structure, causing a parsing error. I am removing
    this line and ensuring the correct variable (`FILE_CHANGE_ICONS`) is used
    within the component.
  - >-
    3.  **`src/stores/copy.store.ts` & `src/hooks/useCopyScreen.tsx`**: A logic
    error was introduced where the `copy.store` incorrectly tried to access
    state from the `useCopyScreen` hook. I am removing the faulty
    `toggleSelection` action from the store and updating the hook to use the
    correct `toggleSelectionById` action, passing the required data to it.
  - '### **Part 2: Resolve Linting Errors and Warnings**'
  - >-
    Next, I will fix all remaining ESLint issues, which include unused
    variables, formatting, and lines that exceed the maximum length.
  - >-
    These changes should resolve all reported errors and warnings, making your
    codebase clean and functional again.
operations:
  - type: write
    path: src/stores/dashboard.store.ts
    content: >
      --- src/stores/dashboard.store.ts

      +++ src/stores/dashboard.store.ts

      @@ -21,14 +21,14 @@
           actions: {
               togglePause: () => set(state => ({
                   status: state.status === DASHBOARD_STATUS.LISTENING ? DASHBOARD_STATUS.PAUSED : DASHBOARD_STATUS.LISTENING,
      -        }),

      +        })),
               startApproveAll: () => set(state => ({
                   status: DASHBOARD_STATUS.CONFIRM_APPROVE,
                   previousStatus: state.status,
               })),
               cancelAction: () => set(state => ({ status: state.previousStatus })),
               setStatus: (status) => set({ status }),
      -        confirmAction: async () => { // The `if` is redundant as this is
      only called from that state.

      +        confirmAction: async () => { // The `if` is redundant as this is
      only called from that state.
                   const previousStatus = get().previousStatus;
                   set({ status: DASHBOARD_STATUS.APPROVING });
                   await DashboardService.approveAll();
                   set({ status: previousStatus });
               },
      -        toggleExpand: () => {

      +        toggleExpand: () => {
                   const { selectedTransactionIndex, expandedTransactionId } = get();
                   const { transactions } = useTransactionStore.getState();
                   const selectedTx = transactions[selectedTransactionIndex];
      @@ -48,7 +48,7 @@
                   } else {
                       set({ expandedTransactionId: selectedTx.id });
                   }
               },
               setExpandedTransactionId: (id) => set({ expandedTransactionId: id }),
               setSelectedIndex: (index) => set({ selectedTransactionIndex: index }),
           },
       }));
    patchStrategy: standard-diff
  - type: write
    path: src/components/DashboardScreen.tsx
    content: >
      --- src/components/DashboardScreen.tsx

      +++ src/components/DashboardScreen.tsx

      @@ -44,14 +44,12 @@
                   )}
                    <Box flexDirection="column" paddingLeft={1}>
                       {files.map(file => (
      -                     <Text key={file.id}>

      -                        <Text
      color="gray">{FILE_TYPE_MAP[file.type]}</Text> {file.path}

      -                    </Text>

      +                    <Text key={file.id}>

      +                        <Text
      color="gray">{FILE_CHANGE_ICONS[file.type]}</Text> {file.path}

      +                    </Text>
                       ))}
                    </Box>
               </Box>
           );
       };
      -                        <Text
      color="gray">{FILE_CHANGE_ICONS[file.type]}</Text> {file.path}
       const EventStreamItem = React.memo(({ transaction, isSelected, isExpanded, isNew }: { transaction: Transaction, isSelected: boolean, isExpanded: boolean, isNew: boolean }) => {
           const [isAnimatingIn, setIsAnimatingIn] = useState(isNew);
           const [isStatusFlashing, setIsStatusFlashing] = useState(false);
    patchStrategy: standard-diff
  - type: write
    path: src/stores/copy.store.ts
    content: >
      --- src/stores/copy.store.ts

      +++ src/stores/copy.store.ts

      @@ -23,7 +23,6 @@
               openForDetail: (transaction: Transaction, selectedFile?: FileItem) => void;
               openForHistory: (transactions: Transaction[]) => void;
      -        toggleSelection: () => void;
               toggleSelectionById: (id: string) => void;
               executeCopy: () => void;
           };
      @@ -58,18 +57,6 @@
                   const items = CopyService.getCopyItemsForHistory(transactions);
                   actions.open(title, items);
               },
      -        toggleSelection: () => set(state => {

      -            const currentItem =
      useCopyScreen.getState().items[useCopyScreen.getState().selectedIndex];

      -            if (!currentItem) return {};

      -            const newSelectedIds = new Set(state.selectedIds);

      -            if (newSelectedIds.has(currentItem.id)) {

      -                newSelectedIds.delete(currentItem.id);

      -            } else {

      -                newSelectedIds.add(currentItem.id);

      -            }

      -            return { selectedIds: newSelectedIds };

      -        }),
               toggleSelectionById: (id: string) => set(state => {
                   const newSelectedIds = new Set(state.selectedIds);
                   if (newSelectedIds.has(id)) {
    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useCopyScreen.tsx
    content: |
      --- src/hooks/useCopyScreen.tsx
      +++ src/hooks/useCopyScreen.tsx
      @@ -22,7 +22,6 @@
               layoutConfig: UI_CONFIG.layout.copyScreen,
           });
       
      -
           useListNavigator({
               itemCount: items.length,
               viewportHeight,
      @@ -34,7 +33,9 @@
                       return;
                   }
                   if (input === ' ') {
      -                actions.toggleSelection();
      +                const currentItem = items[selectedIndex];
      +                if (!currentItem) return;
      +                actions.toggleSelectionById(currentItem.id);
                       return;
                   }
                   if (key.return) {
    patchStrategy: standard-diff
  - type: write
    path: src/components/DebugLogScreen.tsx
    content: |
      --- src/components/DebugLogScreen.tsx
      +++ src/components/DebugLogScreen.tsx
      @@ -4,7 +4,6 @@
       import { useDebugLogScreen } from '../hooks/useDebugLogScreen';
       import { DEBUG_LOG_FOOTER_ACTIONS, DEBUG_LOG_MODES, LOG_LEVEL_COLORS, LOG_LEVEL_TAGS } from '../constants/log.constants';
       import type { LogEntry } from '../types/log.types';
      -import { useStdoutDimensions } from '../utils';
       import ScreenLayout from './layout/ScreenLayout';
       
       const LogEntryRow = ({ entry, isSelected }: { entry: LogEntry; isSelected: boolean }) => {
      @@ -35,7 +34,6 @@
               setFilterQuery,
               viewOffset,
           } = useDebugLogScreen();
      -    const [width] = useStdoutDimensions();
       
           const renderFilter = () => (
               <Box>
    patchStrategy: standard-diff
  - type: write
    path: src/components/GitCommitScreen.tsx
    content: >
      --- src/components/GitCommitScreen.tsx

      +++ src/components/GitCommitScreen.tsx

      @@ -24,9 +24,11 @@
               </Box>
           );
       
      +    const footerActions = commitError ? COMMIT_FOOTER_ACTIONS.FAILURE :
      COMMIT_FOOTER_ACTIONS.BASE;
           const footer = isCommitting
                       ? <Text><Spinner type="dots"/> Committing... please wait.</Text>
      -                : <ActionFooter actions={commitError ?
      COMMIT_FOOTER_ACTIONS.FAILURE : COMMIT_FOOTER_ACTIONS.BASE} />;

      +                : <ActionFooter actions={footerActions} />;
       
           return (
               <ScreenLayout
    patchStrategy: standard-diff
  - type: write
    path: src/components/ReviewScreen.tsx
    content: >
      --- src/components/ReviewScreen.tsx

      +++ src/components/ReviewScreen.tsx

      @@ -297,11 +297,20 @@
       
           const renderFooter = () => {
               // Contextual footer for body views
      -        if (bodyView === REVIEW_BODY_VIEWS.DIFF) return <ActionFooter
      actions={REVIEW_FOOTER_ACTIONS.DIFF_VIEW}/>;

      -        if (bodyView === REVIEW_BODY_VIEWS.REASONING) return
      <ActionFooter actions={REVIEW_FOOTER_ACTIONS.REASONING_VIEW}/>;

      -        if (bodyView === REVIEW_BODY_VIEWS.SCRIPT_OUTPUT) return
      <ActionFooter actions={REVIEW_FOOTER_ACTIONS.SCRIPT_OUTPUT_VIEW}/>;

      -        if (bodyView === REVIEW_BODY_VIEWS.BULK_REPAIR) return
      <Text>{REVIEW_FOOTER_ACTIONS.BULK_REPAIR_VIEW.text}</Text>;

      -        if (bodyView === REVIEW_BODY_VIEWS.BULK_INSTRUCT) return
      <Text>{REVIEW_FOOTER_ACTIONS.BULK_INSTRUCT_VIEW.text}</Text>;

      -        if (bodyView === REVIEW_BODY_VIEWS.CONFIRM_HANDOFF) return
      <ActionFooter actions={REVIEW_FOOTER_ACTIONS.HANDOFF_CONFIRM_VIEW}/>;

      +        switch (bodyView) {

      +            case REVIEW_BODY_VIEWS.DIFF:

      +                return <ActionFooter
      actions={REVIEW_FOOTER_ACTIONS.DIFF_VIEW}/>;

      +            case REVIEW_BODY_VIEWS.REASONING:

      +                return <ActionFooter
      actions={REVIEW_FOOTER_ACTIONS.REASONING_VIEW}/>;

      +            case REVIEW_BODY_VIEWS.SCRIPT_OUTPUT:

      +                return <ActionFooter
      actions={REVIEW_FOOTER_ACTIONS.SCRIPT_OUTPUT_VIEW}/>;

      +            case REVIEW_BODY_VIEWS.BULK_REPAIR:

      +                return
      <Text>{REVIEW_FOOTER_ACTIONS.BULK_REPAIR_VIEW.text}</Text>;

      +            case REVIEW_BODY_VIEWS.BULK_INSTRUCT:

      +                return
      <Text>{REVIEW_FOOTER_ACTIONS.BULK_INSTRUCT_VIEW.text}</Text>;

      +            case REVIEW_BODY_VIEWS.CONFIRM_HANDOFF:

      +                return <ActionFooter
      actions={REVIEW_FOOTER_ACTIONS.HANDOFF_CONFIRM_VIEW}/>;

      +        }
       
               // Dynamic Main footer
               const currentItem = navigableItems[selectedItemIndex];
      @@ -363,7 +372,11 @@
                                   
                                   const isSelected = selectedItemIndex === viewOffset + itemInViewIndex;
                                   return (
      -                                <ScriptItemRow key={script.command}
      script={script} isSelected={isSelected} isExpanded={bodyView ===
      REVIEW_BODY_VIEWS.SCRIPT_OUTPUT && isSelected} />

      +                                <ScriptItemRow

      +                                    key={script.command} script={script}

      +                                    isSelected={isSelected}

      +                                    isExpanded={bodyView ===
      REVIEW_BODY_VIEWS.SCRIPT_OUTPUT && isSelected}

      +                                />
                                   );
                               })}
                           </Box>
    patchStrategy: standard-diff
  - type: write
    path: src/components/TransactionDetailScreen.tsx
    content: >
      --- src/components/TransactionDetailScreen.tsx

      +++ src/components/TransactionDetailScreen.tsx

      @@ -1,5 +1,4 @@
       import { Box, Text } from 'ink';
      -import Separator from './Separator';
       import ContentView from './ContentView';
       import type { FileChangeType } from '../types/domain.types';
       import { useTransactionDetailScreen } from '../hooks/useTransactionDetailScreen';
      @@ -149,7 +148,8 @@
                   if (bodyView === DETAIL_BODY_VIEWS.DIFF_VIEW) {
                       return <ActionFooter actions={[...DETAIL_FOOTER_ACTIONS.DIFF_VIEW, ...baseActions]} />;
                   } else {
      -                return <ActionFooter
      actions={[...DETAIL_FOOTER_ACTIONS.FILE_LIST_VIEW, ...baseActions]} />;

      +                const actions = [...DETAIL_FOOTER_ACTIONS.FILE_LIST_VIEW,
      ...baseActions];

      +                return <ActionFooter actions={actions} />;
                   }
               }
               
    patchStrategy: standard-diff
  - type: write
    path: src/components/TransactionHistoryScreen.tsx
    content: >
      --- src/components/TransactionHistoryScreen.tsx

      +++ src/components/TransactionHistoryScreen.tsx

      @@ -173,7 +173,9 @@
               }
               
               const openActionLabel = selectedItemPath.includes('/file/') ? 'Open File' : 'Open YAML';
      -        return <ActionFooter
      actions={HISTORY_FOOTER_ACTIONS.LIST_MODE(openActionLabel, hasSelection)}
      />;

      +        return (

      +            <ActionFooter
      actions={HISTORY_FOOTER_ACTIONS.LIST_MODE(openActionLabel, hasSelection)}
      />

      +        );
           };
       
           return (
      @@ -237,5 +239,4 @@
           );
       };
       
      -
       export default TransactionHistoryScreen;
    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useDebugLogScreen.tsx
    content: |
      --- src/hooks/useDebugLogScreen.tsx
      +++ src/hooks/useDebugLogScreen.tsx
      @@ -70,7 +70,7 @@
               mode,
               filterQuery,
               setFilterQuery,
      -        viewOffset,
      +        viewOffset,
           };
       };
    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useReviewScreen.tsx
    content: >
      --- src/hooks/useReviewScreen.tsx

      +++ src/hooks/useReviewScreen.tsx

      @@ -29,7 +29,11 @@
           }), [bodyView, layout]);
       
           const { remainingHeight: listViewportHeight } = useLayout(mainListLayoutConfig);
      -    const { viewOffset } = useViewport({ selectedIndex:
      selectedItemIndex, itemCount: 100, layoutConfig: mainListLayoutConfig });

      +    const { viewOffset } = useViewport({

      +        selectedIndex: selectedItemIndex,

      +        itemCount: 100,

      +        layoutConfig: mainListLayoutConfig,

      +    });
       
           // Layout for the body content (diff, reasoning, etc.)
           const bodyLayoutConfig = useMemo(() => ({
    patchStrategy: standard-diff
  - type: write
    path: src/stores/review.store.ts
    content: >
      --- src/stores/review.store.ts

      +++ src/stores/review.store.ts

      @@ -184,8 +184,10 @@
                   const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                   if (!tx?.files) return;
       
      -            const rejectedFiles = tx.files.filter(f =>
      get().fileReviewStates.get(f.id)?.status === 'REJECTED');

      +            const rejectedFiles = tx.files.filter(

      +                f => get().fileReviewStates.get(f.id)?.status ===
      'REJECTED',

      +            );
                   if (rejectedFiles.length === 0) {
                       set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                       return;
      @@ -209,8 +211,9 @@
                   const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                   if (!tx?.files) return;
       
      -            const failedFiles = tx.files.filter(f =>
      get().fileReviewStates.get(f.id)?.status === 'FAILED');

      +            const failedFiles = tx.files.filter(

      +                f => get().fileReviewStates.get(f.id)?.status ===
      'FAILED',

      +            );
                   if (failedFiles.length === 0) {
                       set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                       return;
      @@ -223,11 +226,12 @@
                       case 2: {
                           set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                           failedFiles.forEach(f => get().actions.updateFileReviewStatus(f.id, 'RE_APPLYING'));
                           const results = await ReviewService.runBulkReapply(failedFiles);
      -                    results.forEach(result =>

      +                    results.forEach(result => {
                               get().actions.updateFileReviewStatus(
                                   result.id, result.status, result.error,
      -                        ),

      -                    );

      +                        );

      +                    });
                           break;
                       }
                       case 3:
    patchStrategy: standard-diff
snapshot:
  src/stores/dashboard.store.ts: >-
    import { create } from 'zustand';

    import { useTransactionStore } from './transaction.store';

    import { DashboardService } from '../services/dashboard.service';

    import { DASHBOARD_STATUS } from '../constants/dashboard.constants';


    export type DashboardStatus = (typeof DASHBOARD_STATUS)[keyof typeof
    DASHBOARD_STATUS];
     
    interface DashboardState {
        status: DashboardStatus;
        previousStatus: DashboardStatus;
        selectedTransactionIndex: number;
        expandedTransactionId: string | null;
        actions: {
            togglePause: () => void;
            startApproveAll: () => void;
            confirmAction: () => Promise<void>;
            cancelAction: () => void;
            setStatus: (status: DashboardStatus) => void;
            toggleExpand: () => void;
            setExpandedTransactionId: (id: string | null) => void;
            setSelectedIndex: (index: number) => void;
        };
    }


    export const useDashboardStore = create<DashboardState>((set, get) => ({
        status: DASHBOARD_STATUS.LISTENING,
        previousStatus: DASHBOARD_STATUS.LISTENING,
        selectedTransactionIndex: 0,
        expandedTransactionId: null,
        actions: {
            togglePause: () => set(state => ({
                status: state.status === DASHBOARD_STATUS.LISTENING ? DASHBOARD_STATUS.PAUSED : DASHBOARD_STATUS.LISTENING,
            }),
            startApproveAll: () => set(state => ({
                status: DASHBOARD_STATUS.CONFIRM_APPROVE,
                previousStatus: state.status,
            })),
            cancelAction: () => set(state => ({ status: state.previousStatus })),
            setStatus: (status) => set({ status }),
            confirmAction: async () => { // The `if` is redundant as this is only called from that state.
                const previousStatus = get().previousStatus;
                set({ status: DASHBOARD_STATUS.APPROVING });
                await DashboardService.approveAll();
                set({ status: previousStatus });
            },
            toggleExpand: () => {
                const { selectedTransactionIndex, expandedTransactionId } = get();
                const { transactions } = useTransactionStore.getState();
                const selectedTx = transactions[selectedTransactionIndex];
                if (!selectedTx) return;

                if (expandedTransactionId === selectedTx.id) {
                    set({ expandedTransactionId: null });
                } else {
                    set({ expandedTransactionId: selectedTx.id });
                }
            },
            setExpandedTransactionId: (id) => set({ expandedTransactionId: id }),
            setSelectedIndex: (index) => set({ selectedTransactionIndex: index }),
        },
    }));
  src/stores/copy.store.ts: |-
    import { create } from 'zustand';
    import { useViewStore } from './view.store';
    import { useNotificationStore } from './notification.store';
    import { LoggerService } from '../services/logger.service';
    import { CopyService } from '../services/copy.service';
    import type { CopyItem } from '../types/copy.types';
    import type { Transaction, FileItem } from '../types/domain.types';

    export type { CopyItem };

    interface CopyState {
        title: string;
        items: CopyItem[];
        selectedIds: Set<string>;
        lastCopiedMessage: string | null;
        onClose?: () => void;

        actions: {
            open: (title: string, items: CopyItem[], onClose?: () => void) => void;
            close: () => void;
            openForReview: (transaction: Transaction, files: FileItem[], selectedFile?: FileItem) => void;
            openForDetail: (transaction: Transaction, selectedFile?: FileItem) => void;
            openForHistory: (transactions: Transaction[]) => void;
            toggleSelection: () => void;
            toggleSelectionById: (id: string) => void;
            executeCopy: () => void;
        };
    }

    export const useCopyStore = create<CopyState>((set, get) => ({
        title: '',
        items: [],
        selectedIds: new Set(),
        lastCopiedMessage: null,
        onClose: undefined,

        actions: {
            open: (title, items, onClose) => {
                const defaultSelectedIds = new Set(items.filter(i => i.isDefaultSelected).map(i => i.id));
                useViewStore.getState().actions.setActiveOverlay('copy');
                set({
                    title,
                    items,
                    selectedIds: defaultSelectedIds,
                    lastCopiedMessage: null,
                    onClose,
                });
            },
            close: () => {
                useViewStore.getState().actions.setActiveOverlay('none');
                get().onClose?.();
                set({ items: [], onClose: undefined });
            },
            openForReview: (transaction, files, selectedFile) => {
                const { actions } = get();
                const title = 'Select data to copy from review:';
                const items = CopyService.getCopyItemsForReview(transaction, files, selectedFile);
                actions.open(title, items);
            },
            openForDetail: (transaction, selectedFile) => {
                const { actions } = get();
                const title = `Select data to copy from transaction ${transaction.hash}:`;
                const items = CopyService.getCopyItemsForDetail(transaction, selectedFile);
                actions.open(title, items);
            },
            openForHistory: (transactions) => {
                const { actions } = get();
                const title = `Select data to copy from ${transactions.length} transactions:`;
                const items = CopyService.getCopyItemsForHistory(transactions);
                actions.open(title, items);
            },
            toggleSelection: () => set(state => {
                const currentItem = useCopyScreen.getState().items[useCopyScreen.getState().selectedIndex];
                if (!currentItem) return {};
                const newSelectedIds = new Set(state.selectedIds);
                if (newSelectedIds.has(currentItem.id)) {
                    newSelectedIds.delete(currentItem.id);
                } else {
                    newSelectedIds.add(currentItem.id);
                }
                return { selectedIds: newSelectedIds };
            }),
            toggleSelectionById: (id: string) => set(state => {
                const newSelectedIds = new Set(state.selectedIds);
                if (newSelectedIds.has(id)) {
                    newSelectedIds.delete(id);
                } else {
                    newSelectedIds.add(id);
                }
                return { selectedIds: newSelectedIds };
            }),
            executeCopy: async () => {
                const { items, selectedIds } = get();
                const itemsToCopy = items.filter(i => selectedIds.has(i.id));
                if (itemsToCopy.length === 0) return;

                LoggerService.info(`Copying ${itemsToCopy.length} item(s) to clipboard.`);
                const dataPromises = itemsToCopy.map(item => item.getData());
                const resolvedData = await Promise.all(dataPromises);

                const content = itemsToCopy
                    .map((item, index) => `--- ${item.label} ---\n${resolvedData[index]}`)
                    .join('\n\n');
                const message = `Copied ${itemsToCopy.length} item(s) to clipboard.`;
                LoggerService.debug(`[CLIPBOARD MOCK] ${message}\n${content.substring(0, 200)}...`);
                useNotificationStore.getState().actions.show({
                    type: 'success',
                    title: 'Copied to Clipboard',
                    message,
                });
                set({ lastCopiedMessage: message });
            },
        },
    }));
  src/components/DashboardScreen.tsx: "import React, { useState, useEffect, useRef } from 'react';\nimport { Box, Text } from 'ink';\nimport Spinner from 'ink-spinner';\nimport type { Transaction, TransactionStatus } from '../types/domain.types';\nimport { useDashboardScreen } from '../hooks/useDashboardScreen';\nimport { UI_CONFIG } from '../config/ui.config'; //\nimport ActionFooter from './ActionFooter';\nimport ScreenLayout from './layout/ScreenLayout';\nimport { DASHBOARD_FOOTER_ACTIONS, DASHBOARD_STATUS } from '../constants/dashboard.constants';\nimport { TRANSACTION_STATUS_UI, FILE_CHANGE_ICONS } from '../constants/ui.constants';\n\n// --- Sub-components & Helpers ---\n\nconst getStatusIcon = (status: TransactionStatus) => {\n    if (status === 'IN-PROGRESS' || status === 'COMMITTING') return <Spinner type=\"dots\" />;\n    const ui = TRANSACTION_STATUS_UI[status as keyof typeof TRANSACTION_STATUS_UI];\n    if (!ui) return <Text> </Text>;\n    return <Text color={ui.color}>{ui.text.split(' ')[0]}</Text>;\n};\n\nconst formatTimeAgo = (timestamp: number) => {\n    const seconds = Math.max(0, Math.floor((Date.now() - timestamp) / 1000));\n    if (seconds < 60) return `${seconds}s`;\n    const minutes = Math.floor(seconds / 60);\n    return `${minutes}m`;\n};\n\nconst ExpandedEventInfo = ({ transaction }: { transaction: Transaction }) => {\n    const stats = transaction.stats;\n    const files = transaction.files || [];\n\n    return (\n        <Box flexDirection=\"column\" paddingLeft={4} marginBottom={1} borderStyle=\"round\" borderLeft={true} borderTop={false} borderRight={false} borderBottom={false} borderColor=\"gray\">\n            {stats && (\n                <Text color=\"gray\">\n                    Stats: {stats.files} files, +{stats.linesAdded}/-{stats.linesRemoved}\n                </Text>\n            )}\n             <Box flexDirection=\"column\" paddingLeft={1}>\n                {files.map(file => (\n                     <Text key={file.id}>\n                        <Text color=\"gray\">{FILE_TYPE_MAP[file.type]}</Text> {file.path}\n                    </Text>\n                ))}\n             </Box>\n        </Box>\n    );\n};\n                        <Text color=\"gray\">{FILE_CHANGE_ICONS[file.type]}</Text> {file.path}\nconst EventStreamItem = React.memo(({ transaction, isSelected, isExpanded, isNew }: { transaction: Transaction, isSelected: boolean, isExpanded: boolean, isNew: boolean }) => {\n    const [isAnimatingIn, setIsAnimatingIn] = useState(isNew);\n    const [isStatusFlashing, setIsStatusFlashing] = useState(false);\n    const prevStatus = useRef(transaction.status);\n\n    useEffect(() => {\n        if (isNew) {\n            const timer = setTimeout(() => setIsAnimatingIn(false), 1000);\n            return () => clearTimeout(timer);\n        }\n    }, [isNew]);\n\n    useEffect(() => {\n        if (prevStatus.current !== transaction.status) {\n            setIsStatusFlashing(true);\n            const timer = setTimeout(() => setIsStatusFlashing(false), 500);\n            prevStatus.current = transaction.status;\n            return () => clearTimeout(timer);\n        }\n    }, [transaction.status]);\n\n    const icon = getStatusIcon(transaction.status);\n    const time = formatTimeAgo(transaction.timestamp).padEnd(5, ' ');\n    const statusText = transaction.status.padEnd(11, ' ');\n    const expandIcon = isExpanded ? '▾' : '▸';\n    \n    const messageNode =\n        transaction.status === 'IN-PROGRESS' || transaction.status === 'COMMITTING'\n            ? <Text color={isAnimatingIn ? 'yellow' : 'cyan'}>{transaction.message}</Text>\n            : transaction.message;\n    \n    const content = (\n        <Text>\n            {time} {expandIcon} <Text color={isStatusFlashing ? 'yellow' : undefined} bold={isStatusFlashing}>{icon} {statusText}</Text>{' '}\n            <Text color=\"gray\">{transaction.hash}</Text>\n            {' '}· {messageNode}\n        </Text>\n    );\n\n    if (isSelected) {\n        return <Text bold color={isAnimatingIn ? 'yellow' : 'cyan'}>{'> '}{content}</Text>;\n    }\n\n    return <Text color={isAnimatingIn ? 'yellow' : undefined}>{'  '}{content}</Text>;\n});\n\nconst ConfirmationContent = ({\n    transactionsToConfirm,\n}: {\n    transactionsToConfirm: Transaction[];\n}) => {\n    const actionText = 'APPROVE';\n    \n    return (\n        <Box flexDirection=\"column\" marginY={1} paddingLeft={2}>\n            <Text bold color=\"yellow\">{actionText} ALL PENDING TRANSACTIONS?</Text>\n            <Text>\n                The following {transactionsToConfirm.length} transaction(s) will be approved:\n            </Text>\n            <Box flexDirection=\"column\" paddingLeft={1} marginTop={1}>\n                {transactionsToConfirm.map(tx => (\n                    <Text key={tx.id}>- {tx.hash}: {tx.message}</Text>\n                ))}\n            </Box>\n        </Box>\n    );\n};\n\n// --- Main Component ---\n\nconst DashboardScreen = () => {\n    const {\n        status,\n        transactions,\n        selectedTransactionIndex,\n        pendingApprovals,\n        pendingCommits,\n        isModal,\n        isProcessing,\n        viewOffset,\n        viewportHeight,\n        transactionsToConfirm,\n        expandedTransactionId,\n        newTransactionIds,\n    } = useDashboardScreen({\n        layoutConfig: UI_CONFIG.layout.dashboard,\n    });\n\n    const renderStatusBar = () => {\n        let statusText: string;\n        let statusIcon: React.ReactNode;\n        switch (status) {\n            case DASHBOARD_STATUS.LISTENING: statusText = 'LISTENING'; statusIcon = <Text color=\"green\">●</Text>; break;\n            case DASHBOARD_STATUS.PAUSED: statusText = 'PAUSED'; statusIcon = <Text color=\"yellow\">||</Text>; break;\n            case DASHBOARD_STATUS.APPROVING: statusText = 'APPROVING...'; statusIcon = <Text color=\"cyan\"><Spinner type=\"dots\"/></Text>; break;\n            default: statusText = 'LISTENING'; statusIcon = <Text color=\"green\">●</Text>; //\n        }\n\n        let approvalStr: React.ReactNode = String(pendingApprovals).padStart(2, '0');\n        const commitStr: React.ReactNode = String(pendingCommits).padStart(2, '0');\n\n        if (status === DASHBOARD_STATUS.APPROVING) approvalStr = <Text color=\"cyan\">(<Spinner type=\"dots\"/>)</Text>;\n        if (status === DASHBOARD_STATUS.CONFIRM_APPROVE) {\n            approvalStr = <Text bold color=\"yellow\">┌ {approvalStr} ┐</Text>;\n        }\n        \n        return (\n            <Text>\n                STATUS: {statusIcon} {statusText} · APPROVALS: {approvalStr} · COMMITS: {commitStr}\n            </Text>\n        );\n    };\n\n    const renderFooter = () => {\n        if (isModal) return (\n            <ActionFooter actions={DASHBOARD_FOOTER_ACTIONS.MODAL}/>\n        );\n        if (isProcessing) return <Text>Processing... This may take a moment.</Text>;\n\n\t\treturn <ActionFooter actions={DASHBOARD_FOOTER_ACTIONS.STANDARD({\n            status,\n            hasPending: pendingApprovals > 0,\n            hasApplied: pendingCommits > 0,\n        })} />;\n    };\n    \n    return (\n        <ScreenLayout\n            title={<Text color=\"cyan\">▲ relaycode dashboard</Text>}\n            footer={renderFooter()}\n        >\n            <Box flexDirection=\"column\" flexGrow={1}>\n                <Box>\n                    {renderStatusBar()}\n                </Box>\n                \n                {isModal && (\n                    <Box marginY={1}>\n                        <ConfirmationContent transactionsToConfirm={transactionsToConfirm} />\n                    </Box>\n                )}\n                \n                <Box marginTop={1}><Text bold underline> EVENT STREAM (Last 15 minutes)</Text></Box>\n                <Box flexDirection=\"column\" marginTop={1} flexGrow={1}>\n                    {transactions.length === 0 && (\n                         <Box paddingLeft={2}><Text color=\"gray\">Listening for changes... no events yet.</Text></Box>\n                    )}\n                    {transactions.slice(viewOffset, viewOffset + viewportHeight).map((tx, index) => {\n                        const actualIndex = viewOffset + index;\n                        const isExpanded = expandedTransactionId === tx.id;\n                        const isNew = newTransactionIds.has(tx.id);\n                        return (\n                            <React.Fragment key={tx.id}>\n                                <EventStreamItem\n                                    transaction={tx}\n                                    isSelected={!isModal && actualIndex === selectedTransactionIndex}\n                                    isExpanded={isExpanded}\n                                    isNew={isNew}\n                                />\n                                {isExpanded && <ExpandedEventInfo transaction={tx} />}\n                            </React.Fragment>\n                        );\n                    })}\n                </Box>\n            </Box>\n        </ScreenLayout>\n    );\n};\n\nexport default DashboardScreen;"
  src/components/DebugLogScreen.tsx: >-
    import { Box, Text } from 'ink';

    import TextInput from 'ink-text-input';

    import ActionFooter from './ActionFooter';

    import { useDebugLogScreen } from '../hooks/useDebugLogScreen';

    import { DEBUG_LOG_FOOTER_ACTIONS, DEBUG_LOG_MODES, LOG_LEVEL_COLORS,
    LOG_LEVEL_TAGS } from '../constants/log.constants';

    import type { LogEntry } from '../types/log.types';

    import { useStdoutDimensions } from '../utils';

    import ScreenLayout from './layout/ScreenLayout';


    const LogEntryRow = ({ entry, isSelected }: { entry: LogEntry; isSelected:
    boolean }) => {
        const time = new Date(entry.timestamp).toISOString().split('T')[1]?.replace('Z', '');
        const color = LOG_LEVEL_COLORS[entry.level];
        const tagColors = LOG_LEVEL_TAGS[entry.level];

        return (
            <Text color={color}>
                {isSelected ? '> ' : '  '}
                <Text color="gray">{time}</Text>
                {' '}
                <Text bold color={tagColors.color} backgroundColor={tagColors.backgroundColor}>
                    {' '}{entry.level.padEnd(5, ' ')}{' '}
                </Text>
                {' '}
                {entry.message}
            </Text>
        );
    };


    const DebugLogScreen = () => {
        const {
            logsInView,
            logCount,
            filteredLogCount,
            selectedIndex,
            mode,
            filterQuery,
            setFilterQuery,
            viewOffset,
        } = useDebugLogScreen();
        const [width] = useStdoutDimensions();

        const renderFilter = () => (
            <Box>
                <Text>Filter: </Text>
                {mode === DEBUG_LOG_MODES.FILTER ? (
                    <TextInput
                        value={filterQuery}
                        onChange={setFilterQuery}
                        placeholder="Type to filter log messages..."
                    />
                ) : (
                    <Text color="gray">{filterQuery || '(none)'}</Text>
                )}
                <Box flexGrow={1} /> 
                <Text>
                    Showing {Math.min(viewOffset + 1, filteredLogCount)}-
                    {Math.min(viewOffset + logsInView.length, filteredLogCount)} of {filteredLogCount}
                </Text> 
            </Box>
        );

        const footerActions =
            mode === DEBUG_LOG_MODES.FILTER
                ? DEBUG_LOG_FOOTER_ACTIONS.FILTER_MODE
                : DEBUG_LOG_FOOTER_ACTIONS.LIST_MODE(logCount > 0);

        return (
            <ScreenLayout
                title="▲ relaycode · DEBUG LOG"
                footer={<ActionFooter actions={footerActions} />}
            >
                <Box flexDirection="column" flexGrow={1} paddingX={2}>
                    {renderFilter()}
                    <Box flexDirection="column" flexGrow={1} marginTop={1}>
                        {logsInView.map((entry, index) => (
                            <LogEntryRow
                                key={`${entry.timestamp}-${index}`}
                                entry={entry}
                                isSelected={selectedIndex === index + viewOffset}
                            />
                        ))}
                        {logCount > 0 && filteredLogCount === 0 && (
                            <Text color="gray">No logs match your filter.</Text>
                        )}
                        {logCount === 0 && (
                            <Text color="gray">No log entries yet. Waiting for system activity...</Text>
                        )}
                    </Box>
                </Box>
            </ScreenLayout>
        );
    };


    export default DebugLogScreen;
  src/components/GitCommitScreen.tsx: |-
    import { Box, Text } from 'ink';
    import Spinner from 'ink-spinner';
    import { useGitCommitScreen } from '../hooks/useGitCommitScreen';
    import ActionFooter from './ActionFooter';
    import ScreenLayout from './layout/ScreenLayout';
    import { COMMIT_FOOTER_ACTIONS } from '../constants/commit.constants';

    const GitCommitScreen = () => {
        const { transactionsToCommit, finalCommitMessage, isCommitting, commitError } = useGitCommitScreen();

        const messageParts = finalCommitMessage.split('\n');
        const subject = messageParts[0] || '';
        const body = messageParts.slice(1).join('\n');

        const renderError = () => (
            <Box 
                flexDirection="column" 
                borderStyle="round" 
                borderColor="red" 
                paddingX={2} 
                marginY={1}
            >
                <Text bold color="red">COMMIT FAILED</Text>
                <Text wrap="wrap">The git operation failed. Please check the error message below and resolve any issues before retrying.</Text>
                <Box marginTop={1}>
                    <Text color="red">{commitError}</Text>
                </Box>
            </Box>
        );

        const footer = isCommitting
                    ? <Text><Spinner type="dots"/> Committing... please wait.</Text>
                    : <ActionFooter actions={commitError ? COMMIT_FOOTER_ACTIONS.FAILURE : COMMIT_FOOTER_ACTIONS.BASE} />;

        return (
            <ScreenLayout
                title="▲ relaycode · GIT COMMIT"
                footer={footer}
            >
                <Box flexDirection="column" paddingX={2}>
                    <Box flexDirection="column">
                        <Text>Found {transactionsToCommit.length} new transactions to commit since last git commit.</Text>
                        <Box marginTop={1} flexDirection="column">
                            <Text bold>TRANSACTIONS INCLUDED</Text>
                            {transactionsToCommit.map(tx => (
                                <Text key={tx.id}>- <Text color="gray">{tx.hash}</Text>: {tx.message}</Text>
                            ))}
                        </Box>
                    </Box>
                    <Box marginY={1} flexDirection="column">
                        <Text bold>FINAL COMMIT MESSAGE</Text>
                        <Box marginTop={1} flexDirection="column">
                            <Text color="yellow">{subject}</Text>
                            {body ? <Text>{body}</Text> : null}
                        </Box>
                    </Box>
                    {commitError && renderError()}
                    {!commitError && <Text>This will run &apos;git add .&apos; and &apos;git commit&apos; with the message above.</Text>}
                </Box>
            </ScreenLayout>
        );
    };

    export default GitCommitScreen;
  src/components/ReviewScreen.tsx: >-
    import { Box, Text } from 'ink';

    import ContentView from './ContentView';

    import type { ScriptResult, FileItem, FileChangeType } from
    '../types/domain.types';

    import { useReviewScreen } from '../hooks/useReviewScreen';

    import { REVIEW_BODY_VIEWS, REVIEW_FOOTER_ACTIONS, BULK_REPAIR_OPTIONS,
    BULK_INSTRUCT_OPTIONS } from '../constants/review.constants';

    import ActionFooter from './ActionFooter';

    import { FILE_STATUS_UI } from '../constants/ui.constants';

    import ScreenLayout from './layout/ScreenLayout';


    // --- Sub-components ---


    const FileItemRow = ({ file, reviewState, isFocused }: {
        file: FileItem;
        reviewState: { status: string; error?: string; details?: string };
        isFocused: boolean;
    }) => {
        const ui = FILE_STATUS_UI[reviewState.status as keyof typeof FILE_STATUS_UI] || { icon: '[?]', color: 'gray' };

        const typeColor = (type: FileChangeType) => {
            switch (type) {
                case 'ADD': return 'green';
                case 'DEL': return 'red';
                case 'REN': return 'yellow';
                default: return 'white';
            }
        };

        const diffStats = <Text>(+<Text color="green">{file.linesAdded}</Text>/-<Text color="red">{file.linesRemoved}</Text>)</Text>;
        const strategy = file.strategy === 'standard-diff' ? 'diff' : file.strategy;
        const prefix = isFocused ? '> ' : '  ';
        const colorProps = isFocused ? { bold: true, color: 'cyan' } : {};

        if (reviewState.status === 'FAILED') {
            return (
                <Box>
                    <Text {...colorProps}>
                        {prefix}<Text color={ui.color}>{ui.icon} FAILED {file.path}</Text>
                        <Text color="red">    ({reviewState.error})</Text>
                    </Text>
                </Box>
            );
        }

        if (reviewState.status === 'AWAITING') {
            return (
                <Box>
                    <Text {...colorProps}>
                        {prefix}<Text color={ui.color}>{ui.icon} AWAITING {file.path}</Text>
                        <Text color="yellow">    ({reviewState.details})</Text>
                    </Text>
                </Box>
            );
        }

        if (reviewState.status === 'RE_APPLYING') {
            return (
                 <Box>
                    <Text {...colorProps}>
                        {prefix}<Text color={ui.color}>{ui.icon} RE-APPLYING... {file.path}</Text>
                        <Text color="cyan"> (using &apos;replace&apos; strategy)</Text>
                    </Text>
                </Box>
            );
        }

        return (
            <Box>
                <Text {...colorProps}>
                    {prefix}<Text color={ui.color}>{ui.icon}</Text> {file.type}{' '}
                    <Text color={typeColor(file.type)}>{file.path}</Text>{' '}
                    {diffStats} [{strategy}]
                </Text>
            </Box>
        );
    };


    const ScriptItemRow = ({
        script,
        isSelected,
        isExpanded,
    }: {
        script: ScriptResult;
        isSelected: boolean;
        isExpanded: boolean;
    }) => {
        const icon = script.success ? '✓' : '✗';
        const iconColor = script.success ? 'green' : 'red';
        const arrow = isExpanded ? '▾' : '▸';
        const prefix = isSelected ? '> ' : '  ';
        
        // Extract script type from command (e.g., "bun run test" -> "Post-Command", "bun run lint" -> "Linter")
        const scriptType = script.command.includes('test') ? 'Post-Command' : 
                          script.command.includes('lint') ? 'Linter' : 
                          'Script';

        return (
            <Box>
                <Text bold={isSelected} color={isSelected ? 'cyan' : undefined}>
                    {prefix}<Text color={iconColor}>{icon}</Text> {scriptType}: `{script.command}` ({script.duration}s) {arrow}{' '}
                    {script.summary}
                </Text>
            </Box>
        );
    };


    // --- Main Component ---


    const ReviewScreen = () => {
        const {
            transaction,
            files,
            scripts = [],
            patchStatus,
            selectedItemIndex,
            bodyView,
            isDiffExpanded,
            reasoningScrollIndex,
            scriptErrorIndex,
            fileReviewStates,
            numFiles,
            approvedFilesCount,
            totalLinesAdded,
            totalLinesRemoved,
            selectedBulkRepairOptionIndex,
            selectedBulkInstructOptionIndex,
            navigableItems,
            navigableItemsInView,
            viewOffset,
            contentScrollIndex,
            availableBodyHeight,
            hasRejectedFiles,
        } = useReviewScreen();

        if (!transaction) {
            return <Text>Loading review...</Text>;
        }
        const { hash, message, prompt = '', reasoning = '' } = transaction;

        const renderBody = () => {
            if (bodyView === REVIEW_BODY_VIEWS.NONE) return null;

            if (bodyView === REVIEW_BODY_VIEWS.REASONING) {
                const reasoningText = reasoning || '';
                const reasoningLinesCount = reasoningText.split('\n').length;
                const visibleLinesCount = 10;
                return (
                    <Box flexDirection="column">
                        <ContentView
                            title="REASONING"
                            content={reasoningText}
                            scrollIndex={contentScrollIndex}
                            maxHeight={Math.max(1, availableBodyHeight)}
                        />
                        {reasoningLinesCount > visibleLinesCount && (
                            <Text color="gray">
                                Showing lines {reasoningScrollIndex + 1}-{Math.min(reasoningScrollIndex + visibleLinesCount, reasoningLinesCount)}{' '}
                                of {reasoningLinesCount}
                            </Text>
                        )}
                    </Box>
                );
            }
            
            if (bodyView === REVIEW_BODY_VIEWS.DIFF) {
                const currentItem = navigableItems[selectedItemIndex];
                const selectedFile = currentItem?.type === 'file' ? files.find(f => f.id === currentItem.id) : undefined;
                if (!selectedFile) return null;
                return (
                    <ContentView
                        title={`DIFF: ${selectedFile.path}`}
                        content={selectedFile.diff}
                        highlight="diff"
                        isExpanded={isDiffExpanded}
                        scrollIndex={contentScrollIndex}
                    />
                );
            }

            if (bodyView === REVIEW_BODY_VIEWS.SCRIPT_OUTPUT) {
                 const currentItem = navigableItems[selectedItemIndex];
                 const scriptItems = navigableItems.filter((i): i is { type: 'script'; id: string } => i.type === 'script');
                 const scriptIndex = currentItem?.type === 'script'
                    ? scriptItems.findIndex(i => i.id === currentItem.id)
                    : -1;
                 const selectedScript = scripts[scriptIndex] || null;
                 if (!selectedScript) return null;
                 
                 const outputLines = selectedScript.output.split('\n');
                 const errorLines = outputLines.filter((line: string) =>
                    line.includes('Error') || line.includes('Warning'),
                 );
                 
                 return (
                    <Box flexDirection="column">
                        <Text>
                            {selectedScript.command.includes('lint') ? 'LINTER' : 'SCRIPT'} OUTPUT: `{selectedScript.command}`
                        </Text>
                        <Box marginTop={1} flexDirection="column">
                            {outputLines.map((line: string, index: number) => {
                                const isError = line.includes('Error');
                                const isWarning = line.includes('Warning');
                                const isHighlighted = errorLines[scriptErrorIndex] === line;
                                
                                return (
                                    <Text 
                                        key={index} 
                                        color={isError ? 'red' : isWarning ? 'yellow' : undefined}
                                        bold={isHighlighted}
                                        backgroundColor={isHighlighted ? 'blue' : undefined}
                                    >
                                        {line}
                                    </Text>
                                );
                            })}
                        </Box>
                        {errorLines.length > 0 && (
                            <Text color="gray">
                                Error {scriptErrorIndex + 1} of {errorLines.length} highlighted
                            </Text>
                        )}
                    </Box>
                 );
            }

            if (bodyView === REVIEW_BODY_VIEWS.CONFIRM_HANDOFF) {
                return (
                    <Box flexDirection="column" gap={1}>
                        <Text bold>HANDOFF TO EXTERNAL AGENT</Text>
                        <Box flexDirection="column">
                            <Text>This action will:</Text>
                            <Text>1. Copy a detailed prompt to your clipboard for an agentic AI.</Text>
                            <Text>2. Mark the current transaction as &apos;Handoff&apos; and close this review.</Text>
                            <Text>3. Assume that you and the external agent will complete the work.</Text>
                        </Box>
                        <Text>Relaycode will NOT wait for a new patch. This is a final action.</Text>
                        <Text bold color="yellow">Are you sure you want to proceed?</Text>
                    </Box>
                );
            }

            if (bodyView === REVIEW_BODY_VIEWS.BULK_REPAIR) {
                const failedFiles = files.filter((f: FileItem) => fileReviewStates.get(f.id)?.status === 'FAILED');

                return (
                    <Box flexDirection="column" gap={1}>
                        <Text bold>BULK REPAIR ACTION</Text>

                        <Box flexDirection="column">
                            <Text>The following {failedFiles.length} files failed to apply:</Text>
                            {failedFiles.map((file: FileItem) => (
                                <Text key={file.id}>- {file.path}</Text>
                            ))}
                        </Box>

                        <Text>How would you like to proceed?</Text>

                        <Box flexDirection="column">
                            {BULK_REPAIR_OPTIONS.map((opt, i) => (
                                <Text key={i} color={selectedBulkRepairOptionIndex === i ? 'cyan' : undefined}>
                                    {selectedBulkRepairOptionIndex === i ? '> ' : '  '}
                                    {opt}
                                </Text>
                            ))}
                        </Box>
                    </Box>
                );
            }

            if (bodyView === REVIEW_BODY_VIEWS.BULK_INSTRUCT) {
                const rejectedFiles = files.filter((f: FileItem) => fileReviewStates.get(f.id)?.status === 'REJECTED');

                return (
                    <Box flexDirection="column" gap={1}>
                        <Text bold>BULK INSTRUCTION ACTION</Text>

                        <Box flexDirection="column">
                            <Text>The following {rejectedFiles.length} files were rejected:</Text>
                            {rejectedFiles.map((file: FileItem) => (
                                <Text key={file.id}>- {file.path}</Text>
                            ))}
                        </Box>
                        <Box flexDirection="column" marginTop={1}>
                            {BULK_INSTRUCT_OPTIONS.map((opt, i) => (
                                <Text key={i} color={selectedBulkInstructOptionIndex === i ? 'cyan' : undefined}>
                                    {selectedBulkInstructOptionIndex === i ? '> ' : '  '}
                                    {opt}
                                </Text>
                            ))}
                        </Box>
                    </Box>
                );
            }

            return null;
        };

        const renderFooter = () => {
            // Contextual footer for body views
            if (bodyView === REVIEW_BODY_VIEWS.DIFF) return <ActionFooter actions={REVIEW_FOOTER_ACTIONS.DIFF_VIEW}/>;
            if (bodyView === REVIEW_BODY_VIEWS.REASONING) return <ActionFooter actions={REVIEW_FOOTER_ACTIONS.REASONING_VIEW}/>;
            if (bodyView === REVIEW_BODY_VIEWS.SCRIPT_OUTPUT) return <ActionFooter actions={REVIEW_FOOTER_ACTIONS.SCRIPT_OUTPUT_VIEW}/>;
            if (bodyView === REVIEW_BODY_VIEWS.BULK_REPAIR) return <Text>{REVIEW_FOOTER_ACTIONS.BULK_REPAIR_VIEW.text}</Text>;
            if (bodyView === REVIEW_BODY_VIEWS.BULK_INSTRUCT) return <Text>{REVIEW_FOOTER_ACTIONS.BULK_INSTRUCT_VIEW.text}</Text>;
            if (bodyView === REVIEW_BODY_VIEWS.CONFIRM_HANDOFF) return <ActionFooter actions={REVIEW_FOOTER_ACTIONS.HANDOFF_CONFIRM_VIEW}/>;

            // Dynamic Main footer
            const currentItem = navigableItems[selectedItemIndex];
            const hasFailedFiles = Array.from(fileReviewStates.values()).some(s => s.status === 'FAILED');
            const fileState = currentItem?.type === 'file' ? fileReviewStates.get(currentItem.id) : undefined;

            const footerConfig = {
                isFileSelected: currentItem?.type === 'file',
                fileStatus: fileState?.status as 'FAILED' | 'REJECTED' | 'OTHER' | undefined,
                currentItemType: currentItem?.type as 'file' | 'script' | 'reasoning' | 'prompt' | undefined,
                hasFailedFiles,
                hasRejectedFiles,
                hasApprovedFiles: approvedFilesCount > 0,
            };
            return <ActionFooter actions={REVIEW_FOOTER_ACTIONS.MAIN_VIEW(footerConfig)} />;
        };

        return (
            <ScreenLayout title="▲ relaycode · REVIEW" footer={renderFooter()}>
                {/* Navigator Section */}
                <Box flexDirection="column" marginY={1}>
                    <Box flexDirection="column">
                        <Text>{hash} · {message}</Text>
                        <Box>
                            <Text>
                                (<Text color="green">+{totalLinesAdded}</Text>/<Text color="red">-{totalLinesRemoved}</Text>)
                                {' '}| {numFiles} Files · ({approvedFilesCount}/{numFiles} Appr)
                                {' '}| Showing {viewOffset + 1}-
                                {Math.min(viewOffset + navigableItemsInView.length, navigableItems.length)}{' '}
                                of {navigableItems.length}
                            </Text>
                            {patchStatus === 'PARTIAL_FAILURE' && scripts.length === 0 && (
                                <Text> · Scripts: SKIPPED</Text>
                            )}
                            {patchStatus === 'PARTIAL_FAILURE' && <Text color="red" bold> · MULTIPLE PATCHES FAILED</Text>}
                        </Box>
                    </Box>

                    <Box flexDirection="column" marginTop={1}>
                        <Text color={navigableItems[selectedItemIndex]?.type === 'prompt' ? 'cyan' : undefined}>
                            {navigableItems[selectedItemIndex]?.type === 'prompt' ? '> ' : '  '}
                            (P)rompt ▸ {(prompt || '').substring(0, 50)}...
                        </Text>
                        <Text color={navigableItems[selectedItemIndex]?.type === 'reasoning' ? 'cyan' : undefined}>
                            {navigableItems[selectedItemIndex]?.type === 'reasoning' ? '> ' : '  '}
                            (R)easoning ({(reasoning || '').split('\n\n').length} steps){' '}
                            {bodyView === REVIEW_BODY_VIEWS.REASONING ? '▾' : '▸'}{' '}
                            {((reasoning || '').split('\n')[0] ?? '').substring(0, 40)}...
                        </Text>
                    </Box>
                </Box>

                {/* Script Results (if any) */}
                {scripts.length > 0 && navigableItemsInView.some(i => i.type === 'script') && (
                    <>
                        <Box flexDirection="column" marginY={1}>
                            {scripts.map((script: ScriptResult) => {
                                const itemInViewIndex = navigableItemsInView.findIndex(i => i.type === 'script' && i.id === script.command);
                                if (itemInViewIndex === -1) return null;
                                
                                const isSelected = selectedItemIndex === viewOffset + itemInViewIndex;
                                return (
                                    <ScriptItemRow key={script.command} script={script} isSelected={isSelected} isExpanded={bodyView === REVIEW_BODY_VIEWS.SCRIPT_OUTPUT && isSelected} />
                                );
                            })}
                        </Box>
                    </>
                )}
                
                {/* Files Section */}
                <Box flexDirection="column" marginY={1}>
                    <Text bold>FILES</Text>
                    {files.map((file: FileItem) => {
                        const itemInViewIndex = navigableItemsInView.findIndex(i => i.type === 'file' && i.id === file.id);
                        if (itemInViewIndex === -1) return null; // Only render if visible

                        const isFocused = selectedItemIndex === viewOffset + itemInViewIndex;
                        const reviewState = fileReviewStates.get(file.id);
                        
                        return (
                            <FileItemRow key={file.id} file={file} isFocused={isFocused} reviewState={reviewState || { status: 'AWAITING' }} />
                        );
                    })}
                </Box>

                {/* Body Viewport */}
                {bodyView !== REVIEW_BODY_VIEWS.NONE && (
                    <Box marginY={1}>
                        {renderBody()}
                    </Box>
                )}
            </ScreenLayout>
        );
    };


    export default ReviewScreen;
  src/hooks/useCopyScreen.tsx: |-
    import { useState, useEffect } from 'react';
    import { useCopyStore } from '../stores/copy.store';
    import { useViewStore } from '../stores/view.store';
    import { useViewport } from './useViewport';
    import { UI_CONFIG } from '../config/ui.config';
    import { OVERLAYS } from '../constants/view.constants';
    import { useListNavigator } from './useListNavigator.js';

    export const useCopyScreen = () => {
        const [selectedIndex, setSelectedIndex] = useState(0);

        const {
            title, items, selectedIds, lastCopiedMessage,
            actions,
        } = useCopyStore(state => ({ ...state, actions: state.actions }));
        
        useEffect(() => setSelectedIndex(0), [items]);

        const { viewOffset, viewportHeight } = useViewport({
            selectedIndex,
            itemCount: items.length,
            layoutConfig: UI_CONFIG.layout.copyScreen,
        });


        useListNavigator({
            itemCount: items.length,
            viewportHeight,
            selectedIndex,
            onIndexChange: setSelectedIndex,
            isActive: useViewStore.getState().activeOverlay === OVERLAYS.COPY,
            onKey: (input, key) => {
                if (key.escape) {
                    actions.close();
                    return;
                }
                if (input === ' ') {
                    actions.toggleSelection();
                    return;
                }
                if (key.return) {
                    actions.executeCopy();
                    return;
                }
                const item = items.find(i => i.key.toLowerCase() === input.toLowerCase());
                if (item) {
                    actions.toggleSelectionById(item.id);
                }
            },
        });

        const itemsInView = items.slice(viewOffset, viewOffset + viewportHeight);

        return {
            title,
            itemsInView,
            selectedIndex,
            selectedIds,
            lastCopiedMessage,
            viewOffset,
        };
    };
  src/components/TransactionDetailScreen.tsx: >-
    import { Box, Text } from 'ink';

    import Separator from './Separator';

    import ContentView from './ContentView';

    import type { FileChangeType } from '../types/domain.types';

    import { useTransactionDetailScreen } from
    '../hooks/useTransactionDetailScreen';

    import { DETAIL_BODY_VIEWS, DETAIL_FOOTER_ACTIONS } from
    '../constants/detail.constants';

    import ActionFooter from './ActionFooter';

    import { FILE_CHANGE_ICONS } from '../constants/ui.constants';

    import ScreenLayout from './layout/ScreenLayout';


    const RevertModal = ({ transactionHash }: { transactionHash: string }) => {
        return (
            <Box 
                borderStyle="round"
                borderColor="yellow"
                flexDirection="column"
                paddingX={2}
                width="80%"
                alignSelf='center'
            >
                <Text bold color="yellow" wrap="wrap" >REVERT THIS TRANSACTION?</Text>
                <Box height={1} />
                <Text wrap="wrap">This will create a NEW transaction that reverses all changes made by {transactionHash}. The original transaction record will be preserved.</Text>
                <Box height={1} />
                <Text wrap="wrap">Are you sure?</Text>
            </Box>
        );
    };


    const typeColor = (type: FileChangeType) => {
        switch (type) {
            case 'ADD': return 'green';
            case 'DEL': return 'red';
            case 'REN': return 'yellow';
            default: return 'white';
        }
    };


    const TransactionDetailScreen = () => {
        const {
            transaction, files,
            focusedItemPath, expandedItemPaths, bodyView, contentScrollIndex, availableBodyHeight,
        } = useTransactionDetailScreen();

        if (!transaction) {
            return <Text>Loading transaction...</Text>;
        }

        const renderNavigator = () => {
            const isPromptFocused = focusedItemPath === 'PROMPT';
            const isReasoningFocused = focusedItemPath === 'REASONING';
            const isFilesFocused = focusedItemPath.startsWith('FILES');
            
            const isPromptExpanded = expandedItemPaths.has('PROMPT');
            const isReasoningExpanded = expandedItemPaths.has('REASONING');
            const isFilesExpanded = expandedItemPaths.has('FILES');
            
            return (
                <Box flexDirection="column">
                    <Text color={isPromptFocused ? 'cyan' : undefined}>
                        {isPromptFocused ? '> ' : '  '}
                        {isPromptExpanded ? '▾' : '▸'} (<Text color="cyan" bold>P</Text>)rompt
                    </Text>
                    <Text color={isReasoningFocused ? 'cyan' : undefined}>
                        {isReasoningFocused ? '> ' : '  '}
                        {isReasoningExpanded ? '▾' : '▸'} (<Text color="cyan" bold>R</Text>)easoning{' '}
                        ({transaction.reasoning?.split('\n\n').length || 0} steps)
                    </Text>
                    <Text color={isFilesFocused ? 'cyan' : undefined}>
                        {isFilesFocused && !focusedItemPath.includes('/') ? '> ' : '  '}
                        {isFilesExpanded ? '▾' : '▸'} (<Text color="cyan" bold>F</Text>)iles ({files.length})
                    </Text>
                    {isFilesExpanded && (
                        <Box flexDirection="column" paddingLeft={2}>
                            {files.map((file) => {
                                 const fileId = `FILES/${file.id}`;
                                 const isFileSelected = focusedItemPath === fileId;
                                 const stats = file.type === 'DEL' ? ''
                                    : ` (+${file.linesAdded}/-${file.linesRemoved})`;
                                 return (
                                    <Text key={file.id} color={isFileSelected ? 'cyan' : undefined}>
                                        {isFileSelected ? '> ' : '  '}
                                        {FILE_CHANGE_ICONS[file.type]} <Text color={typeColor(file.type)}>{file.path}</Text>{stats}
                                    </Text>
                                );
                            })}
                        </Box>
                    )}
                </Box>
            );
        };

        const renderBody = () => {
            if (bodyView === DETAIL_BODY_VIEWS.NONE) {
                return <Text color="gray">(Press → to expand a section and view its contents)</Text>;
            }
            if (bodyView === DETAIL_BODY_VIEWS.PROMPT) {
                return (
                    <Box flexDirection="column">
                        <Text>PROMPT</Text>
                        <Box marginTop={1} flexDirection="column">
                            {(transaction.prompt || '').split('\n')
                                .slice(contentScrollIndex, contentScrollIndex + availableBodyHeight)
                                .map((line, i) => <Text key={i}>{line}</Text>)
                            }
                        </Box>
                    </Box>
                );
            }
            if (bodyView === DETAIL_BODY_VIEWS.REASONING) {
                if (!transaction.reasoning) return <Text color="gray">No reasoning provided.</Text>;
                return <ContentView title="REASONING" content={transaction.reasoning} scrollIndex={contentScrollIndex} maxHeight={Math.max(1, availableBodyHeight)} />;
            }
            if (bodyView === DETAIL_BODY_VIEWS.FILES_LIST) {
                 return <Text color="gray">(Select a file and press → to view the diff)</Text>;
            }
            if (bodyView === DETAIL_BODY_VIEWS.DIFF_VIEW) {
                const fileId = focusedItemPath.split('/')[1];
                const file = files.find(f => f.id === fileId);
                if (!file) return null;
                return <ContentView
                    title={`DIFF: ${file.path}`}
                    content={file.diff}
                    highlight='diff'
                    isExpanded={true}
                    scrollIndex={contentScrollIndex}
                    maxHeight={Math.max(1, availableBodyHeight)}
                />;
            }
            return null;
        };

        const renderFooter = () => {
            if (bodyView === DETAIL_BODY_VIEWS.REVERT_CONFIRM) {
                return <ActionFooter actions={DETAIL_FOOTER_ACTIONS.REVERT_CONFIRM} />;
            }
            
            const isFileFocused = focusedItemPath.includes('/');
            const openActionLabel = isFileFocused ? 'Open File' : 'Open YAML';
            const isRevertable = ['APPLIED', 'FAILED'].includes(transaction.status);
            const baseActions = DETAIL_FOOTER_ACTIONS.BASE({
                openActionLabel,
                isRevertable,
            });

            if (isFileFocused) { // Is a file
                if (bodyView === DETAIL_BODY_VIEWS.DIFF_VIEW) {
                    return <ActionFooter actions={[...DETAIL_FOOTER_ACTIONS.DIFF_VIEW, ...baseActions]} />;
                } else {
                    return <ActionFooter actions={[...DETAIL_FOOTER_ACTIONS.FILE_LIST_VIEW, ...baseActions]} />;
                }
            }
            
            if (expandedItemPaths.has(focusedItemPath)) {
                return <ActionFooter actions={[...DETAIL_FOOTER_ACTIONS.SECTION_EXPANDED, ...baseActions]} />;
            }
            return <ActionFooter actions={[...DETAIL_FOOTER_ACTIONS.SECTION_COLLAPSED, ...baseActions]} />;
        };

        const { message, timestamp, status } = transaction;
        const date = new Date(timestamp).toISOString().replace('T', ' ').substring(0, 19);
        const fileStats = `${files.length} Files · +${files.reduce((a, f) => a + f.linesAdded, 0)} lines, -${files.reduce((a, f) => a + f.linesRemoved, 0)} lines`;

        return (
            <ScreenLayout
                title="▲ relaycode · TRANSACTION DETAILS"
                footer={renderFooter()}
            >
                {/* Modal takeover for Revert */}
                {bodyView === DETAIL_BODY_VIEWS.REVERT_CONFIRM && <RevertModal transactionHash={transaction.hash} />}

                {/* Main view */}
                <Box flexDirection="column" display={bodyView === DETAIL_BODY_VIEWS.REVERT_CONFIRM ? 'none' : 'flex'}>
                    <Box flexDirection="column">
                        <Text><Text color="gray">UUID:</Text> {transaction.id}</Text>
                        <Text><Text color="gray">Git:</Text> {message}</Text>
                        <Text><Text color="gray">Date:</Text> {date} · <Text color="gray">Status:</Text> {status}</Text>
                        <Text><Text color="gray">Stats:</Text> {fileStats}</Text>
                    </Box>

                    <Box marginY={1}>
                        {renderNavigator()}
                    </Box>

                    {/* Body */}
                    <Box marginY={1}>
                        {renderBody()}
                    </Box>
                </Box>
            </ScreenLayout>
        );
    };


    export default TransactionDetailScreen;
  src/components/TransactionHistoryScreen.tsx: >-
    import { useMemo } from 'react';

    import { Box, Text } from 'ink';

    import TextInput from 'ink-text-input';

    import Spinner from 'ink-spinner';

    import type { Transaction, FileItem } from '../types/domain.types';

    import { useTransactionHistoryScreen } from
    '../hooks/useTransactionHistoryScreen';

    import { HISTORY_FOOTER_ACTIONS, BULK_ACTIONS_OPTIONS, HISTORY_VIEW_MODES }
    from '../constants/history.constants';

    import ActionFooter from './ActionFooter';

    import ScreenLayout from './layout/ScreenLayout';

    import { TRANSACTION_STATUS_UI, FILE_CHANGE_ICONS } from
    '../constants/ui.constants';


    // --- Sub-components ---


    const ContentRow = ({ title, content, isSelected, isExpanded, isLoading }: {
        title: string;
        content: string;
        isSelected: boolean;
        isExpanded: boolean;
        isLoading: boolean;
    }) => {
        const icon = isExpanded ? '▾' : '▸';
        return (
            <Box flexDirection="column" paddingLeft={6}>
                <Text color={isSelected ? 'cyan' : undefined}>
                    {isSelected ? '> ' : '  '}{icon} {title}
                </Text>
                {isLoading && <Box paddingLeft={8}><Spinner type="dots" /></Box>}
                {isExpanded && !isLoading && (
                    <Box paddingLeft={8} flexDirection="column">
                        {(content || '').split('\n').map((line, i) => <Text key={i}>{line || ' '}</Text>)}
                    </Box>
                )}
            </Box>
        );
    };


    const DiffPreview = ({ diff }: { diff: string }) => {
        const lines = diff.split('\n');
        const previewLines = lines.slice(0, 5);
        const hiddenLines = lines.length > 5 ? lines.length - 5 : 0;

        return (
            <Box flexDirection="column" paddingLeft={8}>
                {previewLines.map((line, i) => {
                    let color = 'white';
                    if (line.startsWith('+')) color = 'green';
                    if (line.startsWith('-')) color = 'red';
                    if (line.startsWith('@@')) color = 'cyan';
                    return <Text key={i} color={color}>{line}</Text>;
                })}
                {hiddenLines > 0 && <Text color="gray">... {hiddenLines} lines hidden ...</Text>}
            </Box>
        );
    };


    const FileRow = ({ file, isSelected, isExpanded, isLoading }: {
        file: FileItem;
        isSelected: boolean;
        isExpanded: boolean;
        isLoading: boolean;
    }) => {
        const icon = isExpanded ? '▾' : '▸';

        return (
            <Box flexDirection="column" paddingLeft={6}>
                <Text color={isSelected ? 'cyan' : undefined}>
                    {isSelected ? '> ' : '  '}{' '}
                    {icon} {FILE_CHANGE_ICONS[file.type]} {file.path}
                </Text>
                {isLoading && <Box paddingLeft={8}><Spinner type="dots" /></Box>}
                {isExpanded && !isLoading && <DiffPreview diff={file.diff} />}
            </Box>
        );
    };


    const TransactionRow = ({
        tx,
        isSelected,
        isExpanded,
        isSelectedForAction,
        hasSelection,
    }: {
        tx: Transaction;
        isSelected: boolean;
        isExpanded: boolean;
        isSelectedForAction: boolean;
        hasSelection: boolean;
    }) => {
        const icon = isExpanded ? '▾' : '▸';
        const uiStatus = TRANSACTION_STATUS_UI[tx.status as keyof typeof TRANSACTION_STATUS_UI] || { text: tx.status, color: 'white' };

        const date = new Date(tx.timestamp).toISOString().split('T')[0];
        const selectionIndicator = isSelectedForAction ? '[x] ' : '[ ] ';
        
        return (
            <Box flexDirection="column" marginBottom={isExpanded ? 1 : 0}>
                <Text color={isSelected ? 'cyan' : undefined}>
                    {isSelected ? '> ' : '  '}
                    {hasSelection && selectionIndicator}
                    {icon} <Text color={uiStatus.color}>{uiStatus.text}</Text> · <Text color="gray">{tx.hash}</Text> · {date} ·{' '}
                    {tx.message}
                </Text>
                {isExpanded && (
                    <Box flexDirection="column" paddingLeft={8}>
                        {tx.stats && (
                            <Text color="gray">
                                Stats: {tx.stats.files} files, +{tx.stats.linesAdded}/-{tx.stats.linesRemoved}
                            </Text>
                        )}
                        <Text>Files:</Text>
                    </Box>
                )}
            </Box>
        );
    };


    const BulkActionsMode = ({ selectedForActionCount }: {
    selectedForActionCount: number }) => {
        return (
            <Box flexDirection="column" marginY={1}>
                <Text bold color="yellow">PERFORM BULK ACTION ON {selectedForActionCount} SELECTED ITEMS</Text>
                <Box marginY={1}>
                    <Text>This action is often irreversible. Are you sure?</Text>
                </Box>
                {BULK_ACTIONS_OPTIONS.map(opt => <Text key={opt}>{opt}</Text>)}
            </Box>
        );
    };


    // --- Main Component ---


    const TransactionHistoryScreen = () => {
        const {
            mode,
            filterQuery,
            selectedForAction,
            selectedItemPath,
            expandedIds,
            loadingPaths,
            actions,
            transactions,
            itemsInView,
            filterStatus,
            showingStatus,
            statsStatus,
            hasSelection,
        } = useTransactionHistoryScreen();

        const transactionsById = useMemo(() => new Map(transactions.map(tx => [tx.id, tx])), [transactions]);

        const renderFooter = () => {
            if (mode === HISTORY_VIEW_MODES.FILTER) {
                return <ActionFooter actions={HISTORY_FOOTER_ACTIONS.FILTER_MODE} />;
            }
            if (mode === HISTORY_VIEW_MODES.BULK_ACTIONS) {
                return <Text>{HISTORY_FOOTER_ACTIONS.BULK_MODE.text}</Text>;
            }
            
            const openActionLabel = selectedItemPath.includes('/file/') ? 'Open File' : 'Open YAML';
            return <ActionFooter actions={HISTORY_FOOTER_ACTIONS.LIST_MODE(openActionLabel, hasSelection)} />;
        };

        return (
            <ScreenLayout title="▲ relaycode · TRANSACTION HISTORY" footer={renderFooter()}>
                <Box>
                    <Text>Filter: </Text>
                    {mode === HISTORY_VIEW_MODES.FILTER ? (
                        <TextInput value={filterQuery} onChange={actions.setFilterQuery} />
                    ) : (
                        <Text>{filterStatus}</Text>
                    )}
                    <Text> · {showingStatus}</Text>
                    {statsStatus && <Text> · <Text color="magenta">{statsStatus}</Text></Text>}
                </Box>

                <Box flexDirection="column" marginY={1}>
                    {mode === HISTORY_VIEW_MODES.BULK_ACTIONS && <BulkActionsMode selectedForActionCount={selectedForAction.size} />}

                    {mode === HISTORY_VIEW_MODES.LIST && itemsInView.map(path => {
                        const txId = path.split('/')[0]!;
                        const tx = transactionsById.get(txId);
                        if (!tx) return <Text key={path}>Error: Missing TX {txId}</Text>;

                        // Is a transaction row
                        if (path === tx.id) {
                            return (
                                <TransactionRow
                                    key={path}
                                    tx={tx}
                                    isSelected={selectedItemPath === path}
                                    isExpanded={expandedIds.has(path)}
                                    isSelectedForAction={selectedForAction.has(tx.id)}
                                    hasSelection={hasSelection}
                                />
                            );
                        }

                        // Is a child row
                        const itemType = path.split('/')[1]!;
                        const isSelected = selectedItemPath === path;
                        const isExpanded = expandedIds.has(path);
                        const isLoading = loadingPaths.has(path);

                        if (itemType === 'file') {
                            const fileId = path.split('/')[2]!;
                            const file = tx.files?.find(f => f.id === fileId);
                            if (!file) return null;
                            return (
                                <FileRow
                                    key={path} file={file} isSelected={isSelected}
                                    isExpanded={isExpanded} isLoading={isLoading}
                                />
                            );
                        }

                        const contentMap = {
                            message: { title: 'Commit Message', content: tx.message || '' },
                            prompt: { title: 'Prompt', content: tx.prompt || '' },
                            reasoning: { title: 'Reasoning', content: tx.reasoning || '' },
                        };

                        const item = contentMap[itemType as keyof typeof contentMap];
                        if (!item) return null;

                        return (
                            <ContentRow
                                key={path}
                                {...item}
                                isSelected={isSelected}
                                isExpanded={isExpanded}
                                isLoading={isLoading}
                            />
                        );
                    })}
                </Box>
            </ScreenLayout>
        );
    };



    export default TransactionHistoryScreen;
  src/stores/review.store.ts: >-
    import { create } from 'zustand';

    import { useAppStore } from './app.store';

    import { useTransactionStore } from './transaction.store';

    import { useViewStore } from './view.store';

    import { ReviewService, type SimulationResult } from
    '../services/review.service';

    import { INITIAL_APPLY_STEPS, PATCH_STATUS, REVIEW_BODY_VIEWS,
    BULK_INSTRUCT_OPTIONS, BULK_REPAIR_OPTIONS } from
    '../constants/review.constants';

    import { sleep } from '../utils';

    import type { FileReviewStatus } from '../types/domain.types';


    export interface ApplyStep {
        id: string;
        title: string;
        status: 'pending' | 'active' | 'done' | 'failed' | 'skipped';
        details?: string;
        substeps?: ApplyStep[];
        startTime?: number;
        duration?: number;
    }


    export type ReviewBodyView = (typeof REVIEW_BODY_VIEWS)[keyof typeof
    REVIEW_BODY_VIEWS];

    export type PatchStatus = (typeof PATCH_STATUS)[keyof typeof PATCH_STATUS];

    export type ApplyUpdate =
        | { type: 'UPDATE_STEP'; payload: { id: string; status: ApplyStep['status']; duration?: number; details?: string } }
        | { type: 'ADD_SUBSTEP'; payload: { parentId: string; substep: Omit<ApplyStep, 'substeps'> } }
        | { type: 'UPDATE_SUBSTEP'; payload: { parentId: string; substepId: string; status: ApplyStep['status']; title?: string } };

    interface ReviewState {
        patchStatus: PatchStatus;
        applySteps: ApplyStep[];
        selectedItemIndex: number;
        bodyView: ReviewBodyView;
        isDiffExpanded: boolean;
        reasoningScrollIndex: number;
        scriptErrorIndex: number;
        processingStartTime: number | null;
        fileReviewStates: Map<string, { status: FileReviewStatus; error?: string; details?: string }>;

        selectedBulkRepairOptionIndex: number;
        selectedBulkInstructOptionIndex: number;
        isCancelling: boolean;
        isSkipping: boolean;

        actions: {
            load: (transactionId: string, initialState?: Partial<Pick<ReviewState, 'bodyView' | 'selectedBulkRepairOptionIndex'>>) => void;
            setSelectedItemIndex: (index: number) => void;
            expandDiff: () => void;
            toggleBodyView: (view: Extract<
                ReviewBodyView, 'bulk_instruct' |
                'diff' | 'reasoning' | 'script_output' | 'bulk_repair' | 'confirm_handoff'
            >) => void;
            setBodyView: (view: ReviewBodyView) => void;
            approve: () => void;
            startApplySimulation: (transactionId: string, scenario: 'success' | 'failure') => void;
            tryRepairFile: (fileId: string) => void;
            showBulkRepair: () => void;
            executeBulkRepairOption: (option: number) => Promise<void>;
            skipCurrentStep: () => void;
            resetSkip: () => void;
            tryInstruct: (fileId: string) => void;
            cancelProcessing: () => void;
            showBulkInstruct: () => void;
            executeBulkInstructOption: (option: number) => Promise<void>;
            confirmHandoff: () => void;
            scrollReasoningUp: () => void;
            scrollReasoningDown: () => void;
            navigateScriptErrorUp: () => void;
            navigateScriptErrorDown: () => void;
            updateApplyStep: (id: string, status: ApplyStep['status'], details?: string) => void;
            addApplySubstep: (parentId: string, substep: Omit<ApplyStep, 'substeps'>) => void;
            updateApplySubstep: (parentId: string, substepId: string, status: ApplyStep['status'], title?: string) => void;
            updateFileReviewStatus: (fileId: string, status: FileReviewStatus, error?: string, details?: string) => void;
            toggleFileApproval: (fileId: string) => void;
            rejectAllFiles: () => void;
            navigateBulkRepairUp: () => void;
            navigateBulkRepairDown: () => void;
            navigateBulkInstructUp: () => void;
            navigateBulkInstructDown: () => void;
        };
    }


    export const useReviewStore = create<ReviewState>((set, get) => ({
        patchStatus: PATCH_STATUS.SUCCESS,
        applySteps: INITIAL_APPLY_STEPS,
        selectedItemIndex: 0,
        bodyView: REVIEW_BODY_VIEWS.NONE,
        isDiffExpanded: false,
        reasoningScrollIndex: 0,
        scriptErrorIndex: 0,
        processingStartTime: null,
        fileReviewStates: new Map(),
        selectedBulkRepairOptionIndex: 0,
        selectedBulkInstructOptionIndex: 0,
        isCancelling: false,
        isSkipping: false,

        actions: {
            load: (transactionId, initialState) => {
                const transaction = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!transaction) return;

                // This logic is preserved from the deleted `prepareTransactionForReview`
                // to allow debug screens to jump directly to a pre-populated review state
                // without running the full simulation.
                const isFailureCase = transaction.id === '1';
                const fileReviewStates = new Map<string, { status: FileReviewStatus; error?: string }>();
                (transaction.files || []).forEach((file, index) => {
                    if (isFailureCase) {
                        const isFailedFile = index > 0;
                        const status = isFailedFile ? 'FAILED' : 'APPROVED';
                        const error = isFailedFile ? (index === 1 ? 'Hunk #1 failed to apply' : 'Context mismatch at line 92') : undefined;
                        fileReviewStates.set(file.id, { status, error });
                    } else {
                        fileReviewStates.set(file.id, { status: 'APPROVED' });
                    }
                });
                const patchStatus = isFailureCase ? 'PARTIAL_FAILURE' : 'SUCCESS';
                useViewStore.getState().actions.setSelectedTransactionId(transaction.id);
                set({
                    patchStatus,
                    fileReviewStates,
                    processingStartTime: null,
                    selectedItemIndex: 0,
                    bodyView: initialState?.bodyView ?? REVIEW_BODY_VIEWS.NONE,
                    isDiffExpanded: false,
                    reasoningScrollIndex: 0,
                    scriptErrorIndex: 0,
                    applySteps: JSON.parse(JSON.stringify(INITIAL_APPLY_STEPS)),
                    selectedBulkRepairOptionIndex: 0,
                    selectedBulkInstructOptionIndex: 0,
                    ...initialState,
                });
            },
            setSelectedItemIndex: (index) => set({ selectedItemIndex: index }),
            toggleBodyView: (view) => set(state => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                const files = tx?.files || [];
                if (view === 'diff' && state.selectedItemIndex >= files.length) return {};
                return {
                    bodyView: state.bodyView === view ? REVIEW_BODY_VIEWS.NONE : view,
                    isDiffExpanded: false,
                };
            }),
            setBodyView: (view) => set({ bodyView: view }),
            expandDiff: () => set(state => ({ isDiffExpanded: !state.isDiffExpanded })),
            approve: () => {
                const { selectedTransactionId } = useViewStore.getState();
                if (selectedTransactionId) {
                    useTransactionStore.getState().actions.updateTransactionStatus(selectedTransactionId, 'APPLIED');
                    useAppStore.getState().actions.showDashboardScreen();
                }
            },
            startApplySimulation: async (transactionId, scenario) => {
                const transaction = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!transaction?.files) return;

                const { showReviewProcessingScreen, showReviewScreen } = useAppStore.getState().actions;
                const { updateApplyStep, addApplySubstep, updateApplySubstep } = get().actions;

                useViewStore.getState().actions.setSelectedTransactionId(transaction.id);
                set({
                    applySteps: JSON.parse(JSON.stringify(INITIAL_APPLY_STEPS)),
                    processingStartTime: Date.now(),
                    isCancelling: false,
                    isSkipping: false,
                    fileReviewStates: new Map(), // Clear previous states
                });

                showReviewProcessingScreen();
                const simulationGenerator = ReviewService.runApplySimulation(transaction.files, scenario);
                let simulationResult: SimulationResult;

                // Manually iterate to get the return value from the async generator
                const iterator = simulationGenerator[Symbol.asyncIterator]();
                while (true) {
                    const { value, done } = await iterator.next();
                    if (done) {
                        simulationResult = value as SimulationResult;
                        break;
                    }
                    const update = value;
                    if (update.type === 'UPDATE_STEP') {
                        updateApplyStep(update.payload.id, update.payload.status, update.payload.details);
                    } else if (update.type === 'ADD_SUBSTEP') {
                        addApplySubstep(update.payload.parentId, update.payload.substep);
                    } else if (update.type === 'UPDATE_SUBSTEP') {
                        updateApplySubstep(update.payload.parentId, update.payload.substepId, update.payload.status, update.payload.title);
                    }
                }

                await sleep(1000);
                set({
                    processingStartTime: null,
                    fileReviewStates: simulationResult.fileReviewStates,
                    patchStatus: simulationResult.patchStatus,
                });
                showReviewScreen();
            },
            tryRepairFile: (fileId) => {
                const selectedTransactionId = useViewStore.getState().selectedTransactionId;
                const { fileReviewStates } = get();
                if (!selectedTransactionId) return;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                const file = tx?.files?.find(f => f.id === fileId);
                if (!file) return;

                const { status, error } = fileReviewStates.get(file.id) || {};
                if (status !== 'FAILED') return;
                
                ReviewService.tryRepairFile(file, error);
                get().actions.updateFileReviewStatus(file.id, 'AWAITING');
            },
            tryInstruct: (fileId) => {
                const selectedTransactionId = useViewStore.getState().selectedTransactionId;
                const { fileReviewStates } = get();
                if (!selectedTransactionId) return;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                const file = tx?.files?.find(f => f.id === fileId);
                if (!tx || !file) return;

                const { status } = fileReviewStates.get(file.id) || {};
                if (status !== 'REJECTED') return;
                
                ReviewService.tryInstructFile(file, tx);
                get().actions.updateFileReviewStatus(file.id, 'AWAITING', undefined, 'Instruction prompt copied!');
            },
            showBulkInstruct: () => get().actions.setBodyView('bulk_instruct'),
            cancelProcessing: () => set({ isCancelling: true }),
            skipCurrentStep: () => set({ isSkipping: true }),
            resetSkip: () => set({ isSkipping: false }),
            executeBulkInstructOption: async (option) => {
                const selectedTransactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                if (!tx?.files) return;

                const rejectedFiles = tx.files.filter(f => get().fileReviewStates.get(f.id)?.status === 'REJECTED');
                if (rejectedFiles.length === 0) {
                    set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                    return;
                }

                switch (option) {
                    case 1:
                        ReviewService.generateBulkInstructPrompt(rejectedFiles, tx);
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                        break;
                    case 2:
                        get().actions.setBodyView('confirm_handoff');
                        break;
                    case 3:
                        rejectedFiles.forEach(file => {
                            get().actions.updateFileReviewStatus(file.id, 'APPROVED');
                        });
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                        break;
                    default:
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                }
            },

            showBulkRepair: () => get().actions.toggleBodyView('bulk_repair'),
            executeBulkRepairOption: async (option) => {
                const selectedTransactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                if (!tx?.files) return;

                const failedFiles = tx.files.filter(f => get().fileReviewStates.get(f.id)?.status === 'FAILED');
                if (failedFiles.length === 0) {
                    set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                    return;
                }

                switch (option) {
                    case 1:
                        ReviewService.generateBulkRepairPrompt(failedFiles);
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                        break;
                    case 2: {
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                        failedFiles.forEach(f => get().actions.updateFileReviewStatus(f.id, 'RE_APPLYING'));
                        const results = await ReviewService.runBulkReapply(failedFiles);
                        results.forEach(result =>
                            get().actions.updateFileReviewStatus(
                                result.id, result.status, result.error,
                            ),
                        );
                        break;
                    }
                    case 3:
                        get().actions.setBodyView('confirm_handoff');
                        break;
                    case 4:
                        failedFiles.forEach(file => {
                            get().actions.updateFileReviewStatus(file.id, 'REJECTED');
                        });
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                        break;
                    default:
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                }
            },
            confirmHandoff: () => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!tx?.files) return;
                const { fileReviewStates } = get();
                ReviewService.generateHandoffPrompt(tx, fileReviewStates);
                ReviewService.performHandoff(tx.hash);
            },
            scrollReasoningUp: () => set(state => ({ reasoningScrollIndex: Math.max(0, state.reasoningScrollIndex - 1) })),
            scrollReasoningDown: () => set(state => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!tx?.reasoning) return {};
                const maxLines = tx.reasoning.split('\n').length;
                return { reasoningScrollIndex: Math.min(maxLines - 1, state.reasoningScrollIndex + 1) };
            }),
            navigateScriptErrorUp: () => set(state => ({ scriptErrorIndex: Math.max(0, state.scriptErrorIndex - 1) })),
            navigateScriptErrorDown: () => set(state => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!tx?.scripts || !tx?.files) return {};
                const selectedScript = tx.scripts[state.selectedItemIndex - tx.files.length];
                if (selectedScript?.output) {
                    const errorLines = selectedScript.output
                        .split('\n')
                        .filter(line => line.includes('Error') || line.includes('Warning'));
                    return { scriptErrorIndex: Math.min(errorLines.length - 1, state.scriptErrorIndex + 1) };
                }
                return {};
            }),
            updateApplyStep: (id, status, details) => {
                set(state => {
                    const newSteps = state.applySteps.map(s => {
                        if (s.id === id) {
                            const newStep: ApplyStep = { ...s, status };
                            if (status === 'active') {
                                newStep.startTime = Date.now();
                            } else if ((status === 'done' || status === 'failed' || status === 'skipped') && s.startTime) {
                                newStep.duration = (Date.now() - s.startTime) / 1000;
                            }
                            if (details !== undefined) newStep.details = details;
                            return newStep;
                        }
                        return s;
                    });
                    return { applySteps: newSteps };
                });
            },
            updateApplySubstep: (parentId, substepId, status, title) => {
                set(state => ({
                    applySteps: state.applySteps.map(s => {
                        if (s.id === parentId && s.substeps) {
                            const newSubsteps = s.substeps.map(sub => {
                                if (sub.id === substepId) {
                                    const newSub: ApplyStep = { ...sub, status };
                                    if (status === 'active') {
                                        newSub.startTime = Date.now();
                                    } else if ((status === 'done' || status === 'failed') && sub.startTime) {
                                        newSub.duration = (Date.now() - sub.startTime) / 1000;
                                    }
                                    if (title) newSub.title = title;
                                    return newSub;
                                }
                                return sub;
                            });
                            return { ...s, substeps: newSubsteps };
                        }
                        return s;
                    }),
                }));
            },
            addApplySubstep: (parentId, substep) => {
                set(state => ({
                    applySteps: state.applySteps.map(s => {
                        if (s.id === parentId) {
                            const newSubsteps = [...(s.substeps || []), substep as ApplyStep];
                            return { ...s, substeps: newSubsteps };
                        }
                        return s;
                    }),
                }));
            },
            updateFileReviewStatus: (fileId, status, error, details) => {
                set(state => {
                    const newStates = new Map(state.fileReviewStates);
                    newStates.set(fileId, { status, error, details });
                    return { fileReviewStates: newStates };
                });
            },
            toggleFileApproval: (fileId) => {
                set(state => {
                    const newStates = new Map(state.fileReviewStates);
                    const current = newStates.get(fileId);
                    if (current) {
                        const newStatus: FileReviewStatus = current.status === 'APPROVED' ? 'REJECTED' : 'APPROVED';
                        newStates.set(fileId, { status: newStatus, error: undefined, details: undefined });
                    }
                    return { fileReviewStates: newStates };
                });
            },
            rejectAllFiles: () => {
                set(state => {
                    const newStates = new Map(state.fileReviewStates);
                    for (const [fileId, reviewState] of newStates.entries()) {
                        if (reviewState.status === 'APPROVED') {
                            newStates.set(fileId, { status: 'REJECTED', error: undefined, details: undefined });
                        }
                    }
                    return { fileReviewStates: newStates };
                });
            },
            navigateBulkRepairUp: () => set(state => ({
                selectedBulkRepairOptionIndex: (state.selectedBulkRepairOptionIndex - 1 + BULK_REPAIR_OPTIONS.length) % BULK_REPAIR_OPTIONS.length,
            })),
            navigateBulkRepairDown: () => set(state => ({
                selectedBulkRepairOptionIndex: (state.selectedBulkRepairOptionIndex + 1) % BULK_REPAIR_OPTIONS.length,
            })),
            navigateBulkInstructUp: () => set(state => ({
                selectedBulkInstructOptionIndex: (state.selectedBulkInstructOptionIndex - 1 + BULK_INSTRUCT_OPTIONS.length) % BULK_INSTRUCT_OPTIONS.length,
            })),
            navigateBulkInstructDown: () => set(state => ({
                selectedBulkInstructOptionIndex: (state.selectedBulkInstructOptionIndex + 1) % BULK_INSTRUCT_OPTIONS.length,
            })),
        },
    }));
  src/hooks/useReviewScreen.tsx: >-
    import { useMemo } from 'react';

    import { useInput, type Key } from 'ink';

    import { useReviewStore } from '../stores/review.store';

    import { useAppStore } from '../stores/app.store';

    import { useNotificationStore } from '../stores/notification.store';

    import { useCopyStore } from '../stores/copy.store';

    import { useTransactionStore, selectSelectedTransaction } from
    '../stores/transaction.store';

    import type { FileItem } from '../types/domain.types';

    import { useLayout } from './useLayout';

    import { useContentViewport } from './useContentViewport';

    import { UI_CONFIG } from '../config/ui.config';

    import { REVIEW_BODY_VIEWS } from '../constants/review.constants';

    import { useListNavigator } from './useListNavigator';

    import { useViewport } from './useViewport';


    type NavigableItem =
        | { type: 'prompt' }
        | { type: 'reasoning' }
        | { type: 'script'; id: string }
        | { type: 'file'; id: string };

    export const useReviewScreen = () => {
        const store = useReviewStore();
        const {
            selectedItemIndex,
            bodyView,
            patchStatus,
            selectedBulkRepairOptionIndex,
            selectedBulkInstructOptionIndex,
        } = store;

        const transaction = useTransactionStore(selectSelectedTransaction);
        const { showDashboardScreen } = useAppStore(s => s.actions);

        const scriptCount = transaction?.scripts?.length || 0;
        const fileCount = transaction?.files?.length || 0;

        const layout = UI_CONFIG.layout.review;

        // Layout for the main navigable item list (prompt, reasoning, files, etc.)
        const mainListLayoutConfig = useMemo(() => ({
            header: layout.header,
            fixedRows: layout.fixedRows,
            marginsY: layout.marginsY,
            separators: layout.separators,
            footer: layout.footer,
            dynamicRows: {
                count: bodyView !== REVIEW_BODY_VIEWS.NONE ? layout.bodyHeightReservation : 0,
            },
        }), [bodyView, layout]);

        const { remainingHeight: listViewportHeight } = useLayout(mainListLayoutConfig);
        const { viewOffset } = useViewport({ selectedIndex: selectedItemIndex, itemCount: 100, layoutConfig: mainListLayoutConfig });

        // Layout for the body content (diff, reasoning, etc.)
        const bodyLayoutConfig = useMemo(() => ({
            header: layout.header,
            separators: layout.separators,
            fixedRows: 2, // meta
            marginsY: 1 + 1 + 1, // meta, scripts, files
            footer: 2,
            dynamicRows: { count: 2 + scriptCount + 1 + fileCount }, // prompt, reasoning, scripts, 'FILES' header, files
        }), [layout, scriptCount, fileCount]);

        const { remainingHeight: availableBodyHeight } = useLayout(bodyLayoutConfig);

        const navigableItems = useMemo((): NavigableItem[] => {
            if (!transaction) return [];
            const scriptItems: NavigableItem[] = (transaction.scripts || []).map(s => ({ type: 'script', id: s.command }));
            const fileItems: NavigableItem[] = (transaction.files || []).map(f => ({ type: 'file', id: f.id }));
            return [{ type: 'prompt' }, { type: 'reasoning' }, ...scriptItems, ...fileItems];
        }, [transaction]);

        const contentLineCount = useMemo(() => {
            const currentItem = navigableItems[selectedItemIndex];
            switch (bodyView) { //
                case REVIEW_BODY_VIEWS.REASONING:
                    return (transaction?.reasoning || '').split('\n').length;
                case REVIEW_BODY_VIEWS.DIFF: {
                    if (currentItem?.type !== 'file') return 0;
                    const selectedFile = (transaction?.files || []).find(f => f.id === currentItem.id);
                    return (selectedFile?.diff || '').split('\n').length;
                }
                case REVIEW_BODY_VIEWS.SCRIPT_OUTPUT: {
                    if (currentItem?.type !== 'script') return 0;
                    const selectedScript = (transaction?.scripts || []).find(s => s.command === currentItem.id);
                    return (selectedScript?.output || '').split('\n').length;
                }
                default: return 0;
            }
        }, [bodyView, navigableItems, selectedItemIndex, transaction]);
        const contentViewport = useContentViewport({ contentLineCount, viewportHeight: availableBodyHeight });

        const navigableItemsInView = navigableItems.slice(viewOffset, viewOffset + listViewportHeight);

        // Memoize files to prevent re-renders, fixing the exhaustive-deps lint warning.
        const files: FileItem[] = useMemo(() => transaction?.files || [], [transaction]);
        const fileReviewStates = useReviewStore(s => s.fileReviewStates);

        const reviewStats = useMemo(() => {
            const approvedFiles = files.filter(f => fileReviewStates.get(f.id)?.status === 'APPROVED');
            return {
                totalFiles: files.length,
                totalLinesAdded: files.reduce((sum, f) => sum + f.linesAdded, 0),
                totalLinesRemoved: files.reduce((sum, f) => sum + f.linesRemoved, 0),
                numFiles: files.length,
                approvedFilesCount: approvedFiles.length,
            };
        }, [files, fileReviewStates]);

        const hasRejectedFiles = useMemo(() => {
            if (!fileReviewStates) return false;
            return Array.from(fileReviewStates.values()).some(s => s.status === 'REJECTED');
        }, [fileReviewStates]);

        const { approvedFilesCount } = reviewStats;

        const isFileSelected = navigableItems[selectedItemIndex]?.type === 'file';

        const scripts = transaction?.scripts || [];

        const {
            setSelectedItemIndex,
            expandDiff,
            toggleBodyView,
            setBodyView,
            startApplySimulation,
            approve,
            tryRepairFile,
            tryInstruct,
            showBulkRepair,
            showBulkInstruct,
            executeBulkRepairOption,
            executeBulkInstructOption,
            confirmHandoff,
            scrollReasoningUp,
            scrollReasoningDown,
            navigateScriptErrorUp,
            navigateScriptErrorDown,
            toggleFileApproval,
            rejectAllFiles,
            navigateBulkRepairUp,
            navigateBulkRepairDown,
            navigateBulkInstructUp,
            navigateBulkInstructDown,
        } = store.actions;

        const openCopyMode = () => {
            if (!transaction) return;
            const currentItem = navigableItems[selectedItemIndex];
            const selectedFile = currentItem?.type === 'file' ? files.find(f => f.id === currentItem.id) : undefined;
            useCopyStore.getState().actions.openForReview(transaction, transaction.files || [], selectedFile);
        };

        const navigateToNextFile = () => {
            const nextFileIndex = navigableItems.findIndex(
                (item, index) => index > selectedItemIndex && item.type === 'file',
            );
            if (nextFileIndex !== -1) {
                setSelectedItemIndex(nextFileIndex);
            }
        };

        const navigateToPreviousFile = () => {
            // Find the last index of a file before the current one
            const prevFileIndex = navigableItems
                .slice(0, selectedItemIndex)
                .findLastIndex(item => item.type === 'file');

            if (prevFileIndex !== -1) {
                setSelectedItemIndex(prevFileIndex);
            }
        };

        // --- Input Handlers ---

        const handleGlobalInput = (input: string, key: Key): boolean => {
            if (input === '1' && transaction) { // For demo purposes
                startApplySimulation(transaction.id, 'success'); return true;
            }
            if (input === '2' && transaction) { // For demo purposes
                startApplySimulation(transaction.id, 'failure'); return true;
            }
            // The 'q' (quit/back) is now handled by the global hotkey hook.

            if (key.escape) {
                switch (bodyView) {
                    case REVIEW_BODY_VIEWS.BULK_REPAIR:
                    case REVIEW_BODY_VIEWS.CONFIRM_HANDOFF:
                    case REVIEW_BODY_VIEWS.BULK_INSTRUCT:
                        toggleBodyView(bodyView);
                        break;
                    default:
                        if (bodyView !== REVIEW_BODY_VIEWS.NONE) {
                            setBodyView(REVIEW_BODY_VIEWS.NONE);
                        }
                        break;
                }
                return true;
            }
            return false;
        };

        const handleHandoffConfirmInput = (_input: string, key: Key): void => {
            if (key.return) confirmHandoff();
        };

        const handleBulkRepairInput = (input: string, key: Key): void => {
            if (key.upArrow) navigateBulkRepairUp();
            if (key.downArrow) navigateBulkRepairDown();
            if (key.return) {
                executeBulkRepairOption(selectedBulkRepairOptionIndex + 1); // Options are 1-based
                return;
            }

            if (input >= '1' && input <= '4') {
                executeBulkRepairOption(parseInt(input));
            }
        };
        
        const handleBulkInstructInput = (input: string, key: Key): void => {
            if (key.upArrow) navigateBulkInstructUp();
            if (key.downArrow) navigateBulkInstructDown();
            if (key.return) {
                executeBulkInstructOption(selectedBulkInstructOptionIndex + 1); // Options are 1-based
                return;
            }

            if (input >= '1' && input <= '3') {
                executeBulkInstructOption(parseInt(input));
            }
        };

        const handleContentScrollInput = (key: Key): boolean => {
            const contentViews = [
                REVIEW_BODY_VIEWS.REASONING,
                REVIEW_BODY_VIEWS.SCRIPT_OUTPUT,
                REVIEW_BODY_VIEWS.DIFF,
            ] as const;
            if (!(contentViews as readonly string[]).includes(bodyView)) return false;

            if (key.upArrow && bodyView !== REVIEW_BODY_VIEWS.DIFF) {
                contentViewport.actions.scrollUp();
                return true;
            }
            if (key.downArrow && bodyView !== REVIEW_BODY_VIEWS.DIFF) {
                contentViewport.actions.scrollDown();
                return true;
            }
            if (key.pageUp) { contentViewport.actions.pageUp(); return true; }
            if (key.pageDown) { contentViewport.actions.pageDown(); return true; }
            return false;
        };

        const handleReasoningInput = (input: string, key: Key): void => {
            if (key.upArrow) scrollReasoningUp();
            if (key.downArrow) scrollReasoningDown();
            if (input.toLowerCase() === 'r') toggleBodyView(REVIEW_BODY_VIEWS.REASONING);
        };

        const handleScriptOutputInput = (input: string, key: Key): void => {
            if (input.toLowerCase() === 'j') navigateScriptErrorDown();
            if (input.toLowerCase() === 'k') navigateScriptErrorUp();
            if (key.return) toggleBodyView(REVIEW_BODY_VIEWS.SCRIPT_OUTPUT);
            if (input.toLowerCase() === 'c') { // TODO: this copy logic is not great.
                const currentItem = navigableItems[selectedItemIndex];
                const selectedScript = currentItem?.type === 'script' ? scripts.find(s => s.command === currentItem.id) : undefined;
                if (selectedScript) {
                    useNotificationStore.getState().actions.show({
                        type: 'success',
                        title: 'Copied to Clipboard',
                        message: `Copied script output for: ${selectedScript.command}`,
                    });
                }
            }
        };

        const handleDiffInput = (input: string, key: Key) => {
            if (key.upArrow) {
                navigateToPreviousFile();
                return;
            }
            if (key.downArrow) {
                navigateToNextFile();
                return;
            }
            if (input.toLowerCase() === 'x') expandDiff();
            if (input.toLowerCase() === 'd' || key.escape) toggleBodyView('diff');
        };

        const handleMainNavigationInput = (input: string, key: Key): void => {
            // Handle Shift+R for reject all
            if (key.shift && input.toLowerCase() === 'r') {
                if (approvedFilesCount > 0 && transaction) {
                    rejectAllFiles();
                }
                return;
            }

            const currentItem = navigableItems[selectedItemIndex];

            if (input === ' ') {
                if (currentItem?.type === 'file') {
                    const fileState = fileReviewStates.get(currentItem.id);
                    if (fileState && fileState.status !== 'FAILED') {
                        toggleFileApproval(currentItem.id);
                    }
                }
            }

            if (input.toLowerCase() === 'd' && currentItem?.type === 'file') {
                toggleBodyView(REVIEW_BODY_VIEWS.DIFF);
            }

            if (input.toLowerCase() === 'r') {
                toggleBodyView(REVIEW_BODY_VIEWS.REASONING);
            }

            if (key.return) { // Enter key
                if (currentItem?.type === 'file') {
                    toggleBodyView(REVIEW_BODY_VIEWS.DIFF);
                } else if (currentItem?.type === 'reasoning') {
                    toggleBodyView(REVIEW_BODY_VIEWS.REASONING);
                } else if (currentItem?.type === 'script') {
                    toggleBodyView(REVIEW_BODY_VIEWS.SCRIPT_OUTPUT);
                }
            }

            if (input.toLowerCase() === 'a') {
                if (approvedFilesCount > 0) {
                    approve();
                    showDashboardScreen();
                }
            }

            if (input.toLowerCase() === 'c') {
                openCopyMode();
            }

            if (input.toLowerCase() === 't') {
                if (key.shift) {
                    const hasFailedFiles = Array.from(fileReviewStates.values()).some(s => s.status === 'FAILED');
                    if (hasFailedFiles) showBulkRepair();
                } else if (currentItem?.type === 'file') {
                    const fileState = fileReviewStates.get(currentItem.id);
                    if (fileState?.status === 'FAILED') tryRepairFile(currentItem.id);
                }
            }

            if (input.toLowerCase() === 'i') {
                if (key.shift) {
                    if (hasRejectedFiles) showBulkInstruct();
                } else if (currentItem?.type === 'file') {
                    const fileState = fileReviewStates.get(currentItem.id);
                    if (fileState?.status === 'REJECTED') {
                        tryInstruct(currentItem.id);
                    }
                }
            }
        };

        useListNavigator({
            itemCount: navigableItems.length,
            viewportHeight: listViewportHeight,
            selectedIndex: selectedItemIndex,
            onIndexChange: setSelectedItemIndex,
            isActive: bodyView === REVIEW_BODY_VIEWS.NONE,
            onKey: handleMainNavigationInput,
        });

        useInput((input: string, key: Key) => {
            if (handleGlobalInput(input, key)) return;
            if (handleContentScrollInput(key)) return;

            switch (bodyView) {
                case REVIEW_BODY_VIEWS.CONFIRM_HANDOFF: return handleHandoffConfirmInput(input, key);
                case REVIEW_BODY_VIEWS.BULK_REPAIR: return handleBulkRepairInput(input, key);
                case REVIEW_BODY_VIEWS.BULK_INSTRUCT: return handleBulkInstructInput(input, key);
                case REVIEW_BODY_VIEWS.REASONING: return handleReasoningInput(input, key);
                case REVIEW_BODY_VIEWS.SCRIPT_OUTPUT: return handleScriptOutputInput(input, key);
                case REVIEW_BODY_VIEWS.DIFF: return handleDiffInput(input, key);
            }
        }, { isActive: bodyView !== REVIEW_BODY_VIEWS.NONE });

        return {
            ...store,
            fileReviewStates,
            selectedItemIndex,
            transaction,
            files,
            scripts,
            patchStatus,
            navigableItems,
            isFileSelected,
            navigableItemsInView,
            viewOffset,
            contentScrollIndex: contentViewport.scrollIndex,
            availableBodyHeight,
            selectedBulkRepairOptionIndex,
            selectedBulkInstructOptionIndex,
            ...reviewStats,
            hasRejectedFiles,
        };
    };
  src/hooks/useDebugLogScreen.tsx: |-
    import { useState, useEffect, useMemo } from 'react';
    import { useInput } from 'ink';
    import { useLogStore } from '../stores/log.store';
    import { useViewStore } from '../stores/view.store';
    import { useViewport } from './useViewport';
    import { LoggerService } from '../services/logger.service';
    import { DEBUG_LOG_MODES } from '../constants/log.constants';
    import { OVERLAYS } from '../constants/view.constants';
    import { UI_CONFIG } from '../config/ui.config';
    import { useListNavigator } from './useListNavigator';

    export const useDebugLogScreen = () => {
        const logs = useLogStore(s => s.logs);
        const clearLogs = useLogStore(s => s.actions.clearLogs);
        const setActiveOverlay = useViewStore(s => s.actions.setActiveOverlay);

        const [selectedIndex, setSelectedIndex] = useState(0);
        const [mode, setMode] = useState<keyof typeof DEBUG_LOG_MODES>('LIST');
        const [filterQuery, setFilterQuery] = useState('');

        const filteredLogs = useMemo(() => logs.filter(log =>
            log.message.toLowerCase().includes(filterQuery.toLowerCase()),
        ), [logs, filterQuery]);

        // Reset index to top when filter changes
        useEffect(() => {
            setSelectedIndex(0);
        }, [filterQuery]);

        // Clamp index if it's out of bounds after logs change for other reasons
        useEffect(() => {
            if (selectedIndex >= filteredLogs.length) {
                setSelectedIndex(Math.max(0, filteredLogs.length - 1));
            }
        }, [filteredLogs.length, selectedIndex]);

        // Header, borders, footer, filter line
        const { viewOffset, viewportHeight } = useViewport({
            selectedIndex,
            itemCount: filteredLogs.length,
            layoutConfig: UI_CONFIG.layout.debugLog,
        });

        const isOverlayActive = useViewStore.getState().activeOverlay === OVERLAYS.LOG;

        useInput((_input, key) => {
            if (mode === DEBUG_LOG_MODES.FILTER) {
                if (key.escape || key.return) {
                    setMode(DEBUG_LOG_MODES.LIST);
                }
            }
        }, { isActive: isOverlayActive && mode === DEBUG_LOG_MODES.FILTER });

        useListNavigator({
            itemCount: filteredLogs.length,
            viewportHeight,
            selectedIndex,
            onIndexChange: setSelectedIndex,
            isActive: isOverlayActive && mode === DEBUG_LOG_MODES.LIST,
            onKey: (input, key) => {
                if (key.escape) {
                    setActiveOverlay(OVERLAYS.NONE);
                    return;
                }
                if (input.toLowerCase() === 'c') {
                    clearLogs();
                    setFilterQuery('');
                    setSelectedIndex(0);
                    return;
                }
                if (input.toLowerCase() === 'f') {
                    setMode(DEBUG_LOG_MODES.FILTER);
                }
            }
        });

        useEffect(() => {
            LoggerService.startSimulator();
            return () => {
                LoggerService.stopSimulator();
            };
        }, []);

        const logsInView = filteredLogs.slice(viewOffset, viewOffset + viewportHeight);

        return {
            logsInView,
            logCount: logs.length,
            filteredLogCount: filteredLogs.length,
            selectedIndex,
            mode,
            filterQuery,
            setFilterQuery,
            viewOffset,
        };
    };
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 208
