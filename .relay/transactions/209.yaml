uuid: c32731c3-c55f-40e9-b5d2-06830560a6ae
projectId: relaycode-tui
createdAt: '2025-09-26T14:06:03.859Z'
gitCommitMsg: >-
  feat(review): overhaul keyboard navigation for consistency

  Refactors the keyboard navigation on the Review Screen to be more intuitive
  and consistent across different content views.

  Key changes include: - Unified the 'Enter' key to toggle content views
  (Prompt, Reasoning, Diff,
    etc.), both opening and closing them. This removes the need for
    view-specific collapse keys.
  - Removed the 'X' key for expanding diffs, as diffs now open fully by
    default and are collapsed with 'Enter'.
  - Enabled main list navigation with Up/Down arrow keys even when content
    views like Prompt, Reasoning, or Script Output are open.
  - Standardized content scrolling to use PageUp/PageDown across all views. -
  Updated action footers to reflect the new, streamlined keybindings.
promptSummary: >-
  The user wants to refactor the keyboard navigation on the Review Screen.

  1.  Unify the "Enter" key to both expand and collapse content views, removing
  the need for the 'X' key for diffs.

  2.  Allow up/down arrow keys to navigate the main item list even when a
  content view (like Prompt or Reasoning) is open. Content scrolling should be
  handled by PageUp/PageDown.
reasoning:
  - >-
    I will implement the requested refactoring to improve keyboard navigation on
    the Review Screen. This involves two main parts: unifying the "Enter" key
    for expanding and collapsing content views (which also makes the 'X' key
    redundant), and enabling main list navigation with up/down arrows even when
    a content view is open.
  - '### Part 1: Unifying `Enter` Key Behavior'
  - >-
    First, I'll remove the now-unnecessary state and actions related to the diff
    view's expanded state from the review store.
  - >-
    Next, I will update the action footers to remove the redundant `X` key and
    improve the labels for clarity. A new footer for the prompt view will also
    be added.
  - '### Part 2: Enabling List Navigation'
  - >-
    Here, I'll refactor the `useReviewScreen` hook. This is the core of the
    change, centralizing input handling and enabling list navigation while
    content views are active.
  - >-
    Finally, I'll update the `ReviewScreen` component to use the new state and
    logic, connect the new footers, and ensure the `ContentView` components are
    rendered correctly.
  - >-
    These changes will provide a more intuitive and consistent navigation
    experience on the review screen.
operations:
  - type: write
    path: src/stores/review.store.ts
    content: >+
      --- src/stores/review.store.ts

      +++ src/stores/review.store.ts

      @@ -21,11 +21,8 @@
           patchStatus: PatchStatus;
           applySteps: ApplyStep[];
           selectedItemIndex: number;
      -    bodyView: ReviewBodyView;

      -    isDiffExpanded: boolean;

      -    reasoningScrollIndex: number;

      +    bodyView: ReviewBodyView;
           scriptErrorIndex: number;
           processingStartTime: number | null;
           fileReviewStates: Map<string, { status: FileReviewStatus; error?: string; details?: string }>;
      @@ -38,7 +35,6 @@
           actions: {
               load: (transactionId: string, initialState?: Partial<Pick<ReviewState, 'bodyView' | 'selectedBulkRepairOptionIndex'>>) => void;
               setSelectedItemIndex: (index: number) => void;
      -        expandDiff: () => void;
               toggleBodyView: (view: Extract<
                   ReviewBodyView, 'prompt' | 'bulk_instruct' |
                   'diff' | 'reasoning' | 'script_output' | 'bulk_repair' | 'confirm_handoff'
      @@ -53,8 +49,6 @@
               showBulkInstruct: () => void;
               executeBulkInstructOption: (option: number) => Promise<void>;
               confirmHandoff: () => void;
      -        scrollReasoningUp: () => void;

      -        scrollReasoningDown: () => void;
               navigateScriptErrorUp: () => void;
               navigateScriptErrorDown: () => void;
               updateApplyStep: (id: string, status: ApplyStep['status'], details?: string) => void;
      @@ -73,9 +67,7 @@
           applySteps: INITIAL_APPLY_STEPS,
           selectedItemIndex: 0,
           bodyView: REVIEW_BODY_VIEWS.NONE,
      -    isDiffExpanded: false,

      -    reasoningScrollIndex: 0,
           scriptErrorIndex: 0,
           processingStartTime: null,
           fileReviewStates: new Map(),
      @@ -108,9 +100,7 @@
                       processingStartTime: null,
                       selectedItemIndex: 0,
                       bodyView: initialState?.bodyView ?? REVIEW_BODY_VIEWS.NONE,
      -                isDiffExpanded: false,

      -                reasoningScrollIndex: 0,
                       scriptErrorIndex: 0,
                       applySteps: JSON.parse(JSON.stringify(INITIAL_APPLY_STEPS)),
                       selectedBulkRepairOptionIndex: 0,
      @@ -124,11 +114,9 @@
                   if (view === 'diff' && state.selectedItemIndex >= files.length) return {};
                   return {
                       bodyView: state.bodyView === view ? REVIEW_BODY_VIEWS.NONE : view,
      -                isDiffExpanded: false,
                   };
               }),
               setBodyView: (view) => set({ bodyView: view }),
      -        expandDiff: () => set(state => ({ isDiffExpanded:
      !state.isDiffExpanded })),
               approve: () => {
                   const { selectedTransactionId } = useViewStore.getState();
                   if (selectedTransactionId) {
      @@ -282,15 +270,6 @@
                   ReviewService.generateHandoffPrompt(tx, fileReviewStates);
                   ReviewService.performHandoff(tx.hash);
               },
      -        scrollReasoningUp: () => set(state => ({ reasoningScrollIndex:
      Math.max(0, state.reasoningScrollIndex - 1) })),

      -        scrollReasoningDown: () => set(state => {

      -            const transactionId =
      useViewStore.getState().selectedTransactionId;

      -            const tx = useTransactionStore.getState().transactions.find(t
      => t.id === transactionId);

      -            if (!tx?.reasoning) return {};

      -            const maxLines = tx.reasoning.split('\n').length;

      -            return { reasoningScrollIndex: Math.min(maxLines - 1,
      state.reasoningScrollIndex + 1) };

      -        }),
               navigateScriptErrorUp: () => set(state => ({ scriptErrorIndex: Math.max(0, state.scriptErrorIndex - 1) })),
               navigateScriptErrorDown: () => set(state => {
                   const transactionId = useViewStore.getState().selectedTransactionId;

    patchStrategy: standard-diff
  - type: write
    path: src/constants/review.constants.ts
    content: |+
      --- src/constants/review.constants.ts
      +++ src/constants/review.constants.ts
      @@ -43,18 +43,26 @@
       export const REVIEW_FOOTER_ACTIONS = {
           DIFF_VIEW: [
               { key: '↑↓', label: 'Next/Prev File' },
      -        { key: 'X', label: 'Expand' },
               { key: 'PgUp/PgDn', label: 'Scroll' },
      -        { key: 'D/Esc', label: 'Back' },
      +        { key: 'D/Enter/Esc', label: 'Back' },
      +    ] as const,
      +    PROMPT_VIEW: [
      +        { key: '↑↓', label: 'Next/Prev Item' },
      +        { key: 'PgUp/PgDn', label: 'Scroll' },
      +        { key: 'P/Enter', label: 'Collapse' },
      +        { key: 'C', label: 'Copy Mode' },
           ] as const,
           REASONING_VIEW: [
      -        { key: '↑↓', label: 'Scroll Text' },
      -        { key: 'R', label: 'Collapse View' },
      +        { key: '↑↓', label: 'Next/Prev Item' },
      +        { key: 'PgUp/PgDn', label: 'Scroll' },
      +        { key: 'R/Enter', label: 'Collapse' },
               { key: 'C', label: 'Copy Mode' },
           ] as const,
           SCRIPT_OUTPUT_VIEW: [
      -        { key: '↑↓', label: 'Nav' },
      +        { key: '↑↓', label: 'Next/Prev Item' },
      +        { key: 'PgUp/PgDn', label: 'Scroll' },
               { key: 'J↓/K↑', label: 'Next/Prev Error' },
               { key: 'C', label: 'Copy Output' },
      -        { key: 'Ent/Esc', label: 'Back' },
      +        { key: 'Enter/Esc', label: 'Back' },
           ] as const,
           BULK_REPAIR_VIEW: { text: 'Use (↑↓) Nav · (Enter) Select · (1-4) Jump · (Esc) Cancel' } as const,
           BULK_INSTRUCT_VIEW: { text: 'Use (↑↓) Nav · (Enter) Select · (1-4) Jump · (Esc) Cancel' } as const,

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useReviewScreen.tsx
    content: >+
      --- src/hooks/useReviewScreen.tsx

      +++ src/hooks/useReviewScreen.tsx

      @@ -9,6 +9,7 @@
       import { UI_CONFIG } from '../config/ui.config';
       import { REVIEW_BODY_VIEWS } from '../constants/review.constants';
       import { useListNavigator } from './useListNavigator';
      +import type { ReviewBodyView } from '../stores/review.store';
       import { useViewport } from './useViewport';
       
       type NavigableItem =
      @@ -118,22 +119,15 @@
           const scripts = transaction?.scripts || [];
       
           const {
      -        setSelectedItemIndex,

      -        expandDiff,

      -        toggleBodyView,

      -        setBodyView,

      -        startApplySimulation,

      -        approve,

      -        tryRepairFile,

      -        tryInstruct,

      -        showBulkRepair,

      -        showBulkInstruct,

      -        executeBulkRepairOption,

      -        executeBulkInstructOption,

      -        confirmHandoff,

      -        scrollReasoningUp,

      -        scrollReasoningDown,

      -        navigateScriptErrorUp,

      -        navigateScriptErrorDown,

      -        toggleFileApproval,

      -        rejectAllFiles,

      -        navigateBulkRepairUp,

      -        navigateBulkRepairDown,

      -        navigateBulkInstructUp,

      -        navigateBulkInstructDown,

      +        setSelectedItemIndex, toggleBodyView, setBodyView,
      startApplySimulation, approve,

      +        tryRepairFile, tryInstruct, showBulkRepair, showBulkInstruct,

      +        executeBulkRepairOption, executeBulkInstructOption,
      confirmHandoff,

      +        navigateScriptErrorUp, navigateScriptErrorDown,
      toggleFileApproval,

      +        rejectAllFiles, navigateBulkRepairUp, navigateBulkRepairDown,

      +        navigateBulkInstructUp, navigateBulkInstructDown,
           } = store.actions;
       
           const openCopyMode = () => {
      @@ -143,6 +137,20 @@
               useCopyStore.getState().actions.openForReview(transaction, transaction.files || [], selectedFile);
           };
       
      +    const navigateToNextItem = () => {

      +        if (selectedItemIndex < navigableItems.length - 1) {

      +            setSelectedItemIndex(selectedItemIndex + 1);

      +            contentViewport.actions.resetScroll();

      +        }

      +    };

      +

      +    const navigateToPreviousItem = () => {

      +        if (selectedItemIndex > 0) {

      +            setSelectedItemIndex(selectedItemIndex - 1);

      +            contentViewport.actions.resetScroll();

      +        }

      +    };

      +
           const navigateToNextFile = () => {
               const nextFileIndex = navigableItems.findIndex(
                   (item, index) => index > selectedItemIndex && item.type === 'file',
      @@ -213,29 +221,20 @@
           };
       
           const handleContentScrollInput = (key: Key): boolean => {
      -        const contentViews = [

      +        const contentViews: ReviewBodyView[] = [
                   REVIEW_BODY_VIEWS.REASONING,
                   REVIEW_BODY_VIEWS.SCRIPT_OUTPUT,
                   REVIEW_BODY_VIEWS.DIFF,
      -        ] as const;

      -        if (!(contentViews as readonly string[]).includes(bodyView))
      return false;

      -

      -        if (key.upArrow && bodyView !== REVIEW_BODY_VIEWS.DIFF) {

      -            contentViewport.actions.scrollUp();

      -            return true;

      -        }

      -        if (key.downArrow && bodyView !== REVIEW_BODY_VIEWS.DIFF) {

      -            contentViewport.actions.scrollDown();

      -            return true;

      -        }

      +            REVIEW_BODY_VIEWS.PROMPT,

      +        ];

      +        if (!contentViews.includes(bodyView)) return false;

      +
               if (key.pageUp) { contentViewport.actions.pageUp(); return true; }
               if (key.pageDown) { contentViewport.actions.pageDown(); return true; }
               return false;
           };
       
           const handleReasoningInput = (input: string, key: Key): void => {
      -        if (key.upArrow) scrollReasoningUp();

      -        if (key.downArrow) scrollReasoningDown();
               if (input.toLowerCase() === 'r') toggleBodyView(REVIEW_BODY_VIEWS.REASONING);
           };
       
      @@ -243,7 +240,6 @@
               if (input.toLowerCase() === 'j') navigateScriptErrorDown();
               if (input.toLowerCase() === 'k') navigateScriptErrorUp();
      -        if (key.return) toggleBodyView(REVIEW_BODY_VIEWS.SCRIPT_OUTPUT);
               if (input.toLowerCase() === 'c') { // TODO: this copy logic is not great.
                   const currentItem = navigableItems[selectedItemIndex];
                   const selectedScript = currentItem?.type === 'script' ? scripts.find(s => s.command === currentItem.id) : undefined;
      @@ -266,8 +262,7 @@
                   navigateToNextFile();
                   return;
               }
      -        if (input.toLowerCase() === 'x') expandDiff();

      -        if (input.toLowerCase() === 'd' || key.escape)
      toggleBodyView('diff');

      +        if (input.toLowerCase() === 'd') toggleBodyView('diff');
           };
       
           const handleMainNavigationInput = (input: string, key: Key): void => {
      @@ -348,7 +343,33 @@
       
           useInput((input: string, key: Key) => {
               if (handleGlobalInput(input, key)) return;
      +

      +        // Global "Enter to collapse" handler for non-modal views

      +        if (key.return) {

      +            if (

      +                bodyView !== REVIEW_BODY_VIEWS.BULK_REPAIR &&

      +                bodyView !== REVIEW_BODY_VIEWS.BULK_INSTRUCT &&

      +                bodyView !== REVIEW_BODY_VIEWS.CONFIRM_HANDOFF &&

      +                bodyView !== REVIEW_BODY_VIEWS.NONE

      +            ) {

      +                setBodyView(REVIEW_BODY_VIEWS.NONE);

      +                return;

      +            }

      +        }

      +

      +        // Allow up/down list navigation even when a content view is open

      +        const listNavigableBodyViews: ReviewBodyView[] = [

      +            REVIEW_BODY_VIEWS.PROMPT, REVIEW_BODY_VIEWS.REASONING,
      REVIEW_BODY_VIEWS.SCRIPT_OUTPUT,

      +        ];

      +

      +        if (listNavigableBodyViews.includes(bodyView)) {

      +            if (key.upArrow) { navigateToPreviousItem(); return; }

      +            if (key.downArrow) { navigateToNextItem(); return; }

      +        }

      +

      +        // Handle content scrolling (PgUp/PgDn)
               if (handleContentScrollInput(key)) return;
       
               switch (bodyView) {
                   case REVIEW_BODY_VIEWS.CONFIRM_HANDOFF: return handleHandoffConfirmInput(input, key);

    patchStrategy: standard-diff
  - type: write
    path: src/components/ReviewScreen.tsx
    content: >+
      --- src/components/ReviewScreen.tsx

      +++ src/components/ReviewScreen.tsx

      @@ -124,11 +124,8 @@
               scripts = [],
               patchStatus,
               selectedItemIndex,
      -        bodyView,

      -        isDiffExpanded,

      -        reasoningScrollIndex,

      +        bodyView,
               scriptErrorIndex,
               fileReviewStates,
               numFiles,
      @@ -181,11 +178,11 @@
                               maxHeight={Math.max(1, availableBodyHeight)}
                           />
                           {reasoningLinesCount > visibleLinesCount && (
                               <Text color="gray">
      -                            Showing lines {reasoningScrollIndex +
      1}-{Math.min(reasoningScrollIndex + visibleLinesCount,
      reasoningLinesCount)}{' '}

      +                            Showing lines {contentScrollIndex +
      1}-{Math.min(contentScrollIndex + visibleLinesCount,
      reasoningLinesCount)}{' '}
                                   of {reasoningLinesCount}
                               </Text>
                           )}
      @@ -201,7 +198,7 @@
                           title={`DIFF: ${selectedFile.path}`}
                           content={selectedFile.diff}
                           highlight="diff"
      -                    isExpanded={isDiffExpanded}

      +                    isExpanded={true}
                           scrollIndex={contentScrollIndex}
                       />
                   );
      @@ -342,6 +339,8 @@
           const renderFooter = () => {
               // Contextual footer for body views
               switch (bodyView) {
      +            case REVIEW_BODY_VIEWS.PROMPT:

      +                return <ActionFooter
      actions={REVIEW_FOOTER_ACTIONS.PROMPT_VIEW} />;
                   case REVIEW_BODY_VIEWS.DIFF:
                       return <ActionFooter actions={REVIEW_FOOTER_ACTIONS.DIFF_VIEW}/>;
                   case REVIEW_BODY_VIEWS.REASONING:

    patchStrategy: standard-diff
snapshot:
  src/stores/review.store.ts: >-
    import { create } from 'zustand';

    import { useAppStore } from './app.store';

    import { useTransactionStore } from './transaction.store';

    import { useViewStore } from './view.store';

    import { ReviewService, type SimulationResult } from
    '../services/review.service';

    import { INITIAL_APPLY_STEPS, PATCH_STATUS, REVIEW_BODY_VIEWS,
    BULK_INSTRUCT_OPTIONS, BULK_REPAIR_OPTIONS } from
    '../constants/review.constants';

    import { sleep } from '../utils';

    import type { FileReviewStatus } from '../types/domain.types';


    export interface ApplyStep {
        id: string;
        title: string;
        status: 'pending' | 'active' | 'done' | 'failed' | 'skipped';
        details?: string;
        substeps?: ApplyStep[];
        startTime?: number;
        duration?: number;
    }


    export type ReviewBodyView = (typeof REVIEW_BODY_VIEWS)[keyof typeof
    REVIEW_BODY_VIEWS];

    export type PatchStatus = (typeof PATCH_STATUS)[keyof typeof PATCH_STATUS];

    export type ApplyUpdate =
        | { type: 'UPDATE_STEP'; payload: { id: string; status: ApplyStep['status']; duration?: number; details?: string } }
        | { type: 'ADD_SUBSTEP'; payload: { parentId: string; substep: Omit<ApplyStep, 'substeps'> } }
        | { type: 'UPDATE_SUBSTEP'; payload: { parentId: string; substepId: string; status: ApplyStep['status']; title?: string } };

    interface ReviewState {
        patchStatus: PatchStatus;
        applySteps: ApplyStep[];
        selectedItemIndex: number;
        bodyView: ReviewBodyView;
        isDiffExpanded: boolean;
        reasoningScrollIndex: number;
        scriptErrorIndex: number;
        processingStartTime: number | null;
        fileReviewStates: Map<string, { status: FileReviewStatus; error?: string; details?: string }>;

        selectedBulkRepairOptionIndex: number;
        selectedBulkInstructOptionIndex: number;
        isCancelling: boolean;
        isSkipping: boolean;

        actions: {
            load: (transactionId: string, initialState?: Partial<Pick<ReviewState, 'bodyView' | 'selectedBulkRepairOptionIndex'>>) => void;
            setSelectedItemIndex: (index: number) => void;
            expandDiff: () => void;
            toggleBodyView: (view: Extract<
                ReviewBodyView, 'prompt' | 'bulk_instruct' |
                'diff' | 'reasoning' | 'script_output' | 'bulk_repair' | 'confirm_handoff'
            >) => void;
            setBodyView: (view: ReviewBodyView) => void;
            approve: () => void;
            startApplySimulation: (transactionId: string, scenario: 'success' | 'failure') => void;
            tryRepairFile: (fileId: string) => void;
            showBulkRepair: () => void;
            executeBulkRepairOption: (option: number) => Promise<void>;
            skipCurrentStep: () => void;
            resetSkip: () => void;
            tryInstruct: (fileId: string) => void;
            cancelProcessing: () => void;
            showBulkInstruct: () => void;
            executeBulkInstructOption: (option: number) => Promise<void>;
            confirmHandoff: () => void;
            scrollReasoningUp: () => void;
            scrollReasoningDown: () => void;
            navigateScriptErrorUp: () => void;
            navigateScriptErrorDown: () => void;
            updateApplyStep: (id: string, status: ApplyStep['status'], details?: string) => void;
            addApplySubstep: (parentId: string, substep: Omit<ApplyStep, 'substeps'>) => void;
            updateApplySubstep: (parentId: string, substepId: string, status: ApplyStep['status'], title?: string) => void;
            updateFileReviewStatus: (fileId: string, status: FileReviewStatus, error?: string, details?: string) => void;
            toggleFileApproval: (fileId: string) => void;
            rejectAllFiles: () => void;
            navigateBulkRepairUp: () => void;
            navigateBulkRepairDown: () => void;
            navigateBulkInstructUp: () => void;
            navigateBulkInstructDown: () => void;
        };
    }


    export const useReviewStore = create<ReviewState>((set, get) => ({
        patchStatus: PATCH_STATUS.SUCCESS,
        applySteps: INITIAL_APPLY_STEPS,
        selectedItemIndex: 0,
        bodyView: REVIEW_BODY_VIEWS.NONE,
        isDiffExpanded: false,
        reasoningScrollIndex: 0,
        scriptErrorIndex: 0,
        processingStartTime: null,
        fileReviewStates: new Map(),
        selectedBulkRepairOptionIndex: 0,
        selectedBulkInstructOptionIndex: 0,
        isCancelling: false,
        isSkipping: false,

        actions: {
            load: (transactionId, initialState) => {
                const transaction = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!transaction) return;

                // This logic is preserved from the deleted `prepareTransactionForReview`
                // to allow debug screens to jump directly to a pre-populated review state
                // without running the full simulation.
                const isFailureCase = transaction.id === '1';
                const fileReviewStates = new Map<string, { status: FileReviewStatus; error?: string }>();
                (transaction.files || []).forEach((file, index) => {
                    if (isFailureCase) {
                        const isFailedFile = index > 0;
                        const status = isFailedFile ? 'FAILED' : 'APPROVED';
                        const error = isFailedFile ? (index === 1 ? 'Hunk #1 failed to apply' : 'Context mismatch at line 92') : undefined;
                        fileReviewStates.set(file.id, { status, error });
                    } else {
                        fileReviewStates.set(file.id, { status: 'APPROVED' });
                    }
                });
                const patchStatus = isFailureCase ? 'PARTIAL_FAILURE' : 'SUCCESS';
                useViewStore.getState().actions.setSelectedTransactionId(transaction.id);
                set({
                    patchStatus,
                    fileReviewStates,
                    processingStartTime: null,
                    selectedItemIndex: 0,
                    bodyView: initialState?.bodyView ?? REVIEW_BODY_VIEWS.NONE,
                    isDiffExpanded: false,
                    reasoningScrollIndex: 0,
                    scriptErrorIndex: 0,
                    applySteps: JSON.parse(JSON.stringify(INITIAL_APPLY_STEPS)),
                    selectedBulkRepairOptionIndex: 0,
                    selectedBulkInstructOptionIndex: 0,
                    ...initialState,
                });
            },
            setSelectedItemIndex: (index) => set({ selectedItemIndex: index }),
            toggleBodyView: (view) => set(state => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                const files = tx?.files || [];
                if (view === 'diff' && state.selectedItemIndex >= files.length) return {};
                return {
                    bodyView: state.bodyView === view ? REVIEW_BODY_VIEWS.NONE : view,
                    isDiffExpanded: false,
                };
            }),
            setBodyView: (view) => set({ bodyView: view }),
            expandDiff: () => set(state => ({ isDiffExpanded: !state.isDiffExpanded })),
            approve: () => {
                const { selectedTransactionId } = useViewStore.getState();
                if (selectedTransactionId) {
                    useTransactionStore.getState().actions.updateTransactionStatus(selectedTransactionId, 'APPLIED');
                    useAppStore.getState().actions.showDashboardScreen();
                }
            },
            startApplySimulation: async (transactionId, scenario) => {
                const transaction = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!transaction?.files) return;

                const { showReviewProcessingScreen, showReviewScreen } = useAppStore.getState().actions;
                const { updateApplyStep, addApplySubstep, updateApplySubstep } = get().actions;

                useViewStore.getState().actions.setSelectedTransactionId(transaction.id);
                set({
                    applySteps: JSON.parse(JSON.stringify(INITIAL_APPLY_STEPS)),
                    processingStartTime: Date.now(),
                    isCancelling: false,
                    isSkipping: false,
                    fileReviewStates: new Map(), // Clear previous states
                });

                showReviewProcessingScreen();
                const simulationGenerator = ReviewService.runApplySimulation(transaction.files, scenario);
                let simulationResult: SimulationResult;

                // Manually iterate to get the return value from the async generator
                const iterator = simulationGenerator[Symbol.asyncIterator]();
                while (true) {
                    const { value, done } = await iterator.next();
                    if (done) {
                        simulationResult = value as SimulationResult;
                        break;
                    }
                    const update = value;
                    if (update.type === 'UPDATE_STEP') {
                        updateApplyStep(update.payload.id, update.payload.status, update.payload.details);
                    } else if (update.type === 'ADD_SUBSTEP') {
                        addApplySubstep(update.payload.parentId, update.payload.substep);
                    } else if (update.type === 'UPDATE_SUBSTEP') {
                        updateApplySubstep(update.payload.parentId, update.payload.substepId, update.payload.status, update.payload.title);
                    }
                }

                await sleep(1000);
                set({
                    processingStartTime: null,
                    fileReviewStates: simulationResult.fileReviewStates,
                    patchStatus: simulationResult.patchStatus,
                });
                showReviewScreen();
            },
            tryRepairFile: (fileId) => {
                const selectedTransactionId = useViewStore.getState().selectedTransactionId;
                const { fileReviewStates } = get();
                if (!selectedTransactionId) return;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                const file = tx?.files?.find(f => f.id === fileId);
                if (!file) return;

                const { status, error } = fileReviewStates.get(file.id) || {};
                if (status !== 'FAILED') return;
                
                ReviewService.tryRepairFile(file, error);
                get().actions.updateFileReviewStatus(file.id, 'AWAITING');
            },
            tryInstruct: (fileId) => {
                const selectedTransactionId = useViewStore.getState().selectedTransactionId;
                const { fileReviewStates } = get();
                if (!selectedTransactionId) return;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                const file = tx?.files?.find(f => f.id === fileId);
                if (!tx || !file) return;

                const { status } = fileReviewStates.get(file.id) || {};
                if (status !== 'REJECTED') return;
                
                ReviewService.tryInstructFile(file, tx);
                get().actions.updateFileReviewStatus(file.id, 'AWAITING', undefined, 'Instruction prompt copied!');
            },
            showBulkInstruct: () => get().actions.setBodyView('bulk_instruct'),
            cancelProcessing: () => set({ isCancelling: true }),
            skipCurrentStep: () => set({ isSkipping: true }),
            resetSkip: () => set({ isSkipping: false }),
            executeBulkInstructOption: async (option) => {
                const selectedTransactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                if (!tx?.files) return;

                const rejectedFiles = tx.files.filter(
                    f => get().fileReviewStates.get(f.id)?.status === 'REJECTED',
                );
                if (rejectedFiles.length === 0) {
                    set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                    return;
                }

                switch (option) {
                    case 1:
                        ReviewService.generateBulkInstructPrompt(rejectedFiles, tx);
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                        break;
                    case 2:
                        get().actions.setBodyView('confirm_handoff');
                        break;
                    case 3:
                        rejectedFiles.forEach(file => {
                            get().actions.updateFileReviewStatus(file.id, 'APPROVED');
                        });
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                        break;
                    default:
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                }
            },

            showBulkRepair: () => get().actions.toggleBodyView('bulk_repair'),
            executeBulkRepairOption: async (option) => {
                const selectedTransactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                if (!tx?.files) return;

                const failedFiles = tx.files.filter(
                    f => get().fileReviewStates.get(f.id)?.status === 'FAILED',
                );
                if (failedFiles.length === 0) {
                    set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                    return;
                }

                switch (option) {
                    case 1:
                        ReviewService.generateBulkRepairPrompt(failedFiles);
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                        break;
                    case 2: {
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                        failedFiles.forEach(f => get().actions.updateFileReviewStatus(f.id, 'RE_APPLYING'));
                        const results = await ReviewService.runBulkReapply(failedFiles);
                        results.forEach(result => {
                            get().actions.updateFileReviewStatus(
                                result.id, result.status, result.error,
                            );
                        });
                        break;
                    }
                    case 3:
                        get().actions.setBodyView('confirm_handoff');
                        break;
                    case 4:
                        failedFiles.forEach(file => {
                            get().actions.updateFileReviewStatus(file.id, 'REJECTED');
                        });
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                        break;
                    default:
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                }
            },
            confirmHandoff: () => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!tx?.files) return;
                const { fileReviewStates } = get();
                ReviewService.generateHandoffPrompt(tx, fileReviewStates);
                ReviewService.performHandoff(tx.hash);
            },
            scrollReasoningUp: () => set(state => ({ reasoningScrollIndex: Math.max(0, state.reasoningScrollIndex - 1) })),
            scrollReasoningDown: () => set(state => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!tx?.reasoning) return {};
                const maxLines = tx.reasoning.split('\n').length;
                return { reasoningScrollIndex: Math.min(maxLines - 1, state.reasoningScrollIndex + 1) };
            }),
            navigateScriptErrorUp: () => set(state => ({ scriptErrorIndex: Math.max(0, state.scriptErrorIndex - 1) })),
            navigateScriptErrorDown: () => set(state => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!tx?.scripts || !tx?.files) return {};
                const selectedScript = tx.scripts[state.selectedItemIndex - tx.files.length];
                if (selectedScript?.output) {
                    const errorLines = selectedScript.output
                        .split('\n')
                        .filter(line => line.includes('Error') || line.includes('Warning'));
                    return { scriptErrorIndex: Math.min(errorLines.length - 1, state.scriptErrorIndex + 1) };
                }
                return {};
            }),
            updateApplyStep: (id, status, details) => {
                set(state => {
                    const newSteps = state.applySteps.map(s => {
                        if (s.id === id) {
                            const newStep: ApplyStep = { ...s, status };
                            if (status === 'active') {
                                newStep.startTime = Date.now();
                            } else if ((status === 'done' || status === 'failed' || status === 'skipped') && s.startTime) {
                                newStep.duration = (Date.now() - s.startTime) / 1000;
                            }
                            if (details !== undefined) newStep.details = details;
                            return newStep;
                        }
                        return s;
                    });
                    return { applySteps: newSteps };
                });
            },
            updateApplySubstep: (parentId, substepId, status, title) => {
                set(state => ({
                    applySteps: state.applySteps.map(s => {
                        if (s.id === parentId && s.substeps) {
                            const newSubsteps = s.substeps.map(sub => {
                                if (sub.id === substepId) {
                                    const newSub: ApplyStep = { ...sub, status };
                                    if (status === 'active') {
                                        newSub.startTime = Date.now();
                                    } else if ((status === 'done' || status === 'failed') && sub.startTime) {
                                        newSub.duration = (Date.now() - sub.startTime) / 1000;
                                    }
                                    if (title) newSub.title = title;
                                    return newSub;
                                }
                                return sub;
                            });
                            return { ...s, substeps: newSubsteps };
                        }
                        return s;
                    }),
                }));
            },
            addApplySubstep: (parentId, substep) => {
                set(state => ({
                    applySteps: state.applySteps.map(s => {
                        if (s.id === parentId) {
                            const newSubsteps = [...(s.substeps || []), substep as ApplyStep];
                            return { ...s, substeps: newSubsteps };
                        }
                        return s;
                    }),
                }));
            },
            updateFileReviewStatus: (fileId, status, error, details) => {
                set(state => {
                    const newStates = new Map(state.fileReviewStates);
                    newStates.set(fileId, { status, error, details });
                    return { fileReviewStates: newStates };
                });
            },
            toggleFileApproval: (fileId) => {
                set(state => {
                    const newStates = new Map(state.fileReviewStates);
                    const current = newStates.get(fileId);
                    if (current) {
                        const newStatus: FileReviewStatus = current.status === 'APPROVED' ? 'REJECTED' : 'APPROVED';
                        newStates.set(fileId, { status: newStatus, error: undefined, details: undefined });
                    }
                    return { fileReviewStates: newStates };
                });
            },
            rejectAllFiles: () => {
                set(state => {
                    const newStates = new Map(state.fileReviewStates);
                    for (const [fileId, reviewState] of newStates.entries()) {
                        if (reviewState.status === 'APPROVED') {
                            newStates.set(fileId, { status: 'REJECTED', error: undefined, details: undefined });
                        }
                    }
                    return { fileReviewStates: newStates };
                });
            },
            navigateBulkRepairUp: () => set(state => ({
                selectedBulkRepairOptionIndex: (state.selectedBulkRepairOptionIndex - 1 + BULK_REPAIR_OPTIONS.length) % BULK_REPAIR_OPTIONS.length,
            })),
            navigateBulkRepairDown: () => set(state => ({
                selectedBulkRepairOptionIndex: (state.selectedBulkRepairOptionIndex + 1) % BULK_REPAIR_OPTIONS.length,
            })),
            navigateBulkInstructUp: () => set(state => ({
                selectedBulkInstructOptionIndex: (state.selectedBulkInstructOptionIndex - 1 + BULK_INSTRUCT_OPTIONS.length) % BULK_INSTRUCT_OPTIONS.length,
            })),
            navigateBulkInstructDown: () => set(state => ({
                selectedBulkInstructOptionIndex: (state.selectedBulkInstructOptionIndex + 1) % BULK_INSTRUCT_OPTIONS.length,
            })),
        },
    }));
  src/constants/review.constants.ts: |-
    import type { ApplyStep } from '../stores/review.store';
    import type { ActionItem } from '../types/actions.types';

    /**
     * Constants for the Review screen and process.
     */
    export const INITIAL_APPLY_STEPS: ApplyStep[] = [
        { id: 'snapshot', title: 'Reading initial file snapshot...', status: 'pending' },
        { id: 'memory', title: 'Applying operations to memory...', status: 'pending', substeps: [] },
        { id: 'post-command', title: 'Running post-command script...', status: 'pending', substeps: [] },
        { id: 'linter', title: 'Analyzing changes with linter...', status: 'pending', substeps: [] },
    ];

    export const REVIEW_BODY_VIEWS = {
        DIFF: 'diff',
        PROMPT: 'prompt',
        REASONING: 'reasoning',
        SCRIPT_OUTPUT: 'script_output',
        BULK_REPAIR: 'bulk_repair',
        CONFIRM_HANDOFF: 'confirm_handoff',
        BULK_INSTRUCT: 'bulk_instruct',
        NONE: 'none',
    } as const;

    export const PATCH_STATUS = {
        SUCCESS: 'SUCCESS',
        PARTIAL_FAILURE: 'PARTIAL_FAILURE',
    } as const;

    export const BULK_REPAIR_OPTIONS = [
        '(1) Copy Bulk Re-apply Prompt (for single-shot AI)',
        '(2) Bulk Change Strategy & Re-apply',
        '(3) Handoff to External Agent',
        '(4) Bulk Abandon All Failed Files',
        '(Esc) Cancel',
    ] as const;

    export const BULK_INSTRUCT_OPTIONS = [
        '(1) Copy Bulk Re-instruct Prompt (for single-shot AI)',
        '(2) Handoff to External Agent',
        '(3) Bulk Un-reject All Files (revert to original)',
        '(4) Cancel',
    ] as const;

    interface ReviewFooterConfig {
        isFileSelected: boolean;
        fileStatus?: 'FAILED' | 'REJECTED' | 'OTHER';
        currentItemType?: 'file' | 'script' | 'reasoning' | 'prompt';
        hasFailedFiles: boolean;
        hasRejectedFiles: boolean;
        hasApprovedFiles: boolean;
    }

    export const REVIEW_FOOTER_ACTIONS = {
        DIFF_VIEW: [
            { key: '↑↓', label: 'Next/Prev File' },
            { key: 'X', label: 'Expand' },
            { key: 'PgUp/PgDn', label: 'Scroll' },
            { key: 'D/Esc', label: 'Back' },
        ] as const,
        REASONING_VIEW: [
            { key: '↑↓', label: 'Scroll Text' },
            { key: 'R', label: 'Collapse View' },
            { key: 'C', label: 'Copy Mode' },
        ] as const,
        SCRIPT_OUTPUT_VIEW: [
            { key: '↑↓', label: 'Nav' },
            { key: 'J↓/K↑', label: 'Next/Prev Error' },
            { key: 'C', label: 'Copy Output' },
            { key: 'Ent/Esc', label: 'Back' },
        ] as const,
        BULK_REPAIR_VIEW: { text: 'Use (↑↓) Nav · (Enter) Select · (1-4) Jump · (Esc) Cancel' } as const,
        BULK_INSTRUCT_VIEW: { text: 'Use (↑↓) Nav · (Enter) Select · (1-4) Jump · (Esc) Cancel' } as const,
        HANDOFF_CONFIRM_VIEW: [
            { key: 'Enter', label: 'Confirm Handoff' },
            { key: 'Esc', label: 'Cancel' },
        ] as const,
        MAIN_VIEW: (config: ReviewFooterConfig): ActionItem[] => {
            const actions: ActionItem[] = [{ key: '↑↓', label: 'Nav' }];

            if (config.isFileSelected) {
                if (config.fileStatus !== 'FAILED') actions.push({ key: 'Spc', label: 'Toggle' });
                actions.push({ key: 'D/Ent', label: 'Diff' });
                if (config.fileStatus === 'FAILED') actions.push({ key: 'T', label: 'Try Repair' });
                if (config.fileStatus === 'REJECTED') actions.push({ key: 'I', label: 'Instruct' });
            } else if (config.currentItemType === 'script') {
                actions.push({ key: 'Ent', label: 'Expand Details' });
            } else {
                actions.push({ key: 'Ent', label: 'Expand' });
            }

            if (config.currentItemType !== 'reasoning') actions.push({ key: 'R', label: 'Reasoning' });
            if (config.hasFailedFiles) actions.push({ key: 'Shift+T', label: 'Bulk Repair' });
            if (config.hasRejectedFiles) actions.push({ key: 'Shift+I', label: 'Bulk Instruct' });

            actions.push({ key: 'C', label: 'Copy' });

            if (config.hasApprovedFiles) actions.push({ key: 'A', label: 'Approve' });
            actions.push({ key: 'Q', label: 'Quit' });
            return actions;
        },
    };

    export const getReviewProcessingFooterActions = (
        isSkippable: boolean,
    ): readonly ActionItem[] => {
        const actions: ActionItem[] = [{ key: 'Ctrl+C', label: 'Cancel Process' }];
        if (isSkippable) {
            actions.push({ key: 'S', label: 'Skip Script' });
        }
        return actions;
    };
  src/hooks/useReviewScreen.tsx: >-
    import { useMemo } from 'react';

    import { useInput, type Key } from 'ink';

    import { useReviewStore } from '../stores/review.store';

    import { useAppStore } from '../stores/app.store';

    import { useNotificationStore } from '../stores/notification.store';

    import { useCopyStore } from '../stores/copy.store';

    import { useTransactionStore, selectSelectedTransaction } from
    '../stores/transaction.store';

    import type { FileItem } from '../types/domain.types';

    import { useLayout } from './useLayout';

    import { useContentViewport } from './useContentViewport';

    import { UI_CONFIG } from '../config/ui.config';

    import { REVIEW_BODY_VIEWS } from '../constants/review.constants';

    import { useListNavigator } from './useListNavigator';

    import { useViewport } from './useViewport';


    type NavigableItem =
        | { type: 'prompt' }
        | { type: 'reasoning' }
        | { type: 'script'; id: string }
        | { type: 'file'; id: string };

    export const useReviewScreen = () => {
        const store = useReviewStore();
        const {
            selectedItemIndex,
            bodyView,
            patchStatus,
            selectedBulkRepairOptionIndex,
            selectedBulkInstructOptionIndex,
        } = store;

        const transaction = useTransactionStore(selectSelectedTransaction);
        const { showDashboardScreen } = useAppStore(s => s.actions);

        const scriptCount = transaction?.scripts?.length || 0;
        const fileCount = transaction?.files?.length || 0;

        const layout = UI_CONFIG.layout.review;

        // Layout for the main navigable item list (prompt, reasoning, files, etc.)
        const mainListLayoutConfig = useMemo(() => ({
            header: layout.header,
            fixedRows: layout.fixedRows,
            marginsY: layout.marginsY,
            separators: layout.separators,
            footer: layout.footer,
            dynamicRows: {
                count: bodyView !== REVIEW_BODY_VIEWS.NONE ? layout.bodyHeightReservation : 0,
            },
        }), [bodyView, layout]);

        const { remainingHeight: listViewportHeight } = useLayout(mainListLayoutConfig);
        const { viewOffset } = useViewport({
            selectedIndex: selectedItemIndex,
            itemCount: 100,
            layoutConfig: mainListLayoutConfig,
        });

        // Layout for the body content (diff, reasoning, etc.)
        const bodyLayoutConfig = useMemo(() => ({
            header: layout.header,
            separators: layout.separators,
            fixedRows: 2, // meta
            marginsY: 1 + 1 + 1, // meta, scripts, files
            footer: 2,
            dynamicRows: { count: 2 + scriptCount + 1 + fileCount }, // prompt, reasoning, scripts, 'FILES' header, files
        }), [layout, scriptCount, fileCount]);

        const { remainingHeight: availableBodyHeight } = useLayout(bodyLayoutConfig);

        const navigableItems = useMemo((): NavigableItem[] => {
            if (!transaction) return [];
            const scriptItems: NavigableItem[] = (transaction.scripts || []).map(s => ({ type: 'script', id: s.command }));
            const fileItems: NavigableItem[] = (transaction.files || []).map(f => ({ type: 'file', id: f.id }));
            return [{ type: 'prompt' }, { type: 'reasoning' }, ...scriptItems, ...fileItems];
        }, [transaction]);

        const contentLineCount = useMemo(() => {
            const currentItem = navigableItems[selectedItemIndex];
            switch (bodyView) { //
                case REVIEW_BODY_VIEWS.REASONING:
                    return (transaction?.reasoning || '').split('\n').length;
                case REVIEW_BODY_VIEWS.PROMPT:
                    return (transaction?.prompt || '').split('\n').length;
                case REVIEW_BODY_VIEWS.DIFF: {
                    if (currentItem?.type !== 'file') return 0;
                    const selectedFile = (transaction?.files || []).find(f => f.id === currentItem.id);
                    return (selectedFile?.diff || '').split('\n').length;
                }
                case REVIEW_BODY_VIEWS.SCRIPT_OUTPUT: {
                    if (currentItem?.type !== 'script') return 0;
                    const selectedScript = (transaction?.scripts || []).find(s => s.command === currentItem.id);
                    return (selectedScript?.output || '').split('\n').length;
                }
                default: return 0;
            }
        }, [bodyView, navigableItems, selectedItemIndex, transaction]);
        const contentViewport = useContentViewport({ contentLineCount, viewportHeight: availableBodyHeight });

        const navigableItemsInView = navigableItems.slice(viewOffset, viewOffset + listViewportHeight);

        // Memoize files to prevent re-renders, fixing the exhaustive-deps lint warning.
        const files: FileItem[] = useMemo(() => transaction?.files || [], [transaction]);
        const fileReviewStates = useReviewStore(s => s.fileReviewStates);

        const reviewStats = useMemo(() => {
            const approvedFiles = files.filter(f => fileReviewStates.get(f.id)?.status === 'APPROVED');
            return {
                totalFiles: files.length,
                totalLinesAdded: files.reduce((sum, f) => sum + f.linesAdded, 0),
                totalLinesRemoved: files.reduce((sum, f) => sum + f.linesRemoved, 0),
                numFiles: files.length,
                approvedFilesCount: approvedFiles.length,
            };
        }, [files, fileReviewStates]);

        const hasRejectedFiles = useMemo(() => {
            if (!fileReviewStates) return false;
            return Array.from(fileReviewStates.values()).some(s => s.status === 'REJECTED');
        }, [fileReviewStates]);

        const { approvedFilesCount } = reviewStats;

        const isFileSelected = navigableItems[selectedItemIndex]?.type === 'file';

        const scripts = transaction?.scripts || [];

        const {
            setSelectedItemIndex,
            expandDiff,
            toggleBodyView,
            setBodyView,
            startApplySimulation,
            approve,
            tryRepairFile,
            tryInstruct,
            showBulkRepair,
            showBulkInstruct,
            executeBulkRepairOption,
            executeBulkInstructOption,
            confirmHandoff,
            scrollReasoningUp,
            scrollReasoningDown,
            navigateScriptErrorUp,
            navigateScriptErrorDown,
            toggleFileApproval,
            rejectAllFiles,
            navigateBulkRepairUp,
            navigateBulkRepairDown,
            navigateBulkInstructUp,
            navigateBulkInstructDown,
        } = store.actions;

        const openCopyMode = () => {
            if (!transaction) return;
            const currentItem = navigableItems[selectedItemIndex];
            const selectedFile = currentItem?.type === 'file' ? files.find(f => f.id === currentItem.id) : undefined;
            useCopyStore.getState().actions.openForReview(transaction, transaction.files || [], selectedFile);
        };

        const navigateToNextFile = () => {
            const nextFileIndex = navigableItems.findIndex(
                (item, index) => index > selectedItemIndex && item.type === 'file',
            );
            if (nextFileIndex !== -1) {
                setSelectedItemIndex(nextFileIndex);
            }
        };

        const navigateToPreviousFile = () => {
            // Find the last index of a file before the current one
            const prevFileIndex = navigableItems
                .slice(0, selectedItemIndex)
                .findLastIndex(item => item.type === 'file');

            if (prevFileIndex !== -1) {
                setSelectedItemIndex(prevFileIndex);
            }
        };

        // --- Input Handlers ---

        const handleGlobalInput = (input: string, key: Key): boolean => {
            if (input === '1' && transaction) { // For demo purposes
                startApplySimulation(transaction.id, 'success'); return true;
            }
            if (input === '2' && transaction) { // For demo purposes
                startApplySimulation(transaction.id, 'failure'); return true;
            }
            // The 'q' (quit/back) is now handled by the global hotkey hook.

            const currentItem = navigableItems[selectedItemIndex];
            if (input.toLowerCase() === 'd' && currentItem?.type === 'file') {
                toggleBodyView(REVIEW_BODY_VIEWS.DIFF);
                return true;
            }

            if (key.escape) {
                switch (bodyView) {
                    case REVIEW_BODY_VIEWS.BULK_REPAIR:
                    case REVIEW_BODY_VIEWS.CONFIRM_HANDOFF:
                    case REVIEW_BODY_VIEWS.BULK_INSTRUCT:
                        toggleBodyView(bodyView);
                        break;
                    default:
                        if (bodyView !== REVIEW_BODY_VIEWS.NONE) {
                            setBodyView(REVIEW_BODY_VIEWS.NONE);
                        }
                        break;
                }
                return true;
            }
            return false;
        };

        const handleHandoffConfirmInput = (_input: string, key: Key): void => {
            if (key.return) confirmHandoff();
        };

        const handleBulkRepairInput = (input: string, key: Key): void => {
            if (key.upArrow) navigateBulkRepairUp();
            if (key.downArrow) navigateBulkRepairDown();
            if (key.return) {
                executeBulkRepairOption(selectedBulkRepairOptionIndex + 1); // Options are 1-based
                return;
            }

            if (input >= '1' && input <= '4') {
                executeBulkRepairOption(parseInt(input));
            }
        };
        
        const handleBulkInstructInput = (input: string, key: Key): void => {
            if (key.upArrow) navigateBulkInstructUp();
            if (key.downArrow) navigateBulkInstructDown();
            if (key.return) {
                executeBulkInstructOption(selectedBulkInstructOptionIndex + 1); // Options are 1-based
                return;
            }

            if (input >= '1' && input <= '3') {
                executeBulkInstructOption(parseInt(input));
            }
        };

        const handleContentScrollInput = (key: Key): boolean => {
            const contentViews = [
                REVIEW_BODY_VIEWS.REASONING,
                REVIEW_BODY_VIEWS.SCRIPT_OUTPUT,
                REVIEW_BODY_VIEWS.DIFF,
            ] as const;
            if (!(contentViews as readonly string[]).includes(bodyView)) return false;

            if (key.upArrow && bodyView !== REVIEW_BODY_VIEWS.DIFF) {
                contentViewport.actions.scrollUp();
                return true;
            }
            if (key.downArrow && bodyView !== REVIEW_BODY_VIEWS.DIFF) {
                contentViewport.actions.scrollDown();
                return true;
            }
            if (key.pageUp) { contentViewport.actions.pageUp(); return true; }
            if (key.pageDown) { contentViewport.actions.pageDown(); return true; }
            return false;
        };

        const handleReasoningInput = (input: string, key: Key): void => {
            if (key.upArrow) scrollReasoningUp();
            if (key.downArrow) scrollReasoningDown();
            if (input.toLowerCase() === 'r') toggleBodyView(REVIEW_BODY_VIEWS.REASONING);
        };

        const handleScriptOutputInput = (input: string, key: Key): void => {
            if (input.toLowerCase() === 'j') navigateScriptErrorDown();
            if (input.toLowerCase() === 'k') navigateScriptErrorUp();
            if (key.return) toggleBodyView(REVIEW_BODY_VIEWS.SCRIPT_OUTPUT);
            if (input.toLowerCase() === 'c') { // TODO: this copy logic is not great.
                const currentItem = navigableItems[selectedItemIndex];
                const selectedScript = currentItem?.type === 'script' ? scripts.find(s => s.command === currentItem.id) : undefined;
                if (selectedScript) {
                    useNotificationStore.getState().actions.show({
                        type: 'success',
                        title: 'Copied to Clipboard',
                        message: `Copied script output for: ${selectedScript.command}`,
                    });
                }
            }
        };

        const handleDiffInput = (input: string, key: Key) => {
            if (key.upArrow) {
                navigateToPreviousFile();
                return;
            }
            if (key.downArrow) {
                navigateToNextFile();
                return;
            }
            if (input.toLowerCase() === 'x') expandDiff();
            if (input.toLowerCase() === 'd' || key.escape) toggleBodyView('diff');
        };

        const handleMainNavigationInput = (input: string, key: Key): void => {
            // Handle Shift+R for reject all
            if (key.shift && input.toLowerCase() === 'r') {
                if (approvedFilesCount > 0 && transaction) {
                    rejectAllFiles();
                }
                return;
            }

            const currentItem = navigableItems[selectedItemIndex];

            if (input === ' ') {
                if (currentItem?.type === 'file') {
                    const fileState = fileReviewStates.get(currentItem.id);
                    if (fileState && fileState.status !== 'FAILED') {
                        toggleFileApproval(currentItem.id);
                    }
                }
            }

            if (input.toLowerCase() === 'p') {
                toggleBodyView(REVIEW_BODY_VIEWS.PROMPT);
            }

            if (input.toLowerCase() === 'r') {
                toggleBodyView(REVIEW_BODY_VIEWS.REASONING);
            }

            if (key.return) { // Enter key
                if (currentItem?.type === 'file') {
                    toggleBodyView(REVIEW_BODY_VIEWS.DIFF);
                } else if (currentItem?.type === 'prompt') {
                    toggleBodyView(REVIEW_BODY_VIEWS.PROMPT);
                } else if (currentItem?.type === 'reasoning') {
                    toggleBodyView(REVIEW_BODY_VIEWS.REASONING);
                } else if (currentItem?.type === 'script') {
                    toggleBodyView(REVIEW_BODY_VIEWS.SCRIPT_OUTPUT);
                }
            }

            if (input.toLowerCase() === 'a') {
                if (approvedFilesCount > 0) {
                    approve();
                    showDashboardScreen();
                }
            }

            if (input.toLowerCase() === 'c') {
                openCopyMode();
            }

            if (input.toLowerCase() === 't') {
                if (key.shift) {
                    const hasFailedFiles = Array.from(fileReviewStates.values()).some(s => s.status === 'FAILED');
                    if (hasFailedFiles) showBulkRepair();
                } else if (currentItem?.type === 'file') {
                    const fileState = fileReviewStates.get(currentItem.id);
                    if (fileState?.status === 'FAILED') tryRepairFile(currentItem.id);
                }
            }

            if (input.toLowerCase() === 'i') {
                if (key.shift) {
                    if (hasRejectedFiles) showBulkInstruct();
                } else if (currentItem?.type === 'file') {
                    const fileState = fileReviewStates.get(currentItem.id);
                    if (fileState?.status === 'REJECTED') {
                        tryInstruct(currentItem.id);
                    }
                }
            }
        };

        useListNavigator({
            itemCount: navigableItems.length,
            viewportHeight: listViewportHeight,
            selectedIndex: selectedItemIndex,
            onIndexChange: setSelectedItemIndex,
            isActive: bodyView === REVIEW_BODY_VIEWS.NONE,
            onKey: handleMainNavigationInput,
        });

        useInput((input: string, key: Key) => {
            if (handleGlobalInput(input, key)) return;
            if (handleContentScrollInput(key)) return;

            switch (bodyView) {
                case REVIEW_BODY_VIEWS.CONFIRM_HANDOFF: return handleHandoffConfirmInput(input, key);
                case REVIEW_BODY_VIEWS.BULK_REPAIR: return handleBulkRepairInput(input, key);
                case REVIEW_BODY_VIEWS.BULK_INSTRUCT: return handleBulkInstructInput(input, key);
                case REVIEW_BODY_VIEWS.REASONING: return handleReasoningInput(input, key);
                case REVIEW_BODY_VIEWS.SCRIPT_OUTPUT: return handleScriptOutputInput(input, key);
                case REVIEW_BODY_VIEWS.DIFF: return handleDiffInput(input, key);
            }
        }, { isActive: bodyView !== REVIEW_BODY_VIEWS.NONE });

        return {
            ...store,
            fileReviewStates,
            selectedItemIndex,
            transaction,
            files,
            scripts,
            patchStatus,
            navigableItems,
            isFileSelected,
            navigableItemsInView,
            viewOffset,
            contentScrollIndex: contentViewport.scrollIndex,
            availableBodyHeight,
            selectedBulkRepairOptionIndex,
            selectedBulkInstructOptionIndex,
            ...reviewStats,
            hasRejectedFiles,
        };
    };
  src/components/ReviewScreen.tsx: >-
    import { Box, Text } from 'ink';

    import ContentView from './ContentView';

    import type { ScriptResult, FileItem, FileChangeType } from
    '../types/domain.types';

    import { useReviewScreen } from '../hooks/useReviewScreen';

    import { REVIEW_BODY_VIEWS, REVIEW_FOOTER_ACTIONS, BULK_REPAIR_OPTIONS,
    BULK_INSTRUCT_OPTIONS } from '../constants/review.constants';

    import ActionFooter from './ActionFooter';

    import { FILE_STATUS_UI } from '../constants/ui.constants';

    import ScreenLayout from './layout/ScreenLayout';


    // --- Sub-components ---


    const FileItemRow = ({ file, reviewState, isFocused }: {
        file: FileItem;
        reviewState: { status: string; error?: string; details?: string };
        isFocused: boolean;
    }) => {
        const ui = FILE_STATUS_UI[reviewState.status as keyof typeof FILE_STATUS_UI] || { icon: '[?]', color: 'gray' };

        const typeColor = (type: FileChangeType) => {
            switch (type) {
                case 'ADD': return 'green';
                case 'DEL': return 'red';
                case 'REN': return 'yellow';
                default: return 'white';
            }
        };

        const diffStats = <Text>(+<Text color="green">{file.linesAdded}</Text>/-<Text color="red">{file.linesRemoved}</Text>)</Text>;
        const strategy = file.strategy === 'standard-diff' ? 'diff' : file.strategy;
        const prefix = isFocused ? '> ' : '  ';
        const colorProps = isFocused ? { bold: true, color: 'cyan' } : {};

        if (reviewState.status === 'FAILED') {
            return (
                <Box>
                    <Text {...colorProps}>
                        {prefix}<Text color={ui.color}>{ui.icon} FAILED {file.path}</Text>
                        <Text color="red">    ({reviewState.error})</Text>
                    </Text>
                </Box>
            );
        }

        if (reviewState.status === 'AWAITING') {
            return (
                <Box>
                    <Text {...colorProps}>
                        {prefix}<Text color={ui.color}>{ui.icon} AWAITING {file.path}</Text>
                        <Text color="yellow">    ({reviewState.details})</Text>
                    </Text>
                </Box>
            );
        }

        if (reviewState.status === 'RE_APPLYING') {
            return (
                 <Box>
                    <Text {...colorProps}>
                        {prefix}<Text color={ui.color}>{ui.icon} RE-APPLYING... {file.path}</Text>
                        <Text color="cyan"> (using &apos;replace&apos; strategy)</Text>
                    </Text>
                </Box>
            );
        }

        return (
            <Box>
                <Text {...colorProps}>
                    {prefix}<Text color={ui.color}>{ui.icon}</Text> {file.type}{' '}
                    <Text color={typeColor(file.type)}>{file.path}</Text>{' '}
                    {diffStats} [{strategy}]
                </Text>
            </Box>
        );
    };


    const ScriptItemRow = ({
        script,
        isSelected,
        isExpanded,
    }: {
        script: ScriptResult;
        isSelected: boolean;
        isExpanded: boolean;
    }) => {
        const icon = script.success ? '✓' : '✗';
        const iconColor = script.success ? 'green' : 'red';
        const arrow = isExpanded ? '▾' : '▸';
        const prefix = isSelected ? '> ' : '  ';
        
        // Extract script type from command (e.g., "bun run test" -> "Post-Command", "bun run lint" -> "Linter")
        const scriptType = script.command.includes('test') ? 'Post-Command' : 
                          script.command.includes('lint') ? 'Linter' : 
                          'Script';

        return (
            <Box>
                <Text bold={isSelected} color={isSelected ? 'cyan' : undefined}>
                    {prefix}<Text color={iconColor}>{icon}</Text> {scriptType}: `{script.command}` ({script.duration}s) {arrow}{' '}
                    {script.summary}
                </Text>
            </Box>
        );
    };


    // --- Main Component ---


    const ReviewScreen = () => {
        const {
            transaction,
            files,
            scripts = [],
            patchStatus,
            selectedItemIndex,
            bodyView,
            isDiffExpanded,
            reasoningScrollIndex,
            scriptErrorIndex,
            fileReviewStates,
            numFiles,
            approvedFilesCount,
            totalLinesAdded,
            totalLinesRemoved,
            selectedBulkRepairOptionIndex,
            selectedBulkInstructOptionIndex,
            navigableItems,
            navigableItemsInView,
            viewOffset,
            contentScrollIndex,
            availableBodyHeight,
            hasRejectedFiles,
        } = useReviewScreen();

        if (!transaction) {
            return <Text>Loading review...</Text>;
        }
        const { hash, message, prompt = '', reasoning = '' } = transaction;

        const renderBody = () => {
            if (bodyView === REVIEW_BODY_VIEWS.NONE) return null;

            if (bodyView === REVIEW_BODY_VIEWS.PROMPT) {
                const promptText = prompt || '';
                return (
                    <Box flexDirection="column">
                        <ContentView
                            title="PROMPT"
                            content={promptText}
                            scrollIndex={contentScrollIndex}
                            maxHeight={Math.max(1, availableBodyHeight)}
                        />
                    </Box>
                );
            }

            if (bodyView === REVIEW_BODY_VIEWS.REASONING) {
                const reasoningText = reasoning || '';
                const reasoningLinesCount = reasoningText.split('\n').length;
                const visibleLinesCount = 10;
                return (
                    <Box flexDirection="column">
                        <ContentView
                            title="REASONING"
                            content={reasoningText}
                            scrollIndex={contentScrollIndex}
                            maxHeight={Math.max(1, availableBodyHeight)}
                        />
                        {reasoningLinesCount > visibleLinesCount && (
                            <Text color="gray">
                                Showing lines {reasoningScrollIndex + 1}-{Math.min(reasoningScrollIndex + visibleLinesCount, reasoningLinesCount)}{' '}
                                of {reasoningLinesCount}
                            </Text>
                        )}
                    </Box>
                );
            }
            
            if (bodyView === REVIEW_BODY_VIEWS.DIFF) {
                const currentItem = navigableItems[selectedItemIndex];
                const selectedFile = currentItem?.type === 'file' ? files.find(f => f.id === currentItem.id) : undefined;
                if (!selectedFile) return null;
                return (
                    <ContentView
                        title={`DIFF: ${selectedFile.path}`}
                        content={selectedFile.diff}
                        highlight="diff"
                        isExpanded={isDiffExpanded}
                        scrollIndex={contentScrollIndex}
                    />
                );
            }

            if (bodyView === REVIEW_BODY_VIEWS.SCRIPT_OUTPUT) {
                 const currentItem = navigableItems[selectedItemIndex];
                 const scriptItems = navigableItems.filter((i): i is { type: 'script'; id: string } => i.type === 'script');
                 const scriptIndex = currentItem?.type === 'script'
                    ? scriptItems.findIndex(i => i.id === currentItem.id)
                    : -1;
                 const selectedScript = scripts[scriptIndex] || null;
                 if (!selectedScript) return null;
                 
                 const outputLines = selectedScript.output.split('\n');
                 const errorLines = outputLines.filter((line: string) =>
                    line.includes('Error') || line.includes('Warning'),
                 );
                 
                 return (
                    <Box flexDirection="column">
                        <Text>
                            {selectedScript.command.includes('lint') ? 'LINTER' : 'SCRIPT'} OUTPUT: `{selectedScript.command}`
                        </Text>
                        <Box marginTop={1} flexDirection="column">
                            {outputLines.map((line: string, index: number) => {
                                const isError = line.includes('Error');
                                const isWarning = line.includes('Warning');
                                const isHighlighted = errorLines[scriptErrorIndex] === line;
                                
                                return (
                                    <Text 
                                        key={index} 
                                        color={isError ? 'red' : isWarning ? 'yellow' : undefined}
                                        bold={isHighlighted}
                                        backgroundColor={isHighlighted ? 'blue' : undefined}
                                    >
                                        {line}
                                    </Text>
                                );
                            })}
                        </Box>
                        {errorLines.length > 0 && (
                            <Text color="gray">
                                Error {scriptErrorIndex + 1} of {errorLines.length} highlighted
                            </Text>
                        )}
                    </Box>
                 );
            }

            if (bodyView === REVIEW_BODY_VIEWS.CONFIRM_HANDOFF) {
                return (
                    <Box flexDirection="column" gap={1}>
                        <Text bold>HANDOFF TO EXTERNAL AGENT</Text>
                        <Box flexDirection="column">
                            <Text>This action will:</Text>
                            <Text>1. Copy a detailed prompt to your clipboard for an agentic AI.</Text>
                            <Text>2. Mark the current transaction as &apos;Handoff&apos; and close this review.</Text>
                            <Text>3. Assume that you and the external agent will complete the work.</Text>
                        </Box>
                        <Text>Relaycode will NOT wait for a new patch. This is a final action.</Text>
                        <Text bold color="yellow">Are you sure you want to proceed?</Text>
                    </Box>
                );
            }

            if (bodyView === REVIEW_BODY_VIEWS.BULK_REPAIR) {
                const failedFiles = files.filter((f: FileItem) => fileReviewStates.get(f.id)?.status === 'FAILED');

                return (
                    <Box flexDirection="column" gap={1}>
                        <Text bold>BULK REPAIR ACTION</Text>

                        <Box flexDirection="column">
                            <Text>The following {failedFiles.length} files failed to apply:</Text>
                            {failedFiles.map((file: FileItem) => (
                                <Text key={file.id}>- {file.path}</Text>
                            ))}
                        </Box>

                        <Text>How would you like to proceed?</Text>

                        <Box flexDirection="column">
                            {BULK_REPAIR_OPTIONS.map((opt, i) => (
                                <Text key={i} color={selectedBulkRepairOptionIndex === i ? 'cyan' : undefined}>
                                    {selectedBulkRepairOptionIndex === i ? '> ' : '  '}
                                    {opt}
                                </Text>
                            ))}
                        </Box>
                    </Box>
                );
            }

            if (bodyView === REVIEW_BODY_VIEWS.BULK_INSTRUCT) {
                const rejectedFiles = files.filter((f: FileItem) => fileReviewStates.get(f.id)?.status === 'REJECTED');

                return (
                    <Box flexDirection="column" gap={1}>
                        <Text bold>BULK INSTRUCTION ACTION</Text>

                        <Box flexDirection="column">
                            <Text>The following {rejectedFiles.length} files were rejected:</Text>
                            {rejectedFiles.map((file: FileItem) => (
                                <Text key={file.id}>- {file.path}</Text>
                            ))}
                        </Box>
                        <Box flexDirection="column" marginTop={1}>
                            {BULK_INSTRUCT_OPTIONS.map((opt, i) => (
                                <Text key={i} color={selectedBulkInstructOptionIndex === i ? 'cyan' : undefined}>
                                    {selectedBulkInstructOptionIndex === i ? '> ' : '  '}
                                    {opt}
                                </Text>
                            ))}
                        </Box>
                    </Box>
                );
            }

            return null;
        };

        const renderFooter = () => {
            // Contextual footer for body views
            switch (bodyView) {
                case REVIEW_BODY_VIEWS.DIFF:
                    return <ActionFooter actions={REVIEW_FOOTER_ACTIONS.DIFF_VIEW}/>;
                case REVIEW_BODY_VIEWS.REASONING:
                    return <ActionFooter actions={REVIEW_FOOTER_ACTIONS.REASONING_VIEW}/>;
                case REVIEW_BODY_VIEWS.SCRIPT_OUTPUT:
                    return <ActionFooter actions={REVIEW_FOOTER_ACTIONS.SCRIPT_OUTPUT_VIEW}/>;
                case REVIEW_BODY_VIEWS.BULK_REPAIR:
                    return <Text>{REVIEW_FOOTER_ACTIONS.BULK_REPAIR_VIEW.text}</Text>;
                case REVIEW_BODY_VIEWS.BULK_INSTRUCT:
                    return <Text>{REVIEW_FOOTER_ACTIONS.BULK_INSTRUCT_VIEW.text}</Text>;
                case REVIEW_BODY_VIEWS.CONFIRM_HANDOFF:
                    return <ActionFooter actions={REVIEW_FOOTER_ACTIONS.HANDOFF_CONFIRM_VIEW}/>;
            }

            // Dynamic Main footer
            const currentItem = navigableItems[selectedItemIndex];
            const hasFailedFiles = Array.from(fileReviewStates.values()).some(s => s.status === 'FAILED');
            const fileState = currentItem?.type === 'file' ? fileReviewStates.get(currentItem.id) : undefined;

            const footerConfig = {
                isFileSelected: currentItem?.type === 'file',
                fileStatus: fileState?.status as 'FAILED' | 'REJECTED' | 'OTHER' | undefined,
                currentItemType: currentItem?.type as 'file' | 'script' | 'reasoning' | 'prompt' | undefined,
                hasFailedFiles,
                hasRejectedFiles,
                hasApprovedFiles: approvedFilesCount > 0,
            };
            return <ActionFooter actions={REVIEW_FOOTER_ACTIONS.MAIN_VIEW(footerConfig)} />;
        };

        return (
            <ScreenLayout title="▲ relaycode · REVIEW" footer={renderFooter()}>
                {/* Navigator Section */}
                <Box flexDirection="column" marginY={1}>
                    <Box flexDirection="column">
                        <Text>{hash} · {message}</Text>
                        <Box>
                            <Text>
                                (<Text color="green">+{totalLinesAdded}</Text>/<Text color="red">-{totalLinesRemoved}</Text>)
                                {' '}| {numFiles} Files · ({approvedFilesCount}/{numFiles} Appr)
                                {' '}| Showing {viewOffset + 1}-
                                {Math.min(viewOffset + navigableItemsInView.length, navigableItems.length)}{' '}
                                of {navigableItems.length}
                            </Text>
                            {patchStatus === 'PARTIAL_FAILURE' && scripts.length === 0 && (
                                <Text> · Scripts: SKIPPED</Text>
                            )}
                            {patchStatus === 'PARTIAL_FAILURE' && <Text color="red" bold> · MULTIPLE PATCHES FAILED</Text>}
                        </Box>
                    </Box>

                    <Box flexDirection="column" marginTop={1}>
                        <Text color={navigableItems[selectedItemIndex]?.type === 'prompt' ? 'cyan' : undefined}>
                            {navigableItems[selectedItemIndex]?.type === 'prompt' ? '> ' : '  '}
                            (P)rompt ▸ {(prompt || '').substring(0, 50)}...
                        </Text>
                        <Text color={navigableItems[selectedItemIndex]?.type === 'reasoning' ? 'cyan' : undefined}>
                            {navigableItems[selectedItemIndex]?.type === 'reasoning' ? '> ' : '  '}
                            (R)easoning ({(reasoning || '').split('\n\n').length} steps){' '}
                            {bodyView === REVIEW_BODY_VIEWS.REASONING ? '▾' : '▸'}{' '}
                            {((reasoning || '').split('\n')[0] ?? '').substring(0, 40)}...
                        </Text>
                    </Box>
                </Box>

                {/* Script Results (if any) */}
                {scripts.length > 0 && navigableItemsInView.some(i => i.type === 'script') && (
                    <>
                        <Box flexDirection="column" marginY={1}>
                            {scripts.map((script: ScriptResult) => {
                                const itemInViewIndex = navigableItemsInView.findIndex(i => i.type === 'script' && i.id === script.command);
                                if (itemInViewIndex === -1) return null;
                                
                                const isSelected = selectedItemIndex === viewOffset + itemInViewIndex;
                                return (
                                    <ScriptItemRow
                                        key={script.command} script={script}
                                        isSelected={isSelected}
                                        isExpanded={bodyView === REVIEW_BODY_VIEWS.SCRIPT_OUTPUT && isSelected}
                                    />
                                );
                            })}
                        </Box>
                    </>
                )}
                
                {/* Files Section */}
                <Box flexDirection="column" marginY={1}>
                    <Text bold>FILES</Text>
                    {files.map((file: FileItem) => {
                        const itemInViewIndex = navigableItemsInView.findIndex(i => i.type === 'file' && i.id === file.id);
                        if (itemInViewIndex === -1) return null; // Only render if visible

                        const isFocused = selectedItemIndex === viewOffset + itemInViewIndex;
                        const reviewState = fileReviewStates.get(file.id);
                        
                        return (
                            <FileItemRow key={file.id} file={file} isFocused={isFocused} reviewState={reviewState || { status: 'AWAITING' }} />
                        );
                    })}
                </Box>

                {/* Body Viewport */}
                {bodyView !== REVIEW_BODY_VIEWS.NONE && (
                    <Box marginY={1}>
                        {renderBody()}
                    </Box>
                )}
            </ScreenLayout>
        );
    };


    export default ReviewScreen;
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: '2025-09-26T14:27:36.785Z'
status: committed
id: 209
