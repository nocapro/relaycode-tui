uuid: 489cc52d-86eb-46f3-a7ce-b1ef3b432a24
projectId: relaycode-tui
createdAt: '2025-09-22T00:39:14.806Z'
gitCommitMsg: >-
  feat(ui): create dedicated ReviewProcessingScreen

  Extracts the patch application UI from the `ReviewScreen` into a new,
  dedicated `ReviewProcessingScreen` component. This aligns the application flow
  with the specifications in `review-processing-screen.readme.md`.

  - Creates `src/components/ReviewProcessingScreen.tsx` to display live patch
  application progress. - Adds a new `review-processing` state to the main app
  store to manage navigation. - Refactors `review.store.ts` to orchestrate
  screen transitions between the processing and review screens. - Simplifies
  `ReviewScreen.tsx` to focus solely on interactive review and repair, removing
  all patch application logic.
promptSummary: >-
  The user wants to extract the processing state screen from the review screen
  into a new component called ReviewProcessingScreen, based on the provided
  markdown documentation. This is a retry of a previously failed patch.
reasoning:
  - >-
    I apologize for the failed patch. The `standard-diff` strategy can sometimes
    fail if the file's content doesn't match exactly. I will now retry the same
    set of changes, but I will use the more resilient `search-replace` strategy
    for the complex modifications in `ReviewScreen.tsx` to ensure the patch
    applies correctly. The other files will be patched as before.
  - '### 1. Create the new `ReviewProcessingScreen` component'
  - >-
    First, I'll create the new component
    `src/components/ReviewProcessingScreen.tsx`. This component will render the
    step-by-step progress of a patch being applied, as defined in the project
    documentation.
  - '### 2. Add the new screen to the App state'
  - >-
    I'll update the main application store to be aware of the new
    `review-processing` screen.
  - '### 3. Update the main `App` to render the new screen'
  - >-
    Now I will modify `App.tsx` to handle rendering the
    `ReviewProcessingScreen`.
  - '### 4. Refactor the Review store'
  - >-
    The `review.store.ts` will be updated to manage the screen transitions
    instead of using an internal `applicationStatus`.
  - '### 5. Clean up the `ReviewScreen` component'
  - >-
    Finally, I'll remove the now-redundant processing logic from
    `ReviewScreen.tsx` using a more robust `search-replace` strategy to avoid
    patching errors.
operations:
  - type: write
    path: src/components/ReviewProcessingScreen.tsx
    content: >-
      import React from 'react';

      import { Box, Text } from 'ink';

      import { useReviewStore, type ApplyStep } from '../stores/review.store';

      import Separator from './Separator';


      const ApplyStepRow = ({ step, isSubstep = false }: { step: ApplyStep,
      isSubstep?: boolean }) => {
          if (isSubstep) {
              let color;
              if (step.status === 'done' && step.title.startsWith('[✓]')) color = 'green';
              if (step.status === 'failed') color = 'red';

              return (
                  <Text color={color}>
                      {'     └─ '}{step.title}
                  </Text>
              );
          }

          let symbol;
          let color;
          switch (step.status) {
              case 'pending': symbol = '( )'; break;
              case 'active': symbol = '(●)'; color = 'cyan'; break;
              case 'done': symbol = '[✓]'; color = 'green'; break;
              case 'failed': symbol = '[!]'; color = 'red'; break;
              case 'skipped': symbol = '(-)'; color = 'gray'; break;
          }

          return (
              <Box flexDirection="column">
                  <Text>
                      <Text color={color}>{symbol}</Text> {step.title} {step.duration && !isSubstep && `(${step.duration}s)`}
                  </Text>
                  {step.details && (
                      <Text color="gray">
                          {'     └─ '}{step.details}
                      </Text>
                  )}
                  {step.substeps?.map((sub, i) => (
                      <ApplyStepRow key={i} step={sub} isSubstep={true} />
                  ))}
              </Box>
          );
      };


      const ReviewProcessingScreen = () => {
          const { hash, message, patchStatus, applySteps } = useReviewStore(state => ({
              hash: state.hash,
              message: state.message,
              patchStatus: state.patchStatus,
              applySteps: state.applySteps,
          }));

          const totalDuration = applySteps.reduce((acc, step) => acc + (step.duration || 0), 0);
          const failureCase = patchStatus === 'PARTIAL_FAILURE';
          const footerText = failureCase
              ? `Elapsed: ${totalDuration.toFixed(1)}s · Transitioning to repair workflow...`
              : `Elapsed: ${totalDuration.toFixed(1)}s · Processing... Please wait.`;

          return (
              <Box flexDirection="column">
                  <Text color="cyan">▲ relaycode apply</Text>
                  <Separator />
                  <Box marginY={1} flexDirection="column">
                      <Text>Applying patch {hash}... ({message})</Text>
                      <Box flexDirection="column" marginTop={1} gap={1}>
                          {applySteps.map(step => <ApplyStepRow key={step.id} step={step} />)}
                      </Box>
                  </Box>
                  <Separator />
                  <Text>{footerText}</Text>
              </Box>
          );
      };


      export default ReviewProcessingScreen;
    patchStrategy: replace
  - type: write
    path: src/stores/app.store.ts
    content: >+
      --- src/stores/app.store.ts

      +++ src/stores/app.store.ts

      @@ -1,11 +1,12 @@
       import { create } from 'zustand';
       
      -export type AppScreen = 'splash' | 'init' | 'dashboard' | 'review';

      +export type AppScreen = 'splash' | 'init' | 'dashboard' | 'review' |
      'review-processing';
       
       interface AppState {
           currentScreen: AppScreen;
           actions: {
               showInitScreen: () => void;
      +        showReviewProcessingScreen: () => void;
               showDashboardScreen: () => void;
               showReviewScreen: () => void;
           };
      @@ -16,6 +17,7 @@
           currentScreen: 'splash',
           actions: {
               showInitScreen: () => set({ currentScreen: 'init' }),
      +        showReviewProcessingScreen: () => set({ currentScreen:
      'review-processing' }),
               showDashboardScreen: () => set({ currentScreen: 'dashboard' }),
               showReviewScreen: () => set({ currentScreen: 'review' }),
           },

    patchStrategy: standard-diff
  - type: write
    path: src/App.tsx
    content: |
      --- src/App.tsx
      +++ src/App.tsx
      @@ -4,6 +4,7 @@
       import InitializationScreen from './components/InitializationScreen';
       import DashboardScreen from './components/DashboardScreen';
       import ReviewScreen from './components/ReviewScreen';
      +import ReviewProcessingScreen from './components/ReviewProcessingScreen';
       
       const App = () => {
           const currentScreen = useAppStore(state => state.currentScreen);
      @@ -28,6 +29,10 @@
               return <ReviewScreen />;
           }
       
      +    if (currentScreen === 'review-processing') {
      +        return <ReviewProcessingScreen />;
      +    }
      +
           return null;
       };
       
    patchStrategy: standard-diff
  - type: write
    path: src/stores/review.store.ts
    content: >+
      --- src/stores/review.store.ts

      +++ src/stores/review.store.ts

      @@ -1,5 +1,6 @@
       import { create } from 'zustand';
       import { sleep } from '../utils';
      +import { useAppStore } from './app.store';
       
       // --- Types ---
       
      @@ -21,8 +22,6 @@
           output: string;
       }
       
      -export type ApplicationStatus = 'APPLYING' | 'REVIEWING';

      -
       export interface ApplyStep {
           id: string;
           title: string;
      @@ -53,8 +52,6 @@
           scripts: ScriptResult[];
       
           // UI State
      -    applicationStatus: ApplicationStatus;
           applySteps: ApplyStep[];
           selectedItemIndex: number; // Can be file or script
           bodyView: BodyView;
      @@ -165,7 +162,6 @@
           scripts: [], // Empty for partial failure scenario
       
           // UI State
      -    applicationStatus: 'REVIEWING',
           applySteps: initialApplySteps,
           selectedItemIndex: 0, // Start with first file
           bodyView: 'none',
      @@ -220,7 +216,10 @@
               }),
               expandDiff: () => set(state => ({ isDiffExpanded: !state.isDiffExpanded })),
               approve: () => { /* NOP for now, would trigger commit and screen change */ },
               startApplySimulation: async (scenario: 'success' | 'failure') => {
      -            set({ applicationStatus: 'APPLYING', applySteps:
      JSON.parse(JSON.stringify(initialApplySteps)) });

      +            const { showReviewProcessingScreen, showReviewScreen } =
      useAppStore.getState().actions;

      +            

      +            set({ applySteps:
      JSON.parse(JSON.stringify(initialApplySteps)) });

      +            showReviewProcessingScreen();
                   
                   const updateStep = (id: string, status: ApplyStep['status'], duration?: number, details?: string) => {
                       set(state => ({
      @@ -291,7 +290,7 @@
                       await sleep(500);
                   }
           
      -            set({ applicationStatus: 'REVIEWING' });

      +            showReviewScreen();
               },
               simulateSuccessScenario: () => set(() => ({
                   hash: '4b9d8f03',

    patchStrategy: standard-diff
  - type: write
    path: src/components/ReviewScreen.tsx
    content: >
      <<<<<<< SEARCH

      import React, { useMemo, useEffect } from 'react';

      import { Box, Text, useInput, useApp } from 'ink';

      import { useReviewStore, type FileItem, type ScriptResult, type ApplyStep
      } from '../stores/review.store';

      =======

      import React, { useMemo } from 'react';

      import { Box, Text, useInput, useApp } from 'ink';

      import { useReviewStore, type FileItem, type ScriptResult } from
      '../stores/review.store';

      >>>>>>> REPLACE

      <<<<<<< SEARCH

      // --- Application simulation components ---


      const ApplyStepRow = ({ step, isSubstep = false }: { step: ApplyStep,
      isSubstep?: boolean }) => {
          if (isSubstep) {
              let color;
              if (step.status === 'done' && step.title.startsWith('[✓]')) color = 'green';
              if (step.status === 'failed') color = 'red';

              return (
                  <Text color={color}>
                      {'     └─ '}{step.title}
                  </Text>
              );
          }

          let symbol;
          let color;
          switch (step.status) {
              case 'pending': symbol = '( )'; break;
              case 'active': symbol = '(●)'; color = 'cyan'; break;
              case 'done': symbol = '[✓]'; color = 'green'; break;
              case 'failed': symbol = '[!]'; color = 'red'; break;
              case 'skipped': symbol = '(-)'; color = 'gray'; break;
          }

          return (
              <Box flexDirection="column">
                  <Text>
                      <Text color={color}>{symbol}</Text> {step.title} {step.duration && !isSubstep && `(${step.duration}s)`}
                  </Text>
                  {step.details && (
                      <Text color="gray">
                          {'     └─ '}{step.details}
                      </Text>
                  )}
                  {step.substeps?.map((sub, i) => (
                      <ApplyStepRow key={i} step={sub} isSubstep={true} />
                  ))}
              </Box>
          );
      };

      =======

      >>>>>>> REPLACE

      <<<<<<< SEARCH
              hash, message, prompt, reasoning, files, scripts, patchStatus,
              linesAdded, linesRemoved, duration,
              selectedItemIndex, bodyView, isDiffExpanded, applicationStatus, applySteps,
              copyModeSelectedIndex, copyModeLastCopied, reasoningScrollIndex, scriptErrorIndex,
          } = store;
      =======
              hash, message, prompt, reasoning, files, scripts, patchStatus,
              linesAdded, linesRemoved, duration,
              selectedItemIndex, bodyView, isDiffExpanded,
              copyModeSelectedIndex, copyModeLastCopied, reasoningScrollIndex, scriptErrorIndex,
          } = store;
      >>>>>>> REPLACE

      <<<<<<< SEARCH
          useEffect(() => {
              // Start with a failure simulation on mount
              startApplySimulation('failure');
          }, [startApplySimulation]);

          useInput((input, key) => {
              if (applicationStatus === 'REVIEWING') {
                   // Allow switching between simulations for demo purposes
                  if (input === '1') {
                      startApplySimulation('success');
                      return;
                  }
                  if (input === '2') {
                      startApplySimulation('failure');
                      return;
                  }
              } else {
                  return; // Disable input during application
              }
      =======
          useInput((input, key) => {
              // For demo purposes: Pressing 1 or 2 triggers the processing screen simulation.
              if (input === '1') {
                  startApplySimulation('success');
                  return;
              }
              if (input === '2') {
                  // The store's default is failure, but to re-trigger the processing screen
                  startApplySimulation('failure');
                  return;
              }
      >>>>>>> REPLACE

      <<<<<<< SEARCH
          const renderApplyScreen = () => {
              const totalDuration = applySteps.reduce((acc, step) => acc + (step.duration || 0), 0);
              const failureCase = patchStatus === 'PARTIAL_FAILURE';
              const footerText = failureCase
                  ? `Elapsed: ${totalDuration.toFixed(1)}s · Transitioning to repair workflow...`
                  : `Elapsed: ${totalDuration.toFixed(1)}s · Processing... Please wait.`;

              return (
                  <Box flexDirection="column">
                      <Text color="cyan">▲ relaycode apply</Text>
                      <Separator />
                      <Box marginY={1}>
                          <Text>Applying patch {hash}... ({message})</Text>
                          <Box flexDirection="column" marginTop={1} gap={1}>
                              {applySteps.map(step => <ApplyStepRow key={step.id} step={step} />)}
                          </Box>
                      </Box>
                      <Separator />
                      <Text>{footerText}</Text>
                  </Box>
              );
          };
      =======

      >>>>>>> REPLACE

      <<<<<<< SEARCH
          if (applicationStatus === 'APPLYING') {
              return renderApplyScreen();
          }
      =======

      >>>>>>> REPLACE
    patchStrategy: search-replace
snapshot:
  src/components/ReviewProcessingScreen.tsx: null
  src/stores/app.store.ts: |-
    import { create } from 'zustand';

    export type AppScreen = 'splash' | 'init' | 'dashboard' | 'review';

    interface AppState {
        currentScreen: AppScreen;
        actions: {
            showInitScreen: () => void;
            showDashboardScreen: () => void;
            showReviewScreen: () => void;
        };
    }

    export const useAppStore = create<AppState>((set) => ({
        currentScreen: 'splash',
        actions: {
            showInitScreen: () => set({ currentScreen: 'init' }),
            showDashboardScreen: () => set({ currentScreen: 'dashboard' }),
            showReviewScreen: () => set({ currentScreen: 'review' }),
        },
    }));
  src/App.tsx: |-
    import React, { useEffect } from 'react';
    import { useAppStore } from './stores/app.store';
    import SplashScreen from './components/SplashScreen';
    import InitializationScreen from './components/InitializationScreen';
    import DashboardScreen from './components/DashboardScreen';
    import ReviewScreen from './components/ReviewScreen';

    const App = () => {
        const currentScreen = useAppStore(state => state.currentScreen);

        useEffect(() => {
            // Clear the terminal when the screen changes to ensure a clean view.
            // This is especially important when transitioning from the splash screen.
            // eslint-disable-next-line no-console
            console.clear();
        }, [currentScreen]);
        
        if (currentScreen === 'splash') {
            return <SplashScreen />;
        }

        if (currentScreen === 'init') {
            return <InitializationScreen />;
        }

        if (currentScreen === 'dashboard') {
            return <DashboardScreen />;
        }

        if (currentScreen === 'review') {
            return <ReviewScreen />;
        }

        return null;
    };

    export default App;
  src/components/ReviewScreen.tsx: >-
    import React, { useMemo, useEffect } from 'react';

    import { Box, Text, useInput, useApp } from 'ink';

    import { useReviewStore, type FileItem, type ScriptResult, type ApplyStep }
    from '../stores/review.store';

    import { useAppStore } from '../stores/app.store';

    import Separator from './Separator';

    import DiffScreen from './DiffScreen';

    import ReasonScreen from './ReasonScreen';


    // --- Sub-components ---


    const FileItemRow = ({ file, isSelected }: { file: FileItem, isSelected:
    boolean }) => {
        let icon;
        let iconColor;
        switch (file.status) {
            case 'APPROVED': icon = '[✓]'; iconColor = 'green'; break;
            case 'REJECTED': icon = '[✗]'; iconColor = 'red'; break;
            case 'FAILED': icon = '[!]'; iconColor = 'red'; break;
        }

        const diffStats = `(+${file.linesAdded}/-${file.linesRemoved})`;
        const strategy = file.strategy === 'standard-diff' ? 'diff' : file.strategy;
        const prefix = isSelected ? '> ' : '  ';

        if (file.status === 'FAILED') {
            return (
                <Box>
                    <Text bold={isSelected} color={isSelected ? 'cyan' : undefined}>
                        {prefix}<Text color={iconColor}>{icon} FAILED {file.path}</Text>
                        <Text color="red">    ({file.error})</Text>
                    </Text>
                </Box>
            );
        }

        return (
            <Box>
                <Text bold={isSelected} color={isSelected ? 'cyan' : undefined}>
                    {prefix}<Text color={iconColor}>{icon}</Text> MOD {file.path} {diffStats} [{strategy}]
                </Text>
            </Box>
        );
    };


    const ScriptItemRow = ({
        script,
        isSelected,
        isExpanded,
    }: {
        script: ScriptResult;
        isSelected: boolean;
        isExpanded: boolean;
    }) => {
        const icon = script.success ? '✓' : '✗';
        const iconColor = script.success ? 'green' : 'red';
        const arrow = isExpanded ? '▾' : '▸';
        const prefix = isSelected ? '> ' : '  ';
        
        // Extract script type from command (e.g., "bun run test" -> "Post-Command", "bun run lint" -> "Linter")
        const scriptType = script.command.includes('test') ? 'Post-Command' : 
                          script.command.includes('lint') ? 'Linter' : 
                          'Script';

        return (
            <Box>
                <Text bold={isSelected} color={isSelected ? 'cyan' : undefined}>
                    {prefix}<Text color={iconColor}>{icon}</Text> {scriptType}: `{script.command}` ({script.duration}s) {arrow}{' '}
                    {script.summary}
                </Text>
            </Box>
        );
    };


    // --- Application simulation components ---


    const ApplyStepRow = ({ step, isSubstep = false }: { step: ApplyStep,
    isSubstep?: boolean }) => {
        if (isSubstep) {
            let color;
            if (step.status === 'done' && step.title.startsWith('[✓]')) color = 'green';
            if (step.status === 'failed') color = 'red';

            return (
                <Text color={color}>
                    {'     └─ '}{step.title}
                </Text>
            );
        }

        let symbol;
        let color;
        switch (step.status) {
            case 'pending': symbol = '( )'; break;
            case 'active': symbol = '(●)'; color = 'cyan'; break;
            case 'done': symbol = '[✓]'; color = 'green'; break;
            case 'failed': symbol = '[!]'; color = 'red'; break;
            case 'skipped': symbol = '(-)'; color = 'gray'; break;
        }

        return (
            <Box flexDirection="column">
                <Text>
                    <Text color={color}>{symbol}</Text> {step.title} {step.duration && !isSubstep && `(${step.duration}s)`}
                </Text>
                {step.details && (
                    <Text color="gray">
                        {'     └─ '}{step.details}
                    </Text>
                )}
                {step.substeps?.map((sub, i) => (
                    <ApplyStepRow key={i} step={sub} isSubstep={true} />
                ))}
            </Box>
        );
    };


    // --- Main Component ---


    const ReviewScreen = () => {
        const { exit } = useApp();
        const store = useReviewStore();
        const { showDashboardScreen } = useAppStore(s => s.actions);
        const {
            hash, message, prompt, reasoning, files, scripts, patchStatus,
            linesAdded, linesRemoved, duration,
            selectedItemIndex, bodyView, isDiffExpanded, applicationStatus, applySteps,
            copyModeSelectedIndex, copyModeLastCopied, reasoningScrollIndex, scriptErrorIndex,
        } = store;
        const {
            moveSelectionUp, moveSelectionDown, toggleFileApproval,
            toggleDiffView, toggleReasoningView, toggleScriptView, expandDiff,
            startApplySimulation,
            rejectAllFiles, approve,
            toggleCopyMode, moveCopySelectionUp, moveCopySelectionDown, copySelectedItem,
            copyUUID, copyMessage, copyPrompt, copyReasoning, copyFileDiff, copyAllDiffs,
            tryRepairFile, showBulkRepair, executeBulkRepairOption,
            scrollReasoningUp, scrollReasoningDown, navigateScriptErrorUp, navigateScriptErrorDown,
        } = store.actions;

        const numFiles = files.length;
        const approvedFilesCount = useMemo(() => files.filter(f => f.status === 'APPROVED').length, [files]);
        const canBeRejected = useMemo(() => files.some(f => f.status === 'APPROVED'), [files]);

        useEffect(() => {
            // Start with a failure simulation on mount
            startApplySimulation('failure');
        }, [startApplySimulation]);

        useInput((input, key) => {
            if (applicationStatus === 'REVIEWING') {
                 // Allow switching between simulations for demo purposes
                if (input === '1') {
                    startApplySimulation('success');
                    return;
                }
                if (input === '2') {
                    startApplySimulation('failure');
                    return;
                }
            } else {
                return; // Disable input during application
            }

            if (input.toLowerCase() === 'q') exit();

            // Handle Escape key - context-sensitive behavior
            if (key.escape) {
                if (bodyView === 'copy_mode') {
                    toggleCopyMode();
                } else if (bodyView === 'bulk_repair') {
                    showBulkRepair(); // Close bulk repair modal
                } else if (bodyView !== 'none') {
                    if (bodyView === 'diff') toggleDiffView();
                    if (bodyView === 'reasoning') toggleReasoningView();
                    if (bodyView === 'script_output') toggleScriptView();
                } else if (canBeRejected) {
                    rejectAllFiles();
                } else {
                    showDashboardScreen();
                }
                return;
            }

            // Copy Mode Navigation
            if (bodyView === 'copy_mode') {
                if (key.upArrow) moveCopySelectionUp();
                if (key.downArrow) moveCopySelectionDown();
                if (key.return) copySelectedItem();
                
                // Hotkey shortcuts
                if (input.toLowerCase() === 'u') copyUUID();
                if (input.toLowerCase() === 'm') copyMessage();
                if (input.toLowerCase() === 'p') copyPrompt();
                if (input.toLowerCase() === 'r') copyReasoning();
                if (input.toLowerCase() === 'f') copyFileDiff();
                if (input.toLowerCase() === 'a') copyAllDiffs();
                if (input.toLowerCase() === 'c') toggleCopyMode();
                return;
            }

            // Bulk Repair Navigation
            if (bodyView === 'bulk_repair') {
                if (input >= '1' && input <= '4') {
                    executeBulkRepairOption(parseInt(input));
                }
                return;
            }

            // Reasoning Scroll Navigation
            if (bodyView === 'reasoning') {
                if (key.upArrow) scrollReasoningUp();
                if (key.downArrow) scrollReasoningDown();
                if (input.toLowerCase() === 'r') toggleReasoningView();
                return;
            }

            // Script Output Navigation
            if (bodyView === 'script_output') {
                if (input.toLowerCase() === 'j') navigateScriptErrorDown();
                if (input.toLowerCase() === 'k') navigateScriptErrorUp();
                if (key.return) toggleScriptView();
                if (input.toLowerCase() === 'c') {
                    // Copy script output
                    const scriptIndex = selectedItemIndex - numFiles;
                    const selectedScript = scripts[scriptIndex];
                    if (selectedScript) {
                        // eslint-disable-next-line no-console
                        console.log(`[CLIPBOARD] Copied script output: ${selectedScript.command}`);
                    }
                }
                return;
            }

            // Diff View Navigation
            if (bodyView === 'diff') {
                if (input.toLowerCase() === 'x') expandDiff();
                if (input.toLowerCase() === 'd') toggleDiffView();
                return;
            }

            // Main View Navigation
            if (key.upArrow) moveSelectionUp();
            if (key.downArrow) moveSelectionDown();

            if (input.toLowerCase() === 'r') toggleReasoningView();

            if (input === ' ') {
                if (selectedItemIndex < numFiles) {
                    const file = files[selectedItemIndex];
                    if (file && file.status !== 'FAILED') {
                        toggleFileApproval();
                    }
                }
            }

            if (input.toLowerCase() === 'd') {
                if (selectedItemIndex < numFiles) {
                    toggleDiffView();
                }
            }

            if (key.return) { // Enter key
                 if (selectedItemIndex >= numFiles) { // It's a script
                    toggleScriptView();
                }
            }

            if (input.toLowerCase() === 'a') {
                if (approvedFilesCount > 0) {
                    approve();
                    showDashboardScreen();
                }
            }

            if (input.toLowerCase() === 'c') {
                toggleCopyMode();
            }

            if (input.toLowerCase() === 't') {
                if (selectedItemIndex < numFiles) {
                    const file = files[selectedItemIndex];
                    if (file && file.status === 'FAILED') {
                        tryRepairFile();
                    }
                }
            }

            // Handle Shift+T for bulk repair
            if (key.shift && input.toLowerCase() === 't') {
                const hasFailedFiles = files.some(f => f.status === 'FAILED');
                if (hasFailedFiles) {
                    showBulkRepair();
                }
            }

            if (input.toLowerCase() === 'q') {
                showDashboardScreen();
            }
        });

        const renderBody = () => {
            if (bodyView === 'none') return null;

            if (bodyView === 'reasoning') {
                const reasoningLines = reasoning.split('\n');
                const visibleLines = reasoningLines.slice(reasoningScrollIndex, reasoningScrollIndex + 10);
                return (
                    <Box flexDirection="column">
                        <Text>REASONING DETAILS</Text>
                        <Box marginTop={1}>
                            {visibleLines.map((line, index) => (
                                <Text key={index}>{line}</Text>
                            ))}
                        </Box>
                        {reasoningLines.length > 10 && (
                            <Text color="gray">
                                Showing lines {reasoningScrollIndex + 1}-{Math.min(reasoningScrollIndex + 10, reasoningLines.length)}{' '}
                                of {reasoningLines.length}
                            </Text>
                        )}
                    </Box>
                );
            }
            
            if (bodyView === 'diff') {
                const selectedFile = files[selectedItemIndex];
                if (!selectedFile) return null;
                return (
                    <DiffScreen
                        filePath={selectedFile.path}
                        diffContent={selectedFile.diff}
                        isExpanded={isDiffExpanded}
                    />
                );
            }

            if (bodyView === 'script_output') {
                 const scriptIndex = selectedItemIndex - numFiles;
                 const selectedScript = scripts[scriptIndex];
                 if (!selectedScript) return null;
                 
                 const outputLines = selectedScript.output.split('\n');
                 const errorLines = outputLines.filter(line =>
                    line.includes('Error') || line.includes('Warning'),
                 );
                 
                 return (
                    <Box flexDirection="column">
                        <Text>{selectedScript.command.includes('lint') ? 'LINTER' : 'SCRIPT'} OUTPUT: `{selectedScript.command}`</Text>
                        <Box marginTop={1}>
                            {outputLines.map((line, index) => {
                                const isError = line.includes('Error');
                                const isWarning = line.includes('Warning');
                                const isHighlighted = errorLines[scriptErrorIndex] === line;
                                
                                return (
                                    <Text 
                                        key={index} 
                                        color={isError ? 'red' : isWarning ? 'yellow' : undefined}
                                        bold={isHighlighted}
                                        backgroundColor={isHighlighted ? 'blue' : undefined}
                                    >
                                        {line}
                                    </Text>
                                );
                            })}
                        </Box>
                        {errorLines.length > 0 && (
                            <Text color="gray">
                                Error {scriptErrorIndex + 1} of {errorLines.length} highlighted
                            </Text>
                        )}
                    </Box>
                 );
            }

            if (bodyView === 'copy_mode') {
                const selectedFile = selectedItemIndex < files.length ? files[selectedItemIndex] : undefined;
                const options = [
                    { key: 'U', label: 'UUID', value: `${hash}-a8b3-4f2c-9d1e-8a7c1b9d8f03` },
                    { key: 'M', label: 'Git Message', value: message },
                    { key: 'P', label: 'Prompt', value: `${prompt.substring(0, 50)}...` },
                    { key: 'R', label: 'Reasoning', value: `${reasoning.substring(0, 50)}...` },
                    { key: 'F', label: 'Diff for', value: selectedFile ? selectedFile.path : 'N/A' },
                    { key: 'A', label: 'All Diffs', value: `${files.length} files` },
                ];

                return (
                    <Box flexDirection="column">
                        <Text>Select item to copy to clipboard:</Text>
                        <Box marginTop={1} />
                        
                        {options.map((option, index) => (
                            <Text key={option.key} bold={index === copyModeSelectedIndex} color={index === copyModeSelectedIndex ? 'cyan' : undefined}>
                                {index === copyModeSelectedIndex ? '> ' : '  '}
                                [{option.key}] {option.label}: {option.value}
                            </Text>
                        ))}
                        
                        <Box marginTop={1} />
                        {copyModeLastCopied && (
                            <Text color="green">✓ Copied {copyModeLastCopied} to clipboard.</Text>
                        )}
                    </Box>
                );
            }

            if (bodyView === 'bulk_repair') {
                const failedFiles = files.filter(f => f.status === 'FAILED');
                
                return (
                    <Box flexDirection="column">
                        <Text>BULK REPAIR ACTION</Text>
                        <Box marginTop={1} />
                        
                        <Text>The following {failedFiles.length} files failed to apply:</Text>
                        {failedFiles.map(file => (
                            <Text key={file.id}>- {file.path}</Text>
                        ))}
                        
                        <Box marginTop={1} />
                        <Text>How would you like to proceed?</Text>
                        <Box marginTop={1} />
                        
                        <Text>{'> (1) Copy Bulk Re-apply Prompt (for single-shot AI)'}</Text>
                        <Text>  (2) Bulk Change Strategy & Re-apply</Text>
                        <Text>  (3) Handoff to External Agent</Text>
                        <Text>  (4) Bulk Abandon All Failed Files</Text>
                        <Text>  (Esc) Cancel</Text>
                    </Box>
                );
            }
            
            return null;
        };

        const renderApplyScreen = () => {
            const totalDuration = applySteps.reduce((acc, step) => acc + (step.duration || 0), 0);
            const failureCase = patchStatus === 'PARTIAL_FAILURE';
            const footerText = failureCase
                ? `Elapsed: ${totalDuration.toFixed(1)}s · Transitioning to repair workflow...`
                : `Elapsed: ${totalDuration.toFixed(1)}s · Processing... Please wait.`;

            return (
                <Box flexDirection="column">
                    <Text color="cyan">▲ relaycode apply</Text>
                    <Separator />
                    <Box marginY={1}>
                        <Text>Applying patch {hash}... ({message})</Text>
                        <Box flexDirection="column" marginTop={1} gap={1}>
                            {applySteps.map(step => <ApplyStepRow key={step.id} step={step} />)}
                        </Box>
                    </Box>
                    <Separator />
                    <Text>{footerText}</Text>
                </Box>
            );
        };

        const renderFooter = () => {
            // Contextual footer for body views
            if (bodyView === 'diff') {
                return <Text>(↑↓) Nav · (X)pand · (D/Esc) Back</Text>;
            }
            if (bodyView === 'reasoning') {
                return <Text>(↑↓) Scroll · (R/Esc) Back</Text>;
            }
            if (bodyView === 'script_output') {
                return (
                    <Text>(↑↓) Nav · (J↓/K↑) Next/Prev Error · (C)opy Output · (Ent/Esc) Back</Text>
                );
            }
            if (bodyView === 'copy_mode') {
                return <Text>(↑↓) Nav · (Enter) Copy Selected · (U,M,P,R,F,A) Hotkeys · (C, Esc) Exit</Text>;
            }
            if (bodyView === 'bulk_repair') {
                return <Text>Choose an option [1-4, Esc]:</Text>;
            }

            // Main footer
            const actions = ['(↑↓) Nav'];

            const isFileSelected = selectedItemIndex < numFiles;
            const hasFailedFiles = files.some(f => f.status === 'FAILED');
            
            if (isFileSelected) {
                const selectedFile = files[selectedItemIndex];
                if (selectedFile && selectedFile.status !== 'FAILED') {
                    actions.push('(Spc) Toggle');
                }
                actions.push('(D)iff');
                
                // Add repair options for failed files
                if (selectedFile && selectedFile.status === 'FAILED') {
                    actions.push('(T)ry Repair');
                }
            } else { // script selected
                actions.push('(Ent) Expand Details');
            }

            actions.push('(R)easoning');
            
            // Add bulk repair if there are failed files
            if (hasFailedFiles) {
                actions.push('(Shift+T) Bulk Repair');
            }
            
            actions.push('(C)opy');

            if (approvedFilesCount > 0) {
                actions.push('(A)pprove');
            }
            
            actions.push('(Esc) Reject All');
            actions.push('(Q)uit');

            return <Text>{actions.join(' · ')}</Text>;
        };

        if (applicationStatus === 'APPLYING') {
            return renderApplyScreen();
        }

        return (
            <Box flexDirection="column">
                {/* Header */}
                <Text color="cyan">▲ relaycode review{bodyView === 'copy_mode' ? ' · copy mode' : ''}</Text>
                <Separator />
                
                {/* Navigator Section */}
                <Box flexDirection="column">
                    {/* Transaction summary */}
                    <Box>
                        <Text>{hash} · {message}</Text>
                    </Box>
                    <Box>
                        <Text>(<Text color="green">+{linesAdded}</Text>/<Text color="red">-{linesRemoved}</Text>) · {approvedFilesCount}/{numFiles} Files · {duration}s</Text>
                        {patchStatus === 'PARTIAL_FAILURE' && <Text color="red" bold> · MULTIPLE PATCHES FAILED</Text>}
                        {scripts.length === 0 && patchStatus === 'PARTIAL_FAILURE' && <Text> · Scripts: SKIPPED</Text>}
                    </Box>
                    
                    <Box marginTop={1} />
                    
                    {/* Prompt and Reasoning */}
                    <Text>(P)rompt ▸ {prompt.substring(0, 50)}...</Text>
                    <Text>(R)easoning ({reasoning.split('\n\n').length} steps) {bodyView === 'reasoning' ? '▾' : '▸'}{' '}
                        {(reasoning.split('\n')[0] ?? '').substring(0, 50)}...
                    </Text>
                    
                    <Separator/>
                    
                    {/* Script Results (if any) */}
                    {scripts.length > 0 && (
                        <>
                            {scripts.map((script, index) => (
                                <ScriptItemRow 
                                    key={script.command} 
                                    script={script}
                                    isSelected={selectedItemIndex === numFiles + index}
                                    isExpanded={bodyView === 'script_output' && selectedItemIndex === numFiles + index}
                                />
                            ))}
                            <Separator/>
                        </>
                    )}
                    
                    {/* Files Section */}
                    <Text>FILES</Text>
                    {files.map((file, index) => (
                        <FileItemRow 
                            key={file.id} 
                            file={file} 
                            isSelected={selectedItemIndex === index}
                        />
                    ))}
                </Box>
                
                <Separator/>
                
                {/* Body Viewport */}
                {bodyView !== 'none' && (
                    <>
                        <Box marginY={1}>
                            {renderBody()}
                        </Box>
                        <Separator />
                    </>
                )}

                {/* Footer */}
                <Box>
                    {renderFooter()}
                </Box>
            </Box>
        );
    };


    export default ReviewScreen;
  src/stores/review.store.ts: >-
    import { create } from 'zustand';

    import { sleep } from '../utils';


    // --- Types ---


    export type FileStatus = 'FAILED' | 'APPROVED' | 'REJECTED';

    export interface FileItem {
        id: string;
        path: string;
        status: FileStatus;
        diff: string;
        linesAdded: number;
        linesRemoved: number;
        error?: string;
        strategy: 'replace' | 'standard-diff';
    }


    export interface ScriptResult {
        command: string;
        success: boolean;
        duration: number;
        summary: string;
        output: string;
    }


    export type ApplicationStatus = 'APPLYING' | 'REVIEWING';


    export interface ApplyStep {
        id: string;
        title: string;
        status: 'pending' | 'active' | 'done' | 'failed' | 'skipped';
        details?: string;
        substeps?: ApplyStep[];
        duration?: number;
    }


    const initialApplySteps: ApplyStep[] = [
        { id: 'snapshot', title: 'Reading initial file snapshot...', status: 'pending' },
        { id: 'memory', title: 'Applying operations to memory...', status: 'pending', substeps: [] },
        { id: 'post-command', title: 'Running post-command script...', status: 'pending', substeps: [] },
        { id: 'linter', title: 'Analyzing changes with linter...', status: 'pending', substeps: [] },
    ];


    export type BodyView = 'diff' | 'reasoning' | 'script_output' | 'copy_mode'
    | 'bulk_repair' | 'none';

    export type PatchStatus = 'SUCCESS' | 'PARTIAL_FAILURE';


    interface ReviewState {
        // Transaction Info
        hash: string;
        message: string;
        prompt: string;
        reasoning: string;
        linesAdded: number;
        linesRemoved: number;
        duration: number;
        patchStatus: PatchStatus;

        // File & Script Info
        files: FileItem[];
        scripts: ScriptResult[];

        // UI State
        applicationStatus: ApplicationStatus;
        applySteps: ApplyStep[];
        selectedItemIndex: number; // Can be file or script
        bodyView: BodyView;
        isDiffExpanded: boolean;
        
        // Copy Mode State
        copyModeSelectedIndex: number;
        copyModeLastCopied: string | null;
        
        // Reasoning Scroll State
        reasoningScrollIndex: number;
        
        // Script Navigation State
        scriptErrorIndex: number;

        actions: {
            moveSelectionUp: () => void;
            moveSelectionDown: () => void;
            toggleFileApproval: () => void;
            rejectAllFiles: () => void;
            toggleDiffView: () => void;
            toggleReasoningView: () => void;
            toggleScriptView: () => void;
            expandDiff: () => void;
            approve: () => void;
            simulateSuccessScenario: () => void;
            startApplySimulation: (scenario: 'success' | 'failure') => void;
            simulateFailureScenario: () => void;
            
            // Copy Mode Actions
            toggleCopyMode: () => void;
            moveCopySelectionUp: () => void;
            moveCopySelectionDown: () => void;
            copySelectedItem: () => void;
            copyUUID: () => void;
            copyMessage: () => void;
            copyPrompt: () => void;
            copyReasoning: () => void;
            copyFileDiff: () => void;
            copyAllDiffs: () => void;
            
            // Repair Actions
            tryRepairFile: () => void;
            showBulkRepair: () => void;
            executeBulkRepairOption: (option: number) => void;
            
            // Navigation Actions
            scrollReasoningUp: () => void;
            scrollReasoningDown: () => void;
            navigateScriptErrorUp: () => void;
            navigateScriptErrorDown: () => void,
        };
    }


    // --- Mock Data ---


    const mockFiles: FileItem[] = [
        { 
            id: '1', 
            path: 'src/core/transaction.ts', 
            status: 'APPROVED', 
            linesAdded: 18, 
            linesRemoved: 5, 
            diff: `--- a/src/core/transaction.ts
    +++ b/src/core/transaction.ts

    @@ -15,7 +15,7 @@ export class Transaction {
       }
     
    -  calculateChanges(): ChangeSet {

    +  computeDelta(): ChangeSet {
         return this.changes;
       }
     }`, 
            strategy: 'replace', 
        },
        { 
            id: '2', 
            path: 'src/utils/logger.ts', 
            status: 'FAILED', 
            linesAdded: 0, 
            linesRemoved: 0, 
            diff: '', 
            error: 'Hunk #1 failed to apply', 
            strategy: 'standard-diff', 
        },
        { 
            id: '3', 
            path: 'src/commands/apply.ts', 
            status: 'FAILED', 
            linesAdded: 0, 
            linesRemoved: 0, 
            diff: '', 
            error: 'Context mismatch at line 92', 
            strategy: 'standard-diff', 
        },
    ];


    const mockScripts: ScriptResult[] = [
        { command: 'bun run test', success: true, duration: 2.3, summary: 'Passed (37 tests)', output: '... test output ...' },
        { command: 'bun run lint', success: false, duration: 1.2, summary: '1 Error, 3 Warnings', output: `src/core/clipboard.ts
      45:12  Error    'clipboardy' is assigned a value but never used. (@typescript-eslint/no-unused-vars)
      88:5   Warning  Unexpected console statement. (no-console)` },
    ];


    const mockReasoning = `1. Identified a potential uncaught exception in the
    \`restoreSnapshot\` function
       if a file operation fails midway through a loop of many files. This could
       leave the project in a partially-reverted, inconsistent state.

    2. Wrapped the file restoration loop in a \`Promise.all\` and added a
    dedicated
       error collection array. This ensures that all file operations are
       attempted and that a comprehensive list of failures is available
       afterward for better error reporting or partial rollback logic.`;

    // --- Store Implementation ---


    export const useReviewStore = create<ReviewState>((set) => ({
        // Transaction Info
        hash: 'e4a7c112',
        message: 'refactor: rename core utility function',
        prompt: 'Rename the `calculateChanges` utility to `computeDelta` across all files and update imports accordingly.',
        reasoning: mockReasoning,
        linesAdded: 18,
        linesRemoved: 5,
        duration: 0.6,
        patchStatus: 'PARTIAL_FAILURE',

        // File & Script Info
        files: mockFiles,
        scripts: [], // Empty for partial failure scenario

        // UI State
        applicationStatus: 'REVIEWING',
        applySteps: initialApplySteps,
        selectedItemIndex: 0, // Start with first file
        bodyView: 'none',
        isDiffExpanded: false,
        
        // Copy Mode State
        copyModeSelectedIndex: 0,
        copyModeLastCopied: null,
        
        // Reasoning Scroll State
        reasoningScrollIndex: 0,
        
        // Script Navigation State
        scriptErrorIndex: 0,

        actions: {
            moveSelectionUp: () => set(state => ({
                selectedItemIndex: Math.max(0, state.selectedItemIndex - 1),
            })),
            moveSelectionDown: () => set(state => ({
                selectedItemIndex: Math.min(state.files.length + state.scripts.length - 1, state.selectedItemIndex + 1),
            })),
            toggleFileApproval: () => set(state => {
                const { selectedItemIndex, files } = state;
                if (selectedItemIndex >= files.length) return {}; // Not a file
                
                const newFiles = [...files];
                const file = newFiles[selectedItemIndex];
                if (file) {
                    if (file.status === 'APPROVED') {
                        file.status = 'REJECTED';
                    } else if (file.status === 'REJECTED') {
                        file.status = 'APPROVED';
                    }
                }
                return { files: newFiles };
            }),
            rejectAllFiles: () => set(state => {
                const newFiles = state.files.map(file => {
                    if (file.status === 'APPROVED') {
                        return { ...file, status: 'REJECTED' as const };
                    }
                    return file;
                });
                return { files: newFiles };
            }),
            toggleDiffView: () => set(state => {
                const { bodyView } = state;
                if (state.selectedItemIndex >= state.files.length) return {}; // Can't show diff for scripts
                return {
                    bodyView: bodyView === 'diff' ? 'none' : 'diff',
                    isDiffExpanded: false, // Always start collapsed
                };
            }),
            toggleReasoningView: () => set(state => {
                const { bodyView } = state;
                return {
                    bodyView: bodyView === 'reasoning' ? 'none' : 'reasoning',
                };
            }),
            toggleScriptView: () => set(state => {
                const { bodyView } = state;
                return {
                    bodyView: bodyView === 'script_output' ? 'none' : 'script_output',
                };
            }),
            expandDiff: () => set(state => ({ isDiffExpanded: !state.isDiffExpanded })),
            approve: () => { /* NOP for now, would trigger commit and screen change */ },
            startApplySimulation: async (scenario: 'success' | 'failure') => {
                set({ applicationStatus: 'APPLYING', applySteps: JSON.parse(JSON.stringify(initialApplySteps)) });
                
                const updateStep = (id: string, status: ApplyStep['status'], duration?: number, details?: string) => {
                    set(state => ({
                        applySteps: state.applySteps.map(s => {
                            if (s.id === id) {
                                const newStep = { ...s, status };
                                if (duration !== undefined) newStep.duration = duration;
                                if (details !== undefined) newStep.details = details;
                                return newStep;
                            }
                            return s;
                        }),
                    }));
                };
        
                const addSubstep = (parentId: string, substep: Omit<ApplyStep, 'substeps'>) => {
                     set(state => ({
                        applySteps: state.applySteps.map(s => {
                            if (s.id === parentId) {
                                const newSubsteps = [...(s.substeps || []), substep as ApplyStep];
                                return { ...s, substeps: newSubsteps };
                            }
                            return s;
                        }),
                    }));
                };
        
                if (scenario === 'success') {
                    useReviewStore.getState().actions.simulateSuccessScenario();
                    
                    updateStep('snapshot', 'active'); await sleep(100);
                    updateStep('snapshot', 'done', 0.1);
        
                    updateStep('memory', 'active'); await sleep(100);
                    addSubstep('memory', { id: 's1', title: '[✓] write: src/core/clipboard.ts (strategy: replace)', status: 'done' });
                    await sleep(100);
                    addSubstep('memory', { id: 's2', title: '[✓] write: src/utils/shell.ts (strategy: standard-diff)', status: 'done' });
                    updateStep('memory', 'done', 0.3);
        
                    updateStep('post-command', 'active'); await sleep(1300);
                    addSubstep('post-command', { id: 's3', title: '`bun run test` ... Passed', status: 'done' });
                    updateStep('post-command', 'done', 2.3);
        
                    updateStep('linter', 'active'); await sleep(1200);
                    addSubstep('linter', { id: 's4', title: '`bun run lint` ... 0 Errors', status: 'done' });
                    updateStep('linter', 'done', 1.2);
        
                    await sleep(500);
        
                } else { // failure scenario
                    useReviewStore.getState().actions.simulateFailureScenario();
                    
                    updateStep('snapshot', 'active'); await sleep(100);
                    updateStep('snapshot', 'done', 0.1);
        
                    updateStep('memory', 'active'); await sleep(100);
                    addSubstep('memory', { id: 'f1', title: '[✓] write: src/core/transaction.ts (strategy: replace)', status: 'done' });
                    await sleep(100);
                    addSubstep('memory', { id: 'f2', title: '[!] failed: src/utils/logger.ts (Hunk #1 failed to apply)', status: 'failed' });
                    await sleep(100);
                    addSubstep('memory', { id: 'f3', title: '[!] failed: src/commands/apply.ts (Context mismatch at line 92)', status: 'failed' });
                    updateStep('memory', 'done', 0.5);
        
                    await sleep(100);
                    updateStep('post-command', 'skipped', undefined, 'Skipped due to patch application failure');
                    await sleep(100);
                    updateStep('linter', 'skipped', undefined, 'Skipped due to patch application failure');
                    
                    await sleep(500);
                }
        
                set({ applicationStatus: 'REVIEWING' });
            },
            simulateSuccessScenario: () => set(() => ({
                hash: '4b9d8f03',
                message: 'refactor: simplify clipboard logic',
                prompt: 'Simplify the clipboard logic using an external library...',
                linesAdded: 22,
                linesRemoved: 11,
                duration: 3.9,
                patchStatus: 'SUCCESS' as const,
                files: [
                    { 
                        id: '1', 
                        path: 'src/core/clipboard.ts', 
                        status: 'APPROVED' as const, 
                        linesAdded: 15, 
                        linesRemoved: 8, 
                        diff: `--- a/src/core/clipboard.ts
    +++ b/src/core/clipboard.ts

    @@ -1,5 +1,6 @@
     import { copy as copyToClipboard } from 'clipboardy';`, 
                        strategy: 'replace' as const,
                    },
                    { 
                        id: '2', 
                        path: 'src/utils/shell.ts', 
                        status: 'APPROVED' as const, 
                        linesAdded: 7, 
                        linesRemoved: 3, 
                        diff: `--- a/src/utils/shell.ts
    +++ b/src/utils/shell.ts`, 
                        strategy: 'standard-diff' as const,
                    },
                ],
                scripts: mockScripts,
                selectedItemIndex: 0,
                bodyView: 'none' as const,
            })),
            simulateFailureScenario: () => set(() => ({
                hash: 'e4a7c112',
                message: 'refactor: rename core utility function',
                prompt: 'Rename the `calculateChanges` utility to `computeDelta` across all files and update imports accordingly.',
                linesAdded: 18,
                linesRemoved: 5,
                duration: 0.6,
                patchStatus: 'PARTIAL_FAILURE' as const,
                files: mockFiles,
                scripts: [],
                selectedItemIndex: 0,
                bodyView: 'none' as const,
            })),
            
            // Copy Mode Actions
            toggleCopyMode: () => set(state => ({
                bodyView: state.bodyView === 'copy_mode' ? 'none' : 'copy_mode',
                copyModeSelectedIndex: 0,
                copyModeLastCopied: null,
            })),
            moveCopySelectionUp: () => set(state => ({
                copyModeSelectedIndex: Math.max(0, state.copyModeSelectedIndex - 1),
            })),
            moveCopySelectionDown: () => set(state => ({
                copyModeSelectedIndex: Math.min(5, state.copyModeSelectedIndex + 1), // 6 total options (U,M,P,R,F,A)
            })),
            copySelectedItem: () => set(state => {
                const { copyModeSelectedIndex, hash, message, prompt, reasoning, files, selectedItemIndex } = state;
                let content = '';
                let label = '';
                
                switch (copyModeSelectedIndex) {
                    case 0: // UUID
                        content = `${hash}-a8b3-4f2c-9d1e-8a7c1b9d8f03`;
                        label = 'UUID';
                        break;
                    case 1: // Git Message
                        content = message;
                        label = 'Git Message';
                        break;
                    case 2: // Prompt
                        content = prompt;
                        label = 'Prompt';
                        break;
                    case 3: // Reasoning
                        content = reasoning;
                        label = 'Reasoning';
                        break;
                    case 4: // Diff for current file
                        if (selectedItemIndex < files.length) {
                            const file = files[selectedItemIndex];
                            if (file) {
                                content = file.diff;
                                label = `Diff for ${file.path}`;
                            }
                        }
                        break;
                    case 5: // All Diffs
                        content = files.map(f => `--- FILE: ${f.path} ---\n${f.diff}`).join('\n\n');
                        label = 'All Diffs';
                        break;
                }
                
                // Mock clipboard operation (TUI environment - no real clipboard)
                // eslint-disable-next-line no-console
                console.log(`[CLIPBOARD] Copied ${label}: ${content.substring(0, 100)}...`);
                
                return { copyModeLastCopied: label };
            }),
            copyUUID: () => set(state => {
                const content = `${state.hash}-a8b3-4f2c-9d1e-8a7c1b9d8f03`;
                // eslint-disable-next-line no-console
                console.log(`[CLIPBOARD] Copied UUID: ${content}`);
                return { copyModeLastCopied: 'UUID' };
            }),
            copyMessage: () => set(state => {
                // eslint-disable-next-line no-console
                console.log(`[CLIPBOARD] Copied Git Message: ${state.message}`);
                return { copyModeLastCopied: 'Git Message' };
            }),
            copyPrompt: () => set(state => {
                // eslint-disable-next-line no-console
                console.log(`[CLIPBOARD] Copied Prompt: ${state.prompt.substring(0, 100)}...`);
                return { copyModeLastCopied: 'Prompt' };
            }),
            copyReasoning: () => set(state => {
                // eslint-disable-next-line no-console
                console.log(`[CLIPBOARD] Copied Reasoning: ${state.reasoning.substring(0, 100)}...`);
                return { copyModeLastCopied: 'Reasoning' };
            }),
            copyFileDiff: () => set(state => {
                if (state.selectedItemIndex < state.files.length) {
                    const file = state.files[state.selectedItemIndex];
                    if (file) {
                        // eslint-disable-next-line no-console
                        console.log(`[CLIPBOARD] Copied diff for: ${file.path}`);
                        return { copyModeLastCopied: `Diff for ${file.path}` };
                    }
                }
                return {};
            }),
            copyAllDiffs: () => set(state => {
                const content = state.files.map(f => `--- FILE: ${f.path} ---\n${f.diff}`).join('\n\n');
                // eslint-disable-next-line no-console
                console.log(`[CLIPBOARD] Copied all diffs: ${state.files.length} files`);
                return { copyModeLastCopied: 'All Diffs' };
            }),
            
            // Repair Actions
            tryRepairFile: () => set(state => {
                const { selectedItemIndex, files } = state;
                if (selectedItemIndex < files.length) {
                    const file = files[selectedItemIndex];
                    if (file && file.status === 'FAILED') {
                        // Generate repair prompt and copy to clipboard
                        const repairPrompt = `The patch failed to apply to ${file.path}. Please generate a corrected patch.

    Error: ${file.error}

    Strategy: ${file.strategy}


    ORIGINAL CONTENT:

    ---

    // ... original file content would be here ...

    ---


    FAILED PATCH:

    ---

    ${file.diff || '// ... failed diff would be here ...'}

    ---


    Please provide a corrected patch that addresses the error.`;

                        // eslint-disable-next-line no-console
                        console.log(`[CLIPBOARD] Copied repair prompt for: ${file.path}`);

                        // Mock: Update file status to show it's being repaired
                        const newFiles = [...files];
                        newFiles[selectedItemIndex] = { ...file, status: 'APPROVED' as const, error: undefined, linesAdded: 5, linesRemoved: 2 };

                        return { files: newFiles, copyModeLastCopied: 'Repair prompt copied to clipboard' };
                    }
                }
                return {};
            }),
            showBulkRepair: () => set(() => ({
                bodyView: 'bulk_repair' as const,
            })),
            executeBulkRepairOption: (option: number) => set(state => {
                switch (option) {
                    case 1: {
                        // Copy Bulk Re-apply Prompt
                        const failedFiles = state.files.filter(f => f.status === 'FAILED');
                        const bulkPrompt = `The previous patch failed to apply to MULTIPLE files. Please generate a new, corrected patch that addresses all the files listed below.

    IMPORTANT: The response MUST contain a complete code block for EACH file
    that needs to be fixed.


    ${failedFiles.map(file => `--- FILE: ${file.path} ---

    Strategy: ${file.strategy}

    Error: ${file.error}


    ORIGINAL CONTENT:

    ---

    // ... original content of ${file.path} ...

    ---


    FAILED PATCH:

    ---

    ${file.diff || '// ... failed diff ...'}

    ---

    `).join('\n')}


    Please analyze all failed files and provide a complete, corrected
    response.`;

                        // eslint-disable-next-line no-console
                        console.log(`[CLIPBOARD] Copied bulk repair prompt for ${failedFiles.length} files`);
                        return { bodyView: 'none' as const, copyModeLastCopied: 'Bulk repair prompt copied' };
                    }
                        
                    case 2: {
                        // Bulk Change Strategy & Re-apply
                        // Mock: Change all failed files to 'replace' strategy and mark as successful
                        const newFiles = state.files.map(file => 
                            file.status === 'FAILED' 
                                ? { ...file, status: 'APPROVED' as const, strategy: 'replace' as const, error: undefined, linesAdded: 3, linesRemoved: 1 }
                                : file,
                        );
                        return { files: newFiles, bodyView: 'none' as const };
                    }
                        
                    case 3: {
                        // Handoff to External Agent
                        // Mock: Generate handoff prompt
                        const failedFiles = state.files.filter(f => f.status === 'FAILED');
                        const handoffPrompt = `# Relaycode Handoff: Failed Patch Application

    The following files failed to apply and require manual intervention:


    ${failedFiles.map(file => `## ${file.path}

    - Error: ${file.error}

    - Strategy: ${file.strategy}

    `).join('\n')}


    Please resolve these issues and provide updated patches.`;

                        // eslint-disable-next-line no-console
                        console.log(`[CLIPBOARD] Copied handoff prompt for ${failedFiles.length} files`);
                        return { bodyView: 'none' as const, copyModeLastCopied: 'Handoff prompt copied' };
                    }
                        
                    case 4: {
                        // Bulk Abandon All Failed Files
                        const abandonedFiles = state.files.map(file => 
                            file.status === 'FAILED' 
                                ? { ...file, status: 'REJECTED' as const }
                                : file,
                        );
                        return { files: abandonedFiles, bodyView: 'none' as const };
                    }
                        
                    default:
                        return { bodyView: 'none' as const };
                }
            }),
            
            // Navigation Actions
            scrollReasoningUp: () => set(state => ({
                reasoningScrollIndex: Math.max(0, state.reasoningScrollIndex - 1),
            })),
            scrollReasoningDown: () => set(state => {
                const maxLines = state.reasoning.split('\n').length;
                return { reasoningScrollIndex: Math.min(maxLines - 1, state.reasoningScrollIndex + 1) };
            }),
            navigateScriptErrorUp: () => set(state => ({
                scriptErrorIndex: Math.max(0, state.scriptErrorIndex - 1),
            })),
            navigateScriptErrorDown: () => set(state => {
                const selectedScript = state.scripts[state.selectedItemIndex - state.files.length];
                if (selectedScript && selectedScript.output) {
                    const errorLines = selectedScript.output.split('\n').filter(line => 
                        line.includes('Error') || line.includes('Warning'),
                    );
                    return { scriptErrorIndex: Math.min(errorLines.length - 1, state.scriptErrorIndex + 1) };
                }
                return {};
            }),
        },
    }));
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: '2025-09-22T00:48:19.789Z'
status: committed
id: 19
