uuid: c3277b5a-4638-4e38-963d-4c3e39b70d49
projectId: relaycode-tui
createdAt: '2025-09-24T15:04:20.690Z'
gitCommitMsg: >-
  refactor(types): remove vestigial type aliases and complete DRY refactor

  This commit completes the final phase of the DRY refactoring by cleaning up
  leftover code smells and ensuring type consistency.

  - Removed the `ReviewFileItem` and `FileChange` type aliases from
  `review.store.ts` and `transaction-history.store.ts`, respectively. These were
  remnants from before the type consolidation. - Updated
  `TransactionHistoryScreen.tsx` to import and use the canonical `FileItem` type
  directly from `domain.types.ts`. - Removed an obsolete `// TODO` comment from
  `review.store.ts`, as the associated refactoring was already complete.

  This ensures that all parts of the application now refer to the single,
  authoritative `FileItem` type, improving maintainability and reducing
  confusion.
promptSummary: >-
  The user asked to execute Part 4 of a refactoring plan, which involves
  cleaning up old type aliases and verifying the consistent use of new, unified
  data types across the application.
reasoning:
  - >-
    This is the final step of the refactoring plan, focusing on cleaning up
    remnants of old types and verifying that the new, consolidated data
    structures are used consistently throughout the application.
  - '### Part 4: Final Cleanup and Verification'
  - >-
    I will start by removing a lingering `// TODO` comment in `review.store.ts`,
    as the refactoring to prevent data duplication has already been completed in
    that store.
  - >-
    Next, I'll remove the `ReviewFileItem` type alias from `review.store.ts`.
    This alias is a leftover from before the types were unified. The
    application's components now correctly import and use the canonical
    `FileItem` type directly from `domain.types.ts`, making this alias obsolete.
  - >-
    Similarly, the `transaction-history.store.ts` file exports a `FileChange`
    alias for `FileItem`. I will remove this export to enforce the use of the
    canonical type.
  - >-
    Finally, I'll update `TransactionHistoryScreen.tsx` to use `FileItem`
    directly. This involves changing the import to source `FileItem` from
    `domain.types.ts` and updating the type annotation in the `FileRow`
    component, completing the cleanup.
  - >-
    With these changes, the codebase is now cleaner, more consistent, and free
    of the old, duplicative type definitions.
operations:
  - type: write
    path: src/stores/review.store.ts
    content: |+
      --- src/stores/review.store.ts
      +++ src/stores/review.store.ts
      @@ -7,8 +7,6 @@
       
       export type { FileItem as ReviewFileItem, ScriptResult, ApplyStep };
       
      -// TODO: Refactor this to not hold a copy of files/scripts.
       export const initialApplySteps: ApplyStep[] = [
           { id: 'snapshot', title: 'Reading initial file snapshot...', status: 'pending' },
           { id: 'memory', title: 'Applying operations to memory...', status: 'pending', substeps: [] },

    patchStrategy: standard-diff
  - type: write
    path: src/stores/review.store.ts
    content: |
      <<<<<<< SEARCH
      export type { FileItem as ReviewFileItem, ScriptResult, ApplyStep };
      =======
      export type { ScriptResult, ApplyStep };
      >>>>>>> REPLACE
    patchStrategy: search-replace
  - type: write
    path: src/stores/transaction-history.store.ts
    content: |+
      --- src/stores/transaction-history.store.ts
      +++ src/stores/transaction-history.store.ts
      @@ -4,8 +4,6 @@
       import type { HistoryViewMode } from '../types/view.types';
       import { useTransactionStore } from './transaction.store';
       
      -export type { FileItem as FileChange };
      - 
       // Omit 'actions' from state type for partial updates
       type HistoryStateData = Omit<TransactionHistoryState, 'actions'>;
       

    patchStrategy: standard-diff
  - type: write
    path: src/components/TransactionHistoryScreen.tsx
    content: >+
      --- src/components/TransactionHistoryScreen.tsx

      +++ src/components/TransactionHistoryScreen.tsx

      @@ -1,6 +1,5 @@
       import React from 'react';
       import { Box, Text } from 'ink';
       import TextInput from 'ink-text-input';
      -import { type FileChange } from '../stores/transaction-history.store';
       import Separator from './Separator';
       import type { Transaction, FileItem } from '../types/domain.types';
       import { useTransactionHistoryScreen } from '../hooks/useTransactionHistoryScreen';
      @@ -23,7 +22,7 @@
           );
       };
       
      -const FileRow = ({ file, isSelected, isExpanded }: { file: FileChange,
      isSelected: boolean, isExpanded: boolean }) => {

      +const FileRow = ({ file, isSelected, isExpanded }: { file: FileItem,
      isSelected: boolean, isExpanded: boolean }) => {
           const icon = isExpanded ? '▾' : '▸';
           const typeMap = { MOD: '[MOD]', ADD: '[ADD]', DEL: '[DEL]', REN: '[REN]' };
           

    patchStrategy: standard-diff
snapshot:
  src/stores/review.store.ts: >-
    import { create } from 'zustand';

    import { sleep } from '../utils';

    import { useAppStore } from './app.store';

    import { ReviewService } from '../services/review.service';

    import { useTransactionStore } from './transaction.store';

    import { moveIndex } from './navigation.utils';

    import type { FileItem, ScriptResult, FileReviewStatus } from
    '../types/domain.types';

    import type { ApplyStep, ReviewBodyView, PatchStatus, ApplyUpdate } from
    '../types/view.types';


    export type { FileItem as ReviewFileItem, ScriptResult, ApplyStep };


    // TODO: Refactor this to not hold a copy of files/scripts.

    export const initialApplySteps: ApplyStep[] = [
        { id: 'snapshot', title: 'Reading initial file snapshot...', status: 'pending' },
        { id: 'memory', title: 'Applying operations to memory...', status: 'pending', substeps: [] },
        { id: 'post-command', title: 'Running post-command script...', status: 'pending', substeps: [] },
        { id: 'linter', title: 'Analyzing changes with linter...', status: 'pending', substeps: [] },
    ];


    type FileReviewState = { status: FileReviewStatus; error?: string };


    interface ReviewState {
        // Transaction Info
        transactionId: string | null;
        patchStatus: PatchStatus;
        fileReviewStates: Record<string, FileReviewState>; // Keyed by FileItem ID

        // UI State
        applySteps: ApplyStep[];
        selectedItemIndex: number; // Can be file or script
        bodyView: ReviewBodyView;
        isDiffExpanded: boolean;

        // Reasoning Scroll State
        reasoningScrollIndex: number;

        // Script Navigation State
        scriptErrorIndex: number;

        actions: {
            moveSelectionUp: () => void;
            moveSelectionDown: () => void;
            toggleFileApproval: () => void;
            rejectAllFiles: () => void;
            expandDiff: () => void;
            toggleBodyView: (view: Extract<ReviewBodyView, 'diff' | 'reasoning' | 'script_output' | 'bulk_repair' | 'confirm_handoff'>) => void;
            setBodyView: (view: ReviewBodyView) => void;
            approve: () => void;
            startApplySimulation: (scenario: 'success' | 'failure') => void;

            // Repair Actions
            tryRepairFile: () => void;
            showBulkRepair: () => void;
            executeBulkRepairOption: (option: number) => Promise<void>;
            confirmHandoff: () => void;

            // Navigation Actions
            scrollReasoningUp: () => void;
            scrollReasoningDown: () => void;
            navigateScriptErrorUp: () => void;
            navigateScriptErrorDown: () => void;

            // "Private" actions for service layer
            load: (transactionId: string, initialState?: { bodyView: ReviewBodyView }) => void;
            _updateApplyStep: (id: string, status: ApplyStep['status'], duration?: number, details?: string) => void;
            _addApplySubstep: (parentId: string, substep: Omit<ApplyStep, 'substeps'>) => void;
        };
    }


    export const useReviewStore = create<ReviewState>((set, get) => ({
        // Transaction Info
        transactionId: null,
        patchStatus: 'SUCCESS', // This will be set on load
        fileReviewStates: {},
        
        // UI State
        applySteps: initialApplySteps,
        selectedItemIndex: 0,
        bodyView: 'none' as const,
        isDiffExpanded: false,

        // Reasoning Scroll State
        reasoningScrollIndex: 0,

        // Script Navigation State
        scriptErrorIndex: 0,

        actions: {
            moveSelectionUp: () => set(state => {
                const tx = useTransactionStore.getState().transactions.find(t => t.id === state.transactionId);
                if (!tx) return {};
                const listSize = (tx.files?.length || 0) + (tx.scripts?.length || 0);
                return { selectedItemIndex: moveIndex(state.selectedItemIndex, 'up', listSize) };
            }),
            moveSelectionDown: () => set(state => {
                const tx = useTransactionStore.getState().transactions.find(t => t.id === state.transactionId);
                if (!tx) return {};
                const listSize = (tx.files?.length || 0) + (tx.scripts?.length || 0);
                return { selectedItemIndex: moveIndex(state.selectedItemIndex, 'down', listSize) };
            }),
            toggleFileApproval: () => set(state => {
                const tx = useTransactionStore.getState().transactions.find(t => t.id === state.transactionId);
                const file = tx?.files?.[state.selectedItemIndex];
                if (!file) return {};

                const currentState = state.fileReviewStates[file.id];
                if (!currentState) return {};

                const newStatus = currentState.status === 'APPROVED' ? 'REJECTED' : 'APPROVED';

                return {
                    fileReviewStates: {
                        ...state.fileReviewStates,
                        [file.id]: { ...currentState, status: newStatus },
                    },
                };
            }),
            rejectAllFiles: () => set(state => {
                const newFileReviewStates = { ...state.fileReviewStates };
                const tx = useTransactionStore.getState().transactions.find(t => t.id === state.transactionId);
                tx?.files?.forEach(file => {
                    const current = newFileReviewStates[file.id];
                    if (current?.status === 'APPROVED') {
                        newFileReviewStates[file.id] = { ...current, status: 'REJECTED' };
                    }
                });
                return { fileReviewStates: newFileReviewStates };
            }),
            toggleBodyView: (view) => set(state => {
                const tx = useTransactionStore.getState().transactions.find(t => t.id === state.transactionId);
                const files = tx?.files || [];
                if (view === 'diff' && state.selectedItemIndex >= files.length) return {}; // Can't show diff for scripts
                return {
                    bodyView: state.bodyView === view ? 'none' : view,
                    isDiffExpanded: false, // Always start collapsed
                };
            }),
            setBodyView: (view) => set({ bodyView: view }),
            expandDiff: () => set(state => ({ isDiffExpanded: !state.isDiffExpanded })),
            approve: () => {
                const { transactionId } = get();
                if (transactionId) {
                    // In a real app, you'd persist the fileReviewStates back into the transaction
                    // For this simulation, we just mark the whole transaction.
                    useTransactionStore.getState().actions.updateTransactionStatus(transactionId, 'APPLIED');
                    // Navigate back to dashboard
                    useAppStore.getState().actions.showDashboardScreen();
                }
            },
            startApplySimulation: async (scenario: 'success' | 'failure') => {
                const { showReviewProcessingScreen, showReviewScreen } = useAppStore.getState().actions;
                const { _updateApplyStep, _addApplySubstep } = get().actions;

                set({ applySteps: JSON.parse(JSON.stringify(initialApplySteps)) });
                showReviewProcessingScreen();

                const simulationGenerator = ReviewService.runApplySimulation(scenario);
                for await (const update of simulationGenerator) {
                    switch (update.type) {
                        case 'UPDATE_STEP':
                            _updateApplyStep(update.payload.id, update.payload.status, update.payload.duration, update.payload.details);
                            break;
                        case 'ADD_SUBSTEP':
                            _addApplySubstep(update.payload.parentId, update.payload.substep);
                            break;
                    }
                }

                // This would now update file statuses based on the result of the apply
                // For now, just return to the screen
                showReviewScreen();
            },

            // Repair Actions
            tryRepairFile: () => {
                set(state => {
                    const tx = useTransactionStore.getState().transactions.find(t => t.id === state.transactionId);
                    const file = tx?.files?.[state.selectedItemIndex];
                    if (!file) return {};
                    
                    const currentReviewState = state.fileReviewStates[file.id];
                    if (currentReviewState?.status !== 'FAILED') return {};

                    // The service returns a new FileItem, but we only update the review state
                    // to avoid re-introducing a copy of the data. The UI for stats won't update.
                    const repairedFile = ReviewService.tryRepairFile(file);

                    return {
                        fileReviewStates: {
                            ...state.fileReviewStates,
                            [file.id]: { status: repairedFile.reviewStatus || 'AWAITING', error: undefined },
                        },
                    };
                });
            },
            showBulkRepair: () => get().actions.toggleBodyView('bulk_repair'),
            executeBulkRepairOption: async (option: number) => {
                const { transactionId } = get();
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!tx?.files) return;

                switch (option) {
                    case 1: { // Generate & Copy Bulk Repair Prompt
                        const bulkPrompt = ReviewService.generateBulkRepairPrompt(tx.files);
                        const failedFiles = tx.files.filter(f => f.reviewStatus === 'FAILED');
                        // eslint-disable-next-line no-console
                        console.log(`[CLIPBOARD] Copied bulk repair prompt for ${failedFiles.length} file(s).`);
                        set({ bodyView: 'none' as const });
                        break;
                    }

                    case 2: { // Attempt Bulk Re-apply
                        set({ bodyView: 'none' as const });

                        const failedFileIds = new Set(tx.files.filter(f => f.reviewStatus === 'FAILED').map(f => f.id));
                        if (failedFileIds.size === 0) break;

                        // Set intermediate state
                        set(state => {
                            const newStates = { ...state.fileReviewStates };
                            failedFileIds.forEach(id => {
                                if (newStates[id]) newStates[id]!.status = 'RE_APPLYING';
                            });
                            return { fileReviewStates: newStates };
                        });

                        // The service takes files, but returns updated files. We need to merge this back.
                        const finalFiles = await ReviewService.runBulkReapply(tx.files);
                        set(state => {
                            const newStates = { ...state.fileReviewStates };
                            finalFiles.forEach(file => {
                                if (newStates[file.id]) {
                                    newStates[file.id] = {
                                        status: file.reviewStatus || 'AWAITING',
                                        error: file.reviewError,
                                    };
                                }
                            });
                            return { fileReviewStates: newStates };
                        });
                        break;
                    }

                    case 3: { // Handoff to Human
                        get().actions.setBodyView('confirm_handoff');
                        break;
                    }

                    case 4: { // Reject All Failed
                        set(state => {
                            const newStates = { ...state.fileReviewStates };
                            Object.keys(newStates).forEach(fileId => {
                                if (newStates[fileId]?.status === 'FAILED') {
                                    newStates[fileId]!.status = 'REJECTED';
                                }
                            });
                            return { fileReviewStates: newStates, bodyView: 'none' as const };
                        });
                        break;
                    }

                    default: // Close modal
                        set({ bodyView: 'none' as const });
                }
            },
            confirmHandoff: () => {
                const { transactionId } = get();
                const transaction = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!transaction?.files) return;

                const handoffPrompt = ReviewService.generateHandoffPrompt(transaction.hash, transaction.message, transaction.reasoning || '', transaction.files);

                // eslint-disable-next-line no-console
                console.log('[CLIPBOARD] Copied Handoff Prompt.'); // In real app: clipboardy.writeSync(handoffPrompt)
                ReviewService.performHandoff(transaction.hash);
            },

            // Navigation Actions
            scrollReasoningUp: () => set(state => ({
                reasoningScrollIndex: Math.max(0, state.reasoningScrollIndex - 1),
            })),
            scrollReasoningDown: () => set(state => {
                const { transactionId } = state;
                if (!transactionId) return {};

                const transaction = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!transaction?.reasoning) return {};

                const maxLines = transaction.reasoning.split('\n').length;
                return { reasoningScrollIndex: Math.min(maxLines - 1, state.reasoningScrollIndex + 1) };
            }),
            navigateScriptErrorUp: () => set(state => ({
                scriptErrorIndex: Math.max(0, state.scriptErrorIndex - 1),
            })),
            navigateScriptErrorDown: () => set(state => {
                const tx = useTransactionStore.getState().transactions.find(t => t.id === state.transactionId);
                if (!tx?.scripts || !tx?.files) return {};

                const selectedScript = tx.scripts[state.selectedItemIndex - tx.files.length];
                if (selectedScript?.output) {
                    const errorLines = selectedScript.output.split('\n').filter(line =>
                        line.includes('Error') || line.includes('Warning'),
                    );
                    return { scriptErrorIndex: Math.min(errorLines.length - 1, state.scriptErrorIndex + 1) };
                }
                return {};
            }),

            // "Private" actions for service layer
            load: (transactionId, initialState) => {
                const transaction = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!transaction) return;

                // This simulates the backend determining which files failed or succeeded.
                // For this demo, tx '1' is the failure case, any other is success.
                const isFailureCase = transaction.id === '1';
                const patchStatus = isFailureCase ? 'PARTIAL_FAILURE' : ('SUCCESS' as PatchStatus);

                const newFileReviewStates: Record<string, FileReviewState> = {};
                (transaction.files || []).forEach((file, index) => {
                    if (isFailureCase) {
                        const isFailedFile = index > 0;
                        newFileReviewStates[file.id] = {
                            status: isFailedFile ? 'FAILED' : 'APPROVED',
                            error: isFailedFile ? (index === 1 ? 'Hunk #1 failed to apply' : 'Context mismatch at line 92') : undefined,
                        };
                    } else {
                        newFileReviewStates[file.id] = { status: 'APPROVED' };
                    }
                });

                set({
                    transactionId: transaction.id,
                    patchStatus,
                    fileReviewStates: newFileReviewStates,
                    selectedItemIndex: 0,
                    bodyView: initialState?.bodyView ?? 'none',
                    isDiffExpanded: false,
                    reasoningScrollIndex: 0,
                    scriptErrorIndex: 0,
                    applySteps: JSON.parse(JSON.stringify(initialApplySteps)), // Reset apply steps
                });
            },
            _updateApplyStep: (id, status, duration, details) => {
                set(state => ({
                    applySteps: state.applySteps.map(s => {
                        if (s.id === id) {
                            const newStep = { ...s, status };
                            if (duration !== undefined) newStep.duration = duration;
                            if (details !== undefined) newStep.details = details;
                            return newStep;
                        }
                        return s;
                    }),
                }));
            },
            _addApplySubstep: (parentId, substep) => {
                 set(state => ({
                    applySteps: state.applySteps.map(s => {
                        if (s.id === parentId) {
                            const newSubsteps = [...(s.substeps || []), substep as ApplyStep];
                            return { ...s, substeps: newSubsteps };
                        }
                        return s;
                    }),
                }));
            },
        },
    }));
  src/stores/transaction-history.store.ts: >-
    import { create } from 'zustand';

    import type { Transaction, FileItem } from '../types/domain.types';

    import type { HistoryViewMode } from '../types/view.types';

    import { useTransactionStore } from './transaction.store';


    export type { FileItem as FileChange };
     
    // Omit 'actions' from state type for partial updates

    type HistoryStateData = Omit<TransactionHistoryState, 'actions'>;


    interface TransactionHistoryState {
        mode: HistoryViewMode;
        selectedItemPath: string; // e.g. "tx-1" or "tx-1/file-2"
        expandedIds: Set<string>; // holds ids of expanded items
        filterQuery: string;
        selectedForAction: Set<string>; // set of transaction IDs

        actions: {
            load: (initialState?: Partial<HistoryStateData>) => void;
            navigateDown: () => void;
            navigateUp: () => void;
            expandOrDrillDown: () => void;
            collapseOrBubbleUp: () => void;
            toggleSelection: () => void;
            setMode: (mode: HistoryViewMode) => void;
            setFilterQuery: (query: string) => void;
            applyFilter: () => void;
            prepareDebugState: (stateName: 'l1-drill' | 'l2-drill' | 'filter' | 'copy' | 'bulk') => void;
        }
    }


    export const getVisibleItemPaths = (transactions: Transaction[],
    expandedIds: Set<string>): string[] => {
        const paths: string[] = [];
        for (const tx of transactions) {
            paths.push(tx.id);
            if (expandedIds.has(tx.id) && tx.files) {
                for (const file of tx.files) {
                    paths.push(`${tx.id}/${file.id}`);
                }
            }
        }
        return paths;
    };


    // --- Store ---

    export const useTransactionHistoryStore =
    create<TransactionHistoryState>((set, get) => ({
        mode: 'LIST',
        selectedItemPath: '',
        expandedIds: new Set(),
        filterQuery: '',
        selectedForAction: new Set(),

        actions: {
            load: (initialState) => {
                const { transactions } = useTransactionStore.getState();
                set({
                    selectedItemPath: transactions[0]?.id || '',
                    mode: 'LIST',
                    expandedIds: new Set(),
                    selectedForAction: new Set(),
                    filterQuery: '',
                    ...initialState,
                });
            },
            navigateUp: () => {
                const { expandedIds, selectedItemPath } = get();
                const { transactions } = useTransactionStore.getState();
                const visibleItems = getVisibleItemPaths(transactions, expandedIds);
                const currentIndex = visibleItems.indexOf(selectedItemPath);
                if (currentIndex > 0) {
                    set({ selectedItemPath: visibleItems[currentIndex - 1]! });
                }
            },
            navigateDown: () => {
                const { expandedIds, selectedItemPath } = get();
                const { transactions } = useTransactionStore.getState();
                const visibleItems = getVisibleItemPaths(transactions, expandedIds);
                const currentIndex = visibleItems.indexOf(selectedItemPath);
                if (currentIndex < visibleItems.length - 1) {
                    set({ selectedItemPath: visibleItems[currentIndex + 1]! });
                }
            },
            expandOrDrillDown: () => set(state => {
                const { selectedItemPath, expandedIds } = state;
                const newExpandedIds = new Set(expandedIds);
                if (!newExpandedIds.has(selectedItemPath)) {
                    newExpandedIds.add(selectedItemPath);
                }
                return { expandedIds: newExpandedIds };
            }),
            collapseOrBubbleUp: () => set(state => {
                const { selectedItemPath, expandedIds } = state;
                const newExpandedIds = new Set(expandedIds);
                if (newExpandedIds.has(selectedItemPath)) {
                    // If it's expanded, collapse it
                    newExpandedIds.delete(selectedItemPath);
                    
                    // Also collapse children
                    for (const id of newExpandedIds) {
                        if (id.startsWith(`${selectedItemPath}/`)) {
                            newExpandedIds.delete(id);
                        }
                    }

                    return { expandedIds: newExpandedIds };
                } else if (selectedItemPath.includes('/')) {
                    // If it's a file, move selection to parent transaction
                    const parentId = selectedItemPath.split('/')[0];
                    return { selectedItemPath: parentId || '' };
                }
                return {};
            }),
            toggleSelection: () => set(state => {
                const { selectedItemPath, selectedForAction } = state;
                const txId = selectedItemPath.split('/')[0];
                if (!txId) return {};

                const newSelection = new Set(selectedForAction);
                if (newSelection.has(txId)) {
                    newSelection.delete(txId);
                } else {
                    newSelection.add(txId);
                }
                return { selectedForAction: newSelection };
            }),
            setMode: (mode) => set({ mode }),
            setFilterQuery: (query) => set({ filterQuery: query }),
            applyFilter: () => {
                // In a real app, this would filter `transactions`.
                // For the demo, we just go back to LIST mode.
                set({ mode: 'LIST' });
            },
            prepareDebugState: (stateName) => {
                switch (stateName) {
                    case 'l1-drill':
                        get().actions.load({ expandedIds: new Set(['3']), selectedItemPath: '3' });
                        break;
                    case 'l2-drill':
                        get().actions.load({ expandedIds: new Set(['3', '3-1']), selectedItemPath: '3-1' });
                        break;
                    case 'filter':
                        get().actions.load({ mode: 'FILTER', filterQuery: 'logger.ts status:committed' });
                        break;
                    case 'copy':
                        get().actions.load({
                            selectedForAction: new Set(['3', '6']),
                        });
                        break;
                    case 'bulk':
                        get().actions.load({ mode: 'BULK_ACTIONS', selectedForAction: new Set(['3', '6']) });
                        break;
                }
            },
        },
    }));
  src/components/TransactionHistoryScreen.tsx: >-
    import React from 'react';

    import { Box, Text } from 'ink';

    import TextInput from 'ink-text-input';

    import { type FileChange } from '../stores/transaction-history.store';

    import Separator from './Separator';

    import type { Transaction, FileItem } from '../types/domain.types';

    import { useTransactionHistoryScreen } from
    '../hooks/useTransactionHistoryScreen';


    // --- Sub-components ---


    const DiffPreview = ({ diff }: { diff: string }) => {
        const lines = diff.split('\n');
        const previewLines = lines.slice(0, 5);
        const hiddenLines = lines.length > 5 ? lines.length - 5 : 0;

        return (
            <Box flexDirection="column" paddingLeft={8}>
                {previewLines.map((line, i) => {
                    let color = 'white';
                    if (line.startsWith('+')) color = 'green';
                    if (line.startsWith('-')) color = 'red';
                    if (line.startsWith('@@')) color = 'cyan';
                    return <Text key={i} color={color}>{line}</Text>;
                })}
                {hiddenLines > 0 && <Text color="gray">... {hiddenLines} lines hidden ...</Text>}
            </Box>
        );
    };


    const FileRow = ({ file, isSelected, isExpanded }: { file: FileChange,
    isSelected: boolean, isExpanded: boolean }) => {
        const icon = isExpanded ? '▾' : '▸';
        const typeMap = { MOD: '[MOD]', ADD: '[ADD]', DEL: '[DEL]', REN: '[REN]' };
        
        return (
            <Box flexDirection="column" paddingLeft={6}>
                <Text color={isSelected ? 'cyan' : undefined}>
                    {isSelected ? '> ' : '  '}
                    {icon} {typeMap[file.type]} {file.path}
                </Text>
                {isExpanded && <DiffPreview diff={file.diff} />}
            </Box>
        );
    };


    const TransactionRow = ({
        tx,
        isSelected,
        isExpanded,
        isSelectedForAction,
    }: {
        tx: Transaction,
        isSelected: boolean,
        isExpanded: boolean,
        isSelectedForAction: boolean,
    }) => {
        const icon = isExpanded ? '▾' : '▸';
        const statusMap = {
            COMMITTED: <Text color="green">✓ Committed</Text>,
            HANDOFF: <Text color="magenta">→ Handoff</Text>,
            REVERTED: <Text color="gray">↩ Reverted</Text>,
        };
        const date = new Date(tx.timestamp).toISOString().split('T')[0];
        const selectionIndicator = isSelectedForAction ? '[x]' : '[ ]';
        
        const statusDisplay = statusMap[tx.status as keyof typeof statusMap] || tx.status;

        return (
            <Box flexDirection="column" marginBottom={isExpanded ? 1 : 0}>
                <Text color={isSelected ? 'cyan' : undefined}>
                    {isSelected ? '> ' : '  '}
                    {selectionIndicator} {icon} {statusDisplay} · {tx.hash} · {date} ·{' '}
                    {tx.message}
                </Text>
                {isExpanded && (
                    <Box flexDirection="column" paddingLeft={8}>
                        {tx.stats && (
                            <Text color="gray">
                                Stats: {tx.stats.files} files, +{tx.stats.linesAdded}/-{tx.stats.linesRemoved}
                            </Text>
                        )}
                        <Text>Files:</Text>
                    </Box>
                )}
            </Box>
        );
    };


    const BulkActionsMode = ({ selectedForActionCount }: {
    selectedForActionCount: number }) => {
        return (
            <Box flexDirection="column" marginY={1}>
                <Text bold color="yellow">PERFORM BULK ACTION ON {selectedForActionCount} SELECTED ITEMS</Text>
                <Box marginY={1}>
                    <Text>This action is often irreversible. Are you sure?</Text>
                </Box>
                <Text>(1) Revert Selected Transactions</Text>
                <Text>(2) Mark as &apos;Git Committed&apos;</Text>
                <Text>(3) Delete Selected Transactions (from Relaycode history)</Text>
                <Text>(Esc) Cancel</Text>
            </Box>
        );
    };


    // --- Main Component ---


    const TransactionHistoryScreen = () => {
        const {
            store,
            transactions,
            itemsInView,
            transactionsInView,
            pathsInViewSet,
            filterStatus,
            showingStatus,
        } = useTransactionHistoryScreen();

        const renderFooter = () => {
            if (store.mode === 'FILTER') return <Text>(Enter) Apply Filter & Return      (Esc) Cancel</Text>; 
            if (store.mode === 'BULK_ACTIONS') return <Text>Choose an option [1-3, Esc]:</Text>;
            
            const actions = ['(↑↓) Nav', '(→) Expand', '(←) Collapse', '(Spc) Select', '(Ent) Details', '(F)ilter'];
            if (store.selectedForAction.size > 0) {
                actions.push('(C)opy', '(B)ulk');
            }
            return <Text>{actions.join(' · ')}</Text>;
        };

        return (
            <Box flexDirection="column">
                <Text color="cyan">▲ relaycode transaction history</Text>
                <Separator />

                <Box>
                    <Text>Filter: </Text>
                    {store.mode === 'FILTER' ? (
                        <TextInput value={store.filterQuery} onChange={store.actions.setFilterQuery} />
                    ) : (
                        <Text>{filterStatus}</Text>
                    )}
                    <Text> · {showingStatus} ({transactions.length} txns)</Text>
                </Box>

                <Box flexDirection="column" marginY={1}>
                    {store.mode === 'BULK_ACTIONS' && <BulkActionsMode selectedForActionCount={store.selectedForAction.size} />}

                    {store.mode === 'LIST' && transactions.map((tx: Transaction) => {
                        const isTxSelected = store.selectedItemPath.startsWith(tx.id);
                        const isTxExpanded = store.expandedIds.has(tx.id);
                        const isSelectedForAction = store.selectedForAction.has(tx.id);

                        const showTxRow = pathsInViewSet.has(tx.id);

                        return (
                            <Box flexDirection="column" key={tx.id}>
                                {showTxRow && (
                                    <TransactionRow
                                        tx={tx}
                                        isSelected={isTxSelected && !store.selectedItemPath.includes('/')}
                                        isExpanded={isTxExpanded}
                                        isSelectedForAction={isSelectedForAction}
                                    />
                                )}
                                {isTxExpanded && tx.files?.map((file: FileItem) => {
                                    if (!pathsInViewSet.has(`${tx.id}/${file.id}`)) return null;
                                    const filePath = `${tx.id}/${file.id}`;
                                    const isFileSelected = store.selectedItemPath === filePath;
                                    const isFileExpanded = store.expandedIds.has(filePath);
                                    return (
                                        <FileRow
                                            key={file.id}
                                            file={file}
                                            isSelected={isFileSelected}
                                            isExpanded={isFileExpanded}
                                        />
                                    );
                                })}
                            </Box>
                        );
                    })}
                </Box>

                <Separator />
                {renderFooter()}
            </Box>
        );
    };


    export default TransactionHistoryScreen;
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 86
