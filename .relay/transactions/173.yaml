uuid: c32c9103-67c9-4676-96a1-a62174d8122d
projectId: relaycode-tui
createdAt: '2025-09-26T01:34:34.514Z'
gitCommitMsg: >-
  refactor(review): guarantee data consistency in simulation flow


  Refactors the patch application simulation to ensure data integrity between
  the processing and review screens.


  - The `ReviewService.runApplySimulation` async generator now returns a
  definitive `SimulationResult` object, making it the single source of truth for
  the outcome. The now-redundant `prepareTransactionForReview` is removed.

  - The `review.store`'s `startApplySimulation` action now orchestrates the
  entire lifecycle: it initiates the simulation, processes its UI updates,
  consumes the final `SimulationResult` to set the store's state, and then
  transitions to the review screen.

  - The `load` action is updated to preserve debug screen functionality.

  - The `useReviewScreen` hook is updated to align its debug hotkeys with the
  new action signature.
promptSummary: >-
  The user requested to refactor the review simulation flow to ensure data
  consistency between the processing screen and the review screen. This involved
  making the simulation service produce a final result, having the store consume
  that result to set state, and updating UI hooks to match.
reasoning:
  - >-
    Excellent, I will execute the refactoring plan to ensure data consistency
    across the asynchronous review and processing flow. This involves modifying
    the simulation service to produce a definitive result, updating the data
    store to orchestrate this new flow, and aligning the UI hooks with the
    updated store actions.
  - '### Part 1: Enhance Simulation Service'
  - >-
    First, I will refactor `review.service.ts`. The `runApplySimulation`
    function will now be responsible for determining the final state of the
    files. It will accept the list of files to process and, upon completion,
    will return a `SimulationResult` object containing the final `patchStatus`
    and `fileReviewStates`. The now-redundant `prepareTransactionForReview`
    function will be removed.
  - '### Part 2: Refactor the Review Store'
  - >-
    Next, I'll update `review.store.ts`. The `startApplySimulation` action will
    now manage the entire flow: it will invoke the simulation, consume the
    `SimulationResult`, and update the store state before transitioning to the
    `ReviewScreen`. The `load` action is also adjusted to preserve the
    functionality of debug screens that jump directly to a pre-populated review
    state.
  - '### Part 3: Update UI Hooks'
  - >-
    Finally, I'll update the debug hotkeys in `useReviewScreen.tsx` to pass the
    transaction ID to the newly refactored `startApplySimulation` action,
    ensuring the demo functionality remains intact.
  - >-
    These changes complete the refactoring, establishing a clear and consistent
    data flow from the processing simulation to the final review screen.
  - '---'
operations:
  - type: write
    path: src/services/review.service.ts
    content: >
      --- src/services/review.service.ts

      +++ src/services/review.service.ts

      @@ -1,8 +1,14 @@
       import { useTransactionStore } from '../stores/transaction.store';
       import { useAppStore } from '../stores/app.store';
       import { sleep } from '../utils';
      -import type { ApplyUpdate, PatchStatus } from '../stores/review.store';

      +import type { ApplyUpdate, PatchStatus } from '../stores/review.store';
       import type { Transaction, FileItem, FileReviewStatus } from '../types/domain.types';
      +

      +export interface SimulationResult {

      +    patchStatus: PatchStatus;

      +    fileReviewStates: Map<string, { status: FileReviewStatus; error?:
      string }>;

      +}
       
       const mockSuccessFiles = [
           'src/components/Button.tsx',
      @@ -107,13 +113,20 @@
           useAppStore.getState().actions.showDashboardScreen();
       };
       
      -async function* runApplySimulation(scenario: 'success' | 'failure'):
      AsyncGenerator<ApplyUpdate> {

      +async function* runApplySimulation(

      +    files: FileItem[],

      +    scenario: 'success' | 'failure',

      +): AsyncGenerator<ApplyUpdate, SimulationResult> {
           if (scenario === 'success') {
               yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'active' } }; await sleep(100);
               yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'done', duration: 0.1 } };
       
               yield { type: 'UPDATE_STEP', payload: { id: 'memory', status: 'active' } }; await sleep(100);
      -        yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory',
      substep: { id: 's1', title: 'write: src/core/clipboard.ts (strategy:
      replace)', status: 'pending' } } };

      -        yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory',
      substep: { id: 's2', title: 'write: src/utils/shell.ts (strategy:
      standard-diff)', status: 'pending' } } };

      +        if (files.length > 0) {

      +            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory',
      substep: { id: 's1', title: `write: ${files[0]!.path} (strategy:
      replace)`, status: 'pending' } } };

      +        }

      +        if (files.length > 1) {

      +            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory',
      substep: { id: 's2', title: `write: ${files[1]!.path} (strategy:
      standard-diff)`, status: 'pending' } } };

      +        }
               await sleep(50);
               yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'memory', substepId: 's1', status: 'active' } };
               yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'memory', substepId: 's2', status: 'active' } };
      @@ -142,14 +155,23 @@
               yield { type: 'UPDATE_STEP', payload: { id: 'linter', status: 'done', duration: 1.2 } };
       
               await sleep(500);
      +

      +        const fileReviewStates = new Map<string, { status:
      FileReviewStatus }>();

      +        files.forEach(file => {

      +            fileReviewStates.set(file.id, { status: 'APPROVED' });

      +        });

      +

      +        return { patchStatus: 'SUCCESS', fileReviewStates };
       
           } else { // failure scenario
               yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'active' } }; await sleep(100);
               yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'done', duration: 0.1 } };
       
               yield { type: 'UPDATE_STEP', payload: { id: 'memory', status: 'active' } }; await sleep(100);
      -        yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory',
      substep: { id: 'f1', title: 'write: src/core/transaction.ts (strategy:
      replace)', status: 'pending' } } };

      -        yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory',
      substep: { id: 'f2', title: 'write: src/utils/logger.ts', status:
      'pending' } } };

      -        yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory',
      substep: { id: 'f3', title: 'write: src/commands/apply.ts', status:
      'pending' } } };

      +        if (files.length > 0) {

      +            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory',
      substep: { id: 'f1', title: `write: ${files[0]!.path} (strategy:
      replace)`, status: 'pending' } } };

      +        }

      +        yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory',
      substep: { id: 'f2', title: `write: ${(files[1] || { path: '...'
      }).path}`, status: 'pending' } } };

      +        yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory',
      substep: { id: 'f3', title: `write: ${(files[2] || { path: '...'
      }).path}`, status: 'pending' } } };
               await sleep(50);
               yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'memory', substepId: 'f1', status: 'active' } };
               yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'memory', substepId: 'f2', status: 'active' } };
      @@ -165,9 +187,9 @@
               await sleep(150);
               yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'memory', substepId: 'f1', status: 'done' } };
               await sleep(100);
      -        yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'memory',
      substepId: 'f2', status: 'failed', title: 'src/utils/logger.ts (Hunk #1
      failed to apply)' } };

      -        await sleep(100);

      -        yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'memory',
      substepId: 'f3', status: 'failed', title: 'src/commands/apply.ts (Context
      mismatch at line 92)' } };

      +        yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'memory',
      substepId: 'f2', status: 'failed', title: `${(files[1] || { path: '...'
      }).path} (Hunk #1 failed to apply)` } };

      +        await sleep(100);

      +        yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'memory',
      substepId: 'f3', status: 'failed', title: `${(files[2] || { path: '...'
      }).path} (Context mismatch at line 92)` } };
               for (let i = 0; i < mockFailureFiles.length; i++) {
                   const file = mockFailureFiles[i]!;
                   const shouldFail = i % 4 === 0 || i === mockFailureFiles.length - 1; // fail a few, including the last one
      @@ -182,41 +204,19 @@
               yield { type: 'UPDATE_STEP', payload: { id: 'linter', status: 'skipped', details: 'Skipped due to patch application failure' } };
       
               await sleep(500);
      +

      +        const fileReviewStates = new Map<string, { status:
      FileReviewStatus; error?: string }>();

      +        files.forEach((file, index) => {

      +            const isFailedFile = index > 0; // Fail all but the first
      file

      +            const status = isFailedFile ? 'FAILED' : 'APPROVED';

      +            const error = isFailedFile ? (index === 1 ? 'Hunk #1 failed
      to apply' : 'Context mismatch at line 92') : undefined;

      +            fileReviewStates.set(file.id, { status, error });

      +        });

      +

      +        return { patchStatus: 'PARTIAL_FAILURE', fileReviewStates };
           }
       }
       
      -const prepareTransactionForReview = (

      -    transaction: Transaction,

      -): {

      -    patchStatus: PatchStatus;

      -    fileReviewStates: Map<string, { status: FileReviewStatus; error?:
      string }>;

      -} => {

      -    // This simulates the backend determining which files failed or
      succeeded and sets it ONCE on load.

      -    // For this demo, tx '1' is the failure case, any other is success.

      -    const isFailureCase = transaction.id === '1';

      -    const fileReviewStates = new Map<string, { status: FileReviewStatus;
      error?: string }>();

      -

      -    (transaction.files || []).forEach((file, index) => {

      -        if (isFailureCase) {

      -            const isFailedFile = index > 0;

      -            const status = isFailedFile ? 'FAILED' : 'APPROVED';

      -            const error = isFailedFile ? (index === 1 ? 'Hunk #1 failed
      to apply' : 'Context mismatch at line 92') : undefined;

      -            fileReviewStates.set(file.id, { status, error });

      -        } else {

      -            fileReviewStates.set(file.id, { status: 'APPROVED' });

      -        }

      -    });

      -    return { patchStatus: isFailureCase ? 'PARTIAL_FAILURE' : 'SUCCESS',
      fileReviewStates };

      -};

      -
       const generateSingleFileRepairPrompt = (file: FileItem, error?: string): string => {
           return `The patch failed to apply to ${file.path}. Please generate a corrected patch.
       
      @@ -282,7 +282,6 @@
       };
       
       export const ReviewService = {
      -    prepareTransactionForReview,
           generateBulkRepairPrompt,
           generateBulkInstructPrompt,
           generateHandoffPrompt,
    patchStrategy: standard-diff
  - type: write
    path: src/stores/review.store.ts
    content: >
      --- src/stores/review.store.ts

      +++ src/stores/review.store.ts

      @@ -1,10 +1,10 @@
       import { create } from 'zustand';
       import { useAppStore } from './app.store';
       import { useTransactionStore } from './transaction.store';
       import { useViewStore } from './view.store';
      -import { ReviewService } from '../services/review.service';

      +import { ReviewService, type SimulationResult } from
      '../services/review.service';
       import { INITIAL_APPLY_STEPS, PATCH_STATUS, REVIEW_BODY_VIEWS } from '../constants/review.constants';
       import { moveIndex } from './navigation.utils';
       import { sleep } from '../utils';
       import type { FileReviewStatus } from '../types/domain.types';
       
       export interface ApplyStep {
      @@ -47,7 +47,7 @@
               >) => void;
               setBodyView: (view: ReviewBodyView) => void;
               approve: () => void;
      -        startApplySimulation: (scenario: 'success' | 'failure') => void;

      +        startApplySimulation: (transactionId: string, scenario: 'success'
      | 'failure') => void;
               tryRepairFile: (fileId: string) => void;
               showBulkRepair: () => void;
               executeBulkRepairOption: (option: number) => Promise<void>;
      @@ -83,9 +83,23 @@
               load: (transactionId, initialState) => {
                   const transaction = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                   if (!transaction) return;
      -            

      -            const { patchStatus, fileReviewStates } =
      ReviewService.prepareTransactionForReview(transaction);

      -

      +

      +            // This logic is preserved from the deleted
      `prepareTransactionForReview`

      +            // to allow debug screens to jump directly to a pre-populated
      review state

      +            // without running the full simulation.

      +            const isFailureCase = transaction.id === '1';

      +            const fileReviewStates = new Map<string, { status:
      FileReviewStatus; error?: string }>();

      +            (transaction.files || []).forEach((file, index) => {

      +                if (isFailureCase) {

      +                    const isFailedFile = index > 0;

      +                    const status = isFailedFile ? 'FAILED' : 'APPROVED';

      +                    const error = isFailedFile ? (index === 1 ? 'Hunk #1
      failed to apply' : 'Context mismatch at line 92') : undefined;

      +                    fileReviewStates.set(file.id, { status, error });

      +                } else {

      +                    fileReviewStates.set(file.id, { status: 'APPROVED'
      });

      +                }

      +            });

      +            const patchStatus = isFailureCase ? 'PARTIAL_FAILURE' :
      'SUCCESS';
                   useViewStore.getState().actions.setSelectedTransactionId(transaction.id);
                   set({
                       patchStatus,
      @@ -117,45 +131,48 @@
                       useAppStore.getState().actions.showDashboardScreen();
                   }
               },
      -        startApplySimulation: async (scenario) => {

      +        startApplySimulation: async (transactionId, scenario) => {

      +            const transaction =
      useTransactionStore.getState().transactions.find(t => t.id ===
      transactionId);

      +            if (!transaction?.files) return;

      +
                   const { showReviewProcessingScreen, showReviewScreen } = useAppStore.getState().actions;
                   const { updateApplyStep, addApplySubstep, updateApplySubstep } = get().actions;
      -            set({ applySteps:
      JSON.parse(JSON.stringify(INITIAL_APPLY_STEPS)), processingStartTime:
      Date.now() });

      +

      +           
      useViewStore.getState().actions.setSelectedTransactionId(transaction.id);

      +            set({

      +                applySteps:
      JSON.parse(JSON.stringify(INITIAL_APPLY_STEPS)),

      +                processingStartTime: Date.now(),

      +                fileReviewStates: new Map(), // Clear previous states

      +            });

      +
                   showReviewProcessingScreen();
      -            const simulationGenerator =
      ReviewService.runApplySimulation(scenario);

      -            for await (const update of simulationGenerator) {

      -                if (update.type === 'UPDATE_STEP') {

      -                    updateApplyStep(

      -                        update.payload.id,

      -                        update.payload.status,

      -                        update.payload.duration,

      -                        update.payload.details,

      -                    );

      -                } else if (update.type === 'ADD_SUBSTEP') {

      -                    addApplySubstep(update.payload.parentId,
      update.payload.substep);

      -                } else if (update.type === 'UPDATE_SUBSTEP') {

      -                    updateApplySubstep(

      -                        update.payload.parentId,

      -                        update.payload.substepId,

      -                        update.payload.status,

      -                        update.payload.title,

      -                    );

      +            const simulationGenerator =
      ReviewService.runApplySimulation(transaction.files, scenario);

      +            let simulationResult: SimulationResult;

      +

      +            // Manually iterate to get the return value from the async
      generator

      +            const iterator = simulationGenerator[Symbol.asyncIterator]();

      +            // eslint-disable-next-line no-constant-condition

      +            while (true) {

      +                const { value, done } = await iterator.next();

      +                if (done) {

      +                    simulationResult = value as SimulationResult;

      +                    break;
                       }
      +                const update = value;

      +                if (update.type === 'UPDATE_STEP') {

      +                    updateApplyStep(update.payload.id,
      update.payload.status, update.payload.duration, update.payload.details);

      +                } else if (update.type === 'ADD_SUBSTEP') {

      +                    addApplySubstep(update.payload.parentId,
      update.payload.substep);

      +                } else if (update.type === 'UPDATE_SUBSTEP') {

      +                    updateApplySubstep(update.payload.parentId,
      update.payload.substepId, update.payload.status, update.payload.title);

      +                }
                   }
      -            // After a brief delay to show the final state, transition to
      the review screen.

      -            // The `patchStatus` from `load` determines which review
      state to show.

      +
                   await sleep(1000);
      -            set({ processingStartTime: null });

      +            set({

      +                processingStartTime: null,

      +                fileReviewStates: simulationResult.fileReviewStates,

      +                patchStatus: simulationResult.patchStatus,

      +            });
                   showReviewScreen();
               },
               tryRepairFile: (fileId) => {
    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useReviewScreen.tsx
    content: |
      --- src/hooks/useReviewScreen.tsx
      +++ src/hooks/useReviewScreen.tsx
      @@ -148,11 +148,11 @@
           // --- Input Handlers ---
       
           const handleGlobalInput = (input: string, key: Key): boolean => {
      -        if (input === '1') { // For demo purposes
      -            startApplySimulation('success'); return true;
      -        }
      -        if (input === '2') { // For demo purposes
      -            startApplySimulation('failure'); return true;
      +        if (input === '1' && transaction) { // For demo purposes
      +            startApplySimulation(transaction.id, 'success'); return true;
      +        }
      +        if (input === '2' && transaction) { // For demo purposes
      +            startApplySimulation(transaction.id, 'failure'); return true;
               }
               // The 'q' (quit/back) is now handled by the global hotkey hook.
       
    patchStrategy: standard-diff
snapshot:
  src/services/review.service.ts: >-
    import { useTransactionStore } from '../stores/transaction.store';

    import { useAppStore } from '../stores/app.store';

    import { sleep } from '../utils';

    import type { ApplyUpdate, PatchStatus } from '../stores/review.store';

    import type { Transaction, FileItem, FileReviewStatus } from
    '../types/domain.types';


    const mockSuccessFiles = [
        'src/components/Button.tsx',
        'src/components/Input.tsx',
        'src/components/Modal.tsx',
        'src/hooks/useForm.ts',
        'src/hooks/useDebounce.ts',
        'src/styles/theme.css',
        'src/utils/formatters.ts',
        'src/pages/HomePage.tsx',
        'src/pages/AboutPage.tsx',
        'src/services/api.ts',
        'src/stores/user.store.ts',
        'src/constants/routes.ts',
        'src/assets/logo.svg',
        'src/config/firebase.ts',
        'src/types/domain.ts',
        'src/features/auth/Login.tsx',
        'src/features/auth/Signup.tsx',
        'src/features/dashboard/Overview.tsx',
        'src/features/settings/Profile.tsx',
        'src/App.tsx',
    ];


    const mockFailureFiles = [
        'src/services/payment.gateway.ts',
        'src/services/notification.service.ts',
        'src/components/UserProfile.tsx',
        'src/components/complex/DataTable.tsx',
        'src/hooks/useInfiniteScroll.ts',
        'src/hooks/useWebSocket.ts',
        'src/utils/crypto.ts',
        'src/utils/date.helper.ts',
        'src/pages/admin/UserManagement.tsx',
        'src/pages/admin/Analytics.tsx',
        'src/stores/cart.store.ts',
        'src/stores/products.store.ts',
        'src/constants/permissions.ts',
        'src/assets/icon-error.svg',
        'src/config/sentry.ts',
        'src/types/api.ts',
        'src/features/checkout/AddressForm.tsx',
        'src/features/checkout/PaymentForm.tsx',
        'src/features/product/ProductDetail.tsx',
        'src/features/product/ProductList.tsx',
    ];


    const generateBulkRepairPrompt = (failedFiles: FileItem[]): string => {
        return `The previous patch failed to apply to MULTIPLE files. Please generate a new, corrected patch that addresses all the files listed below.

    IMPORTANT: The response MUST contain a complete code block for EACH file
    that needs to be fixed.


    ${failedFiles.map(file => `--- FILE: ${file.path} ---

    Strategy: ${file.strategy}

    Error: Hunk #1 failed to apply // This is a mock error


    ORIGINAL CONTENT:

    ---

    // ... original content of ${file.path} ...

    ---


    FAILED PATCH:

    ---

    ${file.diff || '// ... failed diff ...'}

    ---

    `).join('\n')}


    Please analyze all failed files and provide a complete, corrected
    response.`;

    };


    const generateHandoffPrompt = (
        transaction: Transaction,
        fileReviewStates: Map<
            string, { status: FileReviewStatus; error?: string; details?: string }
        >,
    ): string => {
        const successfulFiles = (transaction.files || []).filter(f => fileReviewStates.get(f.id)?.status === 'APPROVED');
        const failedFiles = (transaction.files || []).filter(f => ['FAILED', 'REJECTED'].includes(fileReviewStates.get(f.id)?.status || ''));

        return `I am handing off a failed automated code transaction to you. Your task is to act as my programming assistant and complete the planned changes.

    The full plan for this transaction is detailed in the YAML file located at:
    .relay/transactions/${transaction.hash}.yml. Please use this file as your
    primary source of truth for the overall goal.


    Here is the current status of the transaction:


    --- TRANSACTION SUMMARY ---

    Goal: ${transaction.message}

    Reasoning:

    ${transaction.reasoning || ''}


    --- CURRENT FILE STATUS ---

    SUCCESSFUL CHANGES (already applied, no action needed):

    ${successfulFiles.map(f => `- MODIFIED: ${f.path}`).join('\n') || ' 
    (None)'}


    FAILED CHANGES (these are the files you need to fix):

    ${failedFiles.map(f => `- FAILED: ${f.path} (Error:
    ${fileReviewStates.get(f.id)?.error})`).join('\n')}


    Your job is to now work with me to fix the FAILED files and achieve the
    original goal of the transaction. Please start by asking me which file you
    should work on first.`;

    };


    const performHandoff = (hash: string) => {
        // This is a bit of a hack to find the right transaction to update in the demo
        const txToUpdate = useTransactionStore.getState().transactions.find(tx => tx.hash === hash);
        if (txToUpdate) {
            useTransactionStore.getState().actions.updateTransactionStatus(txToUpdate.id, 'HANDOFF');
        }

        useAppStore.getState().actions.showDashboardScreen();
    };


    async function* runApplySimulation(scenario: 'success' | 'failure'):
    AsyncGenerator<ApplyUpdate> {
        if (scenario === 'success') {
            yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'active' } }; await sleep(100);
            yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'done', duration: 0.1 } };

            yield { type: 'UPDATE_STEP', payload: { id: 'memory', status: 'active' } }; await sleep(100);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 's1', title: 'write: src/core/clipboard.ts (strategy: replace)', status: 'pending' } } };
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 's2', title: 'write: src/utils/shell.ts (strategy: standard-diff)', status: 'pending' } } };
            await sleep(50);
            yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'memory', substepId: 's1', status: 'active' } };
            yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'memory', substepId: 's2', status: 'active' } };
            for (let i = 0; i < mockSuccessFiles.length; i++) {
                const file = mockSuccessFiles[i]!;
                yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: `s${i + 3}`, title: `write: ${file}`, status: 'pending' } } };
            }
            await sleep(50);
            for (let i = 0; i < mockSuccessFiles.length; i++) {
                yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'memory', substepId: `s${i + 3}`, status: 'active' } };
                await sleep(50);
            }

            await sleep(200);
            yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'memory', substepId: 's1', status: 'done' } };
            await sleep(150);
            yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'memory', substepId: 's2', status: 'done' } };
            for (let i = 0; i < mockSuccessFiles.length; i++) {
                yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'memory', substepId: `s${i + 3}`, status: 'done' } };
                await sleep(80);
            }
            yield { type: 'UPDATE_STEP', payload: { id: 'memory', status: 'done', duration: 1.8 } };

            yield { type: 'UPDATE_STEP', payload: { id: 'post-command', status: 'active' } }; await sleep(1300);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'post-command', substep: { id: 's3', title: '`bun run test` ... Passed', status: 'done' } } };
            yield { type: 'UPDATE_STEP', payload: { id: 'post-command', status: 'done', duration: 2.3 } };

            yield { type: 'UPDATE_STEP', payload: { id: 'linter', status: 'active' } }; await sleep(1200);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'linter', substep: { id: 's4', title: '`bun run lint` ... 0 Errors', status: 'done' } } };
            yield { type: 'UPDATE_STEP', payload: { id: 'linter', status: 'done', duration: 1.2 } };

            await sleep(500);

        } else { // failure scenario
            yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'active' } }; await sleep(100);
            yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'done', duration: 0.1 } };

            yield { type: 'UPDATE_STEP', payload: { id: 'memory', status: 'active' } }; await sleep(100);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 'f1', title: 'write: src/core/transaction.ts (strategy: replace)', status: 'pending' } } };
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 'f2', title: 'write: src/utils/logger.ts', status: 'pending' } } };
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 'f3', title: 'write: src/commands/apply.ts', status: 'pending' } } };
            await sleep(50);
            yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'memory', substepId: 'f1', status: 'active' } };
            yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'memory', substepId: 'f2', status: 'active' } };
            yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'memory', substepId: 'f3', status: 'active' } };
            for (let i = 0; i < mockFailureFiles.length; i++) {
                const file = mockFailureFiles[i]!;
                yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: `f${i + 4}`, title: `write: ${file}`, status: 'pending' } } };
            }
            await sleep(50);
            for (let i = 0; i < mockFailureFiles.length; i++) {
                yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'memory', substepId: `f${i + 4}`, status: 'active' } };
                await sleep(50);
            }
            await sleep(150);
            yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'memory', substepId: 'f1', status: 'done' } };
            await sleep(100);
            yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'memory', substepId: 'f2', status: 'failed', title: 'src/utils/logger.ts (Hunk #1 failed to apply)' } };
            await sleep(100);
            yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'memory', substepId: 'f3', status: 'failed', title: 'src/commands/apply.ts (Context mismatch at line 92)' } };
            for (let i = 0; i < mockFailureFiles.length; i++) {
                const file = mockFailureFiles[i]!;
                const shouldFail = i % 4 === 0 || i === mockFailureFiles.length - 1; // fail a few, including the last one
                yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'memory', substepId: `f${i + 4}`, status: shouldFail ? 'failed' : 'done', title: shouldFail ? `${file} (Could not find insertion point)` : undefined } };
                await sleep(80);
            }
            yield { type: 'UPDATE_STEP', payload: { id: 'memory', status: 'done', duration: 2.1 } };

            await sleep(100);
            yield { type: 'UPDATE_STEP', payload: { id: 'post-command', status: 'skipped', details: 'Skipped due to patch application failure' } };
            await sleep(100);
            yield { type: 'UPDATE_STEP', payload: { id: 'linter', status: 'skipped', details: 'Skipped due to patch application failure' } };

            await sleep(500);
        }
    }


    const prepareTransactionForReview = (
        transaction: Transaction,
    ): {
        patchStatus: PatchStatus;
        fileReviewStates: Map<string, { status: FileReviewStatus; error?: string }>;
    } => {
        // This simulates the backend determining which files failed or succeeded and sets it ONCE on load.
        // For this demo, tx '1' is the failure case, any other is success.
        const isFailureCase = transaction.id === '1';
        const fileReviewStates = new Map<string, { status: FileReviewStatus; error?: string }>();

        (transaction.files || []).forEach((file, index) => {
            if (isFailureCase) {
                const isFailedFile = index > 0;
                const status = isFailedFile ? 'FAILED' : 'APPROVED';
                const error = isFailedFile ? (index === 1 ? 'Hunk #1 failed to apply' : 'Context mismatch at line 92') : undefined;
                fileReviewStates.set(file.id, { status, error });
            } else {
                fileReviewStates.set(file.id, { status: 'APPROVED' });
            }
        });
        return { patchStatus: isFailureCase ? 'PARTIAL_FAILURE' : 'SUCCESS', fileReviewStates };
    };


    const generateSingleFileRepairPrompt = (file: FileItem, error?: string):
    string => {
        return `The patch failed to apply to ${file.path}. Please generate a corrected patch.

    Error: ${error || 'Unknown error'}

    Strategy: ${file.strategy}


    ORIGINAL CONTENT:

    ---

    // ... original file content would be here ...

    ---


    FAILED PATCH:

    ---

    ${file.diff || '// ... failed diff would be here ...'}

    ---


    Please provide a corrected patch that addresses the error.`;

    };


    const tryRepairFile = (file: FileItem, error?: string): FileItem => {
        const repairPrompt = generateSingleFileRepairPrompt(file, error);
        // In a real app: clipboardy.writeSync(repairPrompt)
        // eslint-disable-next-line no-console
        console.log(`[CLIPBOARD MOCK] Copied repair prompt for: ${file.path}`, repairPrompt);

        return file;
    };


    const generateSingleFileInstructPrompt = (file: FileItem, transaction:
    Transaction): string => {
        return `The user REJECTED the last proposed change for the file \`${file.path}\`.

    The original high-level goal was:

    ---

    ${transaction.prompt || transaction.message}

    ---


    The rejected change was:

    ---

    ${file.diff || '// ... rejected diff would be here ...'}

    ---


    Please provide an alternative solution for \`${file.path}\` that still
    accomplishes the original goal.

    The response MUST be a complete, corrected patch for this file.`;

    };


    const tryInstructFile = (file: FileItem, transaction: Transaction): void =>
    {
        const instructPrompt = generateSingleFileInstructPrompt(file, transaction);
        // In a real app: clipboardy.writeSync(instructPrompt)
        // eslint-disable-next-line no-console
        console.log(`[CLIPBOARD MOCK] Copied instruction prompt for: ${file.path}`, instructPrompt);
    };


    const generateBulkInstructPrompt = (rejectedFiles: FileItem[], transaction:
    Transaction): string => {
        // Mock implementation for demo. In a real scenario, this would generate a more complex prompt.
        const fileList = rejectedFiles.map(f => `- ${f.path}`).join('\n');
        // eslint-disable-next-line no-console
        console.log(`[CLIPBOARD] Copied bulk instruction prompt for ${rejectedFiles.length} files.`);
        return `The user has rejected changes in multiple files for the goal: "${transaction.message}".\n\nThe rejected files are:\n${fileList}\n\nPlease provide an alternative patch for all of them.`;
    };


    const runBulkReapply = async (
        failedFiles: FileItem[],
    ): Promise<{ id: string; status: FileReviewStatus; error?: string }[]> => {
        await sleep(1500); // Simulate re-apply

        // Mock a mixed result
        let first = true;
        return failedFiles.map(file => {
            if (first) {
                first = false;
                return { id: file.id, status: 'APPROVED' as const };
            } else {
                return {
                    id: file.id,
                    status: 'FAILED' as const,
                    error: "'replace' failed: markers not found",
                };
            }
        });
    };


    export const ReviewService = {
        prepareTransactionForReview,
        generateBulkRepairPrompt,
        generateBulkInstructPrompt,
        generateHandoffPrompt,
        performHandoff,
        runApplySimulation,
        generateSingleFileRepairPrompt,
        tryRepairFile,
        generateSingleFileInstructPrompt,
        tryInstructFile,
        runBulkReapply,
    };
  src/stores/review.store.ts: >-
    import { create } from 'zustand';

    import { useAppStore } from './app.store';

    import { useTransactionStore } from './transaction.store';

    import { useViewStore } from './view.store';

    import { ReviewService } from '../services/review.service';

    import { INITIAL_APPLY_STEPS, PATCH_STATUS, REVIEW_BODY_VIEWS } from
    '../constants/review.constants';

    import { moveIndex } from './navigation.utils';

    import { sleep } from '../utils';

    import type { FileReviewStatus } from '../types/domain.types';


    export interface ApplyStep {
        id: string;
        title: string;
        status: 'pending' | 'active' | 'done' | 'failed' | 'skipped';
        details?: string;
        substeps?: ApplyStep[];
        duration?: number;
    }


    export type ReviewBodyView = (typeof REVIEW_BODY_VIEWS)[keyof typeof
    REVIEW_BODY_VIEWS];

    export type PatchStatus = (typeof PATCH_STATUS)[keyof typeof PATCH_STATUS];

    export type ApplyUpdate =
        | { type: 'UPDATE_STEP'; payload: { id: string; status: ApplyStep['status']; duration?: number; details?: string } }
        | { type: 'ADD_SUBSTEP'; payload: { parentId: string; substep: Omit<ApplyStep, 'substeps'> } }
        | { type: 'UPDATE_SUBSTEP'; payload: { parentId: string; substepId: string; status: ApplyStep['status']; title?: string } };

    interface ReviewState {
        patchStatus: PatchStatus;
        applySteps: ApplyStep[];
        selectedItemIndex: number;
        bodyView: ReviewBodyView;
        isDiffExpanded: boolean;
        reasoningScrollIndex: number;
        scriptErrorIndex: number;
        processingStartTime: number | null;
        fileReviewStates: Map<string, { status: FileReviewStatus; error?: string; details?: string }>;

        selectedBulkRepairOptionIndex: number;
        selectedBulkInstructOptionIndex: number;

        actions: {
            load: (transactionId: string, initialState?: Partial<Pick<ReviewState, 'bodyView' | 'selectedBulkRepairOptionIndex'>>) => void;
            moveSelectionUp: (listSize: number) => void;
            moveSelectionDown: (listSize: number) => void;
            expandDiff: () => void;
            toggleBodyView: (view: Extract<
                ReviewBodyView, 'bulk_instruct' |
                'diff' | 'reasoning' | 'script_output' | 'bulk_repair' | 'confirm_handoff'
            >) => void;
            setBodyView: (view: ReviewBodyView) => void;
            approve: () => void;
            startApplySimulation: (scenario: 'success' | 'failure') => void;
            tryRepairFile: (fileId: string) => void;
            showBulkRepair: () => void;
            executeBulkRepairOption: (option: number) => Promise<void>;
            tryInstruct: (fileId: string) => void;
            showBulkInstruct: () => void;
            executeBulkInstructOption: (option: number) => Promise<void>;
            confirmHandoff: () => void;
            scrollReasoningUp: () => void;
            scrollReasoningDown: () => void;
            navigateScriptErrorUp: () => void;
            navigateScriptErrorDown: () => void;
            updateApplyStep: (id: string, status: ApplyStep['status'], duration?: number, details?: string) => void;
            addApplySubstep: (parentId: string, substep: Omit<ApplyStep, 'substeps'>) => void;
            updateApplySubstep: (parentId: string, substepId: string, status: ApplyStep['status'], title?: string) => void;
            updateFileReviewStatus: (fileId: string, status: FileReviewStatus, error?: string, details?: string) => void;
            toggleFileApproval: (fileId: string) => void;
            rejectAllFiles: () => void;
            navigateBulkRepairUp: () => void;
            navigateBulkRepairDown: () => void;
            navigateBulkInstructUp: () => void;
            navigateBulkInstructDown: () => void;
        };
    }


    export const useReviewStore = create<ReviewState>((set, get) => ({
        patchStatus: PATCH_STATUS.SUCCESS,
        applySteps: INITIAL_APPLY_STEPS,
        selectedItemIndex: 0,
        bodyView: REVIEW_BODY_VIEWS.NONE,
        isDiffExpanded: false,
        reasoningScrollIndex: 0,
        scriptErrorIndex: 0,
        processingStartTime: null,
        fileReviewStates: new Map(),
        selectedBulkRepairOptionIndex: 0,
        selectedBulkInstructOptionIndex: 0,

        actions: {
            load: (transactionId, initialState) => {
                const transaction = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!transaction) return;
                
                const { patchStatus, fileReviewStates } = ReviewService.prepareTransactionForReview(transaction);

                useViewStore.getState().actions.setSelectedTransactionId(transaction.id);
                set({
                    patchStatus,
                    fileReviewStates,
                    processingStartTime: null,
                    selectedItemIndex: 0,
                    bodyView: initialState?.bodyView ?? REVIEW_BODY_VIEWS.NONE,
                    isDiffExpanded: false,
                    reasoningScrollIndex: 0,
                    scriptErrorIndex: 0,
                    applySteps: JSON.parse(JSON.stringify(INITIAL_APPLY_STEPS)),
                    selectedBulkRepairOptionIndex: 0,
                    selectedBulkInstructOptionIndex: 0,
                    ...initialState,
                });
            },
            moveSelectionUp: (listSize) => set(state => {
                return { selectedItemIndex: moveIndex(state.selectedItemIndex, 'up', listSize) };
            }),
            moveSelectionDown: (listSize) => set(state => {
                return { selectedItemIndex: moveIndex(state.selectedItemIndex, 'down', listSize) };
            }),
            toggleBodyView: (view) => set(state => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                const files = tx?.files || [];
                if (view === 'diff' && state.selectedItemIndex >= files.length) return {};
                return {
                    bodyView: state.bodyView === view ? REVIEW_BODY_VIEWS.NONE : view,
                    isDiffExpanded: false,
                };
            }),
            setBodyView: (view) => set({ bodyView: view }),
            expandDiff: () => set(state => ({ isDiffExpanded: !state.isDiffExpanded })),
            approve: () => {
                const { selectedTransactionId } = useViewStore.getState();
                if (selectedTransactionId) {
                    useTransactionStore.getState().actions.updateTransactionStatus(selectedTransactionId, 'APPLIED');
                    useAppStore.getState().actions.showDashboardScreen();
                }
            },
            startApplySimulation: async (scenario) => {
                const { showReviewProcessingScreen, showReviewScreen } = useAppStore.getState().actions;
                const { updateApplyStep, addApplySubstep, updateApplySubstep } = get().actions;
                set({ applySteps: JSON.parse(JSON.stringify(INITIAL_APPLY_STEPS)), processingStartTime: Date.now() });
                showReviewProcessingScreen();
                const simulationGenerator = ReviewService.runApplySimulation(scenario);
                for await (const update of simulationGenerator) {
                    if (update.type === 'UPDATE_STEP') {
                        updateApplyStep(
                            update.payload.id,
                            update.payload.status,
                            update.payload.duration,
                            update.payload.details,
                        );
                    } else if (update.type === 'ADD_SUBSTEP') {
                        addApplySubstep(update.payload.parentId, update.payload.substep);
                    } else if (update.type === 'UPDATE_SUBSTEP') {
                        updateApplySubstep(
                            update.payload.parentId,
                            update.payload.substepId,
                            update.payload.status,
                            update.payload.title,
                        );
                    }
                }
                // After a brief delay to show the final state, transition to the review screen.
                // The `patchStatus` from `load` determines which review state to show.
                await sleep(1000);
                set({ processingStartTime: null });
                showReviewScreen();
            },
            tryRepairFile: (fileId) => {
                const selectedTransactionId = useViewStore.getState().selectedTransactionId;
                const { fileReviewStates } = get();
                if (!selectedTransactionId) return;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                const file = tx?.files?.find(f => f.id === fileId);
                if (!file) return;

                const { status, error } = fileReviewStates.get(file.id) || {};
                if (status !== 'FAILED') return;
                
                ReviewService.tryRepairFile(file, error);
                get().actions.updateFileReviewStatus(file.id, 'AWAITING');
            },
            tryInstruct: (fileId) => {
                const selectedTransactionId = useViewStore.getState().selectedTransactionId;
                const { fileReviewStates } = get();
                if (!selectedTransactionId) return;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                const file = tx?.files?.find(f => f.id === fileId);
                if (!tx || !file) return;

                const { status } = fileReviewStates.get(file.id) || {};
                if (status !== 'REJECTED') return;
                
                ReviewService.tryInstructFile(file, tx);
                get().actions.updateFileReviewStatus(file.id, 'AWAITING', undefined, 'Instruction prompt copied!');
            },
            showBulkInstruct: () => get().actions.setBodyView('bulk_instruct'),
            executeBulkInstructOption: async (option) => {
                const selectedTransactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                if (!tx?.files) return;

                const rejectedFiles = tx.files.filter(f => get().fileReviewStates.get(f.id)?.status === 'REJECTED');
                if (rejectedFiles.length === 0) {
                    set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                    return;
                }

                switch (option) {
                    case 1:
                        ReviewService.generateBulkInstructPrompt(rejectedFiles, tx);
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                        break;
                    case 2:
                        get().actions.setBodyView('confirm_handoff');
                        break;
                    case 3:
                        rejectedFiles.forEach(file => {
                            get().actions.updateFileReviewStatus(file.id, 'APPROVED');
                        });
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                        break;
                    default:
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                }
            },

            showBulkRepair: () => get().actions.toggleBodyView('bulk_repair'),
            executeBulkRepairOption: async (option) => {
                const selectedTransactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                if (!tx?.files) return;

                const failedFiles = tx.files.filter(f => get().fileReviewStates.get(f.id)?.status === 'FAILED');
                if (failedFiles.length === 0) {
                    set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                    return;
                }

                switch (option) {
                    case 1:
                        ReviewService.generateBulkRepairPrompt(failedFiles);
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                        break;
                    case 2: {
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                        failedFiles.forEach(f => get().actions.updateFileReviewStatus(f.id, 'RE_APPLYING'));
                        const results = await ReviewService.runBulkReapply(failedFiles);
                        results.forEach(result =>
                            get().actions.updateFileReviewStatus(
                                result.id, result.status, result.error,
                            ),
                        );
                        break;
                    }
                    case 3:
                        get().actions.setBodyView('confirm_handoff');
                        break;
                    case 4:
                        failedFiles.forEach(file => {
                            get().actions.updateFileReviewStatus(file.id, 'REJECTED');
                        });
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                        break;
                    default:
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                }
            },
            confirmHandoff: () => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!tx?.files) return;
                const { fileReviewStates } = get();
                ReviewService.generateHandoffPrompt(tx, fileReviewStates);
                ReviewService.performHandoff(tx.hash);
            },
            scrollReasoningUp: () => set(state => ({ reasoningScrollIndex: Math.max(0, state.reasoningScrollIndex - 1) })),
            scrollReasoningDown: () => set(state => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!tx?.reasoning) return {};
                const maxLines = tx.reasoning.split('\n').length;
                return { reasoningScrollIndex: Math.min(maxLines - 1, state.reasoningScrollIndex + 1) };
            }),
            navigateScriptErrorUp: () => set(state => ({ scriptErrorIndex: Math.max(0, state.scriptErrorIndex - 1) })),
            navigateScriptErrorDown: () => set(state => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!tx?.scripts || !tx?.files) return {};
                const selectedScript = tx.scripts[state.selectedItemIndex - tx.files.length];
                if (selectedScript?.output) {
                    const errorLines = selectedScript.output
                        .split('\n')
                        .filter(line => line.includes('Error') || line.includes('Warning'));
                    return { scriptErrorIndex: Math.min(errorLines.length - 1, state.scriptErrorIndex + 1) };
                }
                return {};
            }),
            updateApplyStep: (id, status, duration, details) => {
                set(state => ({
                    applySteps: state.applySteps.map(s => {
                        if (s.id === id) {
                            const newStep = { ...s, status };
                            if (duration !== undefined) newStep.duration = duration;
                            if (details !== undefined) newStep.details = details;
                            return newStep;
                        }
                        return s;
                    }),
                }));
            },
            updateApplySubstep: (parentId, substepId, status, title) => {
                set(state => ({
                    applySteps: state.applySteps.map(s => {
                        if (s.id === parentId && s.substeps) {
                            const newSubsteps = s.substeps.map(sub => {
                                if (sub.id === substepId) {
                                    const newSub = { ...sub, status };
                                    if (title) newSub.title = title;
                                    return newSub;
                                }
                                return sub;
                            });
                            return { ...s, substeps: newSubsteps };
                        }
                        return s;
                    }),
                }));
            },
            addApplySubstep: (parentId, substep) => {
                set(state => ({
                    applySteps: state.applySteps.map(s => {
                        if (s.id === parentId) {
                            const newSubsteps = [...(s.substeps || []), substep as ApplyStep];
                            return { ...s, substeps: newSubsteps };
                        }
                        return s;
                    }),
                }));
            },
            updateFileReviewStatus: (fileId, status, error, details) => {
                set(state => {
                    const newStates = new Map(state.fileReviewStates);
                    newStates.set(fileId, { status, error, details });
                    return { fileReviewStates: newStates };
                });
            },
            toggleFileApproval: (fileId) => {
                set(state => {
                    const newStates = new Map(state.fileReviewStates);
                    const current = newStates.get(fileId);
                    if (current) {
                        const newStatus: FileReviewStatus = current.status === 'APPROVED' ? 'REJECTED' : 'APPROVED';
                        newStates.set(fileId, { status: newStatus, error: undefined, details: undefined });
                    }
                    return { fileReviewStates: newStates };
                });
            },
            rejectAllFiles: () => {
                set(state => {
                    const newStates = new Map(state.fileReviewStates);
                    for (const [fileId, reviewState] of newStates.entries()) {
                        if (reviewState.status === 'APPROVED') {
                            newStates.set(fileId, { status: 'REJECTED', error: undefined, details: undefined });
                        }
                    }
                    return { fileReviewStates: newStates };
                });
            },
            navigateBulkRepairUp: () => set(state => ({
                selectedBulkRepairOptionIndex: moveIndex(state.selectedBulkRepairOptionIndex, 'up', 4),
            })),
            navigateBulkRepairDown: () => set(state => ({
                selectedBulkRepairOptionIndex: moveIndex(state.selectedBulkRepairOptionIndex, 'down', 4),
            })),
            navigateBulkInstructUp: () => set(state => ({
                selectedBulkInstructOptionIndex: moveIndex(state.selectedBulkInstructOptionIndex, 'up', 4),
            })),
            navigateBulkInstructDown: () => set(state => ({
                selectedBulkInstructOptionIndex: moveIndex(state.selectedBulkInstructOptionIndex, 'down', 4),
            })),
        },
    }));
  src/hooks/useReviewScreen.tsx: >-
    import { useMemo } from 'react';

    import { useInput, type Key } from 'ink';

    import { useReviewStore } from '../stores/review.store';

    import { useAppStore } from '../stores/app.store';

    import { useCopyStore } from '../stores/copy.store';

    import { useTransactionStore, selectSelectedTransaction } from
    '../stores/transaction.store';

    import type { FileItem } from '../types/domain.types';

    import { useLayout } from './useLayout';

    import { useContentViewport } from './useContentViewport';

    import { UI_CONFIG } from '../config/ui.config';

    import { REVIEW_BODY_VIEWS } from '../constants/review.constants';

    import { useViewport } from './useViewport';


    type NavigableItem =
        | { type: 'prompt' }
        | { type: 'reasoning' }
        | { type: 'script'; id: string }
        | { type: 'file'; id: string };

    export const useReviewScreen = () => {
        const store = useReviewStore();
        const {
            selectedItemIndex,
            bodyView,
            patchStatus,
            selectedBulkRepairOptionIndex,
            selectedBulkInstructOptionIndex,
        } = store;

        const transaction = useTransactionStore(selectSelectedTransaction);
        const { showDashboardScreen } = useAppStore(s => s.actions);

        const scriptCount = transaction?.scripts?.length || 0;
        const fileCount = transaction?.files?.length || 0;

        const layout = UI_CONFIG.layout.review;

        // Layout for the main navigable item list (prompt, reasoning, files, etc.)
        const mainListLayoutConfig = useMemo(() => ({
            header: layout.header,
            fixedRows: layout.fixedRows,
            marginsY: layout.marginsY,
            separators: layout.separators,
            footer: layout.footer,
            dynamicRows: {
                count: bodyView !== REVIEW_BODY_VIEWS.NONE ? layout.bodyHeightReservation : 0,
            },
        }), [bodyView, layout]);

        const { remainingHeight: listViewportHeight } = useLayout(mainListLayoutConfig);
        const { viewOffset } = useViewport({ selectedIndex: selectedItemIndex, itemCount: 100, layoutConfig: mainListLayoutConfig });

        // Layout for the body content (diff, reasoning, etc.)
        const bodyLayoutConfig = useMemo(() => ({
            header: layout.header,
            separators: layout.separators,
            fixedRows: 2, // meta
            marginsY: 1 + 1 + 1, // meta, scripts, files
            footer: 2,
            dynamicRows: { count: 2 + scriptCount + 1 + fileCount }, // prompt, reasoning, scripts, 'FILES' header, files
        }), [layout, scriptCount, fileCount]);

        const { remainingHeight: availableBodyHeight } = useLayout(bodyLayoutConfig);

        const navigableItems = useMemo((): NavigableItem[] => {
            if (!transaction) return [];
            const scriptItems: NavigableItem[] = (transaction.scripts || []).map(s => ({ type: 'script', id: s.command }));
            const fileItems: NavigableItem[] = (transaction.files || []).map(f => ({ type: 'file', id: f.id }));
            return [{ type: 'prompt' }, { type: 'reasoning' }, ...scriptItems, ...fileItems];
        }, [transaction]);

        const contentLineCount = useMemo(() => {
            const currentItem = navigableItems[selectedItemIndex];
            switch (bodyView) { //
                case REVIEW_BODY_VIEWS.REASONING:
                    return (transaction?.reasoning || '').split('\n').length;
                case REVIEW_BODY_VIEWS.DIFF: {
                    if (currentItem?.type !== 'file') return 0;
                    const selectedFile = (transaction?.files || []).find(f => f.id === currentItem.id);
                    return (selectedFile?.diff || '').split('\n').length;
                }
                case REVIEW_BODY_VIEWS.SCRIPT_OUTPUT: {
                    if (currentItem?.type !== 'script') return 0;
                    const selectedScript = (transaction?.scripts || []).find(s => s.command === currentItem.id);
                    return (selectedScript?.output || '').split('\n').length;
                }
                default: return 0;
            }
        }, [bodyView, navigableItems, selectedItemIndex, transaction]);
        const contentViewport = useContentViewport({ contentLineCount, viewportHeight: availableBodyHeight });

        const navigableItemsInView = navigableItems.slice(viewOffset, viewOffset + listViewportHeight);

        // Memoize files to prevent re-renders, fixing the exhaustive-deps lint warning.
        const files: FileItem[] = useMemo(() => transaction?.files || [], [transaction]);
        const fileReviewStates = useReviewStore(s => s.fileReviewStates);

        const reviewStats = useMemo(() => {
            const approvedFiles = files.filter(f => fileReviewStates.get(f.id)?.status === 'APPROVED');
            return {
                totalFiles: files.length,
                totalLinesAdded: files.reduce((sum, f) => sum + f.linesAdded, 0),
                totalLinesRemoved: files.reduce((sum, f) => sum + f.linesRemoved, 0),
                numFiles: files.length,
                approvedFilesCount: approvedFiles.length,
            };
        }, [files, fileReviewStates]);

        const hasRejectedFiles = useMemo(() => {
            if (!fileReviewStates) return false;
            return Array.from(fileReviewStates.values()).some(s => s.status === 'REJECTED');
        }, [fileReviewStates]);

        const { approvedFilesCount } = reviewStats;

        const isFileSelected = navigableItems[selectedItemIndex]?.type === 'file';

        const scripts = transaction?.scripts || [];

        const {
            moveSelectionUp,
            moveSelectionDown,
            expandDiff,
            toggleBodyView,
            setBodyView,
            startApplySimulation,
            approve,
            tryRepairFile,
            tryInstruct,
            showBulkRepair,
            showBulkInstruct,
            executeBulkRepairOption,
            executeBulkInstructOption,
            confirmHandoff,
            scrollReasoningUp,
            scrollReasoningDown,
            navigateScriptErrorUp,
            navigateScriptErrorDown,
            toggleFileApproval,
            rejectAllFiles,
            navigateBulkRepairUp,
            navigateBulkRepairDown,
            navigateBulkInstructUp,
            navigateBulkInstructDown,
        } = store.actions;

        const openCopyMode = () => {
            if (!transaction) return;
            const currentItem = navigableItems[selectedItemIndex];
            const selectedFile = currentItem?.type === 'file' ? files.find(f => f.id === currentItem.id) : undefined;
            useCopyStore.getState().actions.openForReview(transaction, transaction.files || [], selectedFile);
        };

        // --- Input Handlers ---

        const handleGlobalInput = (input: string, key: Key): boolean => {
            if (input === '1') { // For demo purposes
                startApplySimulation('success'); return true;
            }
            if (input === '2') { // For demo purposes
                startApplySimulation('failure'); return true;
            }
            // The 'q' (quit/back) is now handled by the global hotkey hook.

            if (key.escape) {
                switch (bodyView) {
                    case REVIEW_BODY_VIEWS.BULK_REPAIR:
                    case REVIEW_BODY_VIEWS.CONFIRM_HANDOFF:
                    case REVIEW_BODY_VIEWS.BULK_INSTRUCT:
                        toggleBodyView(bodyView);
                        break;
                    default:
                        if (bodyView !== REVIEW_BODY_VIEWS.NONE) {
                            setBodyView(REVIEW_BODY_VIEWS.NONE);
                        }
                        break;
                }
                return true;
            }
            return false;
        };

        const handleHandoffConfirmInput = (_input: string, key: Key): void => {
            if (key.return) confirmHandoff();
        };

        const handleBulkRepairInput = (input: string, key: Key): void => {
            if (key.upArrow) navigateBulkRepairUp();
            if (key.downArrow) navigateBulkRepairDown();
            if (key.return) {
                executeBulkRepairOption(selectedBulkRepairOptionIndex + 1); // Options are 1-based
                return;
            }

            if (input >= '1' && input <= '4') {
                executeBulkRepairOption(parseInt(input));
            }
        };
        
        const handleBulkInstructInput = (input: string, key: Key): void => {
            if (key.upArrow) navigateBulkInstructUp();
            if (key.downArrow) navigateBulkInstructDown();
            if (key.return) {
                executeBulkInstructOption(selectedBulkInstructOptionIndex + 1); // Options are 1-based
                return;
            }

            if (input >= '1' && input <= '3') {
                executeBulkInstructOption(parseInt(input));
            }
        };

        const handleContentScrollInput = (key: Key): boolean => {
            const contentViews = [
                REVIEW_BODY_VIEWS.REASONING,
                REVIEW_BODY_VIEWS.SCRIPT_OUTPUT,
                REVIEW_BODY_VIEWS.DIFF,
            ] as const;
            if (!(contentViews as readonly string[]).includes(bodyView)) return false;

            if (key.upArrow) {
                contentViewport.actions.scrollUp();
                return true;
            }
            if (key.downArrow) { contentViewport.actions.scrollDown(); return true; }
            if (key.pageUp) { contentViewport.actions.pageUp(); return true; }
            if (key.pageDown) { contentViewport.actions.pageDown(); return true; }
            return false;
        };

        const handleReasoningInput = (input: string, key: Key): void => {
            if (key.upArrow) scrollReasoningUp();
            if (key.downArrow) scrollReasoningDown();
            if (input.toLowerCase() === 'r') toggleBodyView(REVIEW_BODY_VIEWS.REASONING);
        };

        const handleScriptOutputInput = (input: string, key: Key): void => {
            if (input.toLowerCase() === 'j') navigateScriptErrorDown();
            if (input.toLowerCase() === 'k') navigateScriptErrorUp();
            if (key.return) toggleBodyView(REVIEW_BODY_VIEWS.SCRIPT_OUTPUT);
            if (input.toLowerCase() === 'c') { // TODO: this copy logic is not great.
                const currentItem = navigableItems[selectedItemIndex];
                const selectedScript = currentItem?.type === 'script' ? scripts.find(s => s.command === currentItem.id) : undefined;
                if (selectedScript) {
                    // eslint-disable-next-line no-console
                    console.log(`[CLIPBOARD] Copied script output: ${selectedScript.command}`); //
                }
            }
        };

        const handleDiffInput = (input: string) => {
            if (input.toLowerCase() === 'x') expandDiff();
            if (input.toLowerCase() === 'd') toggleBodyView('diff');
        }; //

        const handleMainNavigationInput = (input: string, key: Key): void => {
            // Handle Shift+R for reject all
            if (key.shift && input.toLowerCase() === 'r') {
                if (approvedFilesCount > 0 && transaction) {
                    rejectAllFiles();
                }
                return;
            }

            // Main View Navigation
            if (key.upArrow) moveSelectionUp(navigableItems.length);
            if (key.downArrow) moveSelectionDown(navigableItems.length);

            const currentItem = navigableItems[selectedItemIndex];

            if (input === ' ') {
                if (currentItem?.type === 'file') {
                    const fileState = fileReviewStates.get(currentItem.id);
                    if (fileState && fileState.status !== 'FAILED') {
                        toggleFileApproval(currentItem.id);
                    }
                }
            }

            if (input.toLowerCase() === 'd' && currentItem?.type === 'file') {
                toggleBodyView(REVIEW_BODY_VIEWS.DIFF);
            }

            if (input.toLowerCase() === 'r') {
                toggleBodyView(REVIEW_BODY_VIEWS.REASONING);
            }

            if (key.return) { // Enter key
                if (currentItem?.type === 'file') {
                    toggleBodyView(REVIEW_BODY_VIEWS.DIFF);
                } else if (currentItem?.type === 'reasoning') {
                    toggleBodyView(REVIEW_BODY_VIEWS.REASONING);
                } else if (currentItem?.type === 'script') {
                    toggleBodyView(REVIEW_BODY_VIEWS.SCRIPT_OUTPUT);
                }
            }

            if (input.toLowerCase() === 'a') {
                if (approvedFilesCount > 0) {
                    approve();
                    showDashboardScreen();
                }
            }

            if (input.toLowerCase() === 'c') {
                openCopyMode();
            }

            if (input.toLowerCase() === 't') {
                if (key.shift) {
                    const hasFailedFiles = Array.from(fileReviewStates.values()).some(s => s.status === 'FAILED');
                    if (hasFailedFiles) showBulkRepair();
                } else if (currentItem?.type === 'file') {
                    const fileState = fileReviewStates.get(currentItem.id);
                    if (fileState?.status === 'FAILED') tryRepairFile(currentItem.id);
                }
            }

            if (input.toLowerCase() === 'i') {
                if (key.shift) {
                    if (hasRejectedFiles) showBulkInstruct();
                } else if (currentItem?.type === 'file') {
                    const fileState = fileReviewStates.get(currentItem.id);
                    if (fileState?.status === 'REJECTED') {
                        tryInstruct(currentItem.id);
                    }
                }
            }
        };

        useInput((input: string, key: Key) => {
            if (handleGlobalInput(input, key)) {
                return;
            }

            // If we are in a scrollable body view, prioritize that input.
            if (handleContentScrollInput(key)) {
                return;
            }

            switch (bodyView) {
                case REVIEW_BODY_VIEWS.CONFIRM_HANDOFF: return handleHandoffConfirmInput(input, key);
                case REVIEW_BODY_VIEWS.BULK_REPAIR: return handleBulkRepairInput(input, key);
                case REVIEW_BODY_VIEWS.BULK_INSTRUCT: return handleBulkInstructInput(input, key);
                case REVIEW_BODY_VIEWS.REASONING: return handleReasoningInput(input, key);
                case REVIEW_BODY_VIEWS.SCRIPT_OUTPUT: return handleScriptOutputInput(input, key);
                case REVIEW_BODY_VIEWS.DIFF: return handleDiffInput(input);
                default: return handleMainNavigationInput(input, key);
            }
        });

        return {
            ...store,
            fileReviewStates,
            selectedItemIndex,
            transaction,
            files,
            scripts,
            patchStatus,
            navigableItems,
            isFileSelected,
            navigableItemsInView,
            viewOffset,
            contentScrollIndex: contentViewport.scrollIndex,
            availableBodyHeight,
            selectedBulkRepairOptionIndex,
            selectedBulkInstructOptionIndex,
            ...reviewStats,
            hasRejectedFiles,
        };
    };
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 173
