uuid: c32c91a0-d419-4828-97f4-811c79326a57
projectId: relaycode-tui
createdAt: '2025-09-24T14:02:37.596Z'
gitCommitMsg: >-
  refactor(debug): remove setTimeout hacks for declarative state init

  Replaced fragile `setTimeout` calls in the debug menu hook with a robust,
  declarative state initialization pattern.

  - The `review.store`'s `load` action now accepts an optional initial state
  object to declaratively set the UI state (e.g., `bodyView`) upon loading. -
  The `review.service` was updated to pass this initial state through. - The
  debug menu now sets initial screen state directly when calling the store's
  `load` action before navigation. - For complex actions like triggering Copy
  Mode, the `setTimeout` was removed in favor of direct, synchronous calls to
  the relevant stores after the navigation action is dispatched. This relies on
  Zustand's synchronous state updates and improves reliability.
promptSummary: >-
  The user requested to execute Part 4 of the refactoring plan, which involves
  removing `setTimeout` hacks from the debug menu and replacing them with a more
  declarative state initialization pattern.
reasoning:
  - >-
    Excellent. I will execute Part 4 of the master plan: "Eradicating
    Asynchronous Hacks with Declarative State." This involves removing fragile
    `setTimeout` calls from the debug menu by making state initialization more
    declarative. I will achieve this by enhancing the feature stores' `load`
    methods to accept an initial UI state, and by relying on synchronous state
    updates for post-navigation actions.
  - '### Step 1: Enhance `review.store.ts` to Accept Initial State'
  - >-
    I will modify the `load` action in the review store to accept an optional
    `initialState` object. This allows the debug menu to declaratively set the
    initial `bodyView` when loading a transaction for review, eliminating the
    need for a `setTimeout` to toggle the view after the screen loads.
  - '### Step 2: Propagate Initial State Change Through `review.service.ts`'
  - >-
    To maintain clean separation of concerns, I'll update the `ReviewService` to
    pass the new `initialState` parameter through to the `review.store`'s `load`
    action.
  - '### Step 3: Refactor `useDebugMenu.tsx` to Remove Asynchronous Hacks'
  - >-
    This is the core of the change. I will now refactor the debug menu to use
    the new declarative state initialization and remove all `setTimeout` calls.
    For actions that set a specific view, I'll pass the initial state via
    `loadTransactionForReview`. For complex actions like opening the copy modal,
    I will rely on synchronous state updates and call the necessary actions
    immediately after navigation.
  - >-
    This completes the execution of Part 4. The codebase is now more robust,
    declarative, and free of the race conditions and fragility associated with
    `setTimeout` for state management.
operations:
  - type: write
    path: src/stores/review.store.ts
    content: >+
      --- src/stores/review.store.ts

      +++ src/stores/review.store.ts

      @@ -62,7 +62,7 @@
               navigateScriptErrorDown: () => void,
       
               // "Private" actions for service layer
      -        load: (transactionId: string) => void;

      +        load: (transactionId: string, initialState?: { bodyView:
      ReviewBodyView }) => void;
               _updateApplyStep: (id: string, status: ApplyStep['status'], duration?: number, details?: string) => void;
               _addApplySubstep: (parentId: string, substep: Omit<ApplyStep, 'substeps'>) => void;
           };
      @@ -232,7 +232,7 @@
               }),
       
               // "Private" actions for service layer
      -        load: (transactionId) => {

      +        load: (transactionId, initialState) => {
                   const transaction = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                   if (!transaction) return;
       
      @@ -257,7 +257,7 @@
                       files: reviewFiles,
                       scripts: transaction.scripts || [],
                       selectedItemIndex: 0,
      -                bodyView: 'none' as const,

      +                bodyView: initialState?.bodyView ?? 'none',
                       isDiffExpanded: false,
                       reasoningScrollIndex: 0,
                       scriptErrorIndex: 0,

    patchStrategy: standard-diff
  - type: write
    path: src/services/review.service.ts
    content: >+
      --- src/services/review.service.ts

      +++ src/services/review.service.ts

      @@ -95,8 +95,8 @@
           }
       }
       
      -const loadTransactionForReview = (transactionId: string) => {

      -    useReviewStore.getState().actions.load(transactionId);

      +const loadTransactionForReview = (transactionId: string, initialState?: {
      bodyView: ReviewBodyView }) => {

      +    useReviewStore.getState().actions.load(transactionId, initialState);
       };
       
       const generateSingleFileRepairPrompt = (file: ReviewFileItem): string => {

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useDebugMenu.tsx
    content: >+
      --- src/hooks/useDebugMenu.tsx

      +++ src/hooks/useDebugMenu.tsx

      @@ -93,42 +93,31 @@
                   title: 'Review: Diff View',
                   action: () => {
                       ReviewService.loadTransactionForReview('1');
      +                useReviewStore.getState().actions.setBodyView('diff');
                       appActions.showReviewScreen();
      -                setTimeout(() => {

      -                   
      useReviewStore.getState().actions.toggleBodyView('diff');

      -                }, 100);
                   },
               },
               {
                   title: 'Review: Reasoning View',
                   action: () => {
      -                ReviewService.loadTransactionForReview('1');

      +                ReviewService.loadTransactionForReview('1', { bodyView:
      'reasoning' });
                       appActions.showReviewScreen();
      -                setTimeout(() => {

      -                   
      useReviewStore.getState().actions.toggleBodyView('reasoning');

      -                }, 100);
                   },
               },
               {
                   title: 'Review: Copy Mode',
                   action: () => {
                       ReviewService.loadTransactionForReview('1');
                       appActions.showReviewScreen();
      -                setTimeout(() => {

      -                    const { transactionId, files, selectedItemIndex } =
      useReviewStore.getState();

      -                    const tx =
      useTransactionStore.getState().transactions.find(t => t.id ===
      transactionId);

      -                    if (!tx) return;

      -                    const selectedFile = selectedItemIndex < files.length
      ? files[selectedItemIndex] : undefined;

      -                    const items = CopyService.getCopyItemsForReview(tx,
      files, selectedFile);

      -                    useCopyStore.getState().actions.open('Select data to
      copy from review:', items);

      -                }, 100);

      +                const { transactionId, files, selectedItemIndex } =
      useReviewStore.getState();

      +                const tx =
      useTransactionStore.getState().transactions.find(t => t.id ===
      transactionId);

      +                if (!tx) return;

      +                const selectedFile = selectedItemIndex < files.length ?
      files[selectedItemIndex] : undefined;

      +                const items = CopyService.getCopyItemsForReview(tx,
      files, selectedFile);

      +                useCopyStore.getState().actions.open('Select data to copy
      from review:', items);
                   },
               },
               {
      @@ -136,33 +125,21 @@
                   action: () => {
                       ReviewService.loadTransactionForReview('2');
                       appActions.showReviewScreen();
      -                setTimeout(() => {

      -                   
      useReviewStore.getState().actions.toggleBodyView('script_output');

      -                }, 100);

      +               
      useReviewStore.getState().actions.setBodyView('script_output');
                   },
               },
               {
                   title: 'Review: Bulk Repair',
                   action: () => {
      -                ReviewService.loadTransactionForReview('1');

      +                ReviewService.loadTransactionForReview('1', { bodyView:
      'bulk_repair' });
                       appActions.showReviewScreen();
      -                setTimeout(() => {

      -                    useReviewStore.getState().actions.showBulkRepair();

      -                }, 100);
                   },
               },
               {
                   title: 'Review: Handoff Confirm',
                   action: () => {
      -                ReviewService.loadTransactionForReview('1');

      +                ReviewService.loadTransactionForReview('1', { bodyView:
      'confirm_handoff' });
                       appActions.showReviewScreen();
      -                setTimeout(() => {

      -                   
      useReviewStore.getState().actions.executeBulkRepairOption(3); // Option 3
      is Handoff

      -                }, 100);
                   },
               },
               {
      @@ -213,14 +190,11 @@
                   action: () => {
                       historyActions.prepareDebugState('copy');
                       appActions.showTransactionHistoryScreen();
      -                setTimeout(() => {

      -                    const { transactions: allTxs, selectedForAction } =
      useTransactionHistoryStore.getState();

      -                    const txsToCopy = allTxs.filter(tx =>
      selectedForAction.has(tx.id));

      -                    const items =
      CopyService.getCopyItemsForHistory(txsToCopy);

      -                    useCopyStore.getState().actions.open(`Select data to
      copy from ${txsToCopy.length} transactions:`, items);

      -                }, 100);

      +                const { transactions: allTxs, selectedForAction } =
      useTransactionHistoryStore.getState();

      +                const txsToCopy = allTxs.filter(tx =>
      selectedForAction.has(tx.id));

      +                const items =
      CopyService.getCopyItemsForHistory(txsToCopy);

      +                useCopyStore.getState().actions.open(`Select data to copy
      from ${txsToCopy.length} transactions:`, items);
                   },
               },
           ];

    patchStrategy: standard-diff
snapshot:
  src/stores/review.store.ts: >-
    import { create } from 'zustand';

    import { sleep } from '../utils';

    import { useAppStore } from './app.store';

    import { ReviewService } from '../services/review.service';

    import { useTransactionStore, type Transaction } from './transaction.store';

    import { moveIndex } from './navigation.utils';

    import type { ReviewFileItem } from '../types/file.types';

    import type { ScriptResult, ApplyStep, ReviewBodyView, PatchStatus,
    ApplyUpdate } from '../types/review.types';


    export type { ReviewFileItem } from '../types/file.types';

    export type { ScriptResult, ApplyStep } from '../types/review.types';


    export const initialApplySteps: ApplyStep[] = [
        { id: 'snapshot', title: 'Reading initial file snapshot...', status: 'pending' },
        { id: 'memory', title: 'Applying operations to memory...', status: 'pending', substeps: [] },
        { id: 'post-command', title: 'Running post-command script...', status: 'pending', substeps: [] },
        { id: 'linter', title: 'Analyzing changes with linter...', status: 'pending', substeps: [] },
    ];


    interface ReviewState {
        // Transaction Info
        transactionId: string | null;
        patchStatus: PatchStatus;

        // File & Script Info
        files: ReviewFileItem[];
        scripts: ScriptResult[];

        // UI State
        applySteps: ApplyStep[];
        selectedItemIndex: number; // Can be file or script
        bodyView: ReviewBodyView;
        isDiffExpanded: boolean;

        // Reasoning Scroll State
        reasoningScrollIndex: number;

        // Script Navigation State
        scriptErrorIndex: number;

        actions: {
            moveSelectionUp: () => void;
            moveSelectionDown: () => void;
            toggleFileApproval: () => void;
            rejectAllFiles: () => void;
            expandDiff: () => void;
            toggleBodyView: (view: Extract<ReviewBodyView, 'diff' | 'reasoning' | 'script_output' | 'bulk_repair' | 'confirm_handoff'>) => void;
            setBodyView: (view: ReviewBodyView) => void;
            approve: () => void;
            startApplySimulation: (scenario: 'success' | 'failure') => void;

            // Repair Actions
            tryRepairFile: () => void;
            showBulkRepair: () => void;
            executeBulkRepairOption: (option: number) => Promise<void>;
            confirmHandoff: () => void;

            // Navigation Actions
            scrollReasoningUp: () => void;
            scrollReasoningDown: () => void;
            navigateScriptErrorUp: () => void;
            navigateScriptErrorDown: () => void,

            // "Private" actions for service layer
            load: (transactionId: string) => void;
            _updateApplyStep: (id: string, status: ApplyStep['status'], duration?: number, details?: string) => void;
            _addApplySubstep: (parentId: string, substep: Omit<ApplyStep, 'substeps'>) => void;
        };
    }


    export const useReviewStore = create<ReviewState>((set, get) => ({
        // Transaction Info
        transactionId: null,
        patchStatus: 'SUCCESS', // This will be set on load

        // File & Script Info
        files: [],
        scripts: [],

        // UI State
        applySteps: initialApplySteps,
        selectedItemIndex: 0,
        bodyView: 'none' as const,
        isDiffExpanded: false,

        // Reasoning Scroll State
        reasoningScrollIndex: 0,

        // Script Navigation State
        scriptErrorIndex: 0,

        actions: {
            moveSelectionUp: () => set(state => ({
                selectedItemIndex: moveIndex(state.selectedItemIndex, 'up', state.files.length + state.scripts.length),
            })),
            moveSelectionDown: () => set(state => ({
                selectedItemIndex: moveIndex(state.selectedItemIndex, 'down', state.files.length + state.scripts.length),
            })),
            toggleFileApproval: () => set(state => {
                const { selectedItemIndex, files } = state;
                if (selectedItemIndex >= files.length) return {}; // Not a file

                const newFiles = [...files];
                const file = newFiles[selectedItemIndex];
                if (file) {
                    if (file.status === 'APPROVED') {
                        file.status = 'REJECTED';
                    } else if (file.status === 'REJECTED') {
                        file.status = 'APPROVED';
                    }
                }
                return { files: newFiles };
            }),
            rejectAllFiles: () => set(state => {
                const newFiles = state.files.map(file => {
                    if (file.status === 'APPROVED') {
                        return { ...file, status: 'REJECTED' as const };
                    }
                    return file;
                });
                return { files: newFiles };
            }),
            toggleBodyView: (view) => set(state => {
                if (view === 'diff' && state.selectedItemIndex >= state.files.length) return {}; // Can't show diff for scripts
                return {
                    bodyView: state.bodyView === view ? 'none' : view,
                    isDiffExpanded: false, // Always start collapsed
                };
            }),
            setBodyView: (view) => set({ bodyView: view }),
            expandDiff: () => set(state => ({ isDiffExpanded: !state.isDiffExpanded })),
            approve: () => {
                const { transactionId } = get();
                if (transactionId) {
                    // Update transaction status to COMMITTED
                    useTransactionStore.getState().actions.updateTransactionStatus(transactionId, 'COMMITTED');
                    // Navigate back to dashboard
                    useAppStore.getState().actions.showDashboardScreen();
                }
            },
            startApplySimulation: async (scenario: 'success' | 'failure') => {
                const { showReviewProcessingScreen, showReviewScreen } = useAppStore.getState().actions;
                const { _updateApplyStep, _addApplySubstep } = get().actions;

                set({ applySteps: JSON.parse(JSON.stringify(initialApplySteps)) });
                showReviewProcessingScreen();

                const simulationGenerator = ReviewService.runApplySimulation(scenario);
                for await (const update of simulationGenerator) {
                    switch (update.type) {
                        case 'UPDATE_STEP':
                            _updateApplyStep(update.payload.id, update.payload.status, update.payload.duration, update.payload.details);
                            break;
                        case 'ADD_SUBSTEP':
                            _addApplySubstep(update.payload.parentId, update.payload.substep);
                            break;
                    }
                }

                showReviewScreen();
            },

            // Repair Actions
            tryRepairFile: () => {
                set(state => {
                    const { selectedItemIndex, files } = state;
                    if (selectedItemIndex >= files.length) return {};

                    const file = files[selectedItemIndex];
                    if (file?.status === 'FAILED') {
                        const updatedFile = ReviewService.tryRepairFile(file);
                        const newFiles = [...files];
                        newFiles[selectedItemIndex] = updatedFile;
                        return { files: newFiles };
                    }
                    return {};
                });
            },
            showBulkRepair: () => get().actions.toggleBodyView('bulk_repair'),
            executeBulkRepairOption: async (option: number) => {
                const { files } = get();

                switch (option) {
                    case 1: { // Generate & Copy Bulk Repair Prompt
                        const bulkPrompt = ReviewService.generateBulkRepairPrompt(files);
                        const failedFiles = files.filter(f => f.status === 'FAILED');
                        // eslint-disable-next-line no-console
                        console.log(`[CLIPBOARD] Copied bulk repair prompt for ${failedFiles.length} files.`);
                        // In a real app, this would use clipboardy.writeSync(bulkPrompt),
                        set({ bodyView: 'none' as const });
                        break;
                    }

                    case 2: { // Attempt Bulk Re-apply
                        set({ bodyView: 'none' as const });

                        const failedFileIds = new Set(files.filter(f => f.status === 'FAILED').map(f => f.id));
                        if (failedFileIds.size === 0) {
                            break;
                        }

                        // Set intermediate state
                        set(state => ({
                            files: state.files.map(file =>
                                failedFileIds.has(file.id)
                                    ? { ...file, status: 'RE_APPLYING' as const }
                                    : file
                            ),
                        }));

                        const finalFiles = await ReviewService.runBulkReapply(get().files);
                        set({ files: finalFiles });
                        break;
                    }

                    case 3: { // Handoff to Human
                        get().actions.setBodyView('confirm_handoff');
                        break;
                    }

                    case 4: { // Reject All Failed
                        set(state => ({
                            files: state.files.map(file =>
                                file.status === 'FAILED'
                                    ? { ...file, status: 'REJECTED' as const }
                                    : file,
                            ),
                            bodyView: 'none' as const,
                        }));
                        break;
                    }

                    default: // Close modal
                        set({ bodyView: 'none' as const });
                }
            },
            confirmHandoff: () => {
                const { transactionId, files } = get();
                const transaction = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!transaction) return;

                const handoffPrompt = ReviewService.generateHandoffPrompt(transaction.hash, transaction.message, transaction.reasoning || '', files);

                // eslint-disable-next-line no-console
                console.log('[CLIPBOARD] Copied Handoff Prompt.'); // In real app: clipboardy.writeSync(handoffPrompt)
                ReviewService.performHandoff(transaction.hash);
            },

            // Navigation Actions
            scrollReasoningUp: () => set(state => ({
                reasoningScrollIndex: Math.max(0, state.reasoningScrollIndex - 1),
            })),
            scrollReasoningDown: () => set(state => {
                const { transactionId } = state;
                if (!transactionId) return {};

                const transaction = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!transaction?.reasoning) return {};

                const maxLines = transaction.reasoning.split('\n').length;
                return { reasoningScrollIndex: Math.min(maxLines - 1, state.reasoningScrollIndex + 1) };
            }),
            navigateScriptErrorUp: () => set(state => ({
                scriptErrorIndex: Math.max(0, state.scriptErrorIndex - 1),
            })),
            navigateScriptErrorDown: () => set(state => {
                const selectedScript = state.scripts[state.selectedItemIndex - state.files.length];
                if (selectedScript && selectedScript.output) {
                    const errorLines = selectedScript.output.split('\n').filter(line =>
                        line.includes('Error') || line.includes('Warning'),
                    );
                    return { scriptErrorIndex: Math.min(errorLines.length - 1, state.scriptErrorIndex + 1) };
                }
                return {};
            }),

            // "Private" actions for service layer
            load: (transactionId) => {
                const transaction = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!transaction) return;

                // This simulates the backend determining which files failed or succeeded.
                // For this demo, tx '1' is the failure case, any other is success.
                const isFailureCase = transaction.id === '1';
                const patchStatus = isFailureCase ? 'PARTIAL_FAILURE' : 'SUCCESS';

                const reviewFiles: ReviewFileItem[] = (transaction.files || []).map((file, index) => {
                    if (isFailureCase) {
                        return {
                            ...file,
                            status: index === 0 ? 'APPROVED' : 'FAILED',
                            error: index > 0 ? (index === 1 ? 'Hunk #1 failed to apply' : 'Context mismatch at line 92') : undefined,
                            strategy: file.strategy || 'standard-diff',
                        };
                    }
                    return { ...file, status: 'APPROVED', strategy: file.strategy || 'standard-diff' };
                });

                set({
                    transactionId: transaction.id,
                    patchStatus,
                    files: reviewFiles,
                    scripts: transaction.scripts || [],
                    selectedItemIndex: 0,
                    bodyView: 'none' as const,
                    isDiffExpanded: false,
                    reasoningScrollIndex: 0,
                    scriptErrorIndex: 0,
                    applySteps: JSON.parse(JSON.stringify(initialApplySteps)), // Reset apply steps
                });
            },
            _updateApplyStep: (id, status, duration, details) => {
                set(state => ({
                    applySteps: state.applySteps.map(s => {
                        if (s.id === id) {
                            const newStep = { ...s, status };
                            if (duration !== undefined) newStep.duration = duration;
                            if (details !== undefined) newStep.details = details;
                            return newStep;
                        }
                        return s;
                    }),
                }));
            },
            _addApplySubstep: (parentId, substep) => {
                 set(state => ({
                    applySteps: state.applySteps.map(s => {
                        if (s.id === parentId) {
                            const newSubsteps = [...(s.substeps || []), substep as ApplyStep];
                            return { ...s, substeps: newSubsteps };
                        }
                        return s;
                    }),
                }));
            },
        },
    }));
  src/services/review.service.ts: >-
    import { useReviewStore, type ReviewFileItem } from
    '../stores/review.store';

    import { useTransactionStore } from '../stores/transaction.store';

    import { useAppStore } from '../stores/app.store';

    import { sleep } from '../utils';

    import type { ApplyStep, ApplyUpdate } from '../types/review.types';


    const generateBulkRepairPrompt = (files: ReviewFileItem[]): string => {
        const failedFiles = files.filter(f => f.status === 'FAILED');
        return `The previous patch failed to apply to MULTIPLE files. Please generate a new, corrected patch that addresses all the files listed below.

    IMPORTANT: The response MUST contain a complete code block for EACH file
    that needs to be fixed.


    ${failedFiles.map(file => `--- FILE: ${file.path} ---

    Strategy: ${file.strategy}

    Error: ${file.error}


    ORIGINAL CONTENT:

    ---

    // ... original content of ${file.path} ...

    ---


    FAILED PATCH:

    ---

    ${file.diff || '// ... failed diff ...'}

    ---

    `).join('\n')}


    Please analyze all failed files and provide a complete, corrected
    response.`;

    };


    const generateHandoffPrompt = (
        hash: string,
        message: string,
        reasoning: string,
        files: ReviewFileItem[],
    ): string => {
        const successfulFiles = files.filter(f => f.status === 'APPROVED');
        const failedFiles = files.filter(f => f.status === 'FAILED');

        return `I am handing off a failed automated code transaction to you. Your task is to act as my programming assistant and complete the planned changes.

    The full plan for this transaction is detailed in the YAML file located at:
    .relay/transactions/${hash}.yml. Please use this file as your primary source
    of truth for the overall goal.


    Here is the current status of the transaction:


    --- TRANSACTION SUMMARY ---

    Goal: ${message}

    Reasoning:

    ${reasoning}


    --- CURRENT FILE STATUS ---

    SUCCESSFUL CHANGES (already applied, no action needed):

    ${successfulFiles.map(f => `- MODIFIED: ${f.path}`).join('\n') || ' 
    (None)'}


    FAILED CHANGES (these are the files you need to fix):

    ${failedFiles.map(f => `- FAILED: ${f.path} (Error:
    ${f.error})`).join('\n')}


    Your job is to now work with me to fix the FAILED files and achieve the
    original goal of the transaction. Please start by asking me which file you
    should work on first.`;

    };


    const performHandoff = (hash: string) => {
        // This is a bit of a hack to find the right transaction to update in the demo
        const txToUpdate = useTransactionStore.getState().transactions.find(tx => tx.hash === hash);
        if (txToUpdate) {
            useTransactionStore.getState().actions.updateTransactionStatus(txToUpdate.id, 'HANDOFF');
        }

        useAppStore.getState().actions.showDashboardScreen();
    };


    async function* runApplySimulation(scenario: 'success' | 'failure'):
    AsyncGenerator<ApplyUpdate> {
        if (scenario === 'success') {
            yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'active' } }; await sleep(100);
            yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'done', duration: 0.1 } };

            yield { type: 'UPDATE_STEP', payload: { id: 'memory', status: 'active' } }; await sleep(100);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 's1', title: '[✓] write: src/core/clipboard.ts (strategy: replace)', status: 'done' } } };
            await sleep(100);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 's2', title: '[✓] write: src/utils/shell.ts (strategy: standard-diff)', status: 'done' } } };
            yield { type: 'UPDATE_STEP', payload: { id: 'memory', status: 'done', duration: 0.3 } };

            yield { type: 'UPDATE_STEP', payload: { id: 'post-command', status: 'active' } }; await sleep(1300);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'post-command', substep: { id: 's3', title: '`bun run test` ... Passed', status: 'done' } } };
            yield { type: 'UPDATE_STEP', payload: { id: 'post-command', status: 'done', duration: 2.3 } };

            yield { type: 'UPDATE_STEP', payload: { id: 'linter', status: 'active' } }; await sleep(1200);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'linter', substep: { id: 's4', title: '`bun run lint` ... 0 Errors', status: 'done' } } };
            yield { type: 'UPDATE_STEP', payload: { id: 'linter', status: 'done', duration: 1.2 } };

            await sleep(500);

        } else { // failure scenario
            yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'active' } }; await sleep(100);
            yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'done', duration: 0.1 } };

            yield { type: 'UPDATE_STEP', payload: { id: 'memory', status: 'active' } }; await sleep(100);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 'f1', title: '[✓] write: src/core/transaction.ts (strategy: replace)', status: 'done' } } };
            await sleep(100);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 'f2', title: '[!] failed: src/utils/logger.ts (Hunk #1 failed to apply)', status: 'failed' } } };
            await sleep(100);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 'f3', title: '[!] failed: src/commands/apply.ts (Context mismatch at line 92)', status: 'failed' } } };
            yield { type: 'UPDATE_STEP', payload: { id: 'memory', status: 'done', duration: 0.5 } };

            await sleep(100);
            yield { type: 'UPDATE_STEP', payload: { id: 'post-command', status: 'skipped', details: 'Skipped due to patch application failure' } };
            await sleep(100);
            yield { type: 'UPDATE_STEP', payload: { id: 'linter', status: 'skipped', details: 'Skipped due to patch application failure' } };

            await sleep(500);
        }
    }


    const loadTransactionForReview = (transactionId: string) => {
        useReviewStore.getState().actions.load(transactionId);
    };


    const generateSingleFileRepairPrompt = (file: ReviewFileItem): string => {
        return `The patch failed to apply to ${file.path}. Please generate a corrected patch.

    Error: ${file.error}

    Strategy: ${file.strategy}


    ORIGINAL CONTENT:

    ---

    // ... original file content would be here ...

    ---


    FAILED PATCH:

    ---

    ${file.diff || '// ... failed diff would be here ...'}

    ---


    Please provide a corrected patch that addresses the error.`;

    };


    const tryRepairFile = (file: ReviewFileItem): ReviewFileItem => {
        const repairPrompt = generateSingleFileRepairPrompt(file);
        // In a real app: clipboardy.writeSync(repairPrompt)
        // eslint-disable-next-line no-console
        console.log(`[CLIPBOARD] Copied repair prompt for: ${file.path}`);

        // Mock: return the updated file
        return { ...file, status: 'APPROVED' as const, error: undefined, linesAdded: 5, linesRemoved: 2 };
    };


    const runBulkReapply = async (files: ReviewFileItem[]):
    Promise<ReviewFileItem[]> => {
        const failedFileIds = new Set(files.filter(f => f.status === 'FAILED').map(f => f.id));
        if (failedFileIds.size === 0) {
            return files;
        }

        await sleep(1500); // Simulate re-apply

        // Mock a mixed result
        let first = true;
        return files.map(file => {
            if (failedFileIds.has(file.id)) {
                if (first) {
                    first = false;
                    // The file coming in already has the 'RE_APPLYING' status from the store action
                    return { ...file, status: 'APPROVED' as const, strategy: 'replace' as const, error: undefined, linesAdded: 9, linesRemoved: 2 };
                }
                return { ...file, status: 'FAILED' as const, error: "'replace' failed: markers not found" };
            }
            return file;
        });
    };


    export const ReviewService = {
        loadTransactionForReview,
        generateBulkRepairPrompt,
        generateHandoffPrompt,
        performHandoff,
        runApplySimulation,
        generateSingleFileRepairPrompt,
        tryRepairFile,
        runBulkReapply,
    };
  src/hooks/useDebugMenu.tsx: >-
    import { useState } from 'react';

    import { useInput } from 'ink';

    import { useAppStore } from '../stores/app.store';

    import { useDashboardStore } from '../stores/dashboard.store';

    import { useInitStore } from '../stores/init.store';

    import { useCommitStore } from '../stores/commit.store';

    import { useTransactionDetailStore } from
    '../stores/transaction-detail.store';

    import { useCopyStore } from '../stores/copy.store';

    import { COPYABLE_ITEMS } from '../types/copy.types';

    import { CopyService } from '../services/copy.service';

    import { useTransactionHistoryStore } from
    '../stores/transaction-history.store';

    import { ReviewService } from '../services/review.service';

    import { useReviewStore } from '../stores/review.store';

    import type { MenuItem } from '../types/debug.types';

    import { useTransactionStore } from '../stores/transaction.store';

    export type { MenuItem } from '../types/debug.types';


    export const useDebugMenu = () => {
        const [selectedIndex, setSelectedIndex] = useState(0);
        const appActions = useAppStore(s => s.actions);
        const dashboardActions = useDashboardStore(s => s.actions);
        const initActions = useInitStore(s => s.actions);
        const commitActions = useCommitStore(s => s.actions);
        const detailActions = useTransactionDetailStore(s => s.actions);
        const historyActions = useTransactionHistoryStore(s => s.actions);

        const menuItems: MenuItem[] = [
            {
                title: 'Splash Screen',
                action: () => appActions.showSplashScreen(),
            },
            {
                title: 'Init: Analyze Phase',
                action: () => {
                    initActions.setPhase('ANALYZE');
                    appActions.showInitScreen();
                },
            },
            {
                title: 'Init: Interactive Phase',
                action: () => {
                    initActions.setPhase('INTERACTIVE');
                    appActions.showInitScreen();
                },
            },
            {
                title: 'Init: Finalize Phase',
                action: () => {
                    initActions.setPhase('FINALIZE');
                    appActions.showInitScreen();
                },
            },
            {
                title: 'Dashboard: Listening',
                action: () => {
                    dashboardActions.setStatus('LISTENING');
                    appActions.showDashboardScreen();
                },
            },
            {
                title: 'Dashboard: Confirm Approve',
                action: () => {
                    dashboardActions.setStatus('CONFIRM_APPROVE');
                    appActions.showDashboardScreen();
                },
            },
            {
                title: 'Dashboard: Approving',
                action: () => {
                    dashboardActions.setStatus('APPROVING');
                    appActions.showDashboardScreen();
                },
            },
            {
                title: 'Review: Partial Failure (Default)',
                action: () => {
                    ReviewService.loadTransactionForReview('1');
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Success',
                action: () => {
                    ReviewService.loadTransactionForReview('2');
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Diff View',
                action: () => {
                    ReviewService.loadTransactionForReview('1');
                    appActions.showReviewScreen();
                    setTimeout(() => {
                        useReviewStore.getState().actions.toggleBodyView('diff');
                    }, 100);
                },
            },
            {
                title: 'Review: Reasoning View',
                action: () => {
                    ReviewService.loadTransactionForReview('1');
                    appActions.showReviewScreen();
                    setTimeout(() => {
                        useReviewStore.getState().actions.toggleBodyView('reasoning');
                    }, 100);
                },
            },
            {
                title: 'Review: Copy Mode',
                action: () => {
                    ReviewService.loadTransactionForReview('1');
                    appActions.showReviewScreen();
                    setTimeout(() => {
                        const { transactionId, files, selectedItemIndex } = useReviewStore.getState();
                        const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                        if (!tx) return;
                        const selectedFile = selectedItemIndex < files.length ? files[selectedItemIndex] : undefined;
                        const items = CopyService.getCopyItemsForReview(tx, files, selectedFile);
                        useCopyStore.getState().actions.open('Select data to copy from review:', items);
                    }, 100);
                },
            },
            {
                title: 'Review: Script Output',
                action: () => {
                    ReviewService.loadTransactionForReview('2');
                    appActions.showReviewScreen();
                    setTimeout(() => {
                        useReviewStore.getState().actions.toggleBodyView('script_output');
                    }, 100);
                },
            },
            {
                title: 'Review: Bulk Repair',
                action: () => {
                    ReviewService.loadTransactionForReview('1');
                    appActions.showReviewScreen();
                    setTimeout(() => {
                        useReviewStore.getState().actions.showBulkRepair();
                    }, 100);
                },
            },
            {
                title: 'Review: Handoff Confirm',
                action: () => {
                    ReviewService.loadTransactionForReview('1');
                    appActions.showReviewScreen();
                    setTimeout(() => {
                        useReviewStore.getState().actions.executeBulkRepairOption(3); // Option 3 is Handoff
                    }, 100);
                },
            },
            {
                title: 'Review Processing',
                action: () => appActions.showReviewProcessingScreen(),
            },
            {
                title: 'Git Commit Screen',
                action: () => {
                    commitActions.prepareCommitScreen();
                    appActions.showGitCommitScreen();
                },
            },
            {
                title: 'Transaction Detail Screen',
                action: () => {
                    // The dashboard store has transactions, we'll just pick one.
                    detailActions.loadTransaction('3'); // 'feat: implement new dashboard UI'
                    appActions.showTransactionDetailScreen();
                },
            },
            {
                title: 'Transaction History Screen',
                action: () => {
                    historyActions.load();
                    appActions.showTransactionHistoryScreen();
                },
            },
            {
                title: 'History: L1 Drilldown',
                action: () => {
                    historyActions.prepareDebugState('l1-drill');
                    appActions.showTransactionHistoryScreen();
                },
            },
            {
                title: 'History: L2 Drilldown (Diff)',
                action: () => {
                    historyActions.prepareDebugState('l2-drill');
                    appActions.showTransactionHistoryScreen();
                },
            },
            {
                title: 'History: Filter Mode',
                action: () => {
                    historyActions.prepareDebugState('filter');
                    appActions.showTransactionHistoryScreen();
                },
            },
            {
                title: 'History: Copy Mode',
                action: () => {
                    historyActions.prepareDebugState('copy');
                    appActions.showTransactionHistoryScreen();
                    setTimeout(() => {
                        const { transactions: allTxs, selectedForAction } = useTransactionHistoryStore.getState();
                        const txsToCopy = allTxs.filter(tx => selectedForAction.has(tx.id));
                        const items = CopyService.getCopyItemsForHistory(txsToCopy);
                        useCopyStore.getState().actions.open(`Select data to copy from ${txsToCopy.length} transactions:`, items);
                    }, 100);
                },
            },
        ];

        useInput((input, key) => {
            if (key.upArrow) {
                setSelectedIndex(i => moveIndex(i, 'up', menuItems.length));
                return;
            }
            if (key.downArrow) {
                setSelectedIndex(i => moveIndex(i, 'down', menuItems.length));
                return;
            }
            if (key.return) {
                const item = menuItems[selectedIndex];
                if (item) {
                    item.action();
                    appActions.toggleDebugMenu();
                }
                return;
            }
            if (key.escape) {
                appActions.toggleDebugMenu();
                return;
            }

            // No ctrl/meta keys for selection shortcuts, and only single characters
            if (key.ctrl || key.meta || input.length !== 1) return;

            if (input >= '1' && input <= '9') {
                const targetIndex = parseInt(input, 10) - 1;
                if (targetIndex < menuItems.length) {
                    setSelectedIndex(targetIndex);
                }
            } else if (input.toLowerCase() >= 'a' && input.toLowerCase() <= 'z') {
                const targetIndex = 9 + (input.toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0));
                if (targetIndex < menuItems.length) {
                    setSelectedIndex(targetIndex);
                }
            }
        });

        return {
            selectedIndex,
            menuItems,
        };
    };
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 77
