uuid: c32c9162-8e1c-4395-8e3d-0d85915d3119
projectId: relaycode-tui
createdAt: '2025-09-26T00:55:21.905Z'
gitCommitMsg: >-
  refactor: centralize all ui, layout, and string constants

  This major refactoring centralizes all static values, magic strings, and
  layout configurations into dedicated files within `src/constants` and
  `src/config`.

  - **Constants**: Created new constant files and consolidated all hardcoded
  strings, action items, and UI mappings (colors, icons, text) into their
  respective domain-specific files (e.g., `log.constants.ts`,
  `review.constants.ts`). - **Layout**: Moved all `LayoutConfig` objects from
  hooks into a single `ui.config.ts` file for a centralized source of truth for
  screen layouts. - **Hooks**: Refactored all hooks to import and use these
  centralized constants and layout configurations, removing local definitions. -
  **Components**: Updated all components to render UI elements, footers, and
  text based on the new constants, making them more declarative and consistent.
  - **Stores**: Cleaned up stores to use constants for state keys and other
  static values.

  This change dramatically improves maintainability, readability, and
  type-safety across the entire application.
promptSummary: I want to extract out all constants to constants files.
reasoning:
  - >-
    This is a comprehensive refactoring to centralize all constants, making the
    codebase more maintainable, readable, and type-safe. Here is the execution
    of the plan.
  - '### Part 3: Create Missing Constants'
  - >-
    To complete the refactoring, a new constants file for the debug menu is
    required, and the review constants need to be augmented with footer actions.
  - First, I'll create the new constants file for the debug menu.
  - Next, I'll add the necessary footer actions to the review constants file.
  - '### Part 4: Centralize Layout Configuration'
  - I'll centralize all layout values into `ui.config.ts` for consistency.
  - '### Part 5: Finalize Stores'
  - >-
    Now, I'll update the stores to remove hardcoded values and use the new
    constants.
  - '### Part 6: Refactor Hooks'
  - >-
    With the foundation in place, I will refactor all hooks to use the
    centralized constants and configurations.
  - '### Part 7: Refactor Components'
  - >-
    Finally, I'll refactor all the components to be driven by the centralized
    constants.
operations:
  - type: write
    path: src/constants/debug.constants.ts
    content: |-
      import type { ActionItem } from '../types/actions.types';

      export const DEBUG_MENU_FOOTER_ACTIONS: readonly ActionItem[] = [
          { key: '↑↓/PgUp/PgDn', label: 'Nav' },
          { key: '1-9,a-z', label: 'Jump' },
          { key: 'Enter', label: 'Select' },
          { key: 'Esc/Ctrl+B', label: 'Close' },
      ] as const;
    patchStrategy: replace
  - type: write
    path: src/constants/review.constants.ts
    content: >+
      --- src/constants/review.constants.ts

      +++ src/constants/review.constants.ts

      @@ -1,4 +1,5 @@
       import type { ApplyStep } from '../stores/review.store';
      +import type { ActionItem } from '../types/actions.types';
       
       /**
        * Constants for the Review screen and process.
      @@ -47,3 +48,60 @@
           '(3) Bulk Un-reject All Files (revert to original)',
           '(4) Cancel',
       ] as const;
      +

      +interface ReviewFooterConfig {

      +    isFileSelected: boolean;

      +    fileStatus?: 'FAILED' | 'REJECTED' | 'OTHER';

      +    currentItemType?: 'file' | 'script' | 'reasoning' | 'prompt';

      +    hasFailedFiles: boolean;

      +    hasRejectedFiles: boolean;

      +    hasApprovedFiles: boolean;

      +}

      +

      +export const REVIEW_FOOTER_ACTIONS = {

      +    DIFF_VIEW: [

      +        { key: '↑↓', label: 'Nav' },

      +        { key: 'X', label: 'Expand' },

      +        { key: 'D/Esc', label: 'Back' },

      +    ] as const,

      +    REASONING_VIEW: [

      +        { key: '↑↓', label: 'Scroll Text' },

      +        { key: 'R', label: 'Collapse View' },

      +        { key: 'C', label: 'Copy Mode' },

      +    ] as const,

      +    SCRIPT_OUTPUT_VIEW: [

      +        { key: '↑↓', label: 'Nav' },

      +        { key: 'J↓/K↑', label: 'Next/Prev Error' },

      +        { key: 'C', label: 'Copy Output' },

      +        { key: 'Ent/Esc', label: 'Back' },

      +    ] as const,

      +    BULK_REPAIR_VIEW: { text: 'Use (↑↓) Nav · (Enter) Select · (1-4) Jump
      · (Esc) Cancel' } as const,

      +    BULK_INSTRUCT_VIEW: { text: 'Use (↑↓) Nav · (Enter) Select · (1-4)
      Jump · (Esc) Cancel' } as const,

      +    HANDOFF_CONFIRM_VIEW: [

      +        { key: 'Enter', label: 'Confirm Handoff' },

      +        { key: 'Esc', label: 'Cancel' },

      +    ] as const,

      +    MAIN_VIEW: (config: ReviewFooterConfig): ActionItem[] => {

      +        const actions: ActionItem[] = [{ key: '↑↓', label: 'Nav' }];

      +

      +        if (config.isFileSelected) {

      +            if (config.fileStatus !== 'FAILED') actions.push({ key:
      'Spc', label: 'Toggle' });

      +            actions.push({ key: 'D', label: 'Diff' });

      +            if (config.fileStatus === 'FAILED') actions.push({ key: 'T',
      label: 'Try Repair' });

      +            if (config.fileStatus === 'REJECTED') actions.push({ key:
      'I', label: 'Instruct' });

      +        } else if (config.currentItemType === 'script') {

      +            actions.push({ key: 'Ent', label: 'Expand Details' });

      +        } else {

      +            actions.push({ key: 'Ent', label: 'Expand' });

      +        }

      +

      +        if (config.currentItemType !== 'reasoning') actions.push({ key:
      'R', label: 'Reasoning' });

      +        if (config.hasFailedFiles) actions.push({ key: 'Shift+T', label:
      'Bulk Repair' });

      +        if (config.hasRejectedFiles) actions.push({ key: 'Shift+I',
      label: 'Bulk Instruct' });

      +

      +        actions.push({ key: 'C', label: 'Copy' });

      +

      +        if (config.hasApprovedFiles) actions.push({ key: 'A', label:
      'Approve' });

      +        actions.push({ key: 'Q', label: 'Quit' });

      +        return actions;

      +    },

      +};

    patchStrategy: standard-diff
  - type: write
    path: src/config/ui.config.ts
    content: |+
      --- src/config/ui.config.ts
      +++ src/config/ui.config.ts
      @@ -21,6 +21,13 @@
                   marginsY: 3, // for status bar, event stream list, separator
                   footer: 2,
               },
      +        transactionDetail: {
      +            header: 2,
      +            fixedRows: 4,
      +            separators: 2,
      +            marginsY: 1,
      +            footer: 2,
      +        },
               copyScreen: {
                   header: 1,
                   separators: 2,
      @@ -48,5 +55,13 @@
                   marginsY: 1,
                   footer: 2,
               },
      +        review: {
      +            header: 2,
      +            fixedRows: 3, // meta, prompt, reasoning headers
      +            marginsY: 2, // meta container, body
      +            separators: 4, // after title, meta, scripts/files, body
      +            footer: 2,
      +            bodyHeightReservation: 10,
      +        },
           },
       } as const;

    patchStrategy: standard-diff
  - type: write
    path: src/stores/detail.store.ts
    content: >+
      --- src/stores/detail.store.ts

      +++ src/stores/detail.store.ts

      @@ -62,29 +62,29 @@
                   const { focusedItemPath, expandedItemPaths } = state;
                   const newExpandedPaths = new Set(expandedItemPaths);
                   
      -            if (focusedItemPath.includes('/')) { // Is a file

      +            if (focusedItemPath.startsWith(NAVIGATOR_SECTIONS.FILES +
      '/')) { // Is a file
                       return { bodyView: DETAIL_BODY_VIEWS.DIFF_VIEW };
                   }
       
                   // Is a section header
                   if (newExpandedPaths.has(focusedItemPath)) {
                       // Already expanded, drill in if it's FILES
      -                if (focusedItemPath === NAVIGATOR_SECTIONS.FILES) {

      +                if (focusedItemPath === NAVIGATOR_SECTIONS.FILES) { //
                           const visibleItems = getVisibleItemPaths(newExpandedPaths);
      -                    const firstFile = visibleItems.find(item =>
      item.startsWith(`${NAVIGATOR_SECTIONS.FILES}/`));

      +                    const firstFile = visibleItems.find(item =>
      item.startsWith(`${NAVIGATOR_SECTIONS.FILES}/`)); //
                           if (firstFile) {
                               return { focusedItemPath: firstFile, bodyView: DETAIL_BODY_VIEWS.FILES_LIST };
                           }
                       }
                       return {}; // No-op for PROMPT/REASONING if already expanded
                   } else {
                       // Not expanded, so expand it
                       newExpandedPaths.add(focusedItemPath);
      -                let newBodyView: DetailBodyView = DETAIL_BODY_VIEWS.NONE;

      +                let newBodyView: DetailBodyView = DETAIL_BODY_VIEWS.NONE;
      //
                       if (focusedItemPath === NAVIGATOR_SECTIONS.PROMPT) newBodyView = DETAIL_BODY_VIEWS.PROMPT;
                       if (focusedItemPath === NAVIGATOR_SECTIONS.REASONING) newBodyView = DETAIL_BODY_VIEWS.REASONING;
                       if (focusedItemPath === NAVIGATOR_SECTIONS.FILES) newBodyView = DETAIL_BODY_VIEWS.FILES_LIST;
                       return { expandedItemPaths: newExpandedPaths, bodyView: newBodyView };
                   }
               }),
               collapseOrBubbleUp: () => set(state => {

    patchStrategy: standard-diff
  - type: write
    path: src/stores/history.store.ts
    content: |
      --- src/stores/history.store.ts
      +++ src/stores/history.store.ts
      @@ -102,7 +102,7 @@
                   if (newExpandedIds.has(selectedItemPath)) {
                       newExpandedIds.delete(selectedItemPath);
                       // Recursively collapse children
      -                for (const id of newExpandedIds) {
      +                for (const id of newExpandedIds) { //
                           if (id.startsWith(`${selectedItemPath}/`)) {
                               newExpandedIds.delete(id);
                           }
    patchStrategy: standard-diff
  - type: write
    path: src/stores/log.store.ts
    content: |+
      --- src/stores/log.store.ts
      +++ src/stores/log.store.ts
      @@ -1,5 +1,5 @@
       import { create } from 'zustand';
       import type { LogEntry, LogLevel } from '../types/log.types';
      -import { MAX_LOGS } from '../constants/log.constants';
       
       interface LogState {
           logs: LogEntry[];
      @@ -8,6 +8,8 @@
               clearLogs: () => void;
           };
       }
      +
      +const MAX_LOGS = 200;
       
       export const useLogStore = create<LogState>((set) => ({
           logs: [],

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useCopyScreen.tsx
    content: >+
      --- src/hooks/useCopyScreen.tsx

      +++ src/hooks/useCopyScreen.tsx

      @@ -2,8 +2,9 @@
       import { useCopyStore } from '../stores/copy.store';
       import { useViewStore } from '../stores/view.store';
       import { useViewport } from './useViewport';
      -import type { LayoutConfig } from './useLayout';

      +import { UI_CONFIG } from '../config/ui.config';

      +import { OVERLAYS } from '../constants/view.constants';
       
       export const useCopyScreen = () => {
      -    const activeOverlay = useViewStore(s => s.activeOverlay);
           const {
               title, items, selectedIndex, selectedIds, lastCopiedMessage,
               actions,
      @@ -11,11 +12,9 @@
               actions,
           }));
           
      -    // Header, separator, title, margin, separator, status, footer

      -    const layoutConfig: LayoutConfig = { header: 1, separators: 2,
      fixedRows: 2, marginsY: 1, footer: 1 };

      -    
           const { viewOffset, viewportHeight } = useViewport({
               selectedIndex,
      -        layoutConfig,

      +        itemCount: items.length,

      +        layoutConfig: UI_CONFIG.layout.copyScreen,
           });
       
           useInput((input, key) => {
      @@ -47,7 +46,7 @@
               if(item) {
                   actions.toggleSelectionById(item.id);
               }
      -    }, { isActive: activeOverlay === 'copy' });

      +    }, { isActive: useViewStore.getState().activeOverlay ===
      OVERLAYS.COPY });
       
           const itemsInView = items.slice(viewOffset, viewOffset + viewportHeight);
       

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useDashboardScreen.tsx
    content: >+
      --- src/hooks/useDashboardScreen.tsx

      +++ src/hooks/useDashboardScreen.tsx

      @@ -6,6 +6,7 @@
       import { useDetailStore } from '../stores/detail.store';
       import { useHistoryStore } from '../stores/history.store';
       import type { LayoutConfig } from './useLayout';
      +import { DASHBOARD_STATUS } from '../constants/dashboard.constants';
       import { useViewport } from './useViewport';
       
       export const useDashboardScreen = ({ layoutConfig }: { layoutConfig: LayoutConfig }) => {
      @@ -19,6 +20,7 @@
       
           const { viewOffset, viewportHeight } = useViewport({
               selectedIndex: selectedTransactionIndex,
      +        itemCount: transactions.length,
               layoutConfig,
           });
       
      @@ -35,8 +37,8 @@
           const pendingApprovals = pendingTransactions.length;
           const pendingCommits = appliedTransactions.length;
       
      -    const isModal = status === 'CONFIRM_APPROVE';

      -    const isProcessing = status === 'APPROVING';

      +    const isModal = status === DASHBOARD_STATUS.CONFIRM_APPROVE;

      +    const isProcessing = status === DASHBOARD_STATUS.APPROVING;
       
           useInput((input, key) => {
               if (isModal) {
      @@ -93,7 +95,7 @@
                   appActions.showTransactionHistoryScreen();
               }
           });
      -    const transactionsToConfirm = status === 'CONFIRM_APPROVE' ?
      pendingTransactions : [];

      +    const transactionsToConfirm = status ===
      DASHBOARD_STATUS.CONFIRM_APPROVE ? pendingTransactions : [];
       
           return {
               status,

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useDebugLogScreen.tsx
    content: >+
      --- src/hooks/useDebugLogScreen.tsx

      +++ src/hooks/useDebugLogScreen.tsx

      @@ -5,8 +5,10 @@
       import { useViewport } from './useViewport';
       import { LoggerService } from '../services/logger.service';
       import type { LayoutConfig } from './useLayout';
      +import { DEBUG_LOG_MODES } from '../constants/log.constants';

      +import { OVERLAYS } from '../constants/view.constants';

      +import { UI_CONFIG } from '../config/ui.config';
       import { moveIndex } from '../stores/navigation.utils';
       
       export const useDebugLogScreen = () => {
      @@ -15,7 +17,7 @@
           const setActiveOverlay = useViewStore(s => s.actions.setActiveOverlay);
       
           const [selectedIndex, setSelectedIndex] = useState(0);
      -    const [mode, setMode] = useState<'LIST' | 'FILTER'>('LIST');

      +    const [mode, setMode] = useState<keyof typeof
      DEBUG_LOG_MODES>('LIST');
           const [filterQuery, setFilterQuery] = useState('');
       
           const filteredLogs = useMemo(() => logs.filter(log =>
      @@ -35,16 +37,15 @@
           }, [filteredLogs.length, selectedIndex]);
       
           // Header, borders, footer, filter line
      -    const layoutConfig: LayoutConfig = { paddingY: 2, header: 1,
      separators: 2, fixedRows: 1, marginsY: 1, footer: 1 };

      -
           const { viewOffset, viewportHeight } = useViewport({
               selectedIndex,
      -        layoutConfig,

      +        itemCount: filteredLogs.length,

      +        layoutConfig: UI_CONFIG.layout.debugLog,
           });
       
      -    useInput((input, key) => {

      -        if (mode === 'FILTER') {

      +    useInput((input, key) => { 

      +        if (mode === DEBUG_LOG_MODES.FILTER) {
                   if (key.escape || key.return) {
      -                setMode('LIST');

      +                setMode(DEBUG_LOG_MODES.LIST);
                   }
                   return;
               }
       
      @@ -52,7 +53,7 @@
               if (key.escape) {
      -            setActiveOverlay('none');

      +            setActiveOverlay(OVERLAYS.NONE);
                   return;
               }
               if (key.upArrow) {
      @@ -75,9 +76,9 @@
                   return;
               }
               if (input.toLowerCase() === 'f') {
      -            setMode('FILTER');

      +            setMode(DEBUG_LOG_MODES.FILTER);
               }
      -    });

      +    }, { isActive: useViewStore.getState().activeOverlay === OVERLAYS.LOG
      });
       
           useEffect(() => {
               LoggerService.startSimulator();

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useDebugMenu.tsx
    content: >+
      --- src/hooks/useDebugMenu.tsx

      +++ src/hooks/useDebugMenu.tsx

      @@ -10,6 +10,8 @@
       import type { MenuItem } from '../types/debug.types';
       import { useTransactionStore } from '../stores/transaction.store';
       import { moveIndex } from '../stores/navigation.utils';
      +import { UI_CONFIG } from '../config/ui.config';

      +import { OVERLAYS } from '../constants/view.constants';
       import type { LayoutConfig } from './useLayout';
       import { useViewport } from './useViewport';
       export type { MenuItem } from '../types/debug.types';
      @@ -25,7 +27,7 @@
           const menuItems: MenuItem[] = [
               {
                   title: 'View Debug Log',
      -            action: () =>
      useViewStore.getState().actions.setActiveOverlay('log'),

      +            action: () =>
      useViewStore.getState().actions.setActiveOverlay(OVERLAYS.LOG),
               },
               {
                   title: 'Splash Screen',
      @@ -216,11 +218,10 @@
           const [selectedIndex, setSelectedIndex] = useState(0);
           const { menuItems } = useDebugMenuActions();
       
      -    const layoutConfig: LayoutConfig = { paddingY: 2, header: 1,
      separators: 2, footer: 1 };

      -
           const { viewOffset, viewportHeight } = useViewport({
               selectedIndex,
      -        layoutConfig,

      +        itemCount: menuItems.length,

      +        layoutConfig: UI_CONFIG.layout.debugMenu,
           });
           
           useInput((input, key) => {
      @@ -242,12 +243,12 @@
                   const item = menuItems[selectedIndex];
                   if (item) {
                       item.action();
      -                useViewStore.getState().actions.setActiveOverlay('none');

      +               
      useViewStore.getState().actions.setActiveOverlay(OVERLAYS.NONE);
                   }
                   return;
               }
               if (key.escape) {
      -            useViewStore.getState().actions.setActiveOverlay('none');

      +           
      useViewStore.getState().actions.setActiveOverlay(OVERLAYS.NONE);
                   return;
               }
       
      @@ -264,7 +265,7 @@
                       setSelectedIndex(targetIndex);
                   }
               }
      -    });

      +    }, { isActive: useViewStore.getState().activeOverlay ===
      OVERLAYS.DEBUG });
       
           const menuItemsInView = menuItems.slice(viewOffset, viewOffset + viewportHeight);
       

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useGlobalHotkeys.tsx
    content: >+
      --- src/hooks/useGlobalHotkeys.tsx

      +++ src/hooks/useGlobalHotkeys.tsx

      @@ -2,6 +2,7 @@
       import { useAppStore } from '../stores/app.store';
       import { useViewStore } from '../stores/view.store';
       import { MAIN_SCREENS_FOR_QUIT } from '../constants/app.constants';
      +import { OVERLAYS } from '../constants/view.constants';
       
       export const useGlobalHotkeys = ({ isActive }: { isActive: boolean }) => {
           const { exit } = useApp();
      @@ -17,20 +18,20 @@
           useInput((input, key) => {
               // Debug Menu toggle is the highest priority global key
               if (key.ctrl && input === 'b') {
      -            setActiveOverlay(activeOverlay === 'debug' ? 'none' :
      'debug');

      +            setActiveOverlay(activeOverlay === OVERLAYS.DEBUG ?
      OVERLAYS.NONE : OVERLAYS.DEBUG);
                   return;
               }
               if (key.ctrl && input === 'l') {
      -            setActiveOverlay(activeOverlay === 'log' ? 'none' : 'log');

      +            setActiveOverlay(activeOverlay === OVERLAYS.LOG ?
      OVERLAYS.NONE : OVERLAYS.LOG);
                   return;
               }
       
               // If an overlay with its own input is open, stop here.
      -        if (activeOverlay === 'debug' || activeOverlay === 'log') {

      +        if (activeOverlay === OVERLAYS.DEBUG || activeOverlay ===
      OVERLAYS.LOG) {
                   return;
               }
       
               // Help screen takes precedence over other keys
      -        if (activeOverlay === 'help') {

      +        if (activeOverlay === OVERLAYS.HELP) {
                   if (key.escape || input === '?') {
      -                setActiveOverlay('none');

      +                setActiveOverlay(OVERLAYS.NONE);
                   }
                   return;
               }
      @@ -39,7 +40,7 @@
               
               // Open Help
               if (input === '?') {
      -            setActiveOverlay('help');

      +            setActiveOverlay(OVERLAYS.HELP);
                   return;
               }
               

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useReviewScreen.tsx
    content: >+
      --- src/hooks/useReviewScreen.tsx

      +++ src/hooks/useReviewScreen.tsx

      @@ -6,6 +6,8 @@
       import type { FileItem } from '../types/domain.types';
       import { useLayout } from './useLayout';
       import { useContentViewport } from './useContentViewport';
      +import { UI_CONFIG } from '../config/ui.config';

      +import { REVIEW_BODY_VIEWS } from '../constants/review.constants';
       import { useViewport } from './useViewport';
       
       type NavigableItem =
      @@ -30,24 +32,27 @@
           const scriptCount = transaction?.scripts?.length || 0;
           const fileCount = transaction?.files?.length || 0;
       
      +    const layout = UI_CONFIG.layout.review;

      +
           // Layout for the main navigable item list (prompt, reasoning, files, etc.)
           const mainListLayoutConfig = useMemo(() => ({
      -        header: 2, // title+sep

      -        fixedRows: 2 + 1 + 1, // meta + prompt + reasoning headers are
      static before list

      -        marginsY: 1, // meta container

      -        separators: 3, // after meta, after scripts, after files

      -        footer: 2, // ActionFooter can be tall

      +        header: layout.header,

      +        fixedRows: layout.fixedRows,

      +        marginsY: layout.marginsY,

      +        separators: layout.separators,

      +        footer: layout.footer,
               // The body, if visible, also reserves space
      -        dynamicRows: { count: bodyView !== 'none' ? 10 : 0 }, // Reserve
      a block for the body view

      -    }), [bodyView]);

      +        dynamicRows: { count: bodyView !== REVIEW_BODY_VIEWS.NONE ?
      layout.bodyHeightReservation : 0 },

      +    }), [bodyView, layout]);
       
           const { remainingHeight: listViewportHeight } = useLayout(mainListLayoutConfig);
      -    const { viewOffset } = useViewport({ selectedIndex:
      selectedItemIndex, layoutConfig: mainListLayoutConfig });

      +    const { viewOffset } = useViewport({ selectedIndex:
      selectedItemIndex, itemCount: 100, layoutConfig: mainListLayoutConfig });
       
           // Layout for the body content (diff, reasoning, etc.)
           const bodyLayoutConfig = useMemo(() => ({
      -        header: 2,

      +        header: layout.header,

      +        separators: layout.separators,

      +        footer: layout.footer,
               fixedRows: 2, // meta
               marginsY: 1 + 1 + 1, // meta, scripts, files
               separators: 4, // after title, meta, scripts, files, body
      @@ -63,14 +68,14 @@
       
           const contentLineCount = useMemo(() => {
               const currentItem = navigableItems[selectedItemIndex];
      -        switch (bodyView) {

      -            case 'reasoning':

      +        switch (bodyView) { //

      +            case REVIEW_BODY_VIEWS.REASONING:
                       return (transaction?.reasoning || '').split('\n').length;
      -            case 'diff': {

      +            case REVIEW_BODY_VIEWS.DIFF: {
                       if (currentItem?.type !== 'file') return 0;
                       const selectedFile = (transaction?.files || []).find(f => f.id === currentItem.id);
                       return (selectedFile?.diff || '').split('\n').length;
                   }
      -            case 'script_output': {

      +            case REVIEW_BODY_VIEWS.SCRIPT_OUTPUT: {
                       if (currentItem?.type !== 'script') return 0;
                       const selectedScript = (transaction?.scripts || []).find(s => s.command === currentItem.id);
                       return (selectedScript?.output || '').split('\n').length;
      @@ -147,11 +152,11 @@
               // The 'q' (quit/back) is now handled by the global hotkey hook.
       
               if (key.escape) {
      -            if (bodyView === 'bulk_repair' || bodyView ===
      'confirm_handoff' || bodyView === 'bulk_instruct') {

      +            if ([REVIEW_BODY_VIEWS.BULK_REPAIR,
      REVIEW_BODY_VIEWS.CONFIRM_HANDOFF,
      REVIEW_BODY_VIEWS.BULK_INSTRUCT].includes(bodyView)) {
                       toggleBodyView(bodyView);
      -            } else if (bodyView !== 'none') {

      -                setBodyView('none');

      +            } else if (bodyView !== REVIEW_BODY_VIEWS.NONE) {

      +                setBodyView(REVIEW_BODY_VIEWS.NONE);
                   }
                   return true;
               }
      @@ -183,7 +188,7 @@
           };
       
           const handleContentScrollInput = (key: Key): boolean => {
      -        const contentViews = ['reasoning', 'script_output', 'diff'];

      +        const contentViews = [REVIEW_BODY_VIEWS.REASONING,
      REVIEW_BODY_VIEWS.SCRIPT_OUTPUT, REVIEW_BODY_VIEWS.DIFF];
               if (!contentViews.includes(bodyView)) return false;
       
               if (key.upArrow) {
      @@ -197,19 +202,19 @@
           const handleReasoningInput = (input: string, key: Key): void => {
               if (key.upArrow) scrollReasoningUp();
               if (key.downArrow) scrollReasoningDown();
      -        if (input.toLowerCase() === 'r') toggleBodyView('reasoning');

      +        if (input.toLowerCase() === 'r')
      toggleBodyView(REVIEW_BODY_VIEWS.REASONING);
           };
       
           const handleScriptOutputInput = (input: string, key: Key): void => {
               if (input.toLowerCase() === 'j') navigateScriptErrorDown();
               if (input.toLowerCase() === 'k') navigateScriptErrorUp();
      -        if (key.return) toggleBodyView('script_output');

      +        if (key.return) toggleBodyView(REVIEW_BODY_VIEWS.SCRIPT_OUTPUT);
               if (input.toLowerCase() === 'c') { // TODO: this copy logic is not great.
                   const currentItem = navigableItems[selectedItemIndex];
                   const selectedScript = currentItem?.type === 'script' ? scripts.find(s => s.command === currentItem.id) : undefined;
                   if (selectedScript) {
                       // eslint-disable-next-line no-console
      -                console.log(`[CLIPBOARD] Copied script output:
      ${selectedScript.command}`);

      +                console.log(`[CLIPBOARD] Copied script output:
      ${selectedScript.command}`); //
                   }
               }
           };
      @@ -217,7 +222,7 @@
           const handleDiffInput = (input: string) => {
               if (input.toLowerCase() === 'x') expandDiff();
               if (input.toLowerCase() === 'd') toggleBodyView('diff');
      -    };

      +    }; //
       
           const handleMainNavigationInput = (input: string, key: Key): void => {
               // Handle Shift+R for reject all
      @@ -242,19 +247,19 @@
               }
       
               if (input.toLowerCase() === 'd' && currentItem?.type === 'file') {
      -            toggleBodyView('diff');

      +            toggleBodyView(REVIEW_BODY_VIEWS.DIFF);
               }
       
               if (input.toLowerCase() === 'r') {
      -            toggleBodyView('reasoning');

      +            toggleBodyView(REVIEW_BODY_VIEWS.REASONING);
               }
       
               if (key.return) { // Enter key
                   if (currentItem?.type === 'file') {
      -                toggleBodyView('diff');

      +                toggleBodyView(REVIEW_BODY_VIEWS.DIFF);
                   } else if (currentItem?.type === 'reasoning') {
      -                toggleBodyView('reasoning');

      +                toggleBodyView(REVIEW_BODY_VIEWS.REASONING);
                   } else if (currentItem?.type === 'script') {
      -                toggleBodyView('script_output');

      +                toggleBodyView(REVIEW_BODY_VIEWS.SCRIPT_OUTPUT);
                   }
               }
       
      @@ -298,13 +303,13 @@
               }
       
               switch (bodyView) {
      -            case 'confirm_handoff': return
      handleHandoffConfirmInput(input, key);

      -            case 'bulk_repair': return handleBulkRepairInput(input, key);

      -            case 'bulk_instruct': return handleBulkInstructInput(input,
      key);

      -            case 'reasoning': return handleReasoningInput(input, key);

      -            case 'script_output': return handleScriptOutputInput(input,
      key);

      -            case 'diff': return handleDiffInput(input);

      +            case REVIEW_BODY_VIEWS.CONFIRM_HANDOFF: return
      handleHandoffConfirmInput(input, key);

      +            case REVIEW_BODY_VIEWS.BULK_REPAIR: return
      handleBulkRepairInput(input, key);

      +            case REVIEW_BODY_VIEWS.BULK_INSTRUCT: return
      handleBulkInstructInput(input, key);

      +            case REVIEW_BODY_VIEWS.REASONING: return
      handleReasoningInput(input, key);

      +            case REVIEW_BODY_VIEWS.SCRIPT_OUTPUT: return
      handleScriptOutputInput(input, key);

      +            case REVIEW_BODY_VIEWS.DIFF: return handleDiffInput(input);
                   default: return handleMainNavigationInput(input, key);
               }
           });

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useTransactionDetailScreen.tsx
    content: >+
      --- src/hooks/useTransactionDetailScreen.tsx

      +++ src/hooks/useTransactionDetailScreen.tsx

      @@ -7,6 +7,8 @@
       import { EditorService } from '../services/editor.service';
       import { useLayout } from './useLayout';
       import { useContentViewport } from './useContentViewport';
      +import { OVERLAYS } from '../constants/view.constants';

      +import { UI_CONFIG } from '../config/ui.config';
       
       export const useTransactionDetailScreen = () => {
           const store = useDetailStore();
      @@ -23,19 +25,19 @@
       
           const isFilesExpanded = store.expandedItemPaths.has('FILES');
           const layoutConfig = useMemo(() => ({
      -        header: 2, // Header text + separator

      -        fixedRows: 4, // Meta info

      -        separators: 2, // after nav, after body

      -        marginsY: 1, // for body

      -        footer: 2, // ActionFooter can be tall

      +        ...UI_CONFIG.layout.transactionDetail,
               dynamicRows: {
                   count: 3 + (isFilesExpanded ? (files.length || 0) : 0), // navigator items
               },
      -    }), [isFilesExpanded, files.length]);

      +    }), [isFilesExpanded, files.length]); //
       
           const { remainingHeight: availableBodyHeight } = useLayout(layoutConfig);
           
           const contentLineCount = useMemo(() => {
               if (store.bodyView === 'PROMPT') return (transaction?.prompt || '').split('\n').length;
               if (store.bodyView === 'REASONING') return (transaction?.reasoning || '').split('\n').length;
      -        if (store.bodyView === 'DIFF_VIEW') {

      +        if (store.bodyView === 'DIFF_VIEW') { //
                   const fileId = store.focusedItemPath.split('/')[1];
                   const file = files.find(f => f.id === fileId);
                   return (file?.diff || '').split('\n').length;
      @@ -43,7 +45,7 @@
               return 0;
           }, [store.bodyView, store.focusedItemPath, transaction, files]);
       
      -    const viewport = useContentViewport({ contentLineCount,
      viewportHeight: availableBodyHeight });

      +    const viewport = useContentViewport({ contentLineCount,
      viewportHeight: availableBodyHeight, resetOnContentChange: true });
       
           const openCopyMode = () => {
               if (!transaction) return;
      @@ -62,7 +64,7 @@
               }
               
               // --- Content Scrolling ---
      -        if (store.bodyView === 'PROMPT' || store.bodyView === 'REASONING'
      || store.bodyView === 'DIFF_VIEW') {

      +        if (['PROMPT', 'REASONING',
      'DIFF_VIEW'].includes(store.bodyView)) {
                   if (key.upArrow) {
                       viewport.actions.scrollUp();
                       return;
      @@ -87,7 +89,7 @@
               if (input.toLowerCase() === 'o') {
                   if (!transaction) return;
                   const { focusedItemPath } = store;
      -            if (focusedItemPath.includes('/')) { // Is a file

      +            if (focusedItemPath.includes('/')) { //
                       const fileId = focusedItemPath.split('/')[1];
                       const file = files.find(f => f.id === fileId);
                       if (file) EditorService.openFileInEditor(file.path);
      @@ -97,7 +99,7 @@
               }
       
               // Navigator movement only if not scrolling content
      -        if (store.bodyView !== 'PROMPT' && store.bodyView !== 'REASONING'
      && store.bodyView !== 'DIFF_VIEW') {

      +        if (!['PROMPT', 'REASONING',
      'DIFF_VIEW'].includes(store.bodyView)) {
                   if (key.upArrow) navigateUp();
                   if (key.downArrow) navigateDown();
               }
      @@ -105,7 +107,7 @@
               if (key.leftArrow) collapseOrBubbleUp();
               if (key.return) expandOrDrillDown();
               if (key.escape) collapseOrBubbleUp();
      -    }, { isActive: useViewStore.getState().activeOverlay === 'none' });
      // Prevent input when copy overlay is open

      +    }, { isActive: useViewStore.getState().activeOverlay ===
      OVERLAYS.NONE }); // Prevent input when copy overlay is open
       
           return {
               transaction,

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useTransactionHistoryScreen.tsx
    content: >
      --- src/hooks/useTransactionHistoryScreen.tsx

      +++ src/hooks/useTransactionHistoryScreen.tsx

      @@ -7,9 +7,10 @@
       import { EditorService } from '../services/editor.service';
       import { getVisibleItemPaths } from '../stores/navigation.utils';
       import type { LayoutConfig } from './useLayout';
      +import { HISTORY_VIEW_MODES, HISTORY_ITEM_PATH_SEGMENTS } from
      '../constants/history.constants';

      +import { UI_CONFIG } from '../config/ui.config';
       import { useViewport } from './useViewport';
       
      -export const useTransactionHistoryScreen = ({ layoutConfig }: {
      layoutConfig: LayoutConfig }) => {

      +export const useTransactionHistoryScreen = () => {
           const store = useHistoryStore();
           const { mode, selectedItemPath, expandedIds, filterQuery, selectedForAction, loadingPaths, actions } = store;
           const { showDashboardScreen, showTransactionDetailScreen } = useAppStore(s => s.actions);
      @@ -23,7 +24,8 @@
       
           const { viewOffset, viewportHeight } = useViewport({
               selectedIndex,
      -        layoutConfig,

      +        itemCount: visibleItemPaths.length,

      +        layoutConfig: UI_CONFIG.layout.history,
           });
       
           const openCopyMode = () => {
      @@ -35,12 +37,12 @@
           };
       
           const handleFilterInput = (_input: string, key: Key): void => {
      -        if (key.escape) actions.setMode('LIST');

      +        if (key.escape) actions.setMode(HISTORY_VIEW_MODES.LIST);
               if (key.return) actions.applyFilter();
           };
       
           const handleBulkActionsInput = (input: string, key: Key): void => {
      -        if (key.escape) {

      -            actions.setMode('LIST');

      +        if (key.escape) { //

      +            actions.setMode(HISTORY_VIEW_MODES.LIST);
                   return;
               }
               if (input >= '1' && input <= '3') {
                   // eslint-disable-next-line no-console
      -            console.log(`[MOCK] Bulk action #${input} selected.`);

      -            actions.setMode('LIST');

      +            console.log(`[MOCK] Bulk action #${input} selected.`); //

      +            actions.setMode(HISTORY_VIEW_MODES.LIST);
               }
           };
       
      @@ -53,7 +55,7 @@
               if (input === ' ') actions.toggleSelection();
               if (key.return) {
                   const txId = selectedItemPath.split('/')[0];
      -            if (txId && !selectedItemPath.includes('/')) {

      +            if (txId && !selectedItemPath.includes('/')) { //
                       useDetailStore.getState().actions.load(txId);
                       showTransactionDetailScreen();
                   }
      @@ -63,7 +65,7 @@
                   const tx = transactions.find(t => t.id === txId);
                   if (!tx) return;
       
      -            if (selectedItemPath.includes('/file/')) {

      +            if
      (selectedItemPath.includes(HISTORY_ITEM_PATH_SEGMENTS.FILE)) {
                       const fileId = selectedItemPath.split('/')[2];
                       const file = tx.files?.find(f => f.id === fileId);
                       if (file) EditorService.openFileInEditor(file.path);
      @@ -73,20 +75,20 @@
                   }
               }
       
      -        if (input.toLowerCase() === 'f') actions.setMode('FILTER');

      +        if (input.toLowerCase() === 'f')
      actions.setMode(HISTORY_VIEW_MODES.FILTER);
               if (input.toLowerCase() === 'c' && selectedForAction.size > 0) openCopyMode();
      -        if (input.toLowerCase() === 'b' && selectedForAction.size > 0)
      actions.setMode('BULK_ACTIONS');

      +        if (input.toLowerCase() === 'b' && selectedForAction.size > 0)
      actions.setMode(HISTORY_VIEW_MODES.BULK_ACTIONS);
               
               if (key.escape || input.toLowerCase() === 'q') {
                   showDashboardScreen();
               }
           };
       
      -    useInput((input: string, key: Key) => {

      -        if (mode === 'FILTER') {

      +    useInput((input: string, key: Key) => { //

      +        if (mode === HISTORY_VIEW_MODES.FILTER) {
                   handleFilterInput(input, key);
                   return;
               }
      -        if (mode === 'BULK_ACTIONS') {

      +        if (mode === HISTORY_VIEW_MODES.BULK_ACTIONS) {
                   handleBulkActionsInput(input, key);
                   return;
               }
    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useViewport.ts
    content: "--- src/hooks/useViewport.ts\n+++ src/hooks/useViewport.ts\n@@ -4,11 +4,17 @@\n \n interface UseViewportOptions {\n \tselectedIndex: number;\n+\titemCount: number;\n \tlayoutConfig: LayoutConfig;\n }\n \n-export const useViewport = ({ selectedIndex, layoutConfig }: UseViewportOptions) => {\n+export const useViewport = ({ selectedIndex, itemCount, layoutConfig }: UseViewportOptions) => {\n \tconst { remainingHeight: viewportHeight } = useLayout(layoutConfig);\n \tconst [viewOffset, setViewOffset] = useState(0);\n \n+\tuseEffect(() => {\n+\t\tsetViewOffset(0);\n+\t}, [itemCount]);\n+\n \tuseEffect(() => {\n \t\tif (selectedIndex >= 0 && selectedIndex < viewOffset) {\n             setViewOffset(selectedIndex);\n\n"
    patchStrategy: standard-diff
  - type: write
    path: src/components/CopyScreen.tsx
    content: |+
      --- src/components/CopyScreen.tsx
      +++ src/components/CopyScreen.tsx
      @@ -4,6 +4,7 @@
       import { useStdoutDimensions } from '../utils';
       import ActionFooter from './ActionFooter';
       import { useCopyScreen } from '../hooks/useCopyScreen';
      +import { COPY_SCREEN_FOOTER_ACTIONS } from '../constants/copy.constants';
       
       const CopyScreen = () => {
           const {
      @@ -41,12 +42,7 @@
                       </Box>
                       <Separator width={Math.floor(width * 0.8) - 4} />
                       {lastCopiedMessage && <Text color="green">✓ {lastCopiedMessage}</Text>}
      -                <ActionFooter actions={[
      -                    { key: '↑↓/PgUp/PgDn', label: 'Nav' },
      -                    { key: 'Spc/Hotkey', label: 'Toggle' },
      -                    { key: 'Enter', label: 'Copy' },
      -                    { key: 'Esc', label: 'Close' },
      -                ]}/>
      +                <ActionFooter actions={COPY_SCREEN_FOOTER_ACTIONS}/>
                   </Box>
               </Box>
           );

    patchStrategy: standard-diff
  - type: write
    path: src/components/DashboardScreen.tsx
    content: "--- src/components/DashboardScreen.tsx\n+++ src/components/DashboardScreen.tsx\n@@ -5,28 +5,19 @@\n import Separator from './Separator';\n import type { Transaction, TransactionStatus, FileChangeType } from '../types/domain.types';\n import { useDashboardScreen } from '../hooks/useDashboardScreen';\n-import { UI_CONFIG } from '../config/ui.config';\n+import { UI_CONFIG } from '../config/ui.config'; //\n import type { LayoutConfig } from '../hooks/useLayout';\n import ActionFooter from './ActionFooter';\n-import type { ActionItem } from '../types/actions.types';\n+import { DASHBOARD_FOOTER_ACTIONS, DASHBOARD_STATUS } from '../constants/dashboard.constants';\n+import { TRANSACTION_STATUS_UI, FILE_TYPE_MAP } from '../constants/history.constants';\n \n // --- Sub-components & Helpers ---\n \n const getStatusIcon = (status: TransactionStatus) => {\n-    switch (status) {\n-        case 'PENDING': return <Text color=\"yellow\">?</Text>;\n-        case 'APPLIED': return <Text color=\"green\">✓</Text>;\n-        case 'COMMITTED': return <Text color=\"blue\">→</Text>;\n-        case 'HANDOFF': return <Text color=\"magenta\">→</Text>;\n-        case 'FAILED': return <Text color=\"red\">✗</Text>;\n-        case 'REVERTED': return <Text color=\"gray\">↩</Text>;\n-        case 'IN-PROGRESS': return <Spinner type=\"dots\" />;\n-        default: return <Text> </Text>;\n-    }\n-};\n-\n-const getFileChangeTypeIcon = (type: FileChangeType) => {\n-    switch (type) {\n-        case 'MOD': return '[MOD]';\n-        case 'ADD': return '[ADD]';\n-        case 'DEL': return '[DEL]';\n-        case 'REN': return '[REN]';\n-    }\n+    if (status === 'IN-PROGRESS') return <Spinner type=\"dots\" />;\n+    const ui = TRANSACTION_STATUS_UI[status as keyof typeof TRANSACTION_STATUS_UI];\n+    if (!ui) return <Text> </Text>;\n+    return <Text color={ui.color}>{ui.text.split(' ')[0]}</Text>;\n };\n \n const formatTimeAgo = (timestamp: number) => {\n@@ -48,7 +39,7 @@\n              <Box flexDirection=\"column\" paddingLeft={1}>\n                 {files.map(file => (\n                      <Text key={file.id}>\n-                        <Text color=\"gray\">{getFileChangeTypeIcon(file.type)}</Text> {file.path}\n+                        <Text color=\"gray\">{FILE_TYPE_MAP[file.type]}</Text> {file.path}\n                     </Text>\n                 ))}\n              </Box>\n@@ -99,23 +90,9 @@\n         transactionsToConfirm,\n         expandedTransactionId,\n     } = useDashboardScreen({\n-        layoutConfig: {\n-            header: 1,\n-            separators: 2,\n-            fixedRows: 1 + 1, // status bar, event stream header\n-            marginsY: 1 + 1 + 1, // status bar, event stream list, separator\n-            footer: 2,\n-            // Non-event stream vertical space (header, footer, etc.)\n-        },\n+        layoutConfig: UI_CONFIG.layout.dashboard,\n     });\n \n     const renderStatusBar = () => {\n         let statusText: string;\n@@ -124,19 +101,19 @@\n-            case 'LISTENING': statusText = 'LISTENING'; statusIcon = <Text color=\"green\">●</Text>; break;\n-            case 'PAUSED': statusText = 'PAUSED'; statusIcon = <Text color=\"yellow\">||</Text>; break;\n-            case 'APPROVING': statusText = 'APPROVING...'; statusIcon = <Text color=\"cyan\"><Spinner type=\"dots\"/></Text>; break;\n-            default: statusText = 'LISTENING'; statusIcon = <Text color=\"green\">●</Text>;\n+            case DASHBOARD_STATUS.LISTENING: statusText = 'LISTENING'; statusIcon = <Text color=\"green\">●</Text>; break;\n+            case DASHBOARD_STATUS.PAUSED: statusText = 'PAUSED'; statusIcon = <Text color=\"yellow\">||</Text>; break;\n+            case DASHBOARD_STATUS.APPROVING: statusText = 'APPROVING...'; statusIcon = <Text color=\"cyan\"><Spinner type=\"dots\"/></Text>; break;\n+            default: statusText = 'LISTENING'; statusIcon = <Text color=\"green\">●</Text>; //\n         }\n \n         let approvalStr: React.ReactNode = String(pendingApprovals).padStart(2, '0');\n         const commitStr: React.ReactNode = String(pendingCommits).padStart(2, '0');\n \n-        if (status === 'APPROVING') approvalStr = <Text color=\"cyan\">(<Spinner type=\"dots\"/>)</Text>;\n-        if (status === 'CONFIRM_APPROVE') {\n+        if (status === DASHBOARD_STATUS.APPROVING) approvalStr = <Text color=\"cyan\">(<Spinner type=\"dots\"/>)</Text>;\n+        if (status === DASHBOARD_STATUS.CONFIRM_APPROVE) {\n             approvalStr = <Text bold color=\"yellow\">┌ {approvalStr} ┐</Text>;\n         }\n         \n@@ -148,26 +125,12 @@\n \n     const renderFooter = () => {\n         if (isModal) return (\n-            <ActionFooter actions={[\n-                { key: 'Enter', label: 'Confirm' },\n-                { key: 'Esc', label: 'Cancel' },\n-            ]}/>\n+            <ActionFooter actions={DASHBOARD_FOOTER_ACTIONS.MODAL}/>\n         );\n         if (isProcessing) return <Text>Processing... This may take a moment.</Text>;\n \n-        const footerActions: ActionItem[] = [\n-            { key: '↑↓', label: 'Nav' },\n-            { key: '→/Ent', label: 'View' },\n-            { key: '←', label: 'Collapse' },\n-            { key: 'L', label: 'Log' },\n-            { key: 'A', label: 'Approve All' },\n-            { key: 'C', label: 'Commit' },\n-            { key: 'P', label: status === 'PAUSED' ? 'Resume' : 'Pause' },\n-            { key: 'Q', label: 'Quit' },\n-        ];\n-\t\treturn <ActionFooter actions={footerActions} />;\n+\t\treturn <ActionFooter actions={DASHBOARD_FOOTER_ACTIONS.STANDARD(status)} />;\n     };\n     \n     return (\n\n"
    patchStrategy: standard-diff
  - type: write
    path: src/components/DebugLogScreen.tsx
    content: >+
      --- src/components/DebugLogScreen.tsx

      +++ src/components/DebugLogScreen.tsx

      @@ -4,27 +4,16 @@
       import Separator from './Separator';
       import ActionFooter from './ActionFooter';
       import { useDebugLogScreen } from '../hooks/useDebugLogScreen';
      +import { DEBUG_LOG_FOOTER_ACTIONS, DEBUG_LOG_MODES, LOG_LEVEL_COLORS,
      LOG_LEVEL_TAGS } from '../constants/log.constants';
       import type { LogEntry } from '../types/log.types';
       import { useStdoutDimensions } from '../utils';
       
      -const LogLevelColors = {

      -    DEBUG: 'gray',

      -    INFO: 'white',

      -    WARN: 'yellow',

      -    ERROR: 'red',

      -};

      -

      -const LogLevelTag = {

      -    DEBUG: { color: 'white', backgroundColor: 'gray' },

      -    INFO: { color: 'black', backgroundColor: 'cyan' },

      -    WARN: { color: 'black', backgroundColor: 'yellow' },

      -    ERROR: { color: 'white', backgroundColor: 'red' },

      -};

      -
       const LogEntryRow = ({ entry, isSelected }: { entry: LogEntry; isSelected: boolean }) => {
           const time = new Date(entry.timestamp).toISOString().split('T')[1]?.replace('Z', '');
      -    const color = LogLevelColors[entry.level];

      -    const tagColors = LogLevelTag[entry.level];

      +    const color = LOG_LEVEL_COLORS[entry.level];

      +    const tagColors = LOG_LEVEL_TAGS[entry.level];
       
           return (
               <Text color={color}>
      @@ -53,7 +42,7 @@
           const renderFilter = () => (
               <Box>
                   <Text>Filter: </Text>
      -            {mode === 'FILTER' ? (

      +            {mode === DEBUG_LOG_MODES.FILTER ? (
                       <TextInput
                           value={filterQuery}
                           onChange={setFilterQuery}
      @@ -73,16 +62,9 @@
           );
       
           const footerActions =
      -        mode === 'FILTER'

      -            ? [{ key: 'Enter/Esc', label: 'Apply & Close Filter' }]

      -            : [

      -                  { key: '↑↓/PgUp/PgDn', label: 'Scroll' },

      -                  { key: 'F', label: 'Filter' },

      -                  { key: 'C', label: 'Clear' },

      -                  { key: 'Esc/Ctrl+L', label: 'Close' },

      -              ];

      +        mode === DEBUG_LOG_MODES.FILTER

      +            ? DEBUG_LOG_FOOTER_ACTIONS.FILTER_MODE

      +            : DEBUG_LOG_FOOTER_ACTIONS.LIST_MODE;
       
           return (
               <Box

    patchStrategy: standard-diff
  - type: write
    path: src/components/DebugMenu.tsx
    content: |+
      --- src/components/DebugMenu.tsx
      +++ src/components/DebugMenu.tsx
      @@ -4,6 +4,7 @@
       import { useDebugMenu } from '../hooks/useDebugMenu';
       import { useStdoutDimensions } from '../utils';
       import ActionFooter from './ActionFooter';
      +import { DEBUG_MENU_FOOTER_ACTIONS } from '../constants/debug.constants';
       
       const getKeyForIndex = (index: number): string => {
           if (index < 9) {
      @@ -37,13 +38,7 @@
                   </Box>
                   <Separator width={width - 4} />
                   <Box>
      -                <ActionFooter actions={[
      -                    { key: '↑↓/PgUp/PgDn', label: 'Nav' },
      -                    { key: '1-9,a-z', label: 'Jump' },
      -                    { key: 'Enter', label: 'Select' },
      -                    { key: 'Esc/Ctrl+B', label: 'Close' },
      -                ]}/>
      +                <ActionFooter actions={DEBUG_MENU_FOOTER_ACTIONS}/>
                       <Box flexGrow={1} />
                       <Text>
                           {Math.min(viewOffset + 1, totalItems)}-

    patchStrategy: standard-diff
  - type: write
    path: src/components/GitCommitScreen.tsx
    content: >+
      --- src/components/GitCommitScreen.tsx

      +++ src/components/GitCommitScreen.tsx

      @@ -4,6 +4,7 @@
       import Separator from './Separator';
       import { useGitCommitScreen } from '../hooks/useGitCommitScreen';
       import ActionFooter from './ActionFooter';
      +import { COMMIT_SCREEN_FOOTER_ACTIONS } from
      '../constants/commit.constants';
       
       const GitCommitScreen = () => {
           const { transactionsToCommit, finalCommitMessage, isCommitting } = useGitCommitScreen();
      @@ -33,10 +34,7 @@
                   <Separator />
                   {isCommitting
                       ? <Text><Spinner type="dots"/> Committing... please wait.</Text>
      -                : <ActionFooter actions={[

      -                    { key: 'Enter', label: 'Confirm & Commit' },

      -                    { key: 'Esc', label: 'Cancel' },

      -                ]}/>

      +                : <ActionFooter actions={COMMIT_SCREEN_FOOTER_ACTIONS}/>
                   }
               </Box>
           );

    patchStrategy: standard-diff
  - type: write
    path: src/components/ReviewScreen.tsx
    content: >+
      --- src/components/ReviewScreen.tsx

      +++ src/components/ReviewScreen.tsx

      @@ -5,30 +5,19 @@
       import ReasonScreen from './ReasonScreen';
       import type { ScriptResult, FileItem, FileChangeType } from '../types/domain.types';
       import { useReviewScreen } from '../hooks/useReviewScreen';
      +import { REVIEW_BODY_VIEWS, REVIEW_FOOTER_ACTIONS, FILE_STATUS_UI,
      BULK_REPAIR_OPTIONS, BULK_INSTRUCT_OPTIONS } from
      '../constants/review.constants';
       import ActionFooter from './ActionFooter';
       import type { ActionItem } from '../types/actions.types';
       
       // --- Sub-components ---
       
      -const FileItemRow = ({ file, reviewStatus, reviewError, reviewDetails,
      isFocused }: {

      +const FileItemRow = ({ file, reviewState, isFocused }: {
           file: FileItem;
      -    reviewStatus: string;

      -    reviewError?: string;

      -    reviewDetails?: string;

      +    reviewState: { status: string; error?: string; details?: string };
           isFocused: boolean;
       }) => {
      -    let icon;

      -    let iconColor;

      -    switch (reviewStatus) {

      -        case 'APPROVED': icon = '[✓]'; iconColor = 'green'; break;

      -        case 'REJECTED': icon = '[✗]'; iconColor = 'red'; break;

      -        case 'FAILED': icon = '[!]'; iconColor = 'red'; break;

      -        case 'AWAITING': icon = '[●]'; iconColor = 'yellow'; break;

      -        case 'RE_APPLYING': icon = '[●]'; iconColor = 'cyan'; break;

      -    }

      +    const ui = FILE_STATUS_UI[reviewState.status as keyof typeof
      FILE_STATUS_UI] || { icon: '[?]', color: 'gray' };
       
           const typeColor = (type: FileChangeType) => {
               switch (type) {
      @@ -44,30 +33,30 @@
           const prefix = isFocused ? '> ' : '  ';
           const colorProps = isFocused ? { bold: true, color: 'cyan' } : {};
       
      -    if (reviewStatus === 'FAILED') {

      +    if (reviewState.status === 'FAILED') {
               return (
                   <Box>
                       <Text {...colorProps}>
      -                    {prefix}<Text color={iconColor}>{icon} FAILED
      {file.path}</Text>

      -                    <Text color="red">    ({reviewError})</Text>

      +                    {prefix}<Text color={ui.color}>{ui.icon} FAILED
      {file.path}</Text>

      +                    <Text color="red">    ({reviewState.error})</Text>
                       </Text>
                   </Box>
               );
           }
       
      -    if (reviewStatus === 'AWAITING') {

      +    if (reviewState.status === 'AWAITING') {
               return (
                   <Box>
                       <Text {...colorProps}>
      -                    {prefix}<Text color={iconColor}>{icon} AWAITING
      {file.path}</Text>

      -                    <Text color="yellow">    ({reviewDetails})</Text>

      +                    {prefix}<Text color={ui.color}>{ui.icon} AWAITING
      {file.path}</Text>

      +                    <Text color="yellow">   
      ({reviewState.details})</Text>
                       </Text>
                   </Box>
               );
           }
       
      -    if (reviewStatus === 'RE_APPLYING') {

      +    if (reviewState.status === 'RE_APPLYING') {
               return (
                    <Box>
                       <Text {...colorProps}>
      -                    {prefix}<Text color={iconColor}>{icon} RE-APPLYING...
      {file.path}</Text>

      +                    {prefix}<Text color={ui.color}>{ui.icon}
      RE-APPLYING... {file.path}</Text>
                           <Text color="cyan"> (using &apos;replace&apos; strategy)</Text>
                       </Text>
                   </Box>
      @@ -77,7 +66,7 @@
           return (
               <Box>
                   <Text {...colorProps}>
      -                {prefix}<Text color={iconColor}>{icon}</Text>
      {file.type}{' '}

      +                {prefix}<Text color={ui.color}>{ui.icon}</Text>
      {file.type}{' '}
                       <Text color={typeColor(file.type)}>{file.path}</Text>{' '}
                       {diffStats} [{strategy}]
                   </Text>
      @@ -142,9 +131,9 @@
           const { hash, message, prompt = '', reasoning = '' } = transaction;
       
           const renderBody = () => {
      -        if (bodyView === 'none') return null;

      +        if (bodyView === REVIEW_BODY_VIEWS.NONE) return null;
       
      -        if (bodyView === 'reasoning') {

      +        if (bodyView === REVIEW_BODY_VIEWS.REASONING) {
                   const reasoningText = reasoning || '';
                   const reasoningLinesCount = reasoningText.split('\n').length;
                   const visibleLinesCount = 10;
      @@ -165,7 +154,7 @@
                   );
               }
               
      -        if (bodyView === 'diff') {

      +        if (bodyView === REVIEW_BODY_VIEWS.DIFF) {
                   const currentItem = navigableItems[selectedItemIndex];
                   const selectedFile = currentItem?.type === 'file' ? files.find(f => f.id === currentItem.id) : undefined;
                   if (!selectedFile) return null;
      @@ -180,7 +169,7 @@
                   );
               }
       
      -        if (bodyView === 'script_output') {

      +        if (bodyView === REVIEW_BODY_VIEWS.SCRIPT_OUTPUT) {
                    const currentItem = navigableItems[selectedItemIndex];
                    const scriptItems = navigableItems.filter((i): i is { type: 'script'; id: string } => i.type === 'script');
                    const scriptIndex = currentItem?.type === 'script'
      @@ -219,7 +208,7 @@
                    );
               }
       
      -        if (bodyView === 'confirm_handoff') {

      +        if (bodyView === REVIEW_BODY_VIEWS.CONFIRM_HANDOFF) {
                   return (
                       <Box flexDirection="column" gap={1}>
                           <Text bold>HANDOFF TO EXTERNAL AGENT</Text>
      @@ -235,16 +224,9 @@
                   );
               }
       
      -        if (bodyView === 'bulk_repair') {

      +        if (bodyView === REVIEW_BODY_VIEWS.BULK_REPAIR) {
                   const failedFiles = files.filter((f: FileItem) => fileReviewStates.get(f.id)?.status === 'FAILED');
      -            const repairOptions = [

      -                '(1) Copy Bulk Re-apply Prompt (for single-shot AI)',

      -                '(2) Bulk Change Strategy & Re-apply',

      -                '(3) Handoff to External Agent',

      -                '(4) Bulk Abandon All Failed Files',

      -                '(Esc) Cancel',

      -            ];
       
                   return (
                       <Box flexDirection="column" gap={1}>
      @@ -259,7 +241,7 @@
                           <Text>How would you like to proceed?</Text>
       
                           <Box flexDirection="column">
      -                        {repairOptions.map((opt, i) => (

      +                        {BULK_REPAIR_OPTIONS.map((opt, i) => (
                                   <Text key={i} color={selectedBulkRepairOptionIndex === i ? 'cyan' : undefined}>
                                       {selectedBulkRepairOptionIndex === i ? '> ' : '  '}
                                       {opt}
      @@ -270,14 +252,8 @@
                   );
               }
       
      -        if (bodyView === 'bulk_instruct') {

      +        if (bodyView === REVIEW_BODY_VIEWS.BULK_INSTRUCT) {
                   const rejectedFiles = files.filter((f: FileItem) => fileReviewStates.get(f.id)?.status === 'REJECTED');
      -            const instructOptions = [

      -                '(1) Copy Bulk Re-instruct Prompt (for single-shot AI)',

      -                '(2) Handoff to External Agent',

      -                '(3) Bulk Un-reject All Files (revert to original)',

      -                '(4) Cancel',

      -            ];
       
                   return (
                       <Box flexDirection="column" gap={1}>
      @@ -290,7 +266,7 @@
                               ))}
                           </Box>
                           <Box flexDirection="column" marginTop={1}>
      -                        {instructOptions.map((opt, i) => (

      +                        {BULK_INSTRUCT_OPTIONS.map((opt, i) => (
                                   <Text key={i} color={selectedBulkInstructOptionIndex === i ? 'cyan' : undefined}>
                                       {selectedBulkInstructOptionIndex === i ? '> ' : '  '}
                                       {opt}
      @@ -306,66 +282,34 @@
       
           const renderFooter = () => {
               // Contextual footer for body views
      -        if (bodyView === 'diff') {

      -            return <ActionFooter actions={[

      -                { key: '↑↓', label: 'Nav' },

      -                { key: 'X', label: 'Expand' },

      -                { key: 'D/Esc', label: 'Back' },

      -            ]}/>;

      -        }

      -        if (bodyView === 'reasoning') {

      -            return <ActionFooter actions={[

      -                { key: '↑↓', label: 'Scroll Text' },

      -                { key: 'R', label: 'Collapse View' },

      -                { key: 'C', label: 'Copy Mode' },

      -            ]}/>;

      -        }

      -        if (bodyView === 'script_output') {

      -            return <ActionFooter actions={[

      -                { key: '↑↓', label: 'Nav' },

      -                { key: 'J↓/K↑', label: 'Next/Prev Error' },

      -                { key: 'C', label: 'Copy Output' },

      -                { key: 'Ent/Esc', label: 'Back' },

      -            ]}/>;

      -        }

      -        if (bodyView === 'bulk_repair') {

      -            return <Text>Use (↑↓) Nav · (Enter) Select · (1-4) Jump ·
      (Esc) Cancel</Text>;

      -        }

      -        if (bodyView === 'bulk_instruct') {

      -            return <Text>Use (↑↓) Nav · (Enter) Select · (1-4) Jump ·
      (Esc) Cancel</Text>;

      -        }

      -        if (bodyView === 'confirm_handoff') {

      -            return <ActionFooter actions={[

      -                { key: 'Enter', label: 'Confirm Handoff' },

      -                { key: 'Esc', label: 'Cancel' },

      -            ]}/>;

      -        }

      -

      -        // Main footer

      -        const actions: ActionItem[] = [{ key: '↑↓', label: 'Nav' }];

      -

      +        if (bodyView === REVIEW_BODY_VIEWS.DIFF) return <ActionFooter
      actions={REVIEW_FOOTER_ACTIONS.DIFF_VIEW}/>;

      +        if (bodyView === REVIEW_BODY_VIEWS.REASONING) return
      <ActionFooter actions={REVIEW_FOOTER_ACTIONS.REASONING_VIEW}/>;

      +        if (bodyView === REVIEW_BODY_VIEWS.SCRIPT_OUTPUT) return
      <ActionFooter actions={REVIEW_FOOTER_ACTIONS.SCRIPT_OUTPUT_VIEW}/>;

      +        if (bodyView === REVIEW_BODY_VIEWS.BULK_REPAIR) return
      <Text>{REVIEW_FOOTER_ACTIONS.BULK_REPAIR_VIEW.text}</Text>;

      +        if (bodyView === REVIEW_BODY_VIEWS.BULK_INSTRUCT) return
      <Text>{REVIEW_FOOTER_ACTIONS.BULK_INSTRUCT_VIEW.text}</Text>;

      +        if (bodyView === REVIEW_BODY_VIEWS.CONFIRM_HANDOFF) return
      <ActionFooter actions={REVIEW_FOOTER_ACTIONS.HANDOFF_CONFIRM_VIEW}/>;

      +

      +        // Dynamic Main footer
               const currentItem = navigableItems[selectedItemIndex];
      -        

      +        const hasFailedFiles =
      Array.from(fileReviewStates.values()).some(s => s.status === 'FAILED');

      +        const fileState = currentItem?.type === 'file' ?
      fileReviewStates.get(currentItem.id) : undefined;

      +

      +        const footerConfig = {

      +            isFileSelected: currentItem?.type === 'file',

      +            fileStatus: fileState?.status as 'FAILED' | 'REJECTED' |
      'OTHER' | undefined,

      +            currentItemType: currentItem?.type as 'file' | 'script' |
      'reasoning' | 'prompt' | undefined,

      +            hasFailedFiles,

      +            hasRejectedFiles,

      +            hasApprovedFiles: approvedFilesCount > 0,

      +        };

      -        if (currentItem?.type === 'file') {

      -            const selectedFile = files.find(f => f.id ===
      currentItem.id);

      -            const fileState = fileReviewStates.get(currentItem.id);

      -            if (fileState?.status !== 'FAILED') {

      -                actions.push({ key: 'Spc', label: 'Toggle' });

      -            }

      -            actions.push({ key: 'D', label: 'Diff' });

      -            

      -            // Add repair options for failed files

      -            if (selectedFile && fileState?.status === 'FAILED') {

      -                actions.push({ key: 'T', label: 'Try Repair' });

      -            }

      -            if (selectedFile && fileState?.status === 'REJECTED') {

      -                actions.push({ key: 'I', label: 'Instruct' });

      -            }

      -        } else if (currentItem?.type === 'script') {

      -            actions.push({ key: 'Ent', label: 'Expand Details' });

      -        } else { // Prompt or Reasoning

      -            actions.push({ key: 'Ent', label: 'Expand' });

      -        }

      -

      -        if (currentItem?.type !== 'reasoning') {

      -            actions.push({ key: 'R', label: 'Reasoning' });

      -        }

      -

      -        // Add bulk repair if there are failed files

      -        const hasFailedFiles =
      Array.from(fileReviewStates.values()).some(s => s.status === 'FAILED');

      -        if (hasFailedFiles) {

      -            actions.push({ key: 'Shift+T', label: 'Bulk Repair' });

      -        }

      -        // Add bulk instruct if there are rejected files

      -        if (hasRejectedFiles) {

      -            actions.push({ key: 'Shift+I', label: 'Bulk Instruct' });

      -        }

      -        

      -        actions.push({ key: 'C', label: 'Copy' });

      -

      -        if (approvedFilesCount > 0) {

      -            actions.push({ key: 'A', label: 'Approve' });

      -        }

      -

      -        if (Array.from(fileReviewStates.values()).some(s => s.status ===
      'APPROVED' || s.status === 'FAILED')) {

      -            actions.push({ key: 'Shift+R', label: 'Reject All' });

      -        }

      -        actions.push({ key: 'Q', label: 'Quit' });

      -

      -        return <ActionFooter actions={actions} />;

      +        return <ActionFooter
      actions={REVIEW_FOOTER_ACTIONS.MAIN_VIEW(footerConfig)} />;
           };
       
           return (
      @@ -402,7 +346,7 @@
                           </Text>
                           <Text color={navigableItems[selectedItemIndex]?.type === 'reasoning' ? 'cyan' : undefined}>
                               {navigableItems[selectedItemIndex]?.type === 'reasoning' ? '> ' : '  '}
      -                        (R)easoning ({(reasoning ||
      '').split('\n\n').length} steps) {bodyView === 'reasoning' ? '▾' : '▸'}{'
      '}

      +                        (R)easoning ({(reasoning ||
      '').split('\n\n').length} steps) {bodyView === REVIEW_BODY_VIEWS.REASONING
      ? '▾' : '▸'}{' '}
                               {((reasoning || '').split('\n')[0] ?? '').substring(0, 50)}...
                           </Text>
                       </Box>
      @@ -420,7 +364,7 @@
                                   
                                   const isSelected = selectedItemIndex === viewOffset + itemInViewIndex;
                                   return (
      -                                <ScriptItemRow key={script.command}
      script={script} isSelected={isSelected} isExpanded={bodyView ===
      'script_output' && isSelected} />

      +                                <ScriptItemRow key={script.command}
      script={script} isSelected={isSelected} isExpanded={bodyView ===
      REVIEW_BODY_VIEWS.SCRIPT_OUTPUT && isSelected} />
                                   );
                               })}
                           </Box>
      @@ -438,19 +382,14 @@
                           const reviewState = fileReviewStates.get(file.id);
                           
                           return (
      -                        <FileItemRow

      -                            key={file.id} file={file}
      isFocused={isFocused}

      -                            reviewStatus={reviewState?.status ||
      'AWAITING'}

      -                            reviewError={reviewState?.error}

      -                            reviewDetails={reviewState?.details}

      -                        />

      +                        <FileItemRow key={file.id} file={file}
      isFocused={isFocused} reviewState={reviewState || { status: 'AWAITING' }}
      />
                           );
                       })}
                   </Box>
                   
                   <Separator />
                   
                   {/* Body Viewport */}
      -            {bodyView !== 'none' && (

      +            {bodyView !== REVIEW_BODY_VIEWS.NONE && (
                       <>
                           <Box marginY={1}>
                               {renderBody()}

    patchStrategy: standard-diff
  - type: write
    path: src/components/TransactionDetailScreen.tsx
    content: >+
      --- src/components/TransactionDetailScreen.tsx

      +++ src/components/TransactionDetailScreen.tsx

      @@ -4,16 +4,8 @@
       import ReasonScreen from './ReasonScreen';
       import { useTransactionDetailScreen } from '../hooks/useTransactionDetailScreen';
       import type { FileChangeType } from '../types/domain.types';
      +import { DETAIL_BODY_VIEWS, DETAIL_FOOTER_ACTIONS, FILE_CHANGE_TYPE_ICONS
      } from '../constants/detail.constants';
       import ActionFooter from './ActionFooter';
      -import type { ActionItem } from '../types/actions.types';

      -

      -const getFileChangeTypeIcon = (type: FileChangeType) => {

      -    switch (type) {

      -        case 'MOD': return '[MOD]';

      -        case 'ADD': return '[ADD]';

      -        case 'DEL': return '[DEL]';

      -        case 'REN': return '[REN]';

      -    }

      -};
       
       const RevertModal = ({ transactionHash }: { transactionHash: string }) => {
           return (
      @@ -74,7 +66,7 @@
                                    return (
                                       <Text key={file.id} color={isFileSelected ? 'cyan' : undefined}>
                                           {isFileSelected ? '> ' : '  '}
      -                                    {getFileChangeTypeIcon(file.type)}
      {file.path}{stats}

      +                                    {FILE_CHANGE_TYPE_ICONS[file.type]}
      {file.path}{stats}
                                       </Text>
                                   );
                               })}
      @@ -84,10 +76,10 @@
           };
       
           const renderBody = () => {
      -        if (bodyView === 'NONE') {

      +        if (bodyView === DETAIL_BODY_VIEWS.NONE) {
                   return <Text color="gray">(Press → to expand a section and view its contents)</Text>;
               }
      -        if (bodyView === 'PROMPT') {

      +        if (bodyView === DETAIL_BODY_VIEWS.PROMPT) {
                   return (
                       <Box flexDirection="column">
                           <Text>PROMPT</Text>
      @@ -100,14 +92,14 @@
                       </Box>
                   );
               }
      -        if (bodyView === 'REASONING') {

      +        if (bodyView === DETAIL_BODY_VIEWS.REASONING) {
                   if (!transaction.reasoning) return <Text color="gray">No reasoning provided.</Text>;
                   return <ReasonScreen reasoning={transaction.reasoning} scrollIndex={contentScrollIndex} visibleLinesCount={Math.max(1, availableBodyHeight)} />;
               }
      -        if (bodyView === 'FILES_LIST') {

      +        if (bodyView === DETAIL_BODY_VIEWS.FILES_LIST) {
                    return <Text color="gray">(Select a file and press → to view the diff)</Text>;
               }
      -        if (bodyView === 'DIFF_VIEW') {

      +        if (bodyView === DETAIL_BODY_VIEWS.DIFF_VIEW) {
                   const fileId = focusedItemPath.split('/')[1];
                   const file = files.find(f => f.id === fileId);
                   if (!file) return null;
      @@ -117,55 +109,24 @@
           };
       
           const renderFooter = () => {
      -        if (bodyView === 'REVERT_CONFIRM') {

      -            return <ActionFooter actions={[

      -                { key: 'Enter', label: 'Confirm Revert' },

      -                { key: 'Esc', label: 'Cancel' },

      -            ]} />;

      +        if (bodyView === DETAIL_BODY_VIEWS.REVERT_CONFIRM) {

      +            return <ActionFooter
      actions={DETAIL_FOOTER_ACTIONS.REVERT_CONFIRM} />;
               }
               
               const isFileFocused = focusedItemPath.includes('/');
      -        const baseActions: ActionItem[] = [

      -            { key: 'C', label: 'Copy' },

      -            { key: 'O', label: isFileFocused ? 'Open File' : 'Open YAML'
      },

      -            { key: 'U', label: 'Undo' },

      -            { key: 'Q', label: 'Quit/Back' },

      -        ];

      -        let contextualActions: ActionItem[] = [];

      +        const openActionLabel = isFileFocused ? 'Open File' : 'Open
      YAML';

      +        const baseActions = DETAIL_FOOTER_ACTIONS.BASE(openActionLabel);
       
               if (isFileFocused) { // Is a file
      -            if (bodyView === 'DIFF_VIEW') {

      -                contextualActions = [

      -                    { key: '↑↓', label: 'Nav Files' },

      -                    { key: '←', label: 'Back to List' },

      -                ];

      +            if (bodyView === DETAIL_BODY_VIEWS.DIFF_VIEW) {

      +                return <ActionFooter
      actions={[...DETAIL_FOOTER_ACTIONS.DIFF_VIEW, ...baseActions]} />;
                   } else {
      -                contextualActions = [

      -                    { key: '↑↓', label: 'Nav Files' },

      -                    { key: '→', label: 'View Diff' },

      -                    { key: '←', label: 'Back to Sections' },

      -                ];

      +                return <ActionFooter
      actions={[...DETAIL_FOOTER_ACTIONS.FILE_LIST_VIEW, ...baseActions]} />;
                   }
      -            return <ActionFooter actions={[...contextualActions,
      ...baseActions]} />;
               }
               
               if (expandedItemPaths.has(focusedItemPath)) {
      -            contextualActions = [

      -                { key: '↑↓', label: 'Nav/Scroll' },

      -                { key: '→', label: 'Drill In' },

      -                { key: '←', label: 'Collapse' },

      -            ];

      -        } else {

      -            contextualActions = [

      -                { key: '↑↓', label: 'Nav' },

      -                { key: '→', label: 'Expand' },

      -            ];

      +            return <ActionFooter
      actions={[...DETAIL_FOOTER_ACTIONS.SECTION_EXPANDED, ...baseActions]} />;
               }
      -        return <ActionFooter actions={[...contextualActions,
      ...baseActions]} />;

      +        return <ActionFooter
      actions={[...DETAIL_FOOTER_ACTIONS.SECTION_COLLAPSED, ...baseActions]} />;
           };
       
           const { message, timestamp, status } = transaction;
      @@ -178,10 +139,10 @@
                   <Separator />
                   
                   {/* Modal takeover for Revert */}
      -            {bodyView === 'REVERT_CONFIRM' && <RevertModal
      transactionHash={transaction.hash} />}

      +            {bodyView === DETAIL_BODY_VIEWS.REVERT_CONFIRM &&
      <RevertModal transactionHash={transaction.hash} />}
                   
                   {/* Main view */}
      -            <Box flexDirection="column" display={bodyView ===
      'REVERT_CONFIRM' ? 'none' : 'flex'}>

      +            <Box flexDirection="column" display={bodyView ===
      DETAIL_BODY_VIEWS.REVERT_CONFIRM ? 'none' : 'flex'}>
                       {/* Navigator Part A */}
                       <Box flexDirection="column" marginY={1}>
                           <Text>UUID: {transaction.id}</Text>

    patchStrategy: standard-diff
  - type: write
    path: src/components/TransactionHistoryScreen.tsx
    content: >+
      --- src/components/TransactionHistoryScreen.tsx

      +++ src/components/TransactionHistoryScreen.tsx

      @@ -6,7 +6,7 @@
       import Separator from './Separator';
       import type { Transaction, FileItem } from '../types/domain.types';
       import { useTransactionHistoryScreen } from '../hooks/useTransactionHistoryScreen';
      -import type { LayoutConfig } from '../hooks/useLayout';

      +import { HISTORY_FOOTER_ACTIONS, TRANSACTION_STATUS_UI, FILE_TYPE_MAP,
      BULK_ACTIONS_OPTIONS, HISTORY_VIEW_MODES } from
      '../constants/history.constants';
       import ActionFooter from './ActionFooter';
       import type { ActionItem } from '../types/actions.types';
       
      @@ -53,8 +53,7 @@
           isLoading: boolean;
       }) => {
           const icon = isExpanded ? '▾' : '▸';
      -    const typeMap = { MOD: '[MOD]', ADD: '[ADD]', DEL: '[DEL]', REN:
      '[REN]' };

      -    

      +
           return (
               <Box flexDirection="column" paddingLeft={6}>
                   <Text color={isSelected ? 'cyan' : undefined}>
      @@ -78,19 +77,11 @@
           hasSelection: boolean;
       }) => {
           const icon = isExpanded ? '▾' : '▸';
      -    const statusMap = {

      -        COMMITTED: <Text color="green">✓ Committed</Text>,

      -        HANDOFF: <Text color="magenta">→ Handoff</Text>,

      -        REVERTED: <Text color="gray">↩ Reverted</Text>,

      -        APPLIED: <Text color="blue">✓ Applied</Text>,

      -        PENDING: <Text color="yellow">? Pending</Text>,

      -        FAILED: <Text color="red">✗ Failed</Text>,

      -    };

      +    const uiStatus = TRANSACTION_STATUS_UI[tx.status as keyof typeof
      TRANSACTION_STATUS_UI] || { text: tx.status, color: 'white' };

      +
           const date = new Date(tx.timestamp).toISOString().split('T')[0];
           const selectionIndicator = isSelectedForAction ? '[x] ' : '[ ] ';
           
      -    const statusDisplay = statusMap[tx.status as keyof typeof statusMap]
      || tx.status;

      -
           return (
               <Box flexDirection="column" marginBottom={isExpanded ? 1 : 0}>
                   <Text color={isSelected ? 'cyan' : undefined}>
                       {isSelected ? '> ' : '  '}
                       {hasSelection && selectionIndicator}
      -                {icon} {statusDisplay} · {tx.hash} · {date} ·{' '}

      +                {icon} <Text
      color={uiStatus.color}>{uiStatus.text}</Text> · {tx.hash} · {date} ·{' '}
                       {tx.message}
                   </Text>
                   {isExpanded && (
      @@ -113,10 +104,7 @@
                   <Box marginY={1}>
                       <Text>This action is often irreversible. Are you sure?</Text>
                   </Box>
      -            <Text>(1) Revert Selected Transactions</Text>

      -            <Text>(2) Mark as &apos;Git Committed&apos;</Text>

      -            <Text>(3) Delete Selected Transactions (from Relaycode
      history)</Text>

      -            <Text>(Esc) Cancel</Text>

      +            {BULK_ACTIONS_OPTIONS.map(opt => <Text
      key={opt}>{opt}</Text>)}
               </Box>
           );
       };
      @@ -137,42 +125,24 @@
               showingStatus,
               statsStatus,
               hasSelection,
      -    } = useTransactionHistoryScreen({

      -        layoutConfig: {

      -            header: 1,

      -            separators: 2, // after header, after list

      -            fixedRows: 1, // filter row

      -            marginsY: 1, // for list

      -            footer: 2,

      -        },

      -    });

      +    } = useTransactionHistoryScreen();
       
           const transactionsById = useMemo(() => new Map(transactions.map(tx => [tx.id, tx])), [transactions]);
       
           const renderFooter = () => {
      -        if (mode === 'FILTER') return <Text>(Enter) Apply Filter &
      Return      (Esc) Cancel</Text>; 

      -        if (mode === 'BULK_ACTIONS') return <Text>Choose an option [1-3]
      or (Esc) Cancel</Text>;

      +        if (mode === HISTORY_VIEW_MODES.FILTER) {

      +            return <ActionFooter
      actions={HISTORY_FOOTER_ACTIONS.FILTER_MODE} />;

      +        }

      +        if (mode === HISTORY_VIEW_MODES.BULK_ACTIONS) {

      +            return <Text>{HISTORY_FOOTER_ACTIONS.BULK_MODE.text}</Text>;

      +        }
               
               const openActionLabel = selectedItemPath.includes('/file/') ? 'Open File' : 'Open YAML';
      -        const footerActions: ActionItem[] = [

      -            { key: '↑↓/PgUp/PgDn', label: 'Nav' },

      -            { key: '→', label: 'Expand' },

      -            { key: '←', label: 'Collapse' },

      -            { key: 'Spc', label: 'Select' },

      -            { key: 'Ent', label: 'Details' },

      -            { key: 'O', label: openActionLabel },

      -            { key: 'F', label: 'Filter' },

      -        ];

      -

      -        if (selectedForAction.size > 0) {

      -            footerActions.push({ key: 'C', label: 'Copy' }, { key: 'B',
      label: 'Bulk' });

      -        }

      -        return <ActionFooter actions={footerActions} />;

      +        return <ActionFooter
      actions={HISTORY_FOOTER_ACTIONS.LIST_MODE(openActionLabel, hasSelection)}
      />;
           };
       
           return (
               <Box flexDirection="column">
                   <Text color="cyan">▲ relaycode transaction history</Text>
                   <Separator />
       
                   <Box>
                       <Text>Filter: </Text>
      -                {mode === 'FILTER' ? (

      +                {mode === HISTORY_VIEW_MODES.FILTER ? (
                           <TextInput value={filterQuery} onChange={actions.setFilterQuery} />
                       ) : (
                           <Text>{filterStatus}</Text>
      @@ -182,9 +152,9 @@
                   </Box>
       
                   <Box flexDirection="column" marginY={1}>
      -                {mode === 'BULK_ACTIONS' && <BulkActionsMode
      selectedForActionCount={selectedForAction.size} />}

      -

      -                {mode === 'LIST' && itemsInView.map(path => {

      +                {mode === HISTORY_VIEW_MODES.BULK_ACTIONS &&
      <BulkActionsMode selectedForActionCount={selectedForAction.size} />}

      +

      +                {mode === HISTORY_VIEW_MODES.LIST && itemsInView.map(path
      => {
                           const txId = path.split('/')[0]!;
                           const tx = transactionsById.get(txId);
                           if (!tx) return <Text key={path}>Error: Missing TX {txId}</Text>;

    patchStrategy: standard-diff
snapshot:
  src/constants/debug.constants.ts: null
  src/constants/review.constants.ts: |-
    import type { ApplyStep } from '../stores/review.store';

    /**
     * Constants for the Review screen and process.
     */
    export const INITIAL_APPLY_STEPS: ApplyStep[] = [
        { id: 'snapshot', title: 'Reading initial file snapshot...', status: 'pending' },
        { id: 'memory', title: 'Applying operations to memory...', status: 'pending', substeps: [] },
        { id: 'post-command', title: 'Running post-command script...', status: 'pending', substeps: [] },
        { id: 'linter', title: 'Analyzing changes with linter...', status: 'pending', substeps: [] },
    ];

    export const REVIEW_BODY_VIEWS = {
        DIFF: 'diff',
        REASONING: 'reasoning',
        SCRIPT_OUTPUT: 'script_output',
        BULK_REPAIR: 'bulk_repair',
        CONFIRM_HANDOFF: 'confirm_handoff',
        BULK_INSTRUCT: 'bulk_instruct',
        NONE: 'none',
    } as const;

    export const PATCH_STATUS = {
        SUCCESS: 'SUCCESS',
        PARTIAL_FAILURE: 'PARTIAL_FAILURE',
    } as const;

    export const FILE_STATUS_UI = {
        APPROVED: { icon: '[✓]', color: 'green' },
        REJECTED: { icon: '[✗]', color: 'red' },
        FAILED: { icon: '[!]', color: 'red' },
        AWAITING: { icon: '[●]', color: 'yellow' },
        RE_APPLYING: { icon: '[●]', color: 'cyan' },
    } as const;

    export const BULK_REPAIR_OPTIONS = [
        '(1) Copy Bulk Re-apply Prompt (for single-shot AI)',
        '(2) Bulk Change Strategy & Re-apply',
        '(3) Handoff to External Agent',
        '(4) Bulk Abandon All Failed Files',
        '(Esc) Cancel',
    ] as const;

    export const BULK_INSTRUCT_OPTIONS = [
        `(1) Copy Bulk Re-instruct Prompt (for single-shot AI)`,
        '(2) Handoff to External Agent',
        `(3) Bulk Un-reject All Files (revert to original)`,
        '(4) Cancel',
    ] as const;
  src/config/ui.config.ts: |-
    /**
     * Centralized UI configuration.
     * This object is the single source of truth for layout constants, thresholds,
     * and other UI-related magic numbers.
     */
    export const UI_CONFIG = {
        diffScreen: {
            collapseThreshold: 20, // Lines before collapsing
            collapseShowLines: 8,  // Lines to show at top/bottom when collapsed
        },
        splash: {
            initialCountdown: 3, // Seconds before auto-skip
        },
        footer: {
            horizontalPadding: 2, // Minimum space from the left/right edges of the screen
            actionSeparator: ' · ',
        },
        layout: {
            dashboard: {
                header: 1,
                separators: 2,
                fixedRows: 2, // status bar, event stream header
                marginsY: 3, // for status bar, event stream list, separator
                footer: 2,
            },
            copyScreen: {
                header: 1,
                separators: 2,
                fixedRows: 2, // title, status
                marginsY: 1,
                footer: 1,
            },
            debugLog: {
                paddingY: 2,
                header: 1,
                separators: 2,
                fixedRows: 1, // filter line
                marginsY: 1,
                footer: 1,
            },
            debugMenu: {
                paddingY: 2,
                header: 1,
                separators: 2,
                footer: 1,
            },
            history: {
                header: 1,
                separators: 2,
                fixedRows: 1, // filter row
                marginsY: 1,
                footer: 2,
            },
        },
    } as const;
  src/stores/detail.store.ts: >-
    import { create } from 'zustand';

    import { useTransactionStore } from './transaction.store';

    import { useViewStore } from './view.store';

    import { TransactionService } from '../services/transaction.service';

    import { NAVIGATOR_SECTIONS, DETAIL_BODY_VIEWS } from
    '../constants/detail.constants';

    import { findNextPath, findPrevPath, getParentPath } from
    './navigation.utils';


    type ObjectValues<T> = T[keyof T];


    export type NavigatorSection = ObjectValues<typeof NAVIGATOR_SECTIONS>;

    export type DetailBodyView = ObjectValues<typeof DETAIL_BODY_VIEWS>;


    // Omit 'actions' from state type for partial updates

    type DetailStateData = Omit<DetailState, 'actions'>;
     
    interface DetailState {
        focusedItemPath: string; // e.g., 'PROMPT', 'FILES', 'FILES/1-1'
        expandedItemPaths: Set<string>;
        bodyView: DetailBodyView;
        actions: {
            load: (transactionId: string, initialState?: Partial<DetailStateData>) => void;
            navigateUp: () => void;
            navigateDown: () => void;
            expandOrDrillDown: () => void;
            collapseOrBubbleUp: () => void;
            toggleRevertConfirm: () => void;
            confirmRevert: () => void;
        };
    }


    const getVisibleItemPaths = (expandedItemPaths: Set<string>): string[] => {
        const { selectedTransactionId } = useViewStore.getState();
        const transaction = useTransactionStore.getState().transactions.find(tx => tx.id === selectedTransactionId);
        if (!transaction) return [];

        const paths: string[] = [NAVIGATOR_SECTIONS.PROMPT, NAVIGATOR_SECTIONS.REASONING, NAVIGATOR_SECTIONS.FILES];
        if (expandedItemPaths.has(NAVIGATOR_SECTIONS.FILES) && transaction.files) {
            for (const file of transaction.files) {
                paths.push(`${NAVIGATOR_SECTIONS.FILES}/${file.id}`);
            }
        }
        return paths;
    };


    export const useDetailStore = create<DetailState>((set, get) => ({
        focusedItemPath: NAVIGATOR_SECTIONS.PROMPT,
        expandedItemPaths: new Set(),
        bodyView: DETAIL_BODY_VIEWS.NONE,
        actions: {
            load: (transactionId, initialState) => {
                useViewStore.getState().actions.setSelectedTransactionId(transactionId);
                set({
                    focusedItemPath: NAVIGATOR_SECTIONS.PROMPT,
                    expandedItemPaths: new Set(),
                    bodyView: DETAIL_BODY_VIEWS.NONE,
                    ...initialState,
                });
            },
            navigateUp: () => {
                const { expandedItemPaths, focusedItemPath } = get();
                const visibleItems = getVisibleItemPaths(expandedItemPaths);
                set({ focusedItemPath: findPrevPath(focusedItemPath, visibleItems) });
            },
            navigateDown: () => {
                const { expandedItemPaths, focusedItemPath } = get();
                const visibleItems = getVisibleItemPaths(expandedItemPaths);
                set({ focusedItemPath: findNextPath(focusedItemPath, visibleItems) });
            },
            expandOrDrillDown: () => set(state => {
                const { focusedItemPath, expandedItemPaths } = state;
                const newExpandedPaths = new Set(expandedItemPaths);
                
                if (focusedItemPath.includes('/')) { // Is a file
                    return { bodyView: DETAIL_BODY_VIEWS.DIFF_VIEW };
                }

                // Is a section header
                if (newExpandedPaths.has(focusedItemPath)) {
                    // Already expanded, drill in if it's FILES
                    if (focusedItemPath === NAVIGATOR_SECTIONS.FILES) {
                        const visibleItems = getVisibleItemPaths(newExpandedPaths);
                        const firstFile = visibleItems.find(item => item.startsWith(`${NAVIGATOR_SECTIONS.FILES}/`));
                        if (firstFile) {
                            return { focusedItemPath: firstFile, bodyView: DETAIL_BODY_VIEWS.FILES_LIST };
                        }
                    }
                    return {}; // No-op for PROMPT/REASONING if already expanded
                } else {
                    // Not expanded, so expand it
                    newExpandedPaths.add(focusedItemPath);
                    let newBodyView: DetailBodyView = DETAIL_BODY_VIEWS.NONE;
                    if (focusedItemPath === NAVIGATOR_SECTIONS.PROMPT) newBodyView = DETAIL_BODY_VIEWS.PROMPT;
                    if (focusedItemPath === NAVIGATOR_SECTIONS.REASONING) newBodyView = DETAIL_BODY_VIEWS.REASONING;
                    if (focusedItemPath === NAVIGATOR_SECTIONS.FILES) newBodyView = DETAIL_BODY_VIEWS.FILES_LIST;
                    return { expandedItemPaths: newExpandedPaths, bodyView: newBodyView };
                }
            }),
            collapseOrBubbleUp: () => set(state => {
                const { focusedItemPath, expandedItemPaths, bodyView } = state;
                
                if (bodyView === DETAIL_BODY_VIEWS.DIFF_VIEW) {
                    return { bodyView: DETAIL_BODY_VIEWS.FILES_LIST };
                }

                if (getParentPath(focusedItemPath)) { // Is a file
                    return { focusedItemPath: NAVIGATOR_SECTIONS.FILES, bodyView: DETAIL_BODY_VIEWS.FILES_LIST };
                }
                
                // Is a section header
                if (expandedItemPaths.has(focusedItemPath)) {
                    const newExpandedPaths = new Set(expandedItemPaths);
                    newExpandedPaths.delete(focusedItemPath);
                    return { expandedItemPaths: newExpandedPaths, bodyView: DETAIL_BODY_VIEWS.NONE };
                }
                
                return {}; // No-op if not expanded (global back will handle)
            }),
            toggleRevertConfirm: () => set(state => ({
                bodyView: state.bodyView === DETAIL_BODY_VIEWS.REVERT_CONFIRM
                    ? DETAIL_BODY_VIEWS.NONE
                    : DETAIL_BODY_VIEWS.REVERT_CONFIRM,
            })),
            confirmRevert: () => {
                const { selectedTransactionId } = useViewStore.getState();
                if (!selectedTransactionId) return;
                TransactionService.revertTransaction(selectedTransactionId);
                useTransactionStore.getState().actions.updateTransactionStatus(selectedTransactionId, 'REVERTED');
                set({ bodyView: DETAIL_BODY_VIEWS.NONE });
            },
        },
    }));
  src/stores/history.store.ts: >-
    import { create } from 'zustand';

    import { useTransactionStore } from './transaction.store';

    import { getVisibleItemPaths, findNextPath, findPrevPath, getParentPath }
    from './navigation.utils';

    import { HISTORY_VIEW_MODES, HISTORY_ITEM_PATH_SEGMENTS } from
    '../constants/history.constants';

    import { sleep } from '../utils';


    export type HistoryViewMode = (typeof HISTORY_VIEW_MODES)[keyof typeof
    HISTORY_VIEW_MODES];
     
    // Omit 'actions' from state type for partial updates

    type HistoryStateData = Omit<HistoryState, 'actions'>;


    interface HistoryState {
        mode: HistoryViewMode;
        selectedItemPath: string;
        expandedIds: Set<string>;
        loadingPaths: Set<string>;
        filterQuery: string;
        selectedForAction: Set<string>;
        actions: {
            load: (initialState?: Partial<HistoryStateData>) => void;
            navigateDown: () => void;
            navigateUp: () => void;
            navigatePageUp: (viewportHeight: number) => void;
            navigatePageDown: (viewportHeight: number) => void;
            expandOrDrillDown: () => Promise<void>;
            collapseOrBubbleUp: () => void;
            toggleSelection: () => void;
            setMode: (mode: HistoryViewMode) => void;
            setFilterQuery: (query: string) => void;
            applyFilter: () => void;
            prepareDebugState: (stateName: 'l1-drill-content' | 'l2-drill-reasoning' | 'l2-drill-diff' | 'filter' | 'copy' | 'bulk') => void;
        };
    }


    export const useHistoryStore = create<HistoryState>((set, get) => ({
        mode: HISTORY_VIEW_MODES.LIST,
        selectedItemPath: '',
        expandedIds: new Set(),
        loadingPaths: new Set(),
        filterQuery: '',
        selectedForAction: new Set(),
        actions: {
            load: (initialState) => {
                const { transactions } = useTransactionStore.getState();
                set({
                    selectedItemPath: transactions[0]?.id || '',
                    mode: HISTORY_VIEW_MODES.LIST,
                    expandedIds: new Set(),
                    loadingPaths: new Set(),
                    selectedForAction: new Set(),
                    filterQuery: '',
                    ...initialState,
                });
            },
            navigateUp: () => {
                const { expandedIds, selectedItemPath } = get();
                const { transactions } = useTransactionStore.getState();
                const visibleItems = getVisibleItemPaths(transactions, expandedIds);
                set({ selectedItemPath: findPrevPath(selectedItemPath, visibleItems) });
            },
            navigateDown: () => {
                const { expandedIds, selectedItemPath } = get();
                const { transactions } = useTransactionStore.getState();
                const visibleItems = getVisibleItemPaths(transactions, expandedIds);
                set({ selectedItemPath: findNextPath(selectedItemPath, visibleItems) });
            },
            navigatePageUp: (viewportHeight: number) => {
                const { expandedIds, selectedItemPath } = get();
                const { transactions } = useTransactionStore.getState();
                const visibleItems = getVisibleItemPaths(transactions, expandedIds);

                const currentIndex = visibleItems.indexOf(selectedItemPath);
                if (currentIndex === -1) return;

                const newIndex = Math.max(0, currentIndex - viewportHeight);
                set({ selectedItemPath: visibleItems[newIndex]! });
            },
            navigatePageDown: (viewportHeight: number) => {
                const { expandedIds, selectedItemPath } = get();
                const { transactions } = useTransactionStore.getState();
                const visibleItems = getVisibleItemPaths(transactions, expandedIds);

                const currentIndex = visibleItems.indexOf(selectedItemPath);
                if (currentIndex === -1) return;

                const newIndex = Math.min(visibleItems.length - 1, currentIndex + viewportHeight);
                set({ selectedItemPath: visibleItems[newIndex]! });
            },
            expandOrDrillDown: async () => {
                const { selectedItemPath, expandedIds } = get();
                if (expandedIds.has(selectedItemPath)) return;

                // Files and content items with potentially large data can show a loading state
                const isLoadable = selectedItemPath.includes(HISTORY_ITEM_PATH_SEGMENTS.FILE) ||
                                   selectedItemPath.includes(HISTORY_ITEM_PATH_SEGMENTS.PROMPT) ||
                                   selectedItemPath.includes(HISTORY_ITEM_PATH_SEGMENTS.REASONING);

                if (isLoadable) {
                    set(state => ({ loadingPaths: new Set(state.loadingPaths).add(selectedItemPath) }));
                    await sleep(250); // Simulate loading
                    set(state => {
                        const newLoadingPaths = new Set(state.loadingPaths);
                        newLoadingPaths.delete(selectedItemPath);
                        const newExpandedIds = new Set(state.expandedIds).add(selectedItemPath);
                        return { loadingPaths: newLoadingPaths, expandedIds: newExpandedIds };
                    });
                } else { // For transactions or simple items, expand immediately
                    set(state => ({ expandedIds: new Set(state.expandedIds).add(selectedItemPath) }));
                }
            },
            collapseOrBubbleUp: () => set(state => {
                const { selectedItemPath, expandedIds } = state;
                const newExpandedIds = new Set(expandedIds);
                if (newExpandedIds.has(selectedItemPath)) {
                    newExpandedIds.delete(selectedItemPath);
                    // Recursively collapse children
                    for (const id of newExpandedIds) {
                        if (id.startsWith(`${selectedItemPath}/`)) {
                            newExpandedIds.delete(id);
                        }
                    }
                    return { expandedIds: newExpandedIds };
                }
                const parentId = getParentPath(selectedItemPath);
                if (parentId) {
                    return { selectedItemPath: parentId };
                }
                return {};
            }),
            toggleSelection: () => set(state => {
                const { selectedItemPath, selectedForAction } = state;
                const txId = getParentPath(selectedItemPath) || selectedItemPath;
                if (!txId) return {};
                const newSelection = new Set(selectedForAction);
                if (newSelection.has(txId)) {
                    newSelection.delete(txId);
                } else {
                    newSelection.add(txId);
                }
                return { selectedForAction: newSelection };
            }),
            setMode: (mode) => set({ mode }),
            setFilterQuery: (query) => set({ filterQuery: query }),
            applyFilter: () => {
                set({ mode: HISTORY_VIEW_MODES.LIST });
            },
            prepareDebugState: (stateName) => {
                const { actions } = get();
                switch (stateName) {
                    case 'l1-drill-content':
                        actions.load({ expandedIds: new Set(['3']), selectedItemPath: '3' });
                        break;
                    case 'l2-drill-reasoning':
                        actions.load({ expandedIds: new Set(['3', '3/reasoning']), selectedItemPath: '3/reasoning' });
                        break;
                    case 'l2-drill-diff':
                        actions.load({ expandedIds: new Set(['3', '3/file/3-1']), selectedItemPath: '3/file/3-1' });
                        break;
                    case 'filter':
                        actions.load({ mode: HISTORY_VIEW_MODES.FILTER, filterQuery: 'logger.ts status:COMMITTED' });
                        break;
                    case 'copy':
                        actions.load({ selectedForAction: new Set(['3', '6']) });
                        break;
                    case 'bulk':
                        actions.load({ mode: HISTORY_VIEW_MODES.BULK_ACTIONS, selectedForAction: new Set(['3', '6']) });
                        break;
                }
            },
        },
    }));
  src/stores/log.store.ts: |-
    import { create } from 'zustand';
    import type { LogEntry, LogLevel } from '../types/log.types';
    import { MAX_LOGS } from '../constants/log.constants';

    interface LogState {
        logs: LogEntry[];
        actions: {
            addLog: (level: LogLevel, message: string) => void;
            clearLogs: () => void;
        };
    }

    export const useLogStore = create<LogState>((set) => ({
        logs: [],
        actions: {
            addLog: (level, message) => {
                set(state => {
                    const newLog: LogEntry = {
                        level,
                        message,
                        timestamp: Date.now(),
                    };
                    // Prepend new log and trim the array to max size
                    const updatedLogs = [newLog, ...state.logs].slice(0, MAX_LOGS);
                    return { logs: updatedLogs };
                });
            },
            clearLogs: () => set({ logs: [] }),
        },
    }));
  src/hooks/useCopyScreen.tsx: |-
    import { useInput } from 'ink';
    import { useCopyStore } from '../stores/copy.store';
    import { useViewStore } from '../stores/view.store';
    import { useViewport } from './useViewport';
    import type { LayoutConfig } from './useLayout';

    export const useCopyScreen = () => {
        const activeOverlay = useViewStore(s => s.activeOverlay);
        const {
            title, items, selectedIndex, selectedIds, lastCopiedMessage,
            actions,
        } = useCopyStore(state => ({ ...state, actions: state.actions }));
        
        // Header, separator, title, margin, separator, status, footer
        const layoutConfig: LayoutConfig = { header: 1, separators: 2, fixedRows: 2, marginsY: 1, footer: 1 };
        
        const { viewOffset, viewportHeight } = useViewport({
            selectedIndex,
            layoutConfig,
        });

        useInput((input, key) => {
            if (key.escape) {
                actions.close();
                return;
            }
            if (key.upArrow) {
                actions.navigateUp();
                return;
            }
            if (key.downArrow) {
                actions.navigateDown();
                return;
            }
            if (key.pageUp) {
                actions.navigatePageUp(viewportHeight);
                return;
            }
            if (key.pageDown) {
                actions.navigatePageDown(viewportHeight);
                return;
            }
            if (input === ' ') {
                actions.toggleSelection();
                return;
            }
            if (key.return) {
                actions.executeCopy();
                return;
            }
            
            const item = items.find(i => i.key.toLowerCase() === input.toLowerCase());
            if(item) {
                actions.toggleSelectionById(item.id);
            }
        }, { isActive: activeOverlay === 'copy' });

        const itemsInView = items.slice(viewOffset, viewOffset + viewportHeight);

        return {
            title,
            itemsInView,
            selectedIndex,
            selectedIds,
            lastCopiedMessage,
            viewOffset,
        };
    };
  src/hooks/useDashboardScreen.tsx: >-
    import { useInput } from 'ink';

    import { useDashboardStore } from '../stores/dashboard.store';

    import { useAppStore } from '../stores/app.store';

    import { useCommitStore } from '../stores/commit.store';

    import { useTransactionStore, selectTransactionsByStatus } from
    '../stores/transaction.store';

    import { useReviewStore } from '../stores/review.store';

    import { useDetailStore } from '../stores/detail.store';

    import { useHistoryStore } from '../stores/history.store';

    import type { LayoutConfig } from './useLayout';

    import { useViewport } from './useViewport';


    export const useDashboardScreen = ({ layoutConfig }: { layoutConfig:
    LayoutConfig }) => {
        const {
            status,
            selectedTransactionIndex,
            expandedTransactionId,
        } = useDashboardStore();
        const transactions = useTransactionStore(s => s.transactions);
        const pendingTransactions = useTransactionStore(selectTransactionsByStatus('PENDING'));
        const appliedTransactions = useTransactionStore(selectTransactionsByStatus('APPLIED'));

        const { viewOffset, viewportHeight } = useViewport({
            selectedIndex: selectedTransactionIndex,
            layoutConfig,
        });

        const {
            togglePause,
            moveSelectionUp,
            moveSelectionDown,
            startApproveAll,
            confirmAction,
            cancelAction,
            toggleExpand,
        } = useDashboardStore(s => s.actions);
        const appActions = useAppStore(s => s.actions);
        const commitActions = useCommitStore(s => s.actions);

        const pendingApprovals = pendingTransactions.length;
        const pendingCommits = appliedTransactions.length;

        const isModal = status === 'CONFIRM_APPROVE';
        const isProcessing = status === 'APPROVING';

        useInput((input, key) => {
            if (isModal) {
                if (key.return) confirmAction();
                if (key.escape) cancelAction();
                return;
            }

            if (isProcessing) return; // No input while processing

            if (key.leftArrow) {
                if (expandedTransactionId) {
                    toggleExpand();
                }
                return;
            }
            if (key.rightArrow) {
                if (transactions[selectedTransactionIndex] && !expandedTransactionId) {
                    toggleExpand();
                }
                return;
            }

            if (key.upArrow) moveSelectionUp();
            if (key.downArrow) moveSelectionDown();
            
            if (key.return) {
                const selectedTx = transactions[selectedTransactionIndex];
                if (!selectedTx) return;
                
                const isExpanded = expandedTransactionId === selectedTx.id;

                if (isExpanded) {
                    if (selectedTx.status === 'PENDING') {
                        useReviewStore.getState().actions.load(selectedTx.id);
                        appActions.showReviewScreen();
                    } else {
                        useDetailStore.getState().actions.load(selectedTx.id);
                        appActions.showTransactionDetailScreen();
                    }
                } else {
                    toggleExpand();
                }
            }
            
            if (input.toLowerCase() === 'p') togglePause();
            if (input.toLowerCase() === 'a' && pendingApprovals > 0) startApproveAll();
            if (input.toLowerCase() === 'c' && pendingCommits > 0) {
                commitActions.prepareCommitScreen();
                appActions.showGitCommitScreen();
            }
            if (input.toLowerCase() === 'l') {
                useHistoryStore.getState().actions.load();
                appActions.showTransactionHistoryScreen();
            }
        });
        const transactionsToConfirm = status === 'CONFIRM_APPROVE' ? pendingTransactions : [];

        return {
            status,
            transactions,
            selectedTransactionIndex,
            expandedTransactionId,
            pendingApprovals,
            pendingCommits,
            isModal,
            isProcessing,
            viewOffset,
            viewportHeight,
            transactionsToConfirm,
        };
    };
  src/hooks/useDebugLogScreen.tsx: |-
    import { useState, useEffect, useMemo } from 'react';
    import { useInput } from 'ink';
    import { useLogStore } from '../stores/log.store';
    import { useViewStore } from '../stores/view.store';
    import { useViewport } from './useViewport';
    import { LoggerService } from '../services/logger.service';
    import type { LayoutConfig } from './useLayout';
    import { moveIndex } from '../stores/navigation.utils';

    export const useDebugLogScreen = () => {
        const logs = useLogStore(s => s.logs);
        const clearLogs = useLogStore(s => s.actions.clearLogs);
        const setActiveOverlay = useViewStore(s => s.actions.setActiveOverlay);

        const [selectedIndex, setSelectedIndex] = useState(0);
        const [mode, setMode] = useState<'LIST' | 'FILTER'>('LIST');
        const [filterQuery, setFilterQuery] = useState('');

        const filteredLogs = useMemo(() => logs.filter(log =>
            log.message.toLowerCase().includes(filterQuery.toLowerCase()),
        ), [logs, filterQuery]);

        // Reset index to top when filter changes
        useEffect(() => {
            setSelectedIndex(0);
        }, [filterQuery]);

        // Clamp index if it's out of bounds after logs change for other reasons
        useEffect(() => {
            if (selectedIndex >= filteredLogs.length) {
                setSelectedIndex(Math.max(0, filteredLogs.length - 1));
            }
        }, [filteredLogs.length, selectedIndex]);

        // Header, borders, footer, filter line
        const layoutConfig: LayoutConfig = { paddingY: 2, header: 1, separators: 2, fixedRows: 1, marginsY: 1, footer: 1 };

        const { viewOffset, viewportHeight } = useViewport({
            selectedIndex,
            layoutConfig,
        });

        useInput((input, key) => {
            if (mode === 'FILTER') {
                if (key.escape || key.return) {
                    setMode('LIST');
                }
                return;
            }

            if (key.escape) {
                setActiveOverlay('none');
                return;
            }
            if (key.upArrow) {
                setSelectedIndex(i => moveIndex(i, 'up', filteredLogs.length));
                return;
            }
            if (key.downArrow) {
                setSelectedIndex(i => moveIndex(i, 'down', filteredLogs.length));
                return;
            }
            if (key.pageUp) {
                setSelectedIndex(i => Math.max(0, i - viewportHeight));
                return;
            }
            if (key.pageDown) {
                setSelectedIndex(i => Math.min(filteredLogs.length - 1, i + viewportHeight));
                return;
            }
            if (input.toLowerCase() === 'c') {
                clearLogs();
                setFilterQuery('');
                setSelectedIndex(0);
                return;
            }
            if (input.toLowerCase() === 'f') {
                setMode('FILTER');
            }
        });

        useEffect(() => {
            LoggerService.startSimulator();
            return () => {
                LoggerService.stopSimulator();
            };
        }, []);

        const logsInView = filteredLogs.slice(viewOffset, viewOffset + viewportHeight);

        return {
            logsInView,
            logCount: logs.length,
            filteredLogCount: filteredLogs.length,
            selectedIndex,
            mode,
            filterQuery,
            setFilterQuery,
            viewOffset,
        };
    };
  src/hooks/useDebugMenu.tsx: |-
    import { useState } from 'react';
    import { useInput } from 'ink';
    import { useAppStore } from '../stores/app.store';
    import { useViewStore } from '../stores/view.store';
    import { useDashboardStore } from '../stores/dashboard.store';
    import { useReviewStore } from '../stores/review.store';
    import { useDetailStore } from '../stores/detail.store';
    import { useHistoryStore } from '../stores/history.store';
    import { useInitStore } from '../stores/init.store';
    import { useCommitStore } from '../stores/commit.store';
    import { useCopyStore } from '../stores/copy.store';
    import type { MenuItem } from '../types/debug.types';
    import { useTransactionStore } from '../stores/transaction.store';
    import { moveIndex } from '../stores/navigation.utils';
    import type { LayoutConfig } from './useLayout';
    import { useViewport } from './useViewport';
    export type { MenuItem } from '../types/debug.types';

    const useDebugMenuActions = () => {
        const { actions: appActions } = useAppStore();
        const { actions: initActions } = useInitStore();
        const { actions: commitActions } = useCommitStore();
        const { actions: dashboardActions } = useDashboardStore();
        const { actions: reviewActions } = useReviewStore();
        const { actions: detailActions } = useDetailStore();
        const { actions: historyActions } = useHistoryStore();

        const menuItems: MenuItem[] = [
            {
                title: 'View Debug Log',
                action: () => useViewStore.getState().actions.setActiveOverlay('log'),
            },
            {
                title: 'Splash Screen',
                action: () => appActions.showSplashScreen(),
            },
            {
                title: 'Init: Analyze Phase',
                action: () => {
                    initActions.setPhase('ANALYZE');
                    appActions.showInitScreen();
                },
            },
            {
                title: 'Init: Interactive Phase',
                action: () => {
                    initActions.setPhase('INTERACTIVE');
                    appActions.showInitScreen();
                },
            },
            {
                title: 'Init: Finalize Phase',
                action: () => {
                    initActions.setPhase('FINALIZE');
                    appActions.showInitScreen();
                },
            },
            {
                title: 'Dashboard: Listening',
                action: () => {
                    dashboardActions.setStatus('LISTENING');
                    appActions.showDashboardScreen();
                },
            },
            {
                title: 'Dashboard: Confirm Approve',
                action: () => {
                    dashboardActions.startApproveAll();
                    appActions.showDashboardScreen();
                },
            },
            {
                title: 'Dashboard: Approving',
                action: () => {
                    dashboardActions.setStatus('APPROVING');
                    appActions.showDashboardScreen();
                },
            },
            {
                title: 'Dashboard: Expanded View',
                action: () => {
                    dashboardActions.setStatus('LISTENING');
                    dashboardActions.setExpandedTransactionId('1');
                    appActions.showDashboardScreen();
                },
            },
            {
                title: 'Review: Partial Failure (Default)',
                action: () => {
                    reviewActions.load('1');
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Success',
                action: () => {
                    reviewActions.load('2');
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Diff View',
                action: () => {
                    reviewActions.load('1');
                    reviewActions.setBodyView('diff');
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Reasoning View',
                action: () => {
                    reviewActions.load('1', { bodyView: 'reasoning' });
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Copy Mode',
                action: () => {
                    reviewActions.load('1');
                    appActions.showReviewScreen();
                    const tx = useTransactionStore.getState().transactions.find(t => t.id === '1');
                    if (!tx) return;
                    // On load, selected index is 0, so we can assume the first file.
                    const selectedFile = tx.files && tx.files.length > 0
                        ? tx.files[0]
                        : undefined;
                    useCopyStore.getState().actions.openForReview(tx, tx.files || [], selectedFile);
                },
            },
            {
                title: 'Review: Script Output',
                action: () => {
                    reviewActions.load('2');
                    appActions.showReviewScreen();
                    reviewActions.setBodyView('script_output');
                },
            },
            {
                title: 'Review: Bulk Repair',
                action: () => {
                    reviewActions.load('1', { bodyView: 'bulk_repair' });
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Bulk Repair (Navigable)',
                action: () => {
                    reviewActions.load('1', { bodyView: 'bulk_repair', selectedBulkRepairOptionIndex: 1 });
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Bulk Instruct',
                action: () => {
                    reviewActions.load('2'); // Load success case
                    // Reject some files to enable the workflow
                    reviewActions.toggleFileApproval('2-1');
                    reviewActions.toggleFileApproval('2-2');
                    reviewActions.showBulkInstruct();
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Handoff Confirm',
                action: () => {
                    reviewActions.load('1', { bodyView: 'confirm_handoff' });
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review Processing',
                action: () => {
                    reviewActions.load('2'); // Use tx '2' which has scripts
                    appActions.showReviewProcessingScreen();
                },
            },
            {
                title: 'Git Commit Screen',
                action: () => {
                    commitActions.prepareCommitScreen();
                    appActions.showGitCommitScreen();
                },
            },
            {
                title: 'Transaction Detail Screen',
                action: () => {
                    // The dashboard store has transactions, we'll just pick one.
                    detailActions.load('3'); // 'feat: implement new dashboard UI'
                    appActions.showTransactionDetailScreen();
                },
            },
            {
                title: 'Detail: Copy Mode',
                action: () => {
                    detailActions.load('3');
                    appActions.showTransactionDetailScreen();
                    const tx = useTransactionStore.getState().transactions.find(t => t.id === '3');
                    if (!tx) return;
                    const selectedFile = tx.files?.[0];
                    useCopyStore.getState().actions.openForDetail(tx, selectedFile);
                },
            },
            {
                title: 'Detail: Diff View (for File Open action)',
                action: () => {
                    detailActions.load('3', {
                        focusedItemPath: 'FILES/3-1',
                        bodyView: 'DIFF_VIEW',
                        expandedItemPaths: new Set(['FILES']),
                    });
                    appActions.showTransactionDetailScreen();
                },
            },
            {
                title: 'Detail: Revert Confirm',
                action: () => {
                    detailActions.load('3', { bodyView: 'REVERT_CONFIRM' });
                    appActions.showTransactionDetailScreen();
                },
            },
            {
                title: 'Transaction History Screen',
                action: () => {
                    historyActions.load();
                    appActions.showTransactionHistoryScreen();
                },
            },
            {
                title: 'History: L1 Drilldown (Content)',
                action: () => {
                    historyActions.prepareDebugState('l1-drill-content');
                    appActions.showTransactionHistoryScreen();
                },
            },
            {
                title: 'History: L2 Drilldown (Reasoning)',
                action: () => {
                    historyActions.prepareDebugState('l2-drill-reasoning');
                    appActions.showTransactionHistoryScreen();
                },
            },
            {
                title: 'History: L2 Drilldown (for File Open action)',
                action: () => {
                    historyActions.prepareDebugState('l2-drill-diff');
                    appActions.showTransactionHistoryScreen();
                },
            },
            {
                title: 'History: Filter Mode',
                action: () => {
                    historyActions.prepareDebugState('filter');
                    appActions.showTransactionHistoryScreen();
                },
            },
            {
                title: 'History: Copy Mode',
                action: () => {
                    historyActions.prepareDebugState('copy');
                    appActions.showTransactionHistoryScreen();
                    const { transactions } = useTransactionStore.getState();
                    const { selectedForAction } = useHistoryStore.getState();
                    const txsToCopy = transactions.filter(tx => selectedForAction.has(tx.id));
                    useCopyStore.getState().actions.openForHistory(txsToCopy);
                },
            },
            {
                title: 'History: Bulk Actions Mode',
                action: () => {
                    historyActions.prepareDebugState('bulk');
                    appActions.showTransactionHistoryScreen();
                },
            },
        ];
        return { menuItems };
    };

    export const useDebugMenu = () => {
        const [selectedIndex, setSelectedIndex] = useState(0);
        const { menuItems } = useDebugMenuActions();

        const layoutConfig: LayoutConfig = { paddingY: 2, header: 1, separators: 2, footer: 1 };

        const { viewOffset, viewportHeight } = useViewport({
            selectedIndex,
            layoutConfig,
        });
        
        useInput((input, key) => {
            if (key.upArrow) {
                setSelectedIndex(i => moveIndex(i, 'up', menuItems.length));
                return;
            }
            if (key.downArrow) {
                setSelectedIndex(i => moveIndex(i, 'down', menuItems.length));
                return;
            }
            if (key.pageUp) {
                setSelectedIndex(i => Math.max(0, i - viewportHeight));
                return;
            }
            if (key.pageDown) {
                setSelectedIndex(i => Math.min(menuItems.length - 1, i + viewportHeight));
                return;
            }
            if (key.return) {
                const item = menuItems[selectedIndex];
                if (item) {
                    item.action();
                    useViewStore.getState().actions.setActiveOverlay('none');
                }
                return;
            }
            if (key.escape) {
                useViewStore.getState().actions.setActiveOverlay('none');
                return;
            }

            // No ctrl/meta keys for selection shortcuts, and only single characters
            if (key.ctrl || key.meta || input.length !== 1) return;

            if (input >= '1' && input <= '9') {
                const targetIndex = parseInt(input, 10) - 1;
                if (targetIndex < menuItems.length) {
                    setSelectedIndex(targetIndex);
                }
            } else if (input.toLowerCase() >= 'a' && input.toLowerCase() <= 'z') {
                const targetIndex = 9 + (input.toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0));
                if (targetIndex < menuItems.length) {
                    setSelectedIndex(targetIndex);
                }
            }
        });

        const menuItemsInView = menuItems.slice(viewOffset, viewOffset + viewportHeight);

        return {
            selectedIndex,
            menuItems: menuItemsInView,
            viewOffset,
            totalItems: menuItems.length,
        };
    };
  src/hooks/useGlobalHotkeys.tsx: |-
    import { useApp, useInput } from 'ink';
    import { useAppStore } from '../stores/app.store';
    import { useViewStore } from '../stores/view.store';
    import { MAIN_SCREENS_FOR_QUIT } from '../constants/app.constants';

    export const useGlobalHotkeys = ({ isActive }: { isActive: boolean }) => {
        const { exit } = useApp();
        const { currentScreen } = useAppStore(s => ({
            currentScreen: s.currentScreen,
        }));
        const { navigateBack } = useAppStore(s => s.actions);
        const { activeOverlay, setActiveOverlay } = useViewStore(s => ({
            activeOverlay: s.activeOverlay,
            setActiveOverlay: s.actions.setActiveOverlay,
        }));

        useInput((input, key) => {
            // Debug Menu toggle is the highest priority global key
            if (key.ctrl && input === 'b') {
                setActiveOverlay(activeOverlay === 'debug' ? 'none' : 'debug');
                return;
            }
            if (key.ctrl && input === 'l') {
                setActiveOverlay(activeOverlay === 'log' ? 'none' : 'log');
                return;
            }

            // If an overlay with its own input is open, stop here.
            if (activeOverlay === 'debug' || activeOverlay === 'log') {
                return;
            }

            // Help screen takes precedence over other keys
            if (activeOverlay === 'help') {
                if (key.escape || input === '?') {
                    setActiveOverlay('none');
                }
                return;
            }

            // --- Global hotkeys when no modal/overlay is open ---
            
            // Open Help
            if (input === '?') {
                setActiveOverlay('help');
                return;
            }
            
            // Quit from main screens
            if (input.toLowerCase() === 'q') {
                if ((MAIN_SCREENS_FOR_QUIT as readonly string[]).includes(currentScreen)) {
                    exit();
                }
                navigateBack();
            } else if (key.escape) {
                navigateBack();
            }
        }, { isActive });
    };
  src/hooks/useReviewScreen.tsx: >-
    import { useMemo } from 'react';

    import { useInput, type Key } from 'ink';

    import { useReviewStore } from '../stores/review.store';

    import { useAppStore } from '../stores/app.store';

    import { useCopyStore } from '../stores/copy.store';

    import { useTransactionStore, selectSelectedTransaction } from
    '../stores/transaction.store';

    import type { FileItem } from '../types/domain.types';

    import { useLayout } from './useLayout';

    import { useContentViewport } from './useContentViewport';

    import { useViewport } from './useViewport';


    type NavigableItem =
        | { type: 'prompt' }
        | { type: 'reasoning' }
        | { type: 'script'; id: string }
        | { type: 'file'; id: string };

    export const useReviewScreen = () => {
        const store = useReviewStore();
        const {
            selectedItemIndex,
            bodyView,
            patchStatus,
            selectedBulkRepairOptionIndex,
            selectedBulkInstructOptionIndex,
        } = store;

        const transaction = useTransactionStore(selectSelectedTransaction);
        const { showDashboardScreen } = useAppStore(s => s.actions);

        const scriptCount = transaction?.scripts?.length || 0;
        const fileCount = transaction?.files?.length || 0;

        // Layout for the main navigable item list (prompt, reasoning, files, etc.)
        const mainListLayoutConfig = useMemo(() => ({
            header: 2, // title+sep
            fixedRows: 2 + 1 + 1, // meta + prompt + reasoning headers are static before list
            marginsY: 1, // meta container
            separators: 3, // after meta, after scripts, after files
            footer: 2, // ActionFooter can be tall
            // The body, if visible, also reserves space
            dynamicRows: { count: bodyView !== 'none' ? 10 : 0 }, // Reserve a block for the body view
        }), [bodyView]);

        const { remainingHeight: listViewportHeight } = useLayout(mainListLayoutConfig);
        const { viewOffset } = useViewport({ selectedIndex: selectedItemIndex, layoutConfig: mainListLayoutConfig });

        // Layout for the body content (diff, reasoning, etc.)
        const bodyLayoutConfig = useMemo(() => ({
            header: 2,
            fixedRows: 2, // meta
            marginsY: 1 + 1 + 1, // meta, scripts, files
            separators: 4, // after title, meta, scripts, files, body
            footer: 2,
            dynamicRows: { count: 2 + scriptCount + 1 + fileCount }, // prompt, reasoning, scripts, 'FILES' header, files
        }), [scriptCount, fileCount]);

        const { remainingHeight: availableBodyHeight } = useLayout(bodyLayoutConfig);

        const navigableItems = useMemo((): NavigableItem[] => {
            if (!transaction) return [];
            const scriptItems: NavigableItem[] = (transaction.scripts || []).map(s => ({ type: 'script', id: s.command }));
            const fileItems: NavigableItem[] = (transaction.files || []).map(f => ({ type: 'file', id: f.id }));
            return [{ type: 'prompt' }, { type: 'reasoning' }, ...scriptItems, ...fileItems];
        }, [transaction]);

        const contentLineCount = useMemo(() => {
            const currentItem = navigableItems[selectedItemIndex];
            switch (bodyView) {
                case 'reasoning':
                    return (transaction?.reasoning || '').split('\n').length;
                case 'diff': {
                    if (currentItem?.type !== 'file') return 0;
                    const selectedFile = (transaction?.files || []).find(f => f.id === currentItem.id);
                    return (selectedFile?.diff || '').split('\n').length;
                }
                case 'script_output': {
                    if (currentItem?.type !== 'script') return 0;
                    const selectedScript = (transaction?.scripts || []).find(s => s.command === currentItem.id);
                    return (selectedScript?.output || '').split('\n').length;
                }
                default: return 0;
            }
        }, [bodyView, navigableItems, selectedItemIndex, transaction]);
        const contentViewport = useContentViewport({ contentLineCount, viewportHeight: availableBodyHeight });

        const navigableItemsInView = navigableItems.slice(viewOffset, viewOffset + listViewportHeight);

        // Memoize files to prevent re-renders, fixing the exhaustive-deps lint warning.
        const files: FileItem[] = useMemo(() => transaction?.files || [], [transaction]);
        const fileReviewStates = useReviewStore(s => s.fileReviewStates);

        const reviewStats = useMemo(() => {
            const approvedFiles = files.filter(f => fileReviewStates.get(f.id)?.status === 'APPROVED');
            return {
                totalFiles: files.length,
                totalLinesAdded: files.reduce((sum, f) => sum + f.linesAdded, 0),
                totalLinesRemoved: files.reduce((sum, f) => sum + f.linesRemoved, 0),
                numFiles: files.length,
                approvedFilesCount: approvedFiles.length,
            };
        }, [files, fileReviewStates]);

        const hasRejectedFiles = useMemo(() => {
            if (!fileReviewStates) return false;
            return Array.from(fileReviewStates.values()).some(s => s.status === 'REJECTED');
        }, [fileReviewStates]);

        const { approvedFilesCount } = reviewStats;

        const isFileSelected = navigableItems[selectedItemIndex]?.type === 'file';

        const scripts = transaction?.scripts || [];

        const {
            moveSelectionUp,
            moveSelectionDown,
            expandDiff,
            toggleBodyView,
            setBodyView,
            startApplySimulation,
            approve,
            tryRepairFile,
            tryInstruct,
            showBulkRepair,
            showBulkInstruct,
            executeBulkRepairOption,
            executeBulkInstructOption,
            confirmHandoff,
            scrollReasoningUp,
            scrollReasoningDown,
            navigateScriptErrorUp,
            navigateScriptErrorDown,
            toggleFileApproval,
            rejectAllFiles,
            navigateBulkRepairUp,
            navigateBulkRepairDown,
            navigateBulkInstructUp,
            navigateBulkInstructDown,
        } = store.actions;

        const openCopyMode = () => {
            if (!transaction) return;
            const currentItem = navigableItems[selectedItemIndex];
            const selectedFile = currentItem?.type === 'file' ? files.find(f => f.id === currentItem.id) : undefined;
            useCopyStore.getState().actions.openForReview(transaction, transaction.files || [], selectedFile);
        };

        // --- Input Handlers ---

        const handleGlobalInput = (input: string, key: Key): boolean => {
            if (input === '1') { // For demo purposes
                startApplySimulation('success'); return true;
            }
            if (input === '2') { // For demo purposes
                startApplySimulation('failure'); return true;
            }
            // The 'q' (quit/back) is now handled by the global hotkey hook.

            if (key.escape) {
                if (bodyView === 'bulk_repair' || bodyView === 'confirm_handoff' || bodyView === 'bulk_instruct') {
                    toggleBodyView(bodyView);
                } else if (bodyView !== 'none') {
                    setBodyView('none');
                }
                return true;
            }
            return false;
        };

        const handleHandoffConfirmInput = (_input: string, key: Key): void => {
            if (key.return) confirmHandoff();
        };

        const handleBulkRepairInput = (input: string, key: Key): void => {
            if (key.upArrow) navigateBulkRepairUp();
            if (key.downArrow) navigateBulkRepairDown();
            if (key.return) {
                executeBulkRepairOption(selectedBulkRepairOptionIndex + 1); // Options are 1-based
                return;
            }

            if (input >= '1' && input <= '4') {
                executeBulkRepairOption(parseInt(input));
            }
        };
        
        const handleBulkInstructInput = (input: string, key: Key): void => {
            if (key.upArrow) navigateBulkInstructUp();
            if (key.downArrow) navigateBulkInstructDown();
            if (key.return) {
                executeBulkInstructOption(selectedBulkInstructOptionIndex + 1); // Options are 1-based
                return;
            }

            if (input >= '1' && input <= '3') {
                executeBulkInstructOption(parseInt(input));
            }
        };

        const handleContentScrollInput = (key: Key): boolean => {
            const contentViews = ['reasoning', 'script_output', 'diff'];
            if (!contentViews.includes(bodyView)) return false;

            if (key.upArrow) {
                contentViewport.actions.scrollUp();
                return true;
            }
            if (key.downArrow) { contentViewport.actions.scrollDown(); return true; }
            if (key.pageUp) { contentViewport.actions.pageUp(); return true; }
            if (key.pageDown) { contentViewport.actions.pageDown(); return true; }
            return false;
        };

        const handleReasoningInput = (input: string, key: Key): void => {
            if (key.upArrow) scrollReasoningUp();
            if (key.downArrow) scrollReasoningDown();
            if (input.toLowerCase() === 'r') toggleBodyView('reasoning');
        };

        const handleScriptOutputInput = (input: string, key: Key): void => {
            if (input.toLowerCase() === 'j') navigateScriptErrorDown();
            if (input.toLowerCase() === 'k') navigateScriptErrorUp();
            if (key.return) toggleBodyView('script_output');
            if (input.toLowerCase() === 'c') { // TODO: this copy logic is not great.
                const currentItem = navigableItems[selectedItemIndex];
                const selectedScript = currentItem?.type === 'script' ? scripts.find(s => s.command === currentItem.id) : undefined;
                if (selectedScript) {
                    // eslint-disable-next-line no-console
                    console.log(`[CLIPBOARD] Copied script output: ${selectedScript.command}`);
                }
            }
        };

        const handleDiffInput = (input: string) => {
            if (input.toLowerCase() === 'x') expandDiff();
            if (input.toLowerCase() === 'd') toggleBodyView('diff');
        };

        const handleMainNavigationInput = (input: string, key: Key): void => {
            // Handle Shift+R for reject all
            if (key.shift && input.toLowerCase() === 'r') {
                if (approvedFilesCount > 0 && transaction) {
                    rejectAllFiles();
                }
                return;
            }

            // Main View Navigation
            if (key.upArrow) moveSelectionUp(navigableItems.length);
            if (key.downArrow) moveSelectionDown(navigableItems.length);

            const currentItem = navigableItems[selectedItemIndex];

            if (input === ' ') {
                if (currentItem?.type === 'file') {
                    const fileState = fileReviewStates.get(currentItem.id);
                    if (fileState && fileState.status !== 'FAILED') {
                        toggleFileApproval(currentItem.id);
                    }
                }
            }

            if (input.toLowerCase() === 'd' && currentItem?.type === 'file') {
                toggleBodyView('diff');
            }

            if (input.toLowerCase() === 'r') {
                toggleBodyView('reasoning');
            }

            if (key.return) { // Enter key
                if (currentItem?.type === 'file') {
                    toggleBodyView('diff');
                } else if (currentItem?.type === 'reasoning') {
                    toggleBodyView('reasoning');
                } else if (currentItem?.type === 'script') {
                    toggleBodyView('script_output');
                }
            }

            if (input.toLowerCase() === 'a') {
                if (approvedFilesCount > 0) {
                    approve();
                    showDashboardScreen();
                }
            }

            if (input.toLowerCase() === 'c') {
                openCopyMode();
            }

            if (input.toLowerCase() === 't') {
                if (key.shift) {
                    const hasFailedFiles = Array.from(fileReviewStates.values()).some(s => s.status === 'FAILED');
                    if (hasFailedFiles) showBulkRepair();
                } else if (currentItem?.type === 'file') {
                    const fileState = fileReviewStates.get(currentItem.id);
                    if (fileState?.status === 'FAILED') tryRepairFile(currentItem.id);
                }
            }

            if (input.toLowerCase() === 'i') {
                if (key.shift) {
                    if (hasRejectedFiles) showBulkInstruct();
                } else if (currentItem?.type === 'file') {
                    const fileState = fileReviewStates.get(currentItem.id);
                    if (fileState?.status === 'REJECTED') {
                        tryInstruct(currentItem.id);
                    }
                }
            }
        };

        useInput((input: string, key: Key) => {
            if (handleGlobalInput(input, key)) {
                return;
            }

            // If we are in a scrollable body view, prioritize that input.
            if (handleContentScrollInput(key)) {
                return;
            }

            switch (bodyView) {
                case 'confirm_handoff': return handleHandoffConfirmInput(input, key);
                case 'bulk_repair': return handleBulkRepairInput(input, key);
                case 'bulk_instruct': return handleBulkInstructInput(input, key);
                case 'reasoning': return handleReasoningInput(input, key);
                case 'script_output': return handleScriptOutputInput(input, key);
                case 'diff': return handleDiffInput(input);
                default: return handleMainNavigationInput(input, key);
            }
        });

        return {
            ...store,
            fileReviewStates,
            selectedItemIndex,
            transaction,
            files,
            scripts,
            patchStatus,
            navigableItems,
            isFileSelected,
            navigableItemsInView,
            viewOffset,
            contentScrollIndex: contentViewport.scrollIndex,
            availableBodyHeight,
            selectedBulkRepairOptionIndex,
            selectedBulkInstructOptionIndex,
            ...reviewStats,
            hasRejectedFiles,
        };
    };
  src/hooks/useTransactionDetailScreen.tsx: >-
    import { useInput, type Key } from 'ink';

    import { useDetailStore } from '../stores/detail.store';

    import { useViewStore } from '../stores/view.store';

    import { useTransactionStore, selectSelectedTransaction } from
    '../stores/transaction.store';

    import { useMemo } from 'react';

    import { useCopyStore } from '../stores/copy.store';

    import { EditorService } from '../services/editor.service';

    import { useLayout } from './useLayout';

    import { useContentViewport } from './useContentViewport';


    export const useTransactionDetailScreen = () => {
        const store = useDetailStore();
        const transaction = useTransactionStore(selectSelectedTransaction);
        const files = useMemo(() => transaction?.files || [], [transaction]);

        const {
            navigateUp,
            navigateDown,
            expandOrDrillDown,
            collapseOrBubbleUp,
            toggleRevertConfirm,
            confirmRevert,
        } = store.actions;

        const isFilesExpanded = store.expandedItemPaths.has('FILES');
        const layoutConfig = useMemo(() => ({
            header: 2, // Header text + separator
            fixedRows: 4, // Meta info
            separators: 2, // after nav, after body
            marginsY: 1, // for body
            footer: 2, // ActionFooter can be tall
            dynamicRows: {
                count: 3 + (isFilesExpanded ? (files.length || 0) : 0), // navigator items
            },
        }), [isFilesExpanded, files.length]);

        const { remainingHeight: availableBodyHeight } = useLayout(layoutConfig);
        
        const contentLineCount = useMemo(() => {
            if (store.bodyView === 'PROMPT') return (transaction?.prompt || '').split('\n').length;
            if (store.bodyView === 'REASONING') return (transaction?.reasoning || '').split('\n').length;
            if (store.bodyView === 'DIFF_VIEW') {
                const fileId = store.focusedItemPath.split('/')[1];
                const file = files.find(f => f.id === fileId);
                return (file?.diff || '').split('\n').length;
            }
            return 0;
        }, [store.bodyView, store.focusedItemPath, transaction, files]);

        const viewport = useContentViewport({ contentLineCount, viewportHeight: availableBodyHeight });

        const openCopyMode = () => {
            if (!transaction) return;
            const { focusedItemPath } = store;
            const fileId = focusedItemPath.split('/')[1];
            const selectedFile = fileId ? files.find(f => f.id === fileId) : undefined;
            useCopyStore.getState().actions.openForDetail(transaction, selectedFile);
        };

        useInput((input: string, key: Key) => {
            if (store.bodyView === 'REVERT_CONFIRM') {
                if (key.escape) toggleRevertConfirm();
                if (key.return) confirmRevert();
                return;
            }
            
            // --- Content Scrolling ---
            if (store.bodyView === 'PROMPT' || store.bodyView === 'REASONING' || store.bodyView === 'DIFF_VIEW') {
                if (key.upArrow) {
                    viewport.actions.scrollUp();
                    return;
                }
                if (key.downArrow) {
                    viewport.actions.scrollDown();
                    return;
                }
                if (key.pageUp) { viewport.actions.pageUp(); return; }
                if (key.pageDown) { viewport.actions.pageDown(); return; }
            }

            // --- Main Input ---
            if (input.toLowerCase() === 'c') {
                openCopyMode();
                return;
            }
            if (input.toLowerCase() === 'u') {
                toggleRevertConfirm();
                return;
            }
            if (input.toLowerCase() === 'o') {
                if (!transaction) return;
                const { focusedItemPath } = store;
                if (focusedItemPath.includes('/')) { // Is a file
                    const fileId = focusedItemPath.split('/')[1];
                    const file = files.find(f => f.id === fileId);
                    if (file) EditorService.openFileInEditor(file.path);
                } else { // Is a section, open the transaction YAML
                    const yamlPath = EditorService.getTransactionYamlPath(transaction.hash);
                    EditorService.openFileInEditor(yamlPath);
                }
            }

            // Navigator movement only if not scrolling content
            if (store.bodyView !== 'PROMPT' && store.bodyView !== 'REASONING' && store.bodyView !== 'DIFF_VIEW') {
                if (key.upArrow) navigateUp();
                if (key.downArrow) navigateDown();
            }
            if (key.rightArrow) expandOrDrillDown();
            if (key.leftArrow) collapseOrBubbleUp();
            if (key.return) expandOrDrillDown();
            if (key.escape) collapseOrBubbleUp();
        }, { isActive: useViewStore.getState().activeOverlay === 'none' }); // Prevent input when copy overlay is open

        return {
            transaction,
            files,
            focusedItemPath: store.focusedItemPath,
            expandedItemPaths: store.expandedItemPaths,
            bodyView: store.bodyView,
            contentScrollIndex: viewport.scrollIndex,
            availableBodyHeight,
        };
    };
  src/hooks/useTransactionHistoryScreen.tsx: >-
    import { useMemo } from 'react';

    import { useInput, type Key } from 'ink';

    import { useHistoryStore } from '../stores/history.store';

    import { useAppStore } from '../stores/app.store';

    import { useTransactionStore } from '../stores/transaction.store';

    import { useDetailStore } from '../stores/detail.store';

    import { useCopyStore } from '../stores/copy.store';

    import type { TransactionStatus } from '../types/domain.types';

    import { EditorService } from '../services/editor.service';

    import { getVisibleItemPaths } from '../stores/navigation.utils';

    import type { LayoutConfig } from './useLayout';

    import { useViewport } from './useViewport';


    export const useTransactionHistoryScreen = ({ layoutConfig }: {
    layoutConfig: LayoutConfig }) => {
        const store = useHistoryStore();
        const { mode, selectedItemPath, expandedIds, filterQuery, selectedForAction, loadingPaths, actions } = store;
        const { showDashboardScreen, showTransactionDetailScreen } = useAppStore(s => s.actions);
        const transactions = useTransactionStore(s => s.transactions);

        const visibleItemPaths = useMemo(
            () => getVisibleItemPaths(transactions, expandedIds),
            [transactions, expandedIds],
        );
        const selectedIndex = visibleItemPaths.indexOf(selectedItemPath);

        const { viewOffset, viewportHeight } = useViewport({
            selectedIndex,
            layoutConfig,
        });

        const openCopyMode = () => {
            const transactionsToCopy = transactions.filter(tx => selectedForAction.has(tx.id));

            if (transactionsToCopy.length === 0) return;
            useCopyStore.getState().actions.openForHistory(transactionsToCopy);
        };

        const handleFilterInput = (_input: string, key: Key): void => {
            if (key.escape) actions.setMode('LIST');
            if (key.return) actions.applyFilter();
        };

        const handleBulkActionsInput = (input: string, key: Key): void => {
            if (key.escape) {
                actions.setMode('LIST');
                return;
            }
            if (input >= '1' && input <= '3') {
                // eslint-disable-next-line no-console
                console.log(`[MOCK] Bulk action #${input} selected.`);
                actions.setMode('LIST');
            }
        };

        const handleListInput = (input: string, key: Key): void => {
            if (key.upArrow) actions.navigateUp();
            if (key.downArrow) actions.navigateDown();
            if (key.rightArrow) actions.expandOrDrillDown();
            if (key.leftArrow) actions.collapseOrBubbleUp();
            if (key.pageUp) actions.navigatePageUp(viewportHeight);
            if (key.pageDown) actions.navigatePageDown(viewportHeight);
            if (input === ' ') actions.toggleSelection();
            if (key.return) {
                const txId = selectedItemPath.split('/')[0];
                if (txId && !selectedItemPath.includes('/')) {
                    useDetailStore.getState().actions.load(txId);
                    showTransactionDetailScreen();
                }
            }
            if (input.toLowerCase() === 'o') {
                const txId = selectedItemPath.split('/')[0];
                const tx = transactions.find(t => t.id === txId);
                if (!tx) return;

                if (selectedItemPath.includes('/file/')) {
                    const fileId = selectedItemPath.split('/')[2];
                    const file = tx.files?.find(f => f.id === fileId);
                    if (file) EditorService.openFileInEditor(file.path);
                } else {
                    const yamlPath = EditorService.getTransactionYamlPath(tx.hash);
                    EditorService.openFileInEditor(yamlPath);
                }
            }

            if (input.toLowerCase() === 'f') actions.setMode('FILTER');
            if (input.toLowerCase() === 'c' && selectedForAction.size > 0) openCopyMode();
            if (input.toLowerCase() === 'b' && selectedForAction.size > 0) actions.setMode('BULK_ACTIONS');
            
            if (key.escape || input.toLowerCase() === 'q') {
                showDashboardScreen();
            }
        };

        useInput((input: string, key: Key) => {
            if (mode === 'FILTER') {
                handleFilterInput(input, key);
                return;
            }
            if (mode === 'BULK_ACTIONS') {
                handleBulkActionsInput(input, key);
                return;
            }
            handleListInput(input, key);
        });

        const itemsInView = visibleItemPaths.slice(viewOffset, viewOffset + viewportHeight);
        const txIdsInView = useMemo(() => new Set(itemsInView.map(p => p.split('/')[0])), [itemsInView]);
        const transactionsInView = useMemo(
            () => transactions.filter(tx => txIdsInView.has(tx.id)),
            [transactions, txIdsInView],
        );
        const pathsInViewSet = useMemo(() => new Set(itemsInView), [itemsInView]);

        const filterStatusText = filterQuery ? filterQuery : '(none)';
        const showingStatusText = `Showing ${Math.min(viewOffset + 1, visibleItemPaths.length)}-${Math.min(viewOffset + itemsInView.length, visibleItemPaths.length)} of ${visibleItemPaths.length} items`;
        
        const hasSelection = selectedForAction.size > 0;

        const statsStatus = useMemo(() => {
            const stats = transactions.reduce((acc, tx) => {
                acc[tx.status] = (acc[tx.status] || 0) + 1;
                return acc;
            }, {} as Record<TransactionStatus, number>);
            
            const parts = [];
            if (stats.COMMITTED) parts.push(`${stats.COMMITTED} Cmt`);
            if (stats.HANDOFF) parts.push(`${stats.HANDOFF} H/O`);
            if (stats.REVERTED) parts.push(`${stats.REVERTED} Rev`);
            if (stats.APPLIED) parts.push(`${stats.APPLIED} App`);
            if (stats.PENDING) parts.push(`${stats.PENDING} Pend`);
            if (stats.FAILED) parts.push(`${stats.FAILED} Fail`);

            return parts.length > 0 ? `Stats: ${parts.join(', ')}` : '';
        }, [transactions]);

        return {
            mode,
            filterQuery,
            selectedForAction,
            selectedItemPath,
            expandedIds,
            actions,
            transactions,
            viewOffset,
            itemsInView,
            loadingPaths,
            transactionsInView,
            pathsInViewSet,
            filterStatus: filterStatusText,
            showingStatus: showingStatusText,
            statsStatus,
            hasSelection,
            visibleItemPaths,
        };
    };
  src/hooks/useViewport.ts: "import { useState, useEffect } from 'react';\nimport { useStdoutDimensions } from '../utils';\nimport { useLayout, type LayoutConfig } from './useLayout';\n\ninterface UseViewportOptions {\n\tselectedIndex: number;\n\tlayoutConfig: LayoutConfig;\n}\n\nexport const useViewport = ({ selectedIndex, layoutConfig }: UseViewportOptions) => {\n\tconst { remainingHeight: viewportHeight } = useLayout(layoutConfig);\n\tconst [viewOffset, setViewOffset] = useState(0);\n\n\tuseEffect(() => {\n\t\tif (selectedIndex >= 0 && selectedIndex < viewOffset) {\n            setViewOffset(selectedIndex);\n        } else if (selectedIndex >= viewOffset + viewportHeight) {\n            setViewOffset(selectedIndex - viewportHeight + 1);\n        }\n    }, [selectedIndex, viewOffset, viewportHeight]);\n\n    return {\n        viewOffset,\n        viewportHeight,\n        width: useStdoutDimensions()[0],\n    };\n};"
  src/components/CopyScreen.tsx: |-
    import { Box, Text } from 'ink';
    import Separator from './Separator';
    import { useStdoutDimensions } from '../utils';
    import ActionFooter from './ActionFooter';
    import { useCopyScreen } from '../hooks/useCopyScreen';

    const CopyScreen = () => {
        const {
            title,
            itemsInView,
            selectedIndex,
            selectedIds,
            lastCopiedMessage,
            viewOffset,
        } = useCopyScreen();
        const [width] = useStdoutDimensions();

        return (
            <Box 
                width="100%"
                height="100%"
                flexDirection="column"
                justifyContent="center"
                alignItems="center"
            >
                <Box 
                    flexDirection="column" 
                    paddingX={2}
                    width="80%"
                >
                    <Text bold color="yellow">▲ relaycode · copy mode</Text>
                    <Separator width={Math.floor(width * 0.8) - 4} />
                    <Box flexDirection="column" marginY={1}>
                        <Text>{title}</Text>
                        <Box flexDirection="column" marginTop={1}>
                            {itemsInView.map((item, index) => {
                                const isSelected = (index + viewOffset) === selectedIndex;
                                const isChecked = selectedIds.has(item.id);
                                return (
                                    <Text key={item.id} color={isSelected ? 'cyan' : undefined}>
                                        {isSelected ? '> ' : '  '}
                                        [{isChecked ? 'x' : ' '}] ({item.key}) {item.label}
                                    </Text>
                                );
                            })}
                        </Box>
                    </Box>
                    <Separator width={Math.floor(width * 0.8) - 4} />
                    {lastCopiedMessage && <Text color="green">✓ {lastCopiedMessage}</Text>}
                    <ActionFooter actions={[
                        { key: '↑↓/PgUp/PgDn', label: 'Nav' },
                        { key: 'Spc/Hotkey', label: 'Toggle' },
                        { key: 'Enter', label: 'Copy' },
                        { key: 'Esc', label: 'Close' },
                    ]}/>
                </Box>
            </Box>
        );
    };

    export default CopyScreen;
  src/components/DashboardScreen.tsx: "import React from 'react';\nimport { Box, Text } from 'ink';\nimport Spinner from 'ink-spinner';\nimport Separator from './Separator';\nimport type { Transaction, TransactionStatus, FileChangeType } from '../types/domain.types';\nimport { useDashboardScreen } from '../hooks/useDashboardScreen';\nimport { UI_CONFIG } from '../config/ui.config';\nimport type { LayoutConfig } from '../hooks/useLayout';\nimport ActionFooter from './ActionFooter';\nimport type { ActionItem } from '../types/actions.types';\n\n// --- Sub-components & Helpers ---\n\nconst getStatusIcon = (status: TransactionStatus) => {\n    switch (status) {\n        case 'PENDING': return <Text color=\"yellow\">?</Text>;\n        case 'APPLIED': return <Text color=\"green\">✓</Text>;\n        case 'COMMITTED': return <Text color=\"blue\">→</Text>;\n        case 'HANDOFF': return <Text color=\"magenta\">→</Text>;\n        case 'FAILED': return <Text color=\"red\">✗</Text>;\n        case 'REVERTED': return <Text color=\"gray\">↩</Text>;\n        case 'IN-PROGRESS': return <Spinner type=\"dots\" />;\n        default: return <Text> </Text>;\n    }\n};\n\nconst getFileChangeTypeIcon = (type: FileChangeType) => {\n    switch (type) {\n        case 'MOD': return '[MOD]';\n        case 'ADD': return '[ADD]';\n        case 'DEL': return '[DEL]';\n        case 'REN': return '[REN]';\n    }\n};\n\nconst formatTimeAgo = (timestamp: number) => {\n    const seconds = Math.floor((Date.now() - timestamp) / 1000);\n    if (seconds < 60) return `${seconds}s`;\n    const minutes = Math.floor(seconds / 60);\n    return `${minutes}m`;\n};\n\nconst ExpandedEventInfo = ({ transaction }: { transaction: Transaction }) => {\n    const stats = transaction.stats;\n    const files = transaction.files || [];\n\n    return (\n        <Box flexDirection=\"column\" paddingLeft={4} marginBottom={1} borderStyle=\"round\" borderLeft={true} borderTop={false} borderRight={false} borderBottom={false} borderColor=\"gray\">\n            {stats && (\n                <Text color=\"gray\">\n                    Stats: {stats.files} files, +{stats.linesAdded}/-{stats.linesRemoved}\n                </Text>\n            )}\n             <Box flexDirection=\"column\" paddingLeft={1}>\n                {files.map(file => (\n                     <Text key={file.id}>\n                        <Text color=\"gray\">{getFileChangeTypeIcon(file.type)}</Text> {file.path}\n                    </Text>\n                ))}\n             </Box>\n        </Box>\n    );\n};\n\nconst EventStreamItem = ({ transaction, isSelected, isExpanded }: { transaction: Transaction, isSelected: boolean, isExpanded: boolean }) => {\n    const icon = getStatusIcon(transaction.status);\n    const time = formatTimeAgo(transaction.timestamp).padEnd(5, ' ');\n    const statusText = transaction.status.padEnd(11, ' ');\n    const expandIcon = isExpanded ? '▾' : '▸';\n    \n    const messageNode = transaction.status === 'IN-PROGRESS'\n        ? <Text color=\"cyan\">{transaction.message}</Text>\n        : transaction.message;\n    \n    const content = (\n        <Text>\n            {time} {expandIcon} {icon} {statusText}{' '}\n            <Text color=\"gray\">{transaction.hash}</Text>\n            {' '}· {messageNode}\n        </Text>\n    );\n\n    return isSelected ? <Text bold color=\"cyan\">{'> '}{content}</Text> : <Text>{'  '}{content}</Text>;\n};\n\nconst ConfirmationContent = ({\n    transactionsToConfirm,\n}: {\n    transactionsToConfirm: Transaction[];\n}) => {\n    const actionText = 'APPROVE';\n    \n    return (\n        <Box flexDirection=\"column\" marginY={1} paddingLeft={2}>\n            <Text bold color=\"yellow\">{actionText} ALL PENDING TRANSACTIONS?</Text>\n            <Text>\n                The following {transactionsToConfirm.length} transaction(s) will be approved:\n            </Text>\n            <Box flexDirection=\"column\" paddingLeft={1} marginTop={1}>\n                {transactionsToConfirm.map(tx => (\n                    <Text key={tx.id}>- {tx.hash}: {tx.message}</Text>\n                ))}\n            </Box>\n        </Box>\n    );\n};\n\n// --- Main Component ---\n\nconst DashboardScreen = () => {\n    const {\n        status,\n        transactions,\n        selectedTransactionIndex,\n        pendingApprovals,\n        pendingCommits,\n        isModal,\n        isProcessing,\n        viewOffset,\n        viewportHeight,\n        transactionsToConfirm,\n        expandedTransactionId,\n    } = useDashboardScreen({\n        layoutConfig: {\n            header: 1,\n            separators: 2,\n            fixedRows: 1 + 1, // status bar, event stream header\n            marginsY: 1 + 1 + 1, // status bar, event stream list, separator\n            footer: 2,\n            // Non-event stream vertical space (header, footer, etc.)\n        },\n    });\n\n    const renderStatusBar = () => {\n        let statusText: string;\n        let statusIcon: React.ReactNode;\n        switch (status) {\n            case 'LISTENING': statusText = 'LISTENING'; statusIcon = <Text color=\"green\">●</Text>; break;\n            case 'PAUSED': statusText = 'PAUSED'; statusIcon = <Text color=\"yellow\">||</Text>; break;\n            case 'APPROVING': statusText = 'APPROVING...'; statusIcon = <Text color=\"cyan\"><Spinner type=\"dots\"/></Text>; break;\n            default: statusText = 'LISTENING'; statusIcon = <Text color=\"green\">●</Text>;\n        }\n\n        let approvalStr: React.ReactNode = String(pendingApprovals).padStart(2, '0');\n        const commitStr: React.ReactNode = String(pendingCommits).padStart(2, '0');\n\n        if (status === 'APPROVING') approvalStr = <Text color=\"cyan\">(<Spinner type=\"dots\"/>)</Text>;\n        if (status === 'CONFIRM_APPROVE') {\n            approvalStr = <Text bold color=\"yellow\">┌ {approvalStr} ┐</Text>;\n        }\n        \n        return (\n            <Text>\n                STATUS: {statusIcon} {statusText} · APPROVALS: {approvalStr} · COMMITS: {commitStr}\n            </Text>\n        );\n    };\n\n    const renderFooter = () => {\n        if (isModal) return (\n            <ActionFooter actions={[\n                { key: 'Enter', label: 'Confirm' },\n                { key: 'Esc', label: 'Cancel' },\n            ]}/>\n        );\n        if (isProcessing) return <Text>Processing... This may take a moment.</Text>;\n\n        const footerActions: ActionItem[] = [\n            { key: '↑↓', label: 'Nav' },\n            { key: '→/Ent', label: 'View' },\n            { key: '←', label: 'Collapse' },\n            { key: 'L', label: 'Log' },\n            { key: 'A', label: 'Approve All' },\n            { key: 'C', label: 'Commit' },\n            { key: 'P', label: status === 'PAUSED' ? 'Resume' : 'Pause' },\n            { key: 'Q', label: 'Quit' },\n        ];\n\t\treturn <ActionFooter actions={footerActions} />;\n    };\n    \n    return (\n        <Box flexDirection=\"column\" height=\"100%\">\n            <Text color=\"cyan\">▲ relaycode dashboard</Text>\n            <Separator />\n            <Box marginY={1}>\n                {renderStatusBar()}\n            </Box>\n            \n            {isModal && (\n                <>\n                    <ConfirmationContent transactionsToConfirm={transactionsToConfirm} />\n                    <Separator />\n                </>\n            )}\n            \n            <Text bold underline> EVENT STREAM (Last 15 minutes)</Text>\n            <Box flexDirection=\"column\" marginTop={1}>\n                {transactions.length === 0 && (\n                     <Box paddingLeft={2}><Text color=\"gray\">Listening for changes... no events yet.</Text></Box>\n                )}\n                {transactions.slice(viewOffset, viewOffset + viewportHeight).map((tx, index) => {\n                    const actualIndex = viewOffset + index;\n                    const isExpanded = expandedTransactionId === tx.id;\n                    return (\n                        <React.Fragment key={tx.id}>\n                            <EventStreamItem\n                                transaction={tx}\n                                isSelected={!isModal && actualIndex === selectedTransactionIndex}\n                                isExpanded={isExpanded}\n                            />\n                            {isExpanded && <ExpandedEventInfo transaction={tx} />}\n                        </React.Fragment>\n                    );\n                })}\n            </Box>\n\n            <Box marginTop={1}><Separator /></Box>\n            {renderFooter()}\n        </Box>\n    );\n};\n\nexport default DashboardScreen;"
  src/components/DebugLogScreen.tsx: >-
    import { Box, Text } from 'ink';

    import TextInput from 'ink-text-input';

    import Separator from './Separator';

    import ActionFooter from './ActionFooter';

    import { useDebugLogScreen } from '../hooks/useDebugLogScreen';

    import type { LogEntry } from '../types/log.types';

    import { useStdoutDimensions } from '../utils';


    const LogLevelColors = {
        DEBUG: 'gray',
        INFO: 'white',
        WARN: 'yellow',
        ERROR: 'red',
    };


    const LogLevelTag = {
        DEBUG: { color: 'white', backgroundColor: 'gray' },
        INFO: { color: 'black', backgroundColor: 'cyan' },
        WARN: { color: 'black', backgroundColor: 'yellow' },
        ERROR: { color: 'white', backgroundColor: 'red' },
    };


    const LogEntryRow = ({ entry, isSelected }: { entry: LogEntry; isSelected:
    boolean }) => {
        const time = new Date(entry.timestamp).toISOString().split('T')[1]?.replace('Z', '');
        const color = LogLevelColors[entry.level];
        const tagColors = LogLevelTag[entry.level];

        return (
            <Text color={color}>
                {isSelected ? '> ' : '  '}
                <Text color="gray">{time}</Text>
                {' '}
                <Text bold color={tagColors.color} backgroundColor={tagColors.backgroundColor}>
                    {' '}{entry.level.padEnd(5, ' ')}{' '}
                </Text>
                {' '}
                {entry.message}
            </Text>
        );
    };


    const DebugLogScreen = () => {
        const {
            logsInView,
            logCount,
            filteredLogCount,
            selectedIndex,
            mode,
            filterQuery,
            setFilterQuery,
            viewOffset,
        } = useDebugLogScreen();
        const [width] = useStdoutDimensions();

        const renderFilter = () => (
            <Box>
                <Text>Filter: </Text>
                {mode === 'FILTER' ? (
                    <TextInput
                        value={filterQuery}
                        onChange={setFilterQuery}
                        placeholder="Type to filter log messages..."
                    />
                ) : (
                    <Text color="gray">{filterQuery || '(none)'}</Text>
                )}
                <Box flexGrow={1} /> 
                <Text>
                    Showing {Math.min(viewOffset + 1, filteredLogCount)}-
                    {Math.min(viewOffset + logsInView.length, filteredLogCount)} of {filteredLogCount}
                </Text> 
            </Box>
        );

        const footerActions =
            mode === 'FILTER'
                ? [{ key: 'Enter/Esc', label: 'Apply & Close Filter' }]
                : [
                      { key: '↑↓/PgUp/PgDn', label: 'Scroll' },
                      { key: 'F', label: 'Filter' },
                      { key: 'C', label: 'Clear' },
                      { key: 'Esc/Ctrl+L', label: 'Close' },
                  ];

        return (
            <Box
                flexDirection="column"
                width="100%"
                height="100%"
                paddingX={2}
                paddingY={1}
            >
                <Text bold color="black" backgroundColor="yellow"> ▲ relaycode · DEBUG LOG </Text>
                <Separator width={width - 4} />
                <Box marginY={1}>{renderFilter()}</Box>
                <Box flexDirection="column" flexGrow={1}>
                    {logsInView.map((entry, index) => (
                        <LogEntryRow
                            key={`${entry.timestamp}-${index}`}
                            entry={entry}
                            isSelected={selectedIndex === index + viewOffset}
                        />
                    ))}
                    {logCount > 0 && filteredLogCount === 0 && (
                        <Text color="gray">No logs match your filter.</Text>
                    )}
                    {logCount === 0 && (
                        <Text color="gray">No log entries yet. Waiting for system activity...</Text>
                    )}
                </Box>
                <Separator width={width - 4} />
                <ActionFooter actions={footerActions} />
            </Box>
        );
    };


    export default DebugLogScreen;
  src/components/DebugMenu.tsx: |-
    import { Box, Text } from 'ink';
    import Separator from './Separator';
    import { useDebugMenu } from '../hooks/useDebugMenu';
    import { useStdoutDimensions } from '../utils';
    import ActionFooter from './ActionFooter';

    const getKeyForIndex = (index: number): string => {
        if (index < 9) {
            return (index + 1).toString();
        }
        return String.fromCharCode('a'.charCodeAt(0) + (index - 9));
    };

    const DebugMenu = () => {
        const { selectedIndex, menuItems, viewOffset, totalItems } = useDebugMenu();
        const [width] = useStdoutDimensions();

        return (
            <Box
                flexDirection="column"
                width="100%"
                paddingX={2}
                paddingY={1}
            >
                <Text bold color="black" backgroundColor="yellow"> ▲ relaycode · DEBUG MENU </Text>
                <Separator width={width - 4} />
                <Box flexDirection="column" marginY={1}>
                    {menuItems.map((item, index) => {
                        const absoluteIndex = index + viewOffset;
                        return (
                            <Text key={item.title} color={selectedIndex === absoluteIndex ? 'cyan' : undefined}>
                                {selectedIndex === absoluteIndex ? '> ' : '  '}
                                ({getKeyForIndex(absoluteIndex)}) {item.title}
                            </Text>
                        );
                    })}
                </Box>
                <Separator width={width - 4} />
                <Box>
                    <ActionFooter actions={[
                        { key: '↑↓/PgUp/PgDn', label: 'Nav' },
                        { key: '1-9,a-z', label: 'Jump' },
                        { key: 'Enter', label: 'Select' },
                        { key: 'Esc/Ctrl+B', label: 'Close' },
                    ]}/>
                    <Box flexGrow={1} />
                    <Text>
                        {Math.min(viewOffset + 1, totalItems)}-
                        {Math.min(viewOffset + menuItems.length, totalItems)} of {totalItems}
                    </Text>
                </Box>
            </Box>
        );
    };

    export default DebugMenu;
  src/components/GitCommitScreen.tsx: |-
    import { Box, Text } from 'ink';
    import Spinner from 'ink-spinner';
    import Separator from './Separator';
    import { useGitCommitScreen } from '../hooks/useGitCommitScreen';
    import ActionFooter from './ActionFooter';

    const GitCommitScreen = () => {
        const { transactionsToCommit, finalCommitMessage, isCommitting } = useGitCommitScreen();

        const transactionLines = transactionsToCommit.map(tx => (
            <Text key={tx.id}>- {tx.hash}: {tx.message}</Text>
        ));

        return (
            <Box flexDirection="column">
                <Text color="cyan">▲ relaycode git commit</Text>
                <Separator />
                <Box marginY={1} flexDirection="column" paddingX={2}>
                    <Text>Found {transactionsToCommit.length} new transactions to commit since last git commit.</Text>
                    <Box marginTop={1} flexDirection="column">
                        <Text bold>TRANSACTIONS INCLUDED</Text>
                        {transactionLines}
                    </Box>
                </Box>
                <Separator />
                <Box marginY={1} flexDirection="column" paddingX={2}>
                    <Text bold>FINAL COMMIT MESSAGE</Text>
                    <Box marginTop={1}>
                        <Text>{finalCommitMessage}</Text>
                    </Box>
                </Box>
                <Separator />
                <Box marginY={1} paddingX={2}>
                     <Text>This will run &apos;git add .&apos; and &apos;git commit&apos; with the message above.</Text>
                </Box>
                <Separator />
                {isCommitting
                    ? <Text><Spinner type="dots"/> Committing... please wait.</Text>
                    : <ActionFooter actions={[
                        { key: 'Enter', label: 'Confirm & Commit' },
                        { key: 'Esc', label: 'Cancel' },
                    ]}/>
                }
            </Box>
        );
    };

    export default GitCommitScreen;
  src/components/ReviewScreen.tsx: >-
    import { Box, Text } from 'ink';

    import Separator from './Separator';

    import DiffScreen from './DiffScreen';

    import ReasonScreen from './ReasonScreen';

    import type { ScriptResult, FileItem, FileChangeType } from
    '../types/domain.types';

    import { useReviewScreen } from '../hooks/useReviewScreen';

    import ActionFooter from './ActionFooter';

    import type { ActionItem } from '../types/actions.types';


    // --- Sub-components ---


    const FileItemRow = ({ file, reviewStatus, reviewError, reviewDetails,
    isFocused }: {
        file: FileItem;
        reviewStatus: string;
        reviewError?: string;
        reviewDetails?: string;
        isFocused: boolean;
    }) => {
        let icon;
        let iconColor;
        switch (reviewStatus) {
            case 'APPROVED': icon = '[✓]'; iconColor = 'green'; break;
            case 'REJECTED': icon = '[✗]'; iconColor = 'red'; break;
            case 'FAILED': icon = '[!]'; iconColor = 'red'; break;
            case 'AWAITING': icon = '[●]'; iconColor = 'yellow'; break;
            case 'RE_APPLYING': icon = '[●]'; iconColor = 'cyan'; break;
        }

        const typeColor = (type: FileChangeType) => {
            switch (type) {
                case 'ADD': return 'green';
                case 'DEL': return 'red';
                case 'REN': return 'yellow';
                default: return 'white';
            }
        };

        const diffStats = <Text>(+<Text color="green">{file.linesAdded}</Text>/-<Text color="red">{file.linesRemoved}</Text>)</Text>;
        const strategy = file.strategy === 'standard-diff' ? 'diff' : file.strategy;
        const prefix = isFocused ? '> ' : '  ';
        const colorProps = isFocused ? { bold: true, color: 'cyan' } : {};

        if (reviewStatus === 'FAILED') {
            return (
                <Box>
                    <Text {...colorProps}>
                        {prefix}<Text color={iconColor}>{icon} FAILED {file.path}</Text>
                        <Text color="red">    ({reviewError})</Text>
                    </Text>
                </Box>
            );
        }

        if (reviewStatus === 'AWAITING') {
            return (
                <Box>
                    <Text {...colorProps}>
                        {prefix}<Text color={iconColor}>{icon} AWAITING {file.path}</Text>
                        <Text color="yellow">    ({reviewDetails})</Text>
                    </Text>
                </Box>
            );
        }

        if (reviewStatus === 'RE_APPLYING') {
            return (
                 <Box>
                    <Text {...colorProps}>
                        {prefix}<Text color={iconColor}>{icon} RE-APPLYING... {file.path}</Text>
                        <Text color="cyan"> (using &apos;replace&apos; strategy)</Text>
                    </Text>
                </Box>
            );
        }

        return (
            <Box>
                <Text {...colorProps}>
                    {prefix}<Text color={iconColor}>{icon}</Text> {file.type}{' '}
                    <Text color={typeColor(file.type)}>{file.path}</Text>{' '}
                    {diffStats} [{strategy}]
                </Text>
            </Box>
        );
    };


    const ScriptItemRow = ({
        script,
        isSelected,
        isExpanded,
    }: {
        script: ScriptResult;
        isSelected: boolean;
        isExpanded: boolean;
    }) => {
        const icon = script.success ? '✓' : '✗';
        const iconColor = script.success ? 'green' : 'red';
        const arrow = isExpanded ? '▾' : '▸';
        const prefix = isSelected ? '> ' : '  ';
        
        // Extract script type from command (e.g., "bun run test" -> "Post-Command", "bun run lint" -> "Linter")
        const scriptType = script.command.includes('test') ? 'Post-Command' : 
                          script.command.includes('lint') ? 'Linter' : 
                          'Script';

        return (
            <Box>
                <Text bold={isSelected} color={isSelected ? 'cyan' : undefined}>
                    {prefix}<Text color={iconColor}>{icon}</Text> {scriptType}: `{script.command}` ({script.duration}s) {arrow}{' '}
                    {script.summary}
                </Text>
            </Box>
        );
    };


    // --- Main Component ---


    const ReviewScreen = () => {
        const {
            transaction,
            files,
            scripts = [],
            patchStatus,
            selectedItemIndex,
            bodyView,
            isDiffExpanded,
            reasoningScrollIndex,
            scriptErrorIndex,
            fileReviewStates,
            numFiles,
            approvedFilesCount,
            totalLinesAdded,
            totalLinesRemoved,
            selectedBulkRepairOptionIndex,
            selectedBulkInstructOptionIndex,
            navigableItems,
            navigableItemsInView,
            viewOffset,
            contentScrollIndex,
            availableBodyHeight,
            hasRejectedFiles,
        } = useReviewScreen();

        if (!transaction) {
            return <Text>Loading review...</Text>;
        }
        const { hash, message, prompt = '', reasoning = '' } = transaction;

        const renderBody = () => {
            if (bodyView === 'none') return null;

            if (bodyView === 'reasoning') {
                const reasoningText = reasoning || '';
                const reasoningLinesCount = reasoningText.split('\n').length;
                const visibleLinesCount = 10;
                return (
                    <Box flexDirection="column">
                        <ReasonScreen
                            reasoning={reasoningText}
                            scrollIndex={contentScrollIndex}
                            visibleLinesCount={Math.max(1, availableBodyHeight)}
                        />
                        {reasoningLinesCount > visibleLinesCount && (
                            <Text color="gray">
                                Showing lines {reasoningScrollIndex + 1}-{Math.min(reasoningScrollIndex + visibleLinesCount, reasoningLinesCount)}{' '}
                                of {reasoningLinesCount}
                            </Text>
                        )}
                    </Box>
                );
            }
            
            if (bodyView === 'diff') {
                const currentItem = navigableItems[selectedItemIndex];
                const selectedFile = currentItem?.type === 'file' ? files.find(f => f.id === currentItem.id) : undefined;
                if (!selectedFile) return null;
                return (
                    <DiffScreen
                        filePath={selectedFile.path}
                        diffContent={selectedFile.diff}
                        isExpanded={isDiffExpanded}
                        scrollIndex={contentScrollIndex}
                        maxHeight={Math.max(1, availableBodyHeight)}
                    />
                );
            }

            if (bodyView === 'script_output') {
                 const currentItem = navigableItems[selectedItemIndex];
                 const scriptItems = navigableItems.filter((i): i is { type: 'script'; id: string } => i.type === 'script');
                 const scriptIndex = currentItem?.type === 'script'
                    ? scriptItems.findIndex(i => i.id === currentItem.id)
                    : -1;
                 const selectedScript = scripts[scriptIndex] || null;
                 if (!selectedScript) return null;
                 
                 const outputLines = selectedScript.output.split('\n');
                 const errorLines = outputLines.filter((line: string) =>
                    line.includes('Error') || line.includes('Warning'),
                 );
                 
                 return (
                    <Box flexDirection="column">
                        <Text>
                            {selectedScript.command.includes('lint') ? 'LINTER' : 'SCRIPT'} OUTPUT: `{selectedScript.command}`
                        </Text>
                        <Box marginTop={1} flexDirection="column">
                            {outputLines.map((line: string, index: number) => {
                                const isError = line.includes('Error');
                                const isWarning = line.includes('Warning');
                                const isHighlighted = errorLines[scriptErrorIndex] === line;
                                
                                return (
                                    <Text 
                                        key={index} 
                                        color={isError ? 'red' : isWarning ? 'yellow' : undefined}
                                        bold={isHighlighted}
                                        backgroundColor={isHighlighted ? 'blue' : undefined}
                                    >
                                        {line}
                                    </Text>
                                );
                            })}
                        </Box>
                        {errorLines.length > 0 && (
                            <Text color="gray">
                                Error {scriptErrorIndex + 1} of {errorLines.length} highlighted
                            </Text>
                        )}
                    </Box>
                 );
            }

            if (bodyView === 'confirm_handoff') {
                return (
                    <Box flexDirection="column" gap={1}>
                        <Text bold>HANDOFF TO EXTERNAL AGENT</Text>
                        <Box flexDirection="column">
                            <Text>This action will:</Text>
                            <Text>1. Copy a detailed prompt to your clipboard for an agentic AI.</Text>
                            <Text>2. Mark the current transaction as &apos;Handoff&apos; and close this review.</Text>
                            <Text>3. Assume that you and the external agent will complete the work.</Text>
                        </Box>
                        <Text>Relaycode will NOT wait for a new patch. This is a final action.</Text>
                        <Text bold color="yellow">Are you sure you want to proceed?</Text>
                    </Box>
                );
            }

            if (bodyView === 'bulk_repair') {
                const failedFiles = files.filter((f: FileItem) => fileReviewStates.get(f.id)?.status === 'FAILED');
                const repairOptions = [
                    '(1) Copy Bulk Re-apply Prompt (for single-shot AI)',
                    '(2) Bulk Change Strategy & Re-apply',
                    '(3) Handoff to External Agent',
                    '(4) Bulk Abandon All Failed Files',
                    '(Esc) Cancel',
                ];

                return (
                    <Box flexDirection="column" gap={1}>
                        <Text bold>BULK REPAIR ACTION</Text>

                        <Box flexDirection="column">
                            <Text>The following {failedFiles.length} files failed to apply:</Text>
                            {failedFiles.map((file: FileItem) => (
                                <Text key={file.id}>- {file.path}</Text>
                            ))}
                        </Box>

                        <Text>How would you like to proceed?</Text>

                        <Box flexDirection="column">
                            {repairOptions.map((opt, i) => (
                                <Text key={i} color={selectedBulkRepairOptionIndex === i ? 'cyan' : undefined}>
                                    {selectedBulkRepairOptionIndex === i ? '> ' : '  '}
                                    {opt}
                                </Text>
                            ))}
                        </Box>
                    </Box>
                );
            }

            if (bodyView === 'bulk_instruct') {
                const rejectedFiles = files.filter((f: FileItem) => fileReviewStates.get(f.id)?.status === 'REJECTED');
                const instructOptions = [
                    '(1) Copy Bulk Re-instruct Prompt (for single-shot AI)',
                    '(2) Handoff to External Agent',
                    '(3) Bulk Un-reject All Files (revert to original)',
                    '(4) Cancel',
                ];

                return (
                    <Box flexDirection="column" gap={1}>
                        <Text bold>BULK INSTRUCTION ACTION</Text>

                        <Box flexDirection="column">
                            <Text>The following {rejectedFiles.length} files were rejected:</Text>
                            {rejectedFiles.map((file: FileItem) => (
                                <Text key={file.id}>- {file.path}</Text>
                            ))}
                        </Box>
                        <Box flexDirection="column" marginTop={1}>
                            {instructOptions.map((opt, i) => (
                                <Text key={i} color={selectedBulkInstructOptionIndex === i ? 'cyan' : undefined}>
                                    {selectedBulkInstructOptionIndex === i ? '> ' : '  '}
                                    {opt}
                                </Text>
                            ))}
                        </Box>
                    </Box>
                );
            }

            return null;
        };

        const renderFooter = () => {
            // Contextual footer for body views
            if (bodyView === 'diff') {
                return <ActionFooter actions={[
                    { key: '↑↓', label: 'Nav' },
                    { key: 'X', label: 'Expand' },
                    { key: 'D/Esc', label: 'Back' },
                ]}/>;
            }
            if (bodyView === 'reasoning') {
                return <ActionFooter actions={[
                    { key: '↑↓', label: 'Scroll Text' },
                    { key: 'R', label: 'Collapse View' },
                    { key: 'C', label: 'Copy Mode' },
                ]}/>;
            }
            if (bodyView === 'script_output') {
                return <ActionFooter actions={[
                    { key: '↑↓', label: 'Nav' },
                    { key: 'J↓/K↑', label: 'Next/Prev Error' },
                    { key: 'C', label: 'Copy Output' },
                    { key: 'Ent/Esc', label: 'Back' },
                ]}/>;
            }
            if (bodyView === 'bulk_repair') {
                return <Text>Use (↑↓) Nav · (Enter) Select · (1-4) Jump · (Esc) Cancel</Text>;
            }
            if (bodyView === 'bulk_instruct') {
                return <Text>Use (↑↓) Nav · (Enter) Select · (1-4) Jump · (Esc) Cancel</Text>;
            }
            if (bodyView === 'confirm_handoff') {
                return <ActionFooter actions={[
                    { key: 'Enter', label: 'Confirm Handoff' },
                    { key: 'Esc', label: 'Cancel' },
                ]}/>;
            }

            // Main footer
            const actions: ActionItem[] = [{ key: '↑↓', label: 'Nav' }];

            const currentItem = navigableItems[selectedItemIndex];
            
            if (currentItem?.type === 'file') {
                const selectedFile = files.find(f => f.id === currentItem.id);
                const fileState = fileReviewStates.get(currentItem.id);
                if (fileState?.status !== 'FAILED') {
                    actions.push({ key: 'Spc', label: 'Toggle' });
                }
                actions.push({ key: 'D', label: 'Diff' });
                
                // Add repair options for failed files
                if (selectedFile && fileState?.status === 'FAILED') {
                    actions.push({ key: 'T', label: 'Try Repair' });
                }
                if (selectedFile && fileState?.status === 'REJECTED') {
                    actions.push({ key: 'I', label: 'Instruct' });
                }
            } else if (currentItem?.type === 'script') {
                actions.push({ key: 'Ent', label: 'Expand Details' });
            } else { // Prompt or Reasoning
                actions.push({ key: 'Ent', label: 'Expand' });
            }

            if (currentItem?.type !== 'reasoning') {
                actions.push({ key: 'R', label: 'Reasoning' });
            }

            // Add bulk repair if there are failed files
            const hasFailedFiles = Array.from(fileReviewStates.values()).some(s => s.status === 'FAILED');
            if (hasFailedFiles) {
                actions.push({ key: 'Shift+T', label: 'Bulk Repair' });
            }
            // Add bulk instruct if there are rejected files
            if (hasRejectedFiles) {
                actions.push({ key: 'Shift+I', label: 'Bulk Instruct' });
            }
            
            actions.push({ key: 'C', label: 'Copy' });

            if (approvedFilesCount > 0) {
                actions.push({ key: 'A', label: 'Approve' });
            }

            if (Array.from(fileReviewStates.values()).some(s => s.status === 'APPROVED' || s.status === 'FAILED')) {
                actions.push({ key: 'Shift+R', label: 'Reject All' });
            }
            actions.push({ key: 'Q', label: 'Quit' });

            return <ActionFooter actions={actions} />;
        };

        return (
            <Box flexDirection="column">
                {/* Header */}
                <Text color="cyan">▲ relaycode review</Text>
                <Separator />
                
                {/* Navigator Section */}
                <Box flexDirection="column" marginY={1}>
                    <Box flexDirection="column">
                        <Text>{hash} · {message}</Text>
                        <Text>
                            (<Text color="green">+{totalLinesAdded}</Text>/<Text color="red">-{totalLinesRemoved}</Text>
                            ) · {numFiles} Files · ({approvedFilesCount}/{numFiles} Appr)
                            · Showing {viewOffset + 1}-
                            {Math.min(viewOffset + navigableItemsInView.length, navigableItems.length)} of {navigableItems.length}
                            {patchStatus === 'PARTIAL_FAILURE' && scripts.length === 0 && <Text> · Scripts: SKIPPED</Text>}
                            {patchStatus === 'PARTIAL_FAILURE' && <Text color="red" bold> · MULTIPLE PATCHES FAILED</Text>}
                        </Text>
                    </Box>

                    <Box flexDirection="column" marginTop={1}>
                        <Text color={navigableItems[selectedItemIndex]?.type === 'prompt' ? 'cyan' : undefined}>
                            {navigableItems[selectedItemIndex]?.type === 'prompt' ? '> ' : '  '}
                            (P)rompt ▸ {(prompt || '').substring(0, 60)}...
                        </Text>
                        <Text color={navigableItems[selectedItemIndex]?.type === 'reasoning' ? 'cyan' : undefined}>
                            {navigableItems[selectedItemIndex]?.type === 'reasoning' ? '> ' : '  '}
                            (R)easoning ({(reasoning || '').split('\n\n').length} steps) {bodyView === 'reasoning' ? '▾' : '▸'}{' '}
                            {((reasoning || '').split('\n')[0] ?? '').substring(0, 50)}...
                        </Text>
                    </Box>
                </Box>

                <Separator />

                {/* Script Results (if any) */}
                {scripts.length > 0 && navigableItemsInView.some(i => i.type === 'script') && (
                    <>
                        <Box flexDirection="column" marginY={1}>
                            {scripts.map((script: ScriptResult) => {
                                const itemInViewIndex = navigableItemsInView.findIndex(i => i.type === 'script' && i.id === script.command);
                                if (itemInViewIndex === -1) return null; // Only render if visible
                                
                                const isSelected = selectedItemIndex === viewOffset + itemInViewIndex;
                                return (
                                    <ScriptItemRow key={script.command} script={script} isSelected={isSelected} isExpanded={bodyView === 'script_output' && isSelected} />
                                );
                            })}
                        </Box>
                        <Separator />
                    </>
                )}
                
                {/* Files Section */}
                <Box flexDirection="column" marginY={1}>
                    <Text bold>FILES</Text>
                    {files.map((file: FileItem) => {
                        const itemInViewIndex = navigableItemsInView.findIndex(i => i.type === 'file' && i.id === file.id);
                        if (itemInViewIndex === -1) return null; // Only render if visible

                        const isFocused = selectedItemIndex === viewOffset + itemInViewIndex;
                        const reviewState = fileReviewStates.get(file.id);
                        
                        return (
                            <FileItemRow
                                key={file.id} file={file} isFocused={isFocused}
                                reviewStatus={reviewState?.status || 'AWAITING'}
                                reviewError={reviewState?.error}
                                reviewDetails={reviewState?.details}
                            />
                        );
                    })}
                </Box>
                
                <Separator />
                
                {/* Body Viewport */}
                {bodyView !== 'none' && (
                    <>
                        <Box marginY={1}>
                            {renderBody()}
                        </Box>
                        <Separator />
                    </>
                )}

                {/* Footer */}
                <Box>
                    {renderFooter()}
                </Box>
            </Box>
        );
    };


    export default ReviewScreen;
  src/components/TransactionDetailScreen.tsx: >-
    import { Box, Text } from 'ink';

    import Separator from './Separator';

    import DiffScreen from './DiffScreen';

    import ReasonScreen from './ReasonScreen';

    import { useTransactionDetailScreen } from
    '../hooks/useTransactionDetailScreen';

    import type { FileChangeType } from '../types/domain.types';

    import ActionFooter from './ActionFooter';

    import type { ActionItem } from '../types/actions.types';


    const getFileChangeTypeIcon = (type: FileChangeType) => {
        switch (type) {
            case 'MOD': return '[MOD]';
            case 'ADD': return '[ADD]';
            case 'DEL': return '[DEL]';
            case 'REN': return '[REN]';
        }
    };


    const RevertModal = ({ transactionHash }: { transactionHash: string }) => {
        return (
            <Box 
                borderStyle="round"
                borderColor="yellow"
                flexDirection="column"
                paddingX={2}
                width="80%"
                alignSelf='center'
            >
                <Text bold color="yellow" wrap="wrap" >REVERT THIS TRANSACTION?</Text>
                <Box height={1} />
                <Text wrap="wrap">This will create a NEW transaction that reverses all changes made by {transactionHash}. The original transaction record will be preserved.</Text>
                <Box height={1} />
                <Text wrap="wrap">Are you sure?</Text>
            </Box>
        );
    };


    const TransactionDetailScreen = () => {
        const {
            transaction, files,
            focusedItemPath, expandedItemPaths, bodyView, contentScrollIndex, availableBodyHeight,
        } = useTransactionDetailScreen();

        if (!transaction) {
            return <Text>Loading transaction...</Text>;
        }

        const renderNavigator = () => {
            const isPromptFocused = focusedItemPath === 'PROMPT';
            const isReasoningFocused = focusedItemPath === 'REASONING';
            const isFilesFocused = focusedItemPath.startsWith('FILES');
            
            const isPromptExpanded = expandedItemPaths.has('PROMPT');
            const isReasoningExpanded = expandedItemPaths.has('REASONING');
            const isFilesExpanded = expandedItemPaths.has('FILES');
            
            return (
                <Box flexDirection="column">
                    <Text color={isPromptFocused ? 'cyan' : undefined}>
                        {isPromptFocused ? '> ' : '  '}
                        {isPromptExpanded ? '▾' : '▸'} (P)rompt
                    </Text>
                    <Text color={isReasoningFocused ? 'cyan' : undefined}>
                        {isReasoningFocused ? '> ' : '  '}
                        {isReasoningExpanded ? '▾' : '▸'} (R)easoning ({transaction.reasoning?.split('\n\n').length || 0} steps)
                    </Text>
                    <Text color={isFilesFocused ? 'cyan' : undefined}>
                        {isFilesFocused && !focusedItemPath.includes('/') ? '> ' : '  '}
                        {isFilesExpanded ? '▾' : '▸'} (F)iles ({files.length})
                    </Text>
                    {isFilesExpanded && (
                        <Box flexDirection="column" paddingLeft={2}>
                            {files.map((file) => {
                                 const fileId = `FILES/${file.id}`;
                                 const isFileSelected = focusedItemPath === fileId;
                                 const stats = file.type === 'DEL'
                                    ? ''
                                    : ` (+${file.linesAdded}/-${file.linesRemoved})`;
                                 return (
                                    <Text key={file.id} color={isFileSelected ? 'cyan' : undefined}>
                                        {isFileSelected ? '> ' : '  '}
                                        {getFileChangeTypeIcon(file.type)} {file.path}{stats}
                                    </Text>
                                );
                            })}
                        </Box>
                    )}
                </Box>
            );
        };

        const renderBody = () => {
            if (bodyView === 'NONE') {
                return <Text color="gray">(Press → to expand a section and view its contents)</Text>;
            }
            if (bodyView === 'PROMPT') {
                return (
                    <Box flexDirection="column">
                        <Text>PROMPT</Text>
                        <Box marginTop={1} flexDirection="column">
                            {(transaction.prompt || '').split('\n')
                                .slice(contentScrollIndex, contentScrollIndex + availableBodyHeight)
                                .map((line, i) => <Text key={i}>{line}</Text>)
                            }
                        </Box>
                    </Box>
                );
            }
            if (bodyView === 'REASONING') {
                if (!transaction.reasoning) return <Text color="gray">No reasoning provided.</Text>;
                return <ReasonScreen reasoning={transaction.reasoning} scrollIndex={contentScrollIndex} visibleLinesCount={Math.max(1, availableBodyHeight)} />;
            }
            if (bodyView === 'FILES_LIST') {
                 return <Text color="gray">(Select a file and press → to view the diff)</Text>;
            }
            if (bodyView === 'DIFF_VIEW') {
                const fileId = focusedItemPath.split('/')[1];
                const file = files.find(f => f.id === fileId);
                if (!file) return null;
                return <DiffScreen filePath={file.path} diffContent={file.diff} isExpanded={true} scrollIndex={contentScrollIndex} maxHeight={Math.max(1, availableBodyHeight)} />;
            }
            return null;
        };

        const renderFooter = () => {
            if (bodyView === 'REVERT_CONFIRM') {
                return <ActionFooter actions={[
                    { key: 'Enter', label: 'Confirm Revert' },
                    { key: 'Esc', label: 'Cancel' },
                ]} />;
            }
            
            const isFileFocused = focusedItemPath.includes('/');
            const baseActions: ActionItem[] = [
                { key: 'C', label: 'Copy' },
                { key: 'O', label: isFileFocused ? 'Open File' : 'Open YAML' },
                { key: 'U', label: 'Undo' },
                { key: 'Q', label: 'Quit/Back' },
            ];
            let contextualActions: ActionItem[] = [];

            if (isFileFocused) { // Is a file
                if (bodyView === 'DIFF_VIEW') {
                    contextualActions = [
                        { key: '↑↓', label: 'Nav Files' },
                        { key: '←', label: 'Back to List' },
                    ];
                } else {
                    contextualActions = [
                        { key: '↑↓', label: 'Nav Files' },
                        { key: '→', label: 'View Diff' },
                        { key: '←', label: 'Back to Sections' },
                    ];
                }
                return <ActionFooter actions={[...contextualActions, ...baseActions]} />;
            }
            
            if (expandedItemPaths.has(focusedItemPath)) {
                contextualActions = [
                    { key: '↑↓', label: 'Nav/Scroll' },
                    { key: '→', label: 'Drill In' },
                    { key: '←', label: 'Collapse' },
                ];
            } else {
                contextualActions = [
                    { key: '↑↓', label: 'Nav' },
                    { key: '→', label: 'Expand' },
                ];
            }
            return <ActionFooter actions={[...contextualActions, ...baseActions]} />;
        };

        const { message, timestamp, status } = transaction;
        const date = new Date(timestamp).toISOString().replace('T', ' ').substring(0, 19);
        const fileStats = `${files.length} Files · +${files.reduce((a, f) => a + f.linesAdded, 0)} lines, -${files.reduce((a, f) => a + f.linesRemoved, 0)} lines`;

        return (
            <Box flexDirection="column">
                {/* Header */}
                <Text>▲ relaycode transaction details</Text>
                <Separator />
                
                {/* Modal takeover for Revert */}
                {bodyView === 'REVERT_CONFIRM' && <RevertModal transactionHash={transaction.hash} />}
                
                {/* Main view */}
                <Box flexDirection="column" display={bodyView === 'REVERT_CONFIRM' ? 'none' : 'flex'}>
                    {/* Navigator Part A */}
                    <Box flexDirection="column" marginY={1}>
                        <Text>UUID: {transaction.id}</Text>
                        <Text>Git: {message}</Text>
                        <Text>Date: {date} · Status: {status}</Text>
                        <Text>Stats: {fileStats}</Text>
                    </Box>
                    
                    {/* Navigator Part B */}
                    {renderNavigator()}
                    
                    <Separator />
                    
                    {/* Body */}
                    <Box marginY={1}>
                        {renderBody()}
                    </Box>
                    
                    <Separator />
                </Box>
                
                {/* Footer */}
                <Box>
                    {renderFooter()}
                </Box>
            </Box>
        );
    };


    export default TransactionDetailScreen;
  src/components/TransactionHistoryScreen.tsx: >-
    import { useMemo } from 'react';

    import { Box, Text } from 'ink';

    import TextInput from 'ink-text-input';

    import Spinner from 'ink-spinner';

    import Separator from './Separator';

    import type { Transaction, FileItem } from '../types/domain.types';

    import { useTransactionHistoryScreen } from
    '../hooks/useTransactionHistoryScreen';

    import type { LayoutConfig } from '../hooks/useLayout';

    import ActionFooter from './ActionFooter';

    import type { ActionItem } from '../types/actions.types';


    // --- Sub-components ---


    const ContentRow = ({ title, content, isSelected, isExpanded, isLoading }: {
        title: string;
        content: string;
        isSelected: boolean;
        isExpanded: boolean;
        isLoading: boolean;
    }) => {
        const icon = isExpanded ? '▾' : '▸';
        return (
            <Box flexDirection="column" paddingLeft={6}>
                <Text color={isSelected ? 'cyan' : undefined}>
                    {isSelected ? '> ' : '  '}{icon} {title}
                </Text>
                {isLoading && <Box paddingLeft={8}><Spinner type="dots" /></Box>}
                {isExpanded && !isLoading && (
                    <Box paddingLeft={8} flexDirection="column">
                        {(content || '').split('\n').map((line, i) => <Text key={i}>{line || ' '}</Text>)}
                    </Box>
                )}
            </Box>
        );
    };


    const DiffPreview = ({ diff }: { diff: string }) => {
        const lines = diff.split('\n');
        const previewLines = lines.slice(0, 5);
        const hiddenLines = lines.length > 5 ? lines.length - 5 : 0;

        return (
            <Box flexDirection="column" paddingLeft={8}>
                {previewLines.map((line, i) => {
                    let color = 'white';
                    if (line.startsWith('+')) color = 'green';
                    if (line.startsWith('-')) color = 'red';
                    if (line.startsWith('@@')) color = 'cyan';
                    return <Text key={i} color={color}>{line}</Text>;
                })}
                {hiddenLines > 0 && <Text color="gray">... {hiddenLines} lines hidden ...</Text>}
            </Box>
        );
    };


    const FileRow = ({ file, isSelected, isExpanded, isLoading }: {
        file: FileItem;
        isSelected: boolean;
        isExpanded: boolean;
        isLoading: boolean;
    }) => {
        const icon = isExpanded ? '▾' : '▸';
        const typeMap = { MOD: '[MOD]', ADD: '[ADD]', DEL: '[DEL]', REN: '[REN]' };
        
        return (
            <Box flexDirection="column" paddingLeft={6}>
                <Text color={isSelected ? 'cyan' : undefined}>
                    {isSelected ? '> ' : '  '}
                    {icon} {typeMap[file.type]} {file.path}
                </Text>
                {isLoading && <Box paddingLeft={8}><Spinner type="dots" /></Box>}
                {isExpanded && !isLoading && <DiffPreview diff={file.diff} />}
            </Box>
        );
    };


    const TransactionRow = ({
        tx,
        isSelected,
        isExpanded,
        isSelectedForAction,
        hasSelection,
    }: {
        tx: Transaction;
        isSelected: boolean;
        isExpanded: boolean;
        isSelectedForAction: boolean;
        hasSelection: boolean;
    }) => {
        const icon = isExpanded ? '▾' : '▸';
        const statusMap = {
            COMMITTED: <Text color="green">✓ Committed</Text>,
            HANDOFF: <Text color="magenta">→ Handoff</Text>,
            REVERTED: <Text color="gray">↩ Reverted</Text>,
            APPLIED: <Text color="blue">✓ Applied</Text>,
            PENDING: <Text color="yellow">? Pending</Text>,
            FAILED: <Text color="red">✗ Failed</Text>,
        };
        const date = new Date(tx.timestamp).toISOString().split('T')[0];
        const selectionIndicator = isSelectedForAction ? '[x] ' : '[ ] ';
        
        const statusDisplay = statusMap[tx.status as keyof typeof statusMap] || tx.status;

        return (
            <Box flexDirection="column" marginBottom={isExpanded ? 1 : 0}>
                <Text color={isSelected ? 'cyan' : undefined}>
                    {isSelected ? '> ' : '  '}
                    {hasSelection && selectionIndicator}
                    {icon} {statusDisplay} · {tx.hash} · {date} ·{' '}
                    {tx.message}
                </Text>
                {isExpanded && (
                    <Box flexDirection="column" paddingLeft={8}>
                        {tx.stats && (
                            <Text color="gray">
                                Stats: {tx.stats.files} files, +{tx.stats.linesAdded}/-{tx.stats.linesRemoved}
                            </Text>
                        )}
                        <Text>Files:</Text>
                    </Box>
                )}
            </Box>
        );
    };


    const BulkActionsMode = ({ selectedForActionCount }: {
    selectedForActionCount: number }) => {
        return (
            <Box flexDirection="column" marginY={1}>
                <Text bold color="yellow">PERFORM BULK ACTION ON {selectedForActionCount} SELECTED ITEMS</Text>
                <Box marginY={1}>
                    <Text>This action is often irreversible. Are you sure?</Text>
                </Box>
                <Text>(1) Revert Selected Transactions</Text>
                <Text>(2) Mark as &apos;Git Committed&apos;</Text>
                <Text>(3) Delete Selected Transactions (from Relaycode history)</Text>
                <Text>(Esc) Cancel</Text>
            </Box>
        );
    };


    // --- Main Component ---


    const TransactionHistoryScreen = () => {
        const {
            mode,
            filterQuery,
            selectedForAction,
            selectedItemPath,
            expandedIds,
            loadingPaths,
            actions,
            transactions,
            itemsInView,
            filterStatus,
            showingStatus,
            statsStatus,
            hasSelection,
        } = useTransactionHistoryScreen({
            layoutConfig: {
                header: 1,
                separators: 2, // after header, after list
                fixedRows: 1, // filter row
                marginsY: 1, // for list
                footer: 2,
            },
        });

        const transactionsById = useMemo(() => new Map(transactions.map(tx => [tx.id, tx])), [transactions]);

        const renderFooter = () => {
            if (mode === 'FILTER') return <Text>(Enter) Apply Filter & Return      (Esc) Cancel</Text>; 
            if (mode === 'BULK_ACTIONS') return <Text>Choose an option [1-3] or (Esc) Cancel</Text>;
            
            const openActionLabel = selectedItemPath.includes('/file/') ? 'Open File' : 'Open YAML';
            const footerActions: ActionItem[] = [
                { key: '↑↓/PgUp/PgDn', label: 'Nav' },
                { key: '→', label: 'Expand' },
                { key: '←', label: 'Collapse' },
                { key: 'Spc', label: 'Select' },
                { key: 'Ent', label: 'Details' },
                { key: 'O', label: openActionLabel },
                { key: 'F', label: 'Filter' },
            ];

            if (selectedForAction.size > 0) {
                footerActions.push({ key: 'C', label: 'Copy' }, { key: 'B', label: 'Bulk' });
            }
            return <ActionFooter actions={footerActions} />;
        };

        return (
            <Box flexDirection="column">
                <Text color="cyan">▲ relaycode transaction history</Text>
                <Separator />

                <Box>
                    <Text>Filter: </Text>
                    {mode === 'FILTER' ? (
                        <TextInput value={filterQuery} onChange={actions.setFilterQuery} />
                    ) : (
                        <Text>{filterStatus}</Text>
                    )}
                    <Text> · {showingStatus}</Text>
                    {statsStatus && <Text> · {statsStatus}</Text>}
                </Box>

                <Box flexDirection="column" marginY={1}>
                    {mode === 'BULK_ACTIONS' && <BulkActionsMode selectedForActionCount={selectedForAction.size} />}

                    {mode === 'LIST' && itemsInView.map(path => {
                        const txId = path.split('/')[0]!;
                        const tx = transactionsById.get(txId);
                        if (!tx) return <Text key={path}>Error: Missing TX {txId}</Text>;

                        // Is a transaction row
                        if (path === tx.id) {
                            return (
                                <TransactionRow
                                    key={path}
                                    tx={tx}
                                    isSelected={selectedItemPath === path}
                                    isExpanded={expandedIds.has(path)}
                                    isSelectedForAction={selectedForAction.has(tx.id)}
                                    hasSelection={hasSelection}
                                />
                            );
                        }

                        // Is a child row
                        const itemType = path.split('/')[1]!;
                        const isSelected = selectedItemPath === path;
                        const isExpanded = expandedIds.has(path);
                        const isLoading = loadingPaths.has(path);

                        if (itemType === 'file') {
                            const fileId = path.split('/')[2]!;
                            const file = tx.files?.find(f => f.id === fileId);
                            if (!file) return null;
                            return (
                                <FileRow
                                    key={path} file={file} isSelected={isSelected}
                                    isExpanded={isExpanded} isLoading={isLoading}
                                />
                            );
                        }

                        const contentMap = {
                            message: { title: 'Commit Message', content: tx.message || '' },
                            prompt: { title: 'Prompt', content: tx.prompt || '' },
                            reasoning: { title: 'Reasoning', content: tx.reasoning || '' },
                        };

                        const item = contentMap[itemType as keyof typeof contentMap];
                        if (!item) return null;

                        return (
                            <ContentRow
                                key={path}
                                {...item}
                                isSelected={isSelected}
                                isExpanded={isExpanded}
                                isLoading={isLoading}
                            />
                        );
                    })}
                </Box>

                <Separator />
                {renderFooter()}
            </Box>
        );
    };


    export default TransactionHistoryScreen;
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 165
