uuid: c25f9b9f-d009-40da-b413-568b2434579c
projectId: relaycode-tui
createdAt: '2025-09-22T07:22:04.447Z'
gitCommitMsg: >-
  fix(types): export types from stores and hooks to fix compilation errors

  Several UI components were unable to import types because they were not
  re-exported from the stores and hooks they were consuming. This resulted in 15
  TypeScript errors.

  This commit fixes these issues by: - Changing internal `import type` to
  `export type` in relevant store and
    hook files.
  - Adding an aliased export (`ReviewFileItem as FileItem`) to fix a
    component import typo without changing the store's internal logic.
  - Adding a new type export where one was missing.

  These changes resolve all reported TypeScript compilation errors and should
  also fix related implicit `any` errors in the components.
promptSummary: >-
  Fix all TypeScript compilation errors by exporting necessary types from stores
  and hooks.
reasoning:
  - >-
    I will fix the TypeScript errors by ensuring that types used in components
    are properly exported from the hooks and stores they are imported from. The
    primary issue is that many types are imported into store or hook files for
    internal use but are not re-exported, causing import errors in the UI
    components that consume them.
  - 'My plan is as follows:'
  - >-
    1.  In `src/stores/dashboard.store.ts`, I will change the type imports for
    `Transaction`, `TransactionStatus`, and `DashboardStatus` to be type
    exports, making them available to `DashboardScreen.tsx`.
  - >-
    2.  In `src/hooks/useDebugMenu.tsx`, I will export the `MenuItem` type so
    `DebugMenu.tsx` can import it.
  - >-
    3.  In `src/stores/init.store.ts`, I will export the `Task` type (and
    related types) for use in `InitializationScreen.tsx`.
  - >-
    4.  In `src/stores/review.store.ts`, I will export `ApplyStep` and
    `ScriptResult`. I'll also export `ReviewFileItem` with an alias `FileItem`
    to fix the component's typo without breaking the store's internal usage.
  - >-
    5.  In `src/stores/transaction-detail.store.ts`, I will add a type export
    for `FileChangeType` which is needed by `TransactionDetailScreen.tsx`.
  - >-
    6.  In `src/stores/transaction-history.store.ts`, I will export
    `HistoryTransaction` and `FileChange` to resolve typing issues in
    `TransactionHistoryScreen.tsx`, which should also fix the implicit `any`
    errors.
  - >-
    These changes are all surgical modifications to export existing or needed
    types and should resolve all 15 compilation errors.
operations:
  - type: write
    path: src/hooks/useDebugMenu.tsx
    content: |+
      --- src/hooks/useDebugMenu.tsx
      +++ src/hooks/useDebugMenu.tsx
      @@ -8,7 +8,7 @@
       import { useCommitStore } from '../stores/commit.store';
       import { useTransactionDetailStore } from '../stores/transaction-detail.store';
       import { useTransactionHistoryStore } from '../stores/transaction-history.store';
      -import type { MenuItem } from '../types/debug.types';
      +export type { MenuItem } from '../types/debug.types';
       
       export const useDebugMenu = () => {
           const [selectedIndex, setSelectedIndex] = useState(0);

    patchStrategy: standard-diff
  - type: write
    path: src/stores/dashboard.store.ts
    content: >+
      --- src/stores/dashboard.store.ts

      +++ src/stores/dashboard.store.ts

      @@ -2,8 +2,8 @@
       import { create } from 'zustand';
       import { DashboardService } from '../services/dashboard.service';
       import { createDashboardTransactions } from '../data/mocks';
      -import type { Transaction, TransactionStatus } from
      '../types/transaction.types';

      -import type { DashboardStatus } from '../types/dashboard.types';

      +export type { Transaction, TransactionStatus } from
      '../types/transaction.types';

      +export type { DashboardStatus } from '../types/dashboard.types';
       
       // --- Store Interface ---
       interface DashboardState {

    patchStrategy: standard-diff
  - type: write
    path: src/stores/init.store.ts
    content: >+
      --- src/stores/init.store.ts

      +++ src/stores/init.store.ts

      @@ -1,5 +1,5 @@
       import { create } from 'zustand';
      -import type { Task, TaskStatus, InitPhase, GitignoreChoice } from
      '../types/init.types';

      +export type { Task, TaskStatus, InitPhase, GitignoreChoice } from
      '../types/init.types';
       
       // Initial State definitions from README
       export const initialAnalyzeTasks: Task[] = [

    patchStrategy: standard-diff
  - type: write
    path: src/stores/review.store.ts
    content: >+
      --- src/stores/review.store.ts

      +++ src/stores/review.store.ts

      @@ -5,8 +5,8 @@
       import { useDashboardStore } from './dashboard.store';
       import { ReviewService } from '../services/review.service';
       import { mockReviewFiles, mockReviewScripts, mockReviewReasoning } from '../data/mocks';
      -import type { ReviewFileItem } from '../types/file.types';

      -import type { ScriptResult, ApplyStep, ReviewBodyView, PatchStatus } from
      '../types/review.types';

      +export type { ReviewFileItem, ReviewFileItem as FileItem } from
      '../types/file.types';

      +export type { ScriptResult, ApplyStep, ReviewBodyView, PatchStatus } from
      '../types/review.types';
       
       export const initialApplySteps: ApplyStep[] = [
           { id: 'snapshot', title: 'Reading initial file snapshot...', status: 'pending' },

    patchStrategy: standard-diff
  - type: write
    path: src/stores/transaction-detail.store.ts
    content: |+
      --- src/stores/transaction-detail.store.ts
      +++ src/stores/transaction-detail.store.ts
      @@ -5,6 +5,7 @@
       import { mockDetailedTransactionData } from '../data/mocks';
       import type { Transaction } from '../types/transaction.types';
       import type { FileChange as FileDetail } from '../types/file.types';
      +export type { FileChangeType } from '../types/file.types';
       import type { NavigatorSection, DetailBodyView } from '../types/transaction-detail.types';
       
       interface TransactionDetailState {

    patchStrategy: standard-diff
  - type: write
    path: src/stores/transaction-history.store.ts
    content: |+
      --- src/stores/transaction-history.store.ts
      +++ src/stores/transaction-history.store.ts
      @@ -1,8 +1,8 @@
       import { create } from 'zustand';
       import { TransactionService } from '../services/transaction.service';
      -import type { HistoryTransaction } from '../types/transaction.types';
      -import type { FileChange } from '../types/file.types';
      +export type { HistoryTransaction } from '../types/transaction.types';
      +export type { FileChange } from '../types/file.types';
       import type { HistoryViewMode } from '../types/transaction-history.types';
       
       // Omit 'actions' from state type for partial updates

    patchStrategy: standard-diff
snapshot:
  src/hooks/useDebugMenu.tsx: >-
    import { useState } from 'react';

    import { useInput } from 'ink';

    import { useAppStore } from '../stores/app.store';

    import { useDashboardStore } from '../stores/dashboard.store';

    import { useInitStore } from '../stores/init.store';

    import { useReviewStore } from '../stores/review.store';

    import { useCommitStore } from '../stores/commit.store';

    import { useTransactionDetailStore } from
    '../stores/transaction-detail.store';

    import { useTransactionHistoryStore } from
    '../stores/transaction-history.store';

    import type { MenuItem } from '../types/debug.types';


    export const useDebugMenu = () => {
        const [selectedIndex, setSelectedIndex] = useState(0);
        const appActions = useAppStore(s => s.actions);
        const dashboardActions = useDashboardStore(s => s.actions);
        const initActions = useInitStore(s => s.actions);
        const reviewActions = useReviewStore(s => s.actions);
        const commitActions = useCommitStore(s => s.actions);
        const detailActions = useTransactionDetailStore(s => s.actions);
        const historyActions = useTransactionHistoryStore(s => s.actions);

        const menuItems: MenuItem[] = [
            {
                title: 'Splash Screen',
                action: () => appActions.showSplashScreen(),
            },
            {
                title: 'Init: Analyze Phase',
                action: () => {
                    initActions.setPhase('ANALYZE');
                    appActions.showInitScreen();
                },
            },
            {
                title: 'Init: Interactive Phase',
                action: () => {
                    initActions.setPhase('INTERACTIVE');
                    appActions.showInitScreen();
                },
            },
            {
                title: 'Init: Finalize Phase',
                action: () => {
                    initActions.setPhase('FINALIZE');
                    appActions.showInitScreen();
                },
            },
            {
                title: 'Dashboard: Listening',
                action: () => {
                    dashboardActions.setStatus('LISTENING');
                    appActions.showDashboardScreen();
                },
            },
            {
                title: 'Dashboard: Confirm Approve',
                action: () => {
                    dashboardActions.setStatus('CONFIRM_APPROVE');
                    appActions.showDashboardScreen();
                },
            },
            {
                title: 'Dashboard: Approving',
                action: () => {
                    dashboardActions.setStatus('APPROVING');
                    appActions.showDashboardScreen();
                },
            },
            {
                title: 'Review: Partial Failure (Default)',
                action: () => {
                    reviewActions.simulateFailureScenario();
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Success',
                action: () => {
                    reviewActions.simulateSuccessScenario();
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Diff View',
                action: () => {
                    reviewActions.simulateFailureScenario();
                    reviewActions.toggleDiffView();
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Reasoning View',
                action: () => {
                    reviewActions.simulateFailureScenario();
                    reviewActions.toggleReasoningView();
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Copy Mode',
                action: () => {
                    reviewActions.simulateFailureScenario();
                    reviewActions.toggleCopyMode();
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Script Output',
                action: () => {
                    reviewActions.simulateSuccessScenario();
                    reviewActions.toggleScriptView();
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Bulk Repair',
                action: () => {
                    reviewActions.simulateFailureScenario();
                    reviewActions.showBulkRepair();
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Handoff Confirm',
                action: () => {
                    reviewActions.simulateFailureScenario();
                    reviewActions.executeBulkRepairOption(3); // Option 3 is Handoff
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review Processing',
                action: () => appActions.showReviewProcessingScreen(),
            },
            {
                title: 'Git Commit Screen',
                action: () => {
                    commitActions.prepareCommitScreen();
                    appActions.showGitCommitScreen();
                },
            },
            {
                title: 'Transaction Detail Screen',
                action: () => {
                    // The dashboard store has transactions, we'll just pick one.
                    detailActions.loadTransaction('3'); // 'feat: implement new dashboard UI'
                    appActions.showTransactionDetailScreen();
                },
            },
            {
                title: 'Transaction History Screen',
                action: () => {
                    historyActions.load();
                    appActions.showTransactionHistoryScreen();
                },
            },
            {
                title: 'History: L1 Drilldown',
                action: () => {
                    historyActions.prepareDebugState('l1-drill');
                    appActions.showTransactionHistoryScreen();
                },
            },
            {
                title: 'History: L2 Drilldown (Diff)',
                action: () => {
                    historyActions.prepareDebugState('l2-drill');
                    appActions.showTransactionHistoryScreen();
                },
            },
            {
                title: 'History: Filter Mode',
                action: () => {
                    historyActions.prepareDebugState('filter');
                    appActions.showTransactionHistoryScreen();
                },
            },
            {
                title: 'History: Copy Mode',
                action: () => {
                    historyActions.prepareDebugState('copy');
                    appActions.showTransactionHistoryScreen();
                },
            },
        ];

        useInput((input, key) => {
            if (key.upArrow) {
                setSelectedIndex(i => Math.max(0, i - 1));
                return;
            }
            if (key.downArrow) {
                setSelectedIndex(i => Math.min(menuItems.length - 1, i + 1));
                return;
            }
            if (key.return) {
                const item = menuItems[selectedIndex];
                if (item) {
                    item.action();
                    appActions.toggleDebugMenu();
                }
                return;
            }
            if (key.escape || (key.ctrl && input === 'b')) {
                appActions.toggleDebugMenu();
                return;
            }

            // No ctrl/meta keys for selection shortcuts, and only single characters
            if (key.ctrl || key.meta || input.length !== 1) return;

            if (input >= '1' && input <= '9') {
                const targetIndex = parseInt(input, 10) - 1;
                if (targetIndex < menuItems.length) {
                    setSelectedIndex(targetIndex);
                }
            } else if (input.toLowerCase() >= 'a' && input.toLowerCase() <= 'z') {
                const targetIndex = 9 + (input.toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0));
                if (targetIndex < menuItems.length) {
                    setSelectedIndex(targetIndex);
                }
            }
        });

        return {
            selectedIndex,
            menuItems,
        };
    };
  src/stores/dashboard.store.ts: >-
    import { create } from 'zustand';

    import { DashboardService } from '../services/dashboard.service';

    import { createDashboardTransactions } from '../data/mocks';

    import type { Transaction, TransactionStatus } from
    '../types/transaction.types';

    import type { DashboardStatus } from '../types/dashboard.types';


    // --- Store Interface ---

    interface DashboardState {
        status: DashboardStatus;
        previousStatus: DashboardStatus; // To handle cancel from confirmation
        transactions: Transaction[];
        selectedTransactionIndex: number;
        showHelp: boolean;
        actions: {
            togglePause: () => void;
            moveSelectionUp: () => void;
            moveSelectionDown: () => void;
            startApproveAll: () => void;
            confirmAction: () => Promise<void>;
            cancelAction: () => void;
            toggleHelp: () => void;
            setStatus: (status: DashboardStatus) => void; // For debug menu
            updateTransactionStatus: (id: string, status: TransactionStatus) => void;
        };
    }


    // --- Store Implementation ---

    export const useDashboardStore = create<DashboardState>((set, get) => ({
        status: 'LISTENING',
        previousStatus: 'LISTENING',
        transactions: createDashboardTransactions(),
        selectedTransactionIndex: 0,
        showHelp: false,
        actions: {
            togglePause: () => set(state => ({
                status: state.status === 'LISTENING' ? 'PAUSED' : 'LISTENING',
            })),
            moveSelectionUp: () => set(state => ({
                selectedTransactionIndex: Math.max(0, state.selectedTransactionIndex - 1),
            })),
            moveSelectionDown: () => set(state => ({
                selectedTransactionIndex: Math.min(state.transactions.length - 1, state.selectedTransactionIndex + 1),
            })),
            startApproveAll: () => set(state => ({
                status: 'CONFIRM_APPROVE',
                previousStatus: state.status,
            })),
            cancelAction: () => set(state => ({ status: state.previousStatus })),
            toggleHelp: () => set(state => ({ showHelp: !state.showHelp })),
            setStatus: (status) => set({ status }),
            updateTransactionStatus: (id, status) => {
                set(state => ({
                    transactions: state.transactions.map(tx =>
                        tx.id === id ? { ...tx, status, timestamp: Date.now() } : tx,
                    ),
                }));
                // After updating, move selection to the updated transaction
                const index = get().transactions.findIndex(tx => tx.id === id);
                if (index !== -1) set({ selectedTransactionIndex: index });
            },

            confirmAction: async () => {
                const { status, previousStatus } = get();
                if (status === 'CONFIRM_APPROVE') {
                    set({ status: 'APPROVING' });

                    await DashboardService.approveAll();

                    set({ status: previousStatus });
                }
            },
        },
    }));
  src/stores/init.store.ts: >-
    import { create } from 'zustand';

    import type { Task, TaskStatus, InitPhase, GitignoreChoice } from
    '../types/init.types';


    // Initial State definitions from README

    export const initialAnalyzeTasks: Task[] = [
        { id: 'scan', title: 'Scanning project structure...', subtext: 'Finding package.json', status: 'pending' },
        { id: 'project-id', title: 'Determining Project ID', status: 'pending' },
        { id: 'gitignore', title: 'Checking for existing .gitignore', status: 'pending' },
    ];


    export const initialConfigureTasks: Task[] = [
        { id: 'config', title: 'Creating relay.config.json', subtext: 'Writing default configuration with Project ID', status: 'pending' },
        { id: 'state-dir', title: 'Initializing .relay state directory', status: 'pending' },
        { id: 'prompt', title: 'Generating system prompt template', status: 'pending' },
    ];


    // Store Interface

    interface InitState {
        phase: InitPhase;
        analyzeTasks: Task[];
        projectId: string | null;
        gitignoreFound: boolean | null;
        configureTasks: Task[];
        interactiveChoice: GitignoreChoice | null;

        actions: {
            setPhase: (_phase: InitPhase) => void;
            updateAnalyzeTask: (_id: string, _status: TaskStatus) => void;
            setAnalysisResults: (_projectId: string, _gitignoreFound: boolean) => void;
            updateConfigureTask: (_id: string, _status: TaskStatus) => void;
            setInteractiveChoice: (_choice: GitignoreChoice) => void;
            resetInit: () => void;
        };
    }


    // Create the store

    export const useInitStore = create<InitState>((set) => ({
        phase: 'ANALYZE',
        analyzeTasks: initialAnalyzeTasks,
        projectId: null,
        gitignoreFound: null,
        configureTasks: initialConfigureTasks,
        interactiveChoice: null,

        actions: {
            setPhase: (phase) => set({ phase }),
            updateAnalyzeTask: (id, status) => set(state => ({
                analyzeTasks: state.analyzeTasks.map(t => t.id === id ? { ...t, status } : t),
            })),
            setAnalysisResults: (projectId, gitignoreFound) => set({ projectId, gitignoreFound }),
            updateConfigureTask: (id, status) => set(state => ({
                configureTasks: state.configureTasks.map(t => t.id === id ? { ...t, status } : t),
            })),
            setInteractiveChoice: (choice) => set({ interactiveChoice: choice }),
            resetInit: () => set({
                phase: 'ANALYZE',
                analyzeTasks: JSON.parse(JSON.stringify(initialAnalyzeTasks)),
                projectId: null,
                gitignoreFound: null,
                configureTasks: JSON.parse(JSON.stringify(initialConfigureTasks)),
                interactiveChoice: null,
            }),
        },
    }));
  src/stores/review.store.ts: >-
    import { create } from 'zustand';

    import { sleep } from '../utils';

    import { useAppStore } from './app.store';

    import { useDashboardStore } from './dashboard.store';

    import { ReviewService } from '../services/review.service';

    import { mockReviewFiles, mockReviewScripts, mockReviewReasoning } from
    '../data/mocks';

    import type { ReviewFileItem } from '../types/file.types';

    import type { ScriptResult, ApplyStep, ReviewBodyView, PatchStatus } from
    '../types/review.types';


    export const initialApplySteps: ApplyStep[] = [
        { id: 'snapshot', title: 'Reading initial file snapshot...', status: 'pending' },
        { id: 'memory', title: 'Applying operations to memory...', status: 'pending', substeps: [] },
        { id: 'post-command', title: 'Running post-command script...', status: 'pending', substeps: [] },
        { id: 'linter', title: 'Analyzing changes with linter...', status: 'pending', substeps: [] },
    ];


    interface ReviewState {
        // Transaction Info
        hash: string;
        message: string;
        prompt: string;
        reasoning: string;
        linesAdded: number;
        linesRemoved: number;
        duration: number;
        patchStatus: PatchStatus;

        // File & Script Info
        files: ReviewFileItem[];
        scripts: ScriptResult[];

        // UI State
        applySteps: ApplyStep[];
        selectedItemIndex: number; // Can be file or script
        bodyView: ReviewBodyView;
        isDiffExpanded: boolean;

        // Copy Mode State
        copyModeSelectedIndex: number;
        copyModeLastCopied: string | null;

        // Reasoning Scroll State
        reasoningScrollIndex: number;

        // Script Navigation State
        scriptErrorIndex: number;

        actions: {
            moveSelectionUp: () => void;
            moveSelectionDown: () => void;
            toggleFileApproval: () => void;
            rejectAllFiles: () => void;
            toggleDiffView: () => void;
            toggleReasoningView: () => void;
            toggleScriptView: () => void;
            expandDiff: () => void;
            approve: () => void;
            simulateSuccessScenario: () => void;
            startApplySimulation: (scenario: 'success' | 'failure') => void;
            simulateFailureScenario: () => void;

            // Copy Mode Actions
            toggleCopyMode: () => void;
            moveCopySelectionUp: () => void;
            moveCopySelectionDown: () => void;
            copySelectedItem: () => void;
            copyUUID: () => void;
            copyMessage: () => void;
            copyPrompt: () => void;
            copyReasoning: () => void;
            copyFileDiff: () => void;
            copyAllDiffs: () => void;

            // Repair Actions
            tryRepairFile: () => void;
            showBulkRepair: () => void;
            executeBulkRepairOption: (option: number) => Promise<void>;
            confirmHandoff: () => void;

            // Navigation Actions
            scrollReasoningUp: () => void;
            scrollReasoningDown: () => void;
            navigateScriptErrorUp: () => void;
            navigateScriptErrorDown: () => void,

            // "Private" actions for service layer
            _updateApplyStep: (id: string, status: ApplyStep['status'], duration?: number, details?: string) => void;
            _addApplySubstep: (parentId: string, substep: Omit<ApplyStep, 'substeps'>) => void;
        };
    }


    // --- Store Implementation ---


    export const useReviewStore = create<ReviewState>((set, get) => ({
        // Transaction Info
        hash: 'e4a7c112',
        message: 'refactor: rename core utility function',
        prompt: 'Rename the `calculateChanges` utility to `computeDelta` across all files and update imports accordingly.',
        reasoning: mockReviewReasoning,
        linesAdded: 18,
        linesRemoved: 5,
        duration: 0.6,
        patchStatus: 'PARTIAL_FAILURE',

        // File & Script Info
        files: mockReviewFiles,
        scripts: [], // Empty for partial failure scenario

        // UI State
        applySteps: initialApplySteps,
        selectedItemIndex: 0, // Start with first file
        bodyView: 'none' as const,
        isDiffExpanded: false,

        // Copy Mode State
        copyModeSelectedIndex: 0,
        copyModeLastCopied: null,

        // Reasoning Scroll State
        reasoningScrollIndex: 0,

        // Script Navigation State
        scriptErrorIndex: 0,

        actions: {
            moveSelectionUp: () => set(state => ({
                selectedItemIndex: Math.max(0, state.selectedItemIndex - 1),
            })),
            moveSelectionDown: () => set(state => ({
                selectedItemIndex: Math.min(state.files.length + state.scripts.length - 1, state.selectedItemIndex + 1),
            })),
            toggleFileApproval: () => set(state => {
                const { selectedItemIndex, files } = state;
                if (selectedItemIndex >= files.length) return {}; // Not a file

                const newFiles = [...files];
                const file = newFiles[selectedItemIndex];
                if (file) {
                    if (file.status === 'APPROVED') {
                        file.status = 'REJECTED';
                    } else if (file.status === 'REJECTED') {
                        file.status = 'APPROVED';
                    }
                }
                return { files: newFiles };
            }),
            rejectAllFiles: () => set(state => {
                const newFiles = state.files.map(file => {
                    if (file.status === 'APPROVED') {
                        return { ...file, status: 'REJECTED' as const };
                    }
                    return file;
                });
                return { files: newFiles };
            }),
            toggleDiffView: () => set(state => {
                const { bodyView } = state;
                if (state.selectedItemIndex >= state.files.length) return {}; // Can't show diff for scripts
                return {
                    bodyView: bodyView === 'diff' ? 'none' : 'diff',
                    isDiffExpanded: false, // Always start collapsed
                };
            }),
            toggleReasoningView: () => set(state => {
                const { bodyView } = state;
                return {
                    bodyView: bodyView === 'reasoning' ? 'none' : 'reasoning',
                };
            }),
            toggleScriptView: () => set(state => {
                const { bodyView } = state;
                return {
                    bodyView: bodyView === 'script_output' ? 'none' : 'script_output',
                };
            }),
            expandDiff: () => set(state => ({ isDiffExpanded: !state.isDiffExpanded })),
            approve: () => { /* NOP for now, would trigger commit and screen change */ },
            startApplySimulation: async (scenario: 'success' | 'failure') => {
                const { showReviewProcessingScreen, showReviewScreen } = useAppStore.getState().actions;

                set({ applySteps: JSON.parse(JSON.stringify(initialApplySteps)) });
                showReviewProcessingScreen();

                await ReviewService.runApplySimulation(scenario);

                showReviewScreen();
            },
            simulateSuccessScenario: () => set(() => ({
                hash: '4b9d8f03',
                message: 'refactor: simplify clipboard logic',
                prompt: 'Simplify the clipboard logic using an external library...',
                linesAdded: 22,
                linesRemoved: 11,
                duration: 3.9,
                patchStatus: 'SUCCESS' as const,
                files: [
                    {
                        id: '1',
                        path: 'src/core/clipboard.ts',
                        status: 'APPROVED' as const,
                        linesAdded: 15,
                        linesRemoved: 8,
                        diff: `--- a/src/core/clipboard.ts
    +++ b/src/core/clipboard.ts

    @@ -1,5 +1,6 @@
     import { copy as copyToClipboard } from 'clipboardy';`,
                        strategy: 'replace' as const,
                    },
                    {
                        id: '2',
                        path: 'src/utils/shell.ts',
                        status: 'APPROVED' as const,
                        linesAdded: 7,
                        linesRemoved: 3,
                        diff: `--- a/src/utils/shell.ts
    +++ b/src/utils/shell.ts`,
                        strategy: 'standard-diff' as const,
                    },
                ],
                scripts: mockReviewScripts,
                selectedItemIndex: 0,
                bodyView: 'none' as const,
            })),
            simulateFailureScenario: () => set(() => ({
                hash: 'e4a7c112',
                message: 'refactor: rename core utility function',
                prompt: 'Rename the `calculateChanges` utility to `computeDelta` across all files and update imports accordingly.',
                linesAdded: 18,
                linesRemoved: 5,
                duration: 0.6,
                patchStatus: 'PARTIAL_FAILURE' as const,
                files: mockReviewFiles,
                scripts: [],
                // Reset UI state
                bodyView: 'none',
                isDiffExpanded: false,
                reasoningScrollIndex: 0,
                scriptErrorIndex: 0,
                selectedItemIndex: 0,
            })),

            // Copy Mode Actions
            toggleCopyMode: () => set(state => ({
                bodyView: state.bodyView === 'copy_mode' ? 'none' as const : 'copy_mode' as const,
                copyModeSelectedIndex: 0,
                copyModeLastCopied: null,
            })),
            moveCopySelectionUp: () => set(state => ({
                copyModeSelectedIndex: Math.max(0, state.copyModeSelectedIndex - 1),
            })),
            moveCopySelectionDown: () => set(state => ({
                copyModeSelectedIndex: Math.min(5, state.copyModeSelectedIndex + 1), // 6 total options (U,M,P,R,F,A)
            })),
            copySelectedItem: () => set(state => {
                const { copyModeSelectedIndex, hash, message, prompt, reasoning, files, selectedItemIndex } = state;
                let content = '';
                let label = '';

                switch (copyModeSelectedIndex) {
                    case 0: // UUID
                        content = `${hash}-a8b3-4f2c-9d1e-8a7c1b9d8f03`;
                        label = 'UUID';
                        break;
                    case 1: // Git Message
                        content = message;
                        label = 'Git Message';
                        break;
                    case 2: // Prompt
                        content = prompt;
                        label = 'Prompt';
                        break;
                    case 3: // Reasoning
                        content = reasoning;
                        label = 'Reasoning';
                        break;
                    case 4: // Diff for current file
                        if (selectedItemIndex < files.length) {
                            const file = files[selectedItemIndex];
                            if (file) {
                                content = file.diff;
                                label = `Diff for ${file.path}`;
                            }
                        }
                        break;
                    case 5: // All Diffs
                        content = files.map(f => `--- FILE: ${f.path} ---\n${f.diff}`).join('\n\n');
                        label = 'All Diffs';
                        break;
                }

                // Mock clipboard operation (TUI environment - no real clipboard)
                // eslint-disable-next-line no-console
                console.log(`[CLIPBOARD] Copied ${label}: ${content.substring(0, 100)}...`);

                return { copyModeLastCopied: label };
            }),
            copyUUID: () => set(state => {
                const content = `${state.hash}-a8b3-4f2c-9d1e-8a7c1b9d8f03`;
                // eslint-disable-next-line no-console
                console.log(`[CLIPBOARD] Copied UUID: ${content}`);
                return { copyModeLastCopied: 'UUID' };
            }),
            copyMessage: () => set(state => {
                // eslint-disable-next-line no-console
                console.log(`[CLIPBOARD] Copied Git Message: ${state.message}`);
                return { copyModeLastCopied: 'Git Message' };
            }),
            copyPrompt: () => set(state => {
                // eslint-disable-next-line no-console
                console.log(`[CLIPBOARD] Copied Prompt: ${state.prompt.substring(0, 100)}...`);
                return { copyModeLastCopied: 'Prompt' };
            }),
            copyReasoning: () => set(state => {
                // eslint-disable-next-line no-console
                console.log(`[CLIPBOARD] Copied Reasoning: ${state.reasoning.substring(0, 100)}...`);
                return { copyModeLastCopied: 'Reasoning' };
            }),
            copyFileDiff: () => set(state => {
                if (state.selectedItemIndex < state.files.length) {
                    const file = state.files[state.selectedItemIndex];
                    if (file) {
                        // eslint-disable-next-line no-console
                        console.log(`[CLIPBOARD] Copied diff for: ${file.path}`);
                        return { copyModeLastCopied: `Diff for ${file.path}` };
                    }
                }
                return {};
            }),
            copyAllDiffs: () => set(state => {
                // eslint-disable-next-line no-console
                console.log(`[CLIPBOARD] Copied all diffs: ${state.files.length} files`);
                return { copyModeLastCopied: 'All Diffs' };
            }),

            // Repair Actions
            tryRepairFile: () => {
                const { selectedItemIndex, files } = get();
                if (selectedItemIndex < files.length) {
                    const file = files[selectedItemIndex];
                    if (file && file.status === 'FAILED') {
                        ReviewService.tryRepairFile(file, selectedItemIndex);
                    }
                }
            },
            showBulkRepair: () => set(() => ({
                bodyView: 'bulk_repair' as const,
            })),
            executeBulkRepairOption: async (option: number) => {
                const { files } = get();

                switch (option) {
                    case 1: { // Generate & Copy Bulk Repair Prompt
                        const bulkPrompt = ReviewService.generateBulkRepairPrompt(files);
                        const failedFiles = files.filter(f => f.status === 'FAILED');
                        // eslint-disable-next-line no-console
                        console.log(`[CLIPBOARD] Copied bulk repair prompt for ${failedFiles.length} files.`);
                        // In a real app, this would use clipboardy.writeSync(bulkPrompt),
                        set({ bodyView: 'none' as const, copyModeLastCopied: 'Bulk repair prompt copied.' });
                        break;
                    }

                    case 2: { // Attempt Bulk Re-apply
                        set({ bodyView: 'none' as const });
                        await ReviewService.runBulkReapply();
                        break;
                    }

                    case 3: { // Handoff to Human
                        set({ bodyView: 'confirm_handoff' as const });
                        break;
                    }

                    case 4: { // Reject All Failed
                        set(state => ({
                            files: state.files.map(file =>
                                file.status === 'FAILED'
                                    ? { ...file, status: 'REJECTED' as const }
                                    : file,
                            ),
                            bodyView: 'none' as const,
                        }));
                        break;
                    }

                    default: // Close modal
                        set({ bodyView: 'none' as const });
                }
            },
            confirmHandoff: () => {
                const { hash, message, reasoning, files } = get();
                const handoffPrompt = ReviewService.generateHandoffPrompt(hash, message, reasoning, files);

                // eslint-disable-next-line no-console
                console.log('[CLIPBOARD] Copied Handoff Prompt.'); // In real app: clipboardy.writeSync(handoffPrompt)
                ReviewService.performHandoff(hash);
            },

            // Navigation Actions
            scrollReasoningUp: () => set(state => ({
                reasoningScrollIndex: Math.max(0, state.reasoningScrollIndex - 1),
            })),
            scrollReasoningDown: () => set(state => {
                const maxLines = state.reasoning.split('\n').length;
                return { reasoningScrollIndex: Math.min(maxLines - 1, state.reasoningScrollIndex + 1) };
            }),
            navigateScriptErrorUp: () => set(state => ({
                scriptErrorIndex: Math.max(0, state.scriptErrorIndex - 1),
            })),
            navigateScriptErrorDown: () => set(state => {
                const selectedScript = state.scripts[state.selectedItemIndex - state.files.length];
                if (selectedScript && selectedScript.output) {
                    const errorLines = selectedScript.output.split('\n').filter(line =>
                        line.includes('Error') || line.includes('Warning'),
                    );
                    return { scriptErrorIndex: Math.min(errorLines.length - 1, state.scriptErrorIndex + 1) };
                }
                return {};
            }),

            // "Private" actions for service layer
            _updateApplyStep: (id, status, duration, details) => {
                set(state => ({
                    applySteps: state.applySteps.map(s => {
                        if (s.id === id) {
                            const newStep = { ...s, status };
                            if (duration !== undefined) newStep.duration = duration;
                            if (details !== undefined) newStep.details = details;
                            return newStep;
                        }
                        return s;
                    }),
                }));
            },
            _addApplySubstep: (parentId, substep) => {
                 set(state => ({
                    applySteps: state.applySteps.map(s => {
                        if (s.id === parentId) {
                            const newSubsteps = [...(s.substeps || []), substep as ApplyStep];
                            return { ...s, substeps: newSubsteps };
                        }
                        return s;
                    }),
                }));
            },
        },
    }));
  src/stores/transaction-detail.store.ts: >-
    import { create } from 'zustand';

    import { useDashboardStore } from './dashboard.store';

    import { TransactionService } from '../services/transaction.service';

    import { mockDetailedTransactionData } from '../data/mocks';

    import type { Transaction } from '../types/transaction.types';

    import type { FileChange as FileDetail } from '../types/file.types';

    import type { NavigatorSection, DetailBodyView } from
    '../types/transaction-detail.types';


    interface TransactionDetailState {
        // Data
        transaction: Transaction | null;
        prompt: string;
        reasoning: string;
        files: FileDetail[];

        // UI State
        navigatorFocus: NavigatorSection | 'FILES_LIST';
        expandedSection: NavigatorSection | null;
        selectedFileIndex: number;
        bodyView: DetailBodyView;
        copyModeSelectionIndex: number;
        copyModeSelections: Record<string, boolean>;
        copyModeLastCopied: string | null;

        // Actions
        actions: {
            loadTransaction: (transactionId: string) => void;
            navigateUp: () => void;
            navigateDown: () => void;
            handleEnterOrRight: () => void;
            handleEscapeOrLeft: () => void;
            toggleCopyMode: () => void;
            toggleRevertConfirm: () => void;
            copyModeNavigateUp: () => void;
            copyModeNavigateDown: () => void;
            copyModeToggleSelection: () => void;
            copyModeExecuteCopy: () => void;
            confirmRevert: () => void;
        }
    }


    const navigatorOrder: NavigatorSection[] = ['PROMPT', 'REASONING', 'FILES'];

    const copyOptionsList = [
        'Git Message', 'Prompt', 'Reasoning', `All Diffs (${mockDetailedTransactionData.files.length} files)`, `Diff for: ${mockDetailedTransactionData.files[0]?.path}`, 'UUID', 'Full YAML representation',
    ];


    export const useTransactionDetailStore =
    create<TransactionDetailState>((set, get) => ({
        transaction: null,
        prompt: '',
        reasoning: '',
        files: [],

        navigatorFocus: 'PROMPT',
        expandedSection: null,
        selectedFileIndex: 0,
        bodyView: 'NONE',
        copyModeSelectionIndex: 0,
        copyModeSelections: { 'Git Message': true, 'Reasoning': true }, // Default selections from readme
        copyModeLastCopied: null,

        actions: {
            loadTransaction: (transactionId) => {
                const { transactions } = useDashboardStore.getState();
                const transaction = transactions.find(tx => tx.id === transactionId);
                if (transaction) {
                    set({
                        transaction,
                        ...mockDetailedTransactionData,
                        // Reset UI state
                        navigatorFocus: 'PROMPT',
                        expandedSection: null,
                        selectedFileIndex: 0,
                        bodyView: 'NONE',
                    });
                }
            },
            navigateUp: () => {
                const { navigatorFocus, selectedFileIndex } = get();
                if (navigatorFocus === 'FILES_LIST') {
                    set({ selectedFileIndex: Math.max(0, selectedFileIndex - 1) });
                } else {
                    const currentIndex = navigatorOrder.indexOf(navigatorFocus as NavigatorSection);
                    if (currentIndex > 0) {
                        set({ navigatorFocus: navigatorOrder[currentIndex - 1] });
                    }
                }
            },
            navigateDown: () => {
                const { navigatorFocus, selectedFileIndex, files } = get();
                if (navigatorFocus === 'FILES_LIST') {
                    set({ selectedFileIndex: Math.min(files.length - 1, selectedFileIndex + 1) });
                } else {
                    const currentIndex = navigatorOrder.indexOf(navigatorFocus as NavigatorSection);
                    if (currentIndex < navigatorOrder.length - 1) {
                        set({ navigatorFocus: navigatorOrder[currentIndex + 1] });
                    }
                }
            },
            handleEnterOrRight: () => {
                const { navigatorFocus, expandedSection } = get();

                if (navigatorFocus === 'FILES_LIST') {
                    // Already in file list, now show diff
                    set({ bodyView: 'DIFF_VIEW' });
                    return;
                }

                if (expandedSection === navigatorFocus) {
                    // Section is already expanded, handle nested navigation
                    if (navigatorFocus === 'FILES') {
                        set({ navigatorFocus: 'FILES_LIST', bodyView: 'FILES_LIST' });
                    }
                    return;
                }

                // Expand the focused section
                set({ expandedSection: navigatorFocus });

                switch(navigatorFocus) {
                    case 'PROMPT':
                        set({ bodyView: 'PROMPT' });
                        break;
                    case 'REASONING':
                        set({ bodyView: 'REASONING' });
                        break;
                    case 'FILES':
                        set({ bodyView: 'FILES_LIST' });
                        break;
                }
            },
            handleEscapeOrLeft: () => {
                const { navigatorFocus, expandedSection, bodyView } = get();

                if (bodyView === 'DIFF_VIEW') {
                    set({ bodyView: 'FILES_LIST' }); // Go back from diff to file list
                    return;
                }

                if (navigatorFocus === 'FILES_LIST') {
                    set({ navigatorFocus: 'FILES', bodyView: 'NONE' }); // Go back from file list to files section
                    return;
                }

                // If a section is expanded, collapse it
                if (expandedSection) {
                    set({ expandedSection: null, bodyView: 'NONE' });
                    return;
                }
            },
            toggleCopyMode: () => set(state => {
                if (state.bodyView === 'COPY_MODE') {
                    return { bodyView: 'NONE' };
                }
                return {
                    bodyView: 'COPY_MODE',
                    copyModeSelectionIndex: 0,
                    copyModeLastCopied: null,
                };
            }),
            toggleRevertConfirm: () => set(state => ({
                bodyView: state.bodyView === 'REVERT_CONFIRM' ? 'NONE' : 'REVERT_CONFIRM',
            })),
            copyModeNavigateUp: () => set(state => ({
                copyModeSelectionIndex: Math.max(0, state.copyModeSelectionIndex - 1),
            })),
            copyModeNavigateDown: () => set(state => ({
                copyModeSelectionIndex: Math.min(copyOptionsList.length - 1, state.copyModeSelectionIndex + 1),
            })),
            copyModeToggleSelection: () => set(state => {
                const currentOption = copyOptionsList[state.copyModeSelectionIndex];
                if (!currentOption) return {};

                const newSelections = { ...state.copyModeSelections };
                newSelections[currentOption] = !newSelections[currentOption];
                return { copyModeSelections: newSelections };
            }),
            copyModeExecuteCopy: () => {
                // Mock copy to clipboard
                const { copyModeSelections } = get();
                const selectedItems = Object.keys(copyModeSelections).filter(key => copyModeSelections[key]);
                const message = `Copied ${selectedItems.length} items to clipboard.`;
                // In real app: clipboardy.writeSync(...)
                // eslint-disable-next-line no-console
                console.log(`[CLIPBOARD] Mock copy: ${selectedItems.join(', ')}`);
                set({ copyModeLastCopied: message });
            },
            confirmRevert: () => {
                const { transaction } = get();
                if (!transaction) return;
                TransactionService.revertTransaction(transaction.id);
                set({ bodyView: 'NONE' });
            },
        },
    }));
  src/stores/transaction-history.store.ts: >-
    import { create } from 'zustand';

    import { TransactionService } from '../services/transaction.service';

    import type { HistoryTransaction } from '../types/transaction.types';

    import type { FileChange } from '../types/file.types';

    import type { HistoryViewMode } from '../types/transaction-history.types';


    // Omit 'actions' from state type for partial updates

    type HistoryStateData = Omit<TransactionHistoryState, 'actions'>;


    interface TransactionHistoryState {
        transactions: HistoryTransaction[];
        mode: HistoryViewMode;
        selectedItemPath: string; // e.g. "tx-1" or "tx-1/file-2"
        expandedIds: Set<string>; // holds ids of expanded items
        filterQuery: string;
        selectedForAction: Set<string>; // set of transaction IDs
        copyModeSelections: Set<string>;
        lastCopiedMessage: string | null;

        actions: {
            load: (initialState?: Partial<HistoryStateData>) => void;
            navigateDown: () => void;
            navigateUp: () => void;
            expandOrDrillDown: () => void;
            collapseOrBubbleUp: () => void;
            toggleSelection: () => void;
            setMode: (mode: HistoryViewMode) => void;
            setFilterQuery: (query: string) => void;
            applyFilter: () => void;
            toggleCopySelection: (field: string) => void;
            executeCopy: () => void;
            prepareDebugState: (stateName: 'l1-drill' | 'l2-drill' | 'filter' | 'copy' | 'bulk') => void;
        }
    }


    export const getVisibleItemPaths = (transactions: HistoryTransaction[],
    expandedIds: Set<string>): string[] => {
        const paths: string[] = [];
        for (const tx of transactions) {
            paths.push(tx.id);
            if (expandedIds.has(tx.id)) {
                for (const file of tx.files) {
                    paths.push(`${tx.id}/${file.id}`);
                }
            }
        }
        return paths;
    };


    // --- Store ---

    export const useTransactionHistoryStore =
    create<TransactionHistoryState>((set, get) => ({
        transactions: [],
        mode: 'LIST',
        selectedItemPath: 'tx-0',
        expandedIds: new Set(),
        filterQuery: '',
        selectedForAction: new Set(),
        copyModeSelections: new Set(['Git Messages', 'Reasonings']),
        lastCopiedMessage: null,

        actions: {
            load: (initialState) => {
                const transactions = TransactionService.createMockTransactions();
                set({
                    transactions,
                    selectedItemPath: transactions[0]?.id || '',
                    mode: 'LIST',
                    expandedIds: new Set(),
                    selectedForAction: new Set(),
                    filterQuery: '',
                    copyModeSelections: new Set(['Git Messages', 'Reasonings']),
                    lastCopiedMessage: null,
                    ...initialState,
                });
            },
            navigateUp: () => {
                const { transactions, expandedIds, selectedItemPath } = get();
                const visibleItems = getVisibleItemPaths(transactions, expandedIds);
                const currentIndex = visibleItems.indexOf(selectedItemPath);
                if (currentIndex > 0) {
                    set({ selectedItemPath: visibleItems[currentIndex - 1] });
                }
            },
            navigateDown: () => {
                const { transactions, expandedIds, selectedItemPath } = get();
                const visibleItems = getVisibleItemPaths(transactions, expandedIds);
                const currentIndex = visibleItems.indexOf(selectedItemPath);
                if (currentIndex < visibleItems.length - 1) {
                    set({ selectedItemPath: visibleItems[currentIndex + 1] });
                }
            },
            expandOrDrillDown: () => set(state => {
                const { selectedItemPath, expandedIds } = state;
                const newExpandedIds = new Set(expandedIds);
                if (!newExpandedIds.has(selectedItemPath)) {
                    newExpandedIds.add(selectedItemPath);
                }
                return { expandedIds: newExpandedIds };
            }),
            collapseOrBubbleUp: () => set(state => {
                const { selectedItemPath, expandedIds } = state;
                const newExpandedIds = new Set(expandedIds);
                if (newExpandedIds.has(selectedItemPath)) {
                    // If it's expanded, collapse it
                    newExpandedIds.delete(selectedItemPath);
                    
                    // Also collapse children
                    for (const id of newExpandedIds) {
                        if (id.startsWith(`${selectedItemPath}/`)) {
                            newExpandedIds.delete(id);
                        }
                    }

                    return { expandedIds: newExpandedIds };
                } else if (selectedItemPath.includes('/')) {
                    // If it's a file, move selection to parent transaction
                    const parentId = selectedItemPath.split('/')[0];
                    return { selectedItemPath: parentId || '' };
                }
                return {};
            }),
            toggleSelection: () => set(state => {
                const { selectedItemPath, selectedForAction } = state;
                const txId = selectedItemPath.split('/')[0];
                if (!txId) return {};

                const newSelection = new Set(selectedForAction);
                if (newSelection.has(txId)) {
                    newSelection.delete(txId);
                } else {
                    newSelection.add(txId);
                }
                return { selectedForAction: newSelection };
            }),
            setMode: (mode) => set({ mode, lastCopiedMessage: null }),
            setFilterQuery: (query) => set({ filterQuery: query }),
            applyFilter: () => {
                // In a real app, this would filter `transactions`.
                // For the demo, we just go back to LIST mode.
                set({ mode: 'LIST' });
            },
            toggleCopySelection: (field) => set(state => {
                const newSelections = new Set(state.copyModeSelections);
                if (newSelections.has(field)) {
                    newSelections.delete(field);
                } else {
                    newSelections.add(field);
                }
                return { copyModeSelections: newSelections };
            }),
            executeCopy: () => {
                 // Mock copy
                const { selectedForAction, copyModeSelections } = get();
                const message = `Copied ${Array.from(copyModeSelections).join(' & ')} from ${selectedForAction.size} transactions to clipboard.`;
                // In real app: clipboardy.writeSync(...)
                // eslint-disable-next-line no-console
                console.log(`[CLIPBOARD MOCK] ${message}`);
                set({ lastCopiedMessage: message });
            },
            prepareDebugState: (stateName) => {
                switch (stateName) {
                    case 'l1-drill':
                        get().actions.load({ expandedIds: new Set(['tx-0']), selectedItemPath: 'tx-0' });
                        break;
                    case 'l2-drill':
                        get().actions.load({ expandedIds: new Set(['tx-0', 'tx-0/0-1']), selectedItemPath: 'tx-0/0-1' });
                        break;
                    case 'filter':
                        get().actions.load({ mode: 'FILTER', filterQuery: 'logger.ts status:committed' });
                        break;
                    case 'copy':
                        get().actions.load({
                            mode: 'COPY',
                            selectedForAction: new Set(['tx-0', 'tx-2']),
                            copyModeSelections: new Set(['Git Messages', 'Diffs', 'UUIDs']),
                        });
                        break;
                    case 'bulk':
                        get().actions.load({ mode: 'BULK_ACTIONS', selectedForAction: new Set(['tx-0', 'tx-2']) });
                        break;
                }
            },
        },
    }));
approved: false
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: undone
id: 54
