uuid: c6b81d77-6f8d-4e94-8255-a50d6f22d64a
projectId: relaycode-tui
createdAt: '2025-09-26T08:13:57.204Z'
gitCommitMsg: >-
  refactor: Implement layout components, generalize views, and decouple UI state

  This commit executes a major refactoring to improve DRYness and
  maintainability:

  Part 3: - Introduces reusable `<ScreenLayout>` and `<ModalLayout>` components
  to standardize screen structure and reduce boilerplate in multiple components.
  - Refactors all major screens (Dashboard, Review, Detail, History, etc.) and
  overlays (Copy, Notification) to use these new layouts.

  Part 4: - Generalizes `DiffScreen` into a more flexible `<ContentView>`
  component capable of rendering and syntax-highlighting different types of
  content. - Deletes the redundant `ReasonScreen` and updates all call sites to
  use the new `ContentView`.

  Part 5: - Decouples ephemeral UI state (e.g., `selectedIndex`) from global
  Zustand stores (`copy`, `dashboard`, `review`) and moves it into the relevant
  screen hooks. - Simplifies store logic by removing navigation actions
  (`moveUp`/`moveDown`). - Refactors screen hooks (`useDashboardScreen`,
  `useReviewScreen`, `useCopyScreen`) to manage their own navigation state and
  integrate with the `useListNavigator` hook.
promptSummary: >-
  The user requested to execute parts 3, 4, and 5 of a multi-part refactoring
  plan to improve code structure and reduce duplication.
reasoning:
  - >-
    Of course. As an expert AI programmer, I have analyzed your request and will
    now execute the comprehensive refactoring plan. This involves creating
    reusable layout components, generalizing content views, and decoupling UI
    state from global stores to achieve radical DRYness and improve
    maintainability.
  - '### Part 3: Introduce Reusable Layout Components'
  - First, I will create the new reusable layout components.
  - '### Part 4: Generalize Content View Components'
  - >-
    I will now delete `ReasonScreen.tsx` and evolve `DiffScreen.tsx` into a more
    generic `ContentView.tsx`.
  - '### Part 3 & 4: Refactor Screens'
  - >-
    Now I will refactor the existing screens to use the new layouts and the
    `ContentView` component.
  - '### Part 5: Decouple UI State from Global Stores'
  - Finally, I will decouple ephemeral UI state from the global stores.
operations:
  - type: write
    path: src/components/layout/ModalLayout.tsx
    content: |-
      import { Box } from 'ink';

      interface ModalLayoutProps {
          children: React.ReactNode;
          width?: string | number;
      }

      const ModalLayout = ({ children, width = '80%' }: ModalLayoutProps) => {
          return (
              <Box
                  flexDirection="column"
                  justifyContent="center"
                  alignItems="center"
                  width="100%"
                  height="100%"
              >
                  <Box
                      flexDirection="column"
                      paddingY={1}
                      width={width}
                      backgroundColor="black"
                  >
                      {children}
                  </Box>
              </Box>
          );
      };

      export default ModalLayout;
    patchStrategy: replace
  - type: write
    path: src/components/layout/ScreenLayout.tsx
    content: |-
      import { Box, Text } from 'ink';
      import Separator from '../Separator';

      interface ScreenLayoutProps {
          title: React.ReactNode;
          footer: React.ReactNode;
          children: React.ReactNode;
      }

      const ScreenLayout = ({ title, footer, children }: ScreenLayoutProps) => {
          return (
              <Box flexDirection="column" flexGrow={1}>
                  {typeof title === 'string' ? (
                      <Text bold color="black" backgroundColor="yellow"> {title} </Text>
                  ) : (
                      title
                  )}
                  <Separator />
                  <Box flexDirection="column" flexGrow={1} marginY={1}>
                      {children}
                  </Box>
                  <Separator />
                  <Box>
                      {footer}
                  </Box>
              </Box>
          );
      };

      export default ScreenLayout;
    patchStrategy: replace
  - type: delete
    path: src/components/ReasonScreen.tsx
  - type: rename
    from: src/components/DiffScreen.tsx
    to: src/components/ContentView.tsx
  - type: write
    path: src/components/ContentView.tsx
    content: |-
      import { Box, Text } from 'ink';
      import { UI_CONFIG } from '../config/ui.config';

      interface ContentViewProps {
          title: string;
          content: string;
          isExpanded?: boolean;
          scrollIndex?: number;
          maxHeight?: number;
          highlight?: 'diff' | 'none';
      }
      const ContentView = ({
          title,
          content,
          isExpanded = true,
          scrollIndex = 0,
          maxHeight,
          highlight = 'none',
      }: ContentViewProps) => {
          const lines = content.split('\n');
          const COLLAPSE_THRESHOLD = UI_CONFIG.diffScreen.collapseThreshold;
          const COLLAPSE_SHOW_LINES = UI_CONFIG.diffScreen.collapseShowLines;

          const renderContent = () => {
              if (!isExpanded && lines.length > COLLAPSE_THRESHOLD) {
                  const topLines = lines.slice(0, COLLAPSE_SHOW_LINES);
                  const bottomLines = lines.slice(lines.length - COLLAPSE_SHOW_LINES);
                  const hiddenLines = lines.length - (COLLAPSE_SHOW_LINES * 2);

                  return (
                      <>
                          {topLines.map((line, i) => renderLine(line, i))}
                          <Text color="gray">... {hiddenLines} lines hidden ...</Text>
                          {bottomLines.map((line, i) => renderLine(line, i + topLines.length + 1))}
                      </>
                  );
              }
              // Handle vertical scrolling for expanded view
              if (isExpanded && maxHeight) {
                  const visibleLines = lines.slice(scrollIndex, scrollIndex + maxHeight);
                  return visibleLines.map((line, i) => renderLine(line, scrollIndex + i));
              }
              return lines.map((line, i) => renderLine(line, i));
          };

          const renderLine = (line: string, key: number) => {
              let color = 'white';
              if (highlight === 'diff') {
                  if (line.startsWith('+')) color = 'green';
                  if (line.startsWith('-')) color = 'red';
                  if (line.startsWith('@@')) color = 'cyan';
              }
              return <Text key={key} color={color}>{line}</Text>;
          };

          return (
              <Box flexDirection="column">
                  <Text>{title}</Text>
                  <Box flexDirection="column" marginTop={1}>
                      {renderContent()}
                  </Box>
              </Box>
          );
      };

      export default ContentView;
    patchStrategy: replace
  - type: write
    path: src/components/NotificationScreen.tsx
    content: >
      --- src/components/NotificationScreen.tsx

      +++ src/components/NotificationScreen.tsx

      @@ -1,7 +1,7 @@
       import { Box, Text } from 'ink';
       import { useNotificationScreen } from '../hooks/useNotificationScreen';
       import ActionFooter from './ActionFooter';
      +import ModalLayout from './layout/ModalLayout';
       import { NOTIFICATION_FOOTER_ACTIONS, NOTIFICATION_TYPE_CONFIG } from '../constants/notification.constants';
       
       const NotificationScreen = () => {
      @@ -14,31 +14,20 @@
           const config = NOTIFICATION_TYPE_CONFIG[notification.type];
       
           return (
      -        <Box

      -            flexDirection="column"

      -            justifyContent="center"

      -            alignItems="center"

      -            width="100%"

      -            height="100%"

      -        >

      -            <Box

      -                flexDirection="column"

      -                paddingY={1}

      -                width="80%"

      -                backgroundColor="black"

      -            >

      -                <Box paddingX={2} marginBottom={1}
      backgroundColor={config.color}>

      -                    <Text bold color="black">{config.title}</Text>

      -                </Box>

      -                <Box paddingX={2}>

      -                    <Text>{notification.message}</Text>

      -                </Box>

      -                <Box marginTop={1}>

      -                    <Box paddingX={2}>

      -                        <Text color="gray">(Dismissing in
      {countdown}s...)</Text>

      -                    </Box>

      -                </Box>

      -                <Box marginTop={1}>

      -                    <ActionFooter actions={NOTIFICATION_FOOTER_ACTIONS}
      />

      -                </Box>

      +        <ModalLayout>

      +            <Box paddingX={2} marginBottom={1}
      backgroundColor={config.color}>

      +                <Text bold color="black">{config.title}</Text>
                   </Box>
      -        </Box>

      +            <Box paddingX={2}>

      +                <Text>{notification.message}</Text>

      +            </Box>

      +            <Box marginTop={1}>

      +                <Box paddingX={2}>

      +                    <Text color="gray">(Dismissing in
      {countdown}s...)</Text>

      +                </Box>

      +            </Box>

      +            <Box marginTop={1}>

      +                <ActionFooter actions={NOTIFICATION_FOOTER_ACTIONS} />

      +            </Box>

      +        </ModalLayout>
           );
       };
       
    patchStrategy: standard-diff
  - type: write
    path: src/components/CopyScreen.tsx
    content: >
      --- src/components/CopyScreen.tsx

      +++ src/components/CopyScreen.tsx

      @@ -3,6 +3,7 @@
       import { useStdoutDimensions } from '../utils';
       import ActionFooter from './ActionFooter';
       import { useCopyScreen } from '../hooks/useCopyScreen';
      +import ModalLayout from './layout/ModalLayout';
       import { COPY_SCREEN_FOOTER_ACTIONS } from '../constants/copy.constants';
       
       const CopyScreen = () => {
      @@ -16,51 +17,39 @@
           const [width] = useStdoutDimensions();
       
           return (
      -        <Box 

      -            width="100%"

      -            height="100%"

      -            flexDirection="column"

      -            justifyContent="center"

      -            alignItems="center"

      +        <ModalLayout>

      +            <Box

      +                flexDirection="column"

      +                paddingX={2}

      +                width="100%"

      +            >

      +                <Text bold color="black" backgroundColor="yellow"> ▲
      relaycode · COPY MODE </Text>

      +                <Separator width={Math.floor(width * 0.8) - 4} />

      +                <Box flexDirection="column" marginY={1}>

      +                    <Text>{title}</Text>

      +                    <Box flexDirection="column" marginTop={1}>

      +                        {itemsInView.map((item, index) => {

      +                            const isSelected = (index + viewOffset) ===
      selectedIndex;

      +                            const isChecked = selectedIds.has(item.id);

      +                            return (

      +                                <Text key={item.id} color={isSelected ?
      'cyan' : undefined}>

      +                                    {isSelected ? '> ' : '  '}

      +                                    [{isChecked ? 'x' : ' '}]
      ({item.key}) {item.label}

      +                                </Text>

      +                            );

      +                        })}

      +                    </Box>

      +                </Box>

      +                <Separator width={Math.floor(width * 0.8) - 4} />

      +                {lastCopiedMessage && <Text color="green">✓
      {lastCopiedMessage}</Text>}

      +                <ActionFooter actions={COPY_SCREEN_FOOTER_ACTIONS}/>

      +            </Box>

      +        </ModalLayout>

      +    );

      +};

      +

      +export default CopyScreen;


      -        >

      -            <Box 

      -                flexDirection="column" 

      -                paddingX={2}

      -                width="80%"

      -            >

      -                <Text bold color="black" backgroundColor="yellow"> ▲
      relaycode · COPY MODE </Text>

      -                <Separator width={Math.floor(width * 0.8) - 4} />

      -                <Box flexDirection="column" marginY={1}>

      -                    <Text>{title}</Text>

      -                    <Box flexDirection="column" marginTop={1}>

      -                        {itemsInView.map((item, index) => {

      -                            const isSelected = (index + viewOffset) ===
      selectedIndex;

      -                            const isChecked = selectedIds.has(item.id);

      -                            return (

      -                                <Text key={item.id} color={isSelected ?
      'cyan' : undefined}>

      -                                    {isSelected ? '> ' : '  '}

      -                                    [{isChecked ? 'x' : ' '}]
      ({item.key}) {item.label}

      -                                </Text>

      -                            );

      -                        })}

      -                    </Box>

      -                </Box>

      -                <Separator width={Math.floor(width * 0.8) - 4} />

      -                {lastCopiedMessage && <Text color="green">✓
      {lastCopiedMessage}</Text>}

      -                <ActionFooter actions={COPY_SCREEN_FOOTER_ACTIONS}/>

      -            </Box>

      -        </Box>

      -    );

      -};

      -

      -export default CopyScreen;
    patchStrategy: standard-diff
  - type: write
    path: src/components/DebugLogScreen.tsx
    content: >
      --- src/components/DebugLogScreen.tsx

      +++ src/components/DebugLogScreen.tsx

      @@ -1,11 +1,11 @@
       import { Box, Text } from 'ink';
       import TextInput from 'ink-text-input';
      -import Separator from './Separator';
       import ActionFooter from './ActionFooter';
       import { useDebugLogScreen } from '../hooks/useDebugLogScreen';
       import { DEBUG_LOG_FOOTER_ACTIONS, DEBUG_LOG_MODES, LOG_LEVEL_COLORS, LOG_LEVEL_TAGS } from '../constants/log.constants';
       import type { LogEntry } from '../types/log.types';
       import { useStdoutDimensions } from '../utils';
      +import ScreenLayout from './layout/ScreenLayout';
       
       const LogEntryRow = ({ entry, isSelected }: { entry: LogEntry; isSelected: boolean }) => {
           const time = new Date(entry.timestamp).toISOString().split('T')[1]?.replace('Z', '');
      @@ -62,35 +62,27 @@
                   : DEBUG_LOG_FOOTER_ACTIONS.LIST_MODE(logCount > 0);
       
           return (
      -        <Box

      -            flexDirection="column"

      -            width="100%"

      -            height="100%"

      -            paddingX={2}

      -            paddingY={1}

      +        <ScreenLayout

      +            title="▲ relaycode · DEBUG LOG"

      +            footer={<ActionFooter actions={footerActions} />}
               >
      -            <Text bold color="black" backgroundColor="yellow"> ▲
      relaycode · DEBUG LOG </Text>

      -            <Separator width={width - 4} />

      -            <Box marginY={1}>{renderFilter()}</Box>

      -            <Box flexDirection="column" flexGrow={1}>

      -                {logsInView.map((entry, index) => (

      -                    <LogEntryRow

      -                        key={`${entry.timestamp}-${index}`}

      -                        entry={entry}

      -                        isSelected={selectedIndex === index + viewOffset}

      -                    />

      -                ))}

      -                {logCount > 0 && filteredLogCount === 0 && (

      -                    <Text color="gray">No logs match your filter.</Text>

      -                )}

      -                {logCount === 0 && (

      -                    <Text color="gray">No log entries yet. Waiting for
      system activity...</Text>

      -                )}

      +            <Box flexDirection="column" flexGrow={1} paddingX={2}>

      +                {renderFilter()}

      +                <Box flexDirection="column" flexGrow={1} marginTop={1}>

      +                    {logsInView.map((entry, index) => (

      +                        <LogEntryRow

      +                            key={`${entry.timestamp}-${index}`}

      +                            entry={entry}

      +                            isSelected={selectedIndex === index +
      viewOffset}

      +                        />

      +                    ))}

      +                    {logCount > 0 && filteredLogCount === 0 && (

      +                        <Text color="gray">No logs match your
      filter.</Text>

      +                    )}

      +                    {logCount === 0 && (

      +                        <Text color="gray">No log entries yet. Waiting
      for system activity...</Text>

      +                    )}

      +                </Box>
                   </Box>
      -            <Separator width={width - 4} />

      -            <ActionFooter actions={footerActions} />

      -        </Box>

      +        </ScreenLayout>
           );
       };
       
    patchStrategy: standard-diff
  - type: write
    path: src/components/GitCommitScreen.tsx
    content: >
      --- src/components/GitCommitScreen.tsx

      +++ src/components/GitCommitScreen.tsx

      @@ -1,8 +1,8 @@
       import { Box, Text } from 'ink';
       import Spinner from 'ink-spinner';
      -import Separator from './Separator';
       import { useGitCommitScreen } from '../hooks/useGitCommitScreen';
       import ActionFooter from './ActionFooter';
      +import ScreenLayout from './layout/ScreenLayout';
       import { COMMIT_FOOTER_ACTIONS } from '../constants/commit.constants';
       
       const GitCommitScreen = () => {
      @@ -29,40 +29,35 @@
               </Box>
           );
       
      +    const footer = isCommitting

      +                ? <Text><Spinner type="dots"/> Committing... please
      wait.</Text>

      +                : <ActionFooter actions={commitError ?
      COMMIT_FOOTER_ACTIONS.FAILURE : COMMIT_FOOTER_ACTIONS.BASE} />;

      +
           return (
      -        <Box flexDirection="column">

      -            <Text bold color="black" backgroundColor="yellow"> ▲
      relaycode · GIT COMMIT </Text>

      -            <Separator />

      -            <Box marginY={1} flexDirection="column" paddingX={2}>

      -                <Text>Found {transactionsToCommit.length} new
      transactions to commit since last git commit.</Text>

      -                <Box marginTop={1} flexDirection="column">

      -                    <Text bold>TRANSACTIONS INCLUDED</Text>

      -                    {transactionsToCommit.map(tx => (

      -                        <Text key={tx.id}>- <Text
      color="gray">{tx.hash}</Text>: {tx.message}</Text>

      -                    ))}

      -                </Box>

      +        <ScreenLayout

      +            title="▲ relaycode · GIT COMMIT"

      +            footer={footer}

      +        >

      +            <Box flexDirection="column" paddingX={2}>

      +                <Box flexDirection="column">

      +                    <Text>Found {transactionsToCommit.length} new
      transactions to commit since last git commit.</Text>

      +                    <Box marginTop={1} flexDirection="column">

      +                        <Text bold>TRANSACTIONS INCLUDED</Text>

      +                        {transactionsToCommit.map(tx => (

      +                            <Text key={tx.id}>- <Text
      color="gray">{tx.hash}</Text>: {tx.message}</Text>

      +                        ))}

      +                    </Box>

      +                </Box>

      +                <Box marginY={1} flexDirection="column">

      +                    <Text bold>FINAL COMMIT MESSAGE</Text>

      +                    <Box marginTop={1} flexDirection="column">

      +                        <Text color="yellow">{subject}</Text>

      +                        {body ? <Text>{body}</Text> : null}

      +                    </Box>

      +                </Box>

      +                {commitError && renderError()}

      +                {!commitError && <Text>This will run &apos;git add
      .&apos; and &apos;git commit&apos; with the message above.</Text>}
                   </Box>
      -            <Separator />

      -            <Box marginY={1} flexDirection="column" paddingX={2}>

      -                <Text bold>FINAL COMMIT MESSAGE</Text>

      -                <Box marginTop={1} flexDirection="column">

      -                    <Text color="yellow">{subject}</Text>

      -                    {body ? <Text>{body}</Text> : null}

      -                </Box>

      -            </Box>

      -            {commitError && renderError()}

      -            <Separator />

      -            {!commitError && <Box marginY={1} paddingX={2}>

      -                 <Text>This will run &apos;git add .&apos; and &apos;git
      commit&apos; with the message above.</Text>

      -            </Box>}

      -            <Separator />

      -            {isCommitting

      -                ? <Text><Spinner type="dots"/> Committing... please
      wait.</Text>

      -                : <ActionFooter actions={commitError ?
      COMMIT_FOOTER_ACTIONS.FAILURE : COMMIT_FOOTER_ACTIONS.BASE} />

      -            }

      -        </Box>

      +        </ScreenLayout>
           );
       };
       
    patchStrategy: standard-diff
  - type: write
    path: src/components/TransactionHistoryScreen.tsx
    content: >
      --- src/components/TransactionHistoryScreen.tsx

      +++ src/components/TransactionHistoryScreen.tsx

      @@ -2,11 +2,11 @@
       import { Box, Text } from 'ink';
       import TextInput from 'ink-text-input';
       import Spinner from 'ink-spinner';
      -import Separator from './Separator';
       import type { Transaction, FileItem } from '../types/domain.types';
       import { useTransactionHistoryScreen } from '../hooks/useTransactionHistoryScreen';
       import { HISTORY_FOOTER_ACTIONS, BULK_ACTIONS_OPTIONS, HISTORY_VIEW_MODES } from '../constants/history.constants';
       import ActionFooter from './ActionFooter';
      +import ScreenLayout from './layout/ScreenLayout';
       import { TRANSACTION_STATUS_UI, FILE_CHANGE_ICONS } from '../constants/ui.constants';
       
       // --- Sub-components ---
      @@ -158,11 +158,7 @@
           };
       
           return (
      -        <Box flexDirection="column">

      -            <Text bold color="black" backgroundColor="yellow"> ▲
      relaycode · TRANSACTION HISTORY </Text>

      -            <Separator />

      -

      +        <ScreenLayout title="▲ relaycode · TRANSACTION HISTORY"
      footer={renderFooter()}>
                   <Box>
                       <Text>Filter: </Text>
                       {mode === HISTORY_VIEW_MODES.FILTER ? (
      @@ -234,9 +230,7 @@
                           );
                       })}
                   </Box>
      -

      -            <Separator />

      -            {renderFooter()}

      -        </Box>

      -    );

      -};

      +        </ScreenLayout>

      +    );

      +};

      +
    patchStrategy: standard-diff
  - type: write
    path: src/components/ReviewScreen.tsx
    content: >
      --- src/components/ReviewScreen.tsx

      +++ src/components/ReviewScreen.tsx

      @@ -1,11 +1,11 @@
       import { Box, Text } from 'ink';
      -import Separator from './Separator';

      -import DiffScreen from './DiffScreen';

      -import ReasonScreen from './ReasonScreen';

      +import ContentView from './ContentView';
       import type { ScriptResult, FileItem, FileChangeType } from '../types/domain.types';
       import { useReviewScreen } from '../hooks/useReviewScreen';
       import { REVIEW_BODY_VIEWS, REVIEW_FOOTER_ACTIONS, BULK_REPAIR_OPTIONS, BULK_INSTRUCT_OPTIONS } from '../constants/review.constants';
       import ActionFooter from './ActionFooter';
       import { FILE_STATUS_UI } from '../constants/ui.constants';
      +import ScreenLayout from './layout/ScreenLayout';
       
       // --- Sub-components ---
       
      @@ -140,8 +140,9 @@
                   const visibleLinesCount = 10;
                   return (
                       <Box flexDirection="column">
      -                    <ReasonScreen

      -                        reasoning={reasoningText}

      +                    <ContentView

      +                        title="REASONING"

      +                        content={reasoningText}
                               scrollIndex={contentScrollIndex}
      -                        visibleLinesCount={Math.max(1,
      availableBodyHeight)}

      +                        maxHeight={Math.max(1, availableBodyHeight)}
                           />
                           {reasoningLinesCount > visibleLinesCount && (
                               <Text color="gray">
      @@ -158,12 +159,12 @@
                   const selectedFile = currentItem?.type === 'file' ? files.find(f => f.id === currentItem.id) : undefined;
                   if (!selectedFile) return null;
                   return (
      -                <DiffScreen

      -                    filePath={selectedFile.path}

      -                    diffContent={selectedFile.diff}

      +                <ContentView

      +                    title={`DIFF: ${selectedFile.path}`}

      +                    content={selectedFile.diff}

      +                    highlight="diff"
                           isExpanded={isDiffExpanded}
                           scrollIndex={contentScrollIndex}
      -                    maxHeight={Math.max(1, availableBodyHeight)}
                       />
                   );
               }
      @@ -321,11 +322,7 @@
           };
       
           return (
      -        <Box flexDirection="column">

      -            {/* Header */}

      -            <Text bold color="black" backgroundColor="yellow"> ▲
      relaycode · REVIEW </Text>

      -            <Separator />

      -            

      +        <ScreenLayout title="▲ relaycode · REVIEW"
      footer={renderFooter()}>
                   {/* Navigator Section */}
                   <Box flexDirection="column" marginY={1}>
                       <Box flexDirection="column">
      @@ -357,8 +354,6 @@
                       </Box>
                   </Box>
       
      -            <Separator />

      -
                   {/* Script Results (if any) */}
                   {scripts.length > 0 && navigableItemsInView.some(i => i.type === 'script') && (
                       <>
      @@ -373,7 +368,6 @@
                                   );
                               })}
                           </Box>
      -                    <Separator />
                       </>
                   )}
                   
      @@ -391,24 +385,14 @@
                           );
                       })}
                   </Box>
      -            

      -            <Separator />

      -            

      +
                   {/* Body Viewport */}
                   {bodyView !== REVIEW_BODY_VIEWS.NONE && (
      -                <>

      -                    <Box marginY={1}>

      -                        {renderBody()}

      -                    </Box>

      -                    <Separator />

      -                </>

      -            )}

      -

      -            {/* Footer */}

      -            <Box>

      -                {renderFooter()}

      -            </Box>

      -        </Box>

      -    );

      -};

      -

      -export default ReviewScreen;

      +                <Box marginY={1}>

      +                    {renderBody()}

      +                </Box>

      +            )}

      +        </ScreenLayout>

      +    );

      +};

      +

      +export default ReviewScreen;
    patchStrategy: standard-diff
  - type: write
    path: src/components/TransactionDetailScreen.tsx
    content: >
      --- src/components/TransactionDetailScreen.tsx

      +++ src/components/TransactionDetailScreen.tsx

      @@ -1,11 +1,10 @@
       import { Box, Text } from 'ink';
       import Separator from './Separator';
      -import DiffScreen from './DiffScreen';

      -import ReasonScreen from './ReasonScreen';

      +import ContentView from './ContentView';
       import type { FileChangeType } from '../types/domain.types';
       import { useTransactionDetailScreen } from '../hooks/useTransactionDetailScreen';
       import { DETAIL_BODY_VIEWS, DETAIL_FOOTER_ACTIONS } from '../constants/detail.constants';
       import ActionFooter from './ActionFooter';
       import { FILE_CHANGE_ICONS } from '../constants/ui.constants';
      +import ScreenLayout from './layout/ScreenLayout';
       
       const RevertModal = ({ transactionHash }: { transactionHash: string }) => {
           return (
      @@ -112,12 +111,20 @@
               }
               if (bodyView === DETAIL_BODY_VIEWS.REASONING) {
                   if (!transaction.reasoning) return <Text color="gray">No reasoning provided.</Text>;
      -            return <ReasonScreen reasoning={transaction.reasoning}
      scrollIndex={contentScrollIndex} visibleLinesCount={Math.max(1,
      availableBodyHeight)} />;

      +            return <ContentView title="REASONING"
      content={transaction.reasoning} scrollIndex={contentScrollIndex}
      maxHeight={Math.max(1, availableBodyHeight)} />;
               }
               if (bodyView === DETAIL_BODY_VIEWS.FILES_LIST) {
                    return <Text color="gray">(Select a file and press → to view the diff)</Text>;
               }
               if (bodyView === DETAIL_BODY_VIEWS.DIFF_VIEW) {
                   const fileId = focusedItemPath.split('/')[1];
                   const file = files.find(f => f.id === fileId);
                   if (!file) return null;
      -            return <DiffScreen filePath={file.path}
      diffContent={file.diff} isExpanded={true} scrollIndex={contentScrollIndex}
      maxHeight={Math.max(1, availableBodyHeight)} />;

      +            return <ContentView

      +                title={`DIFF: ${file.path}`}

      +                content={file.diff}

      +                highlight='diff'

      +                isExpanded={true}

      +                scrollIndex={contentScrollIndex}

      +                maxHeight={Math.max(1, availableBodyHeight)}

      +            />;
               }
               return null;
           };
      @@ -155,42 +162,31 @@
           const fileStats = `${files.length} Files · +${files.reduce((a, f) => a + f.linesAdded, 0)} lines, -${files.reduce((a, f) => a + f.linesRemoved, 0)} lines`;
       
           return (
      -        <Box flexDirection="column">

      -            {/* Header */}

      -            <Text bold color="black" backgroundColor="yellow"> ▲
      relaycode · TRANSACTION DETAILS </Text>

      -            <Separator />

      -            

      +        <ScreenLayout

      +            title="▲ relaycode · TRANSACTION DETAILS"

      +            footer={renderFooter()}

      +        >
                   {/* Modal takeover for Revert */}
                   {bodyView === DETAIL_BODY_VIEWS.REVERT_CONFIRM && <RevertModal transactionHash={transaction.hash} />}
      -            

      +
                   {/* Main view */}
                   <Box flexDirection="column" display={bodyView === DETAIL_BODY_VIEWS.REVERT_CONFIRM ? 'none' : 'flex'}>
      -                {/* Navigator Part A */}

      -                <Box flexDirection="column" marginY={1}>

      +                <Box flexDirection="column">
                           <Text><Text color="gray">UUID:</Text> {transaction.id}</Text>
                           <Text><Text color="gray">Git:</Text> {message}</Text>
                           <Text><Text color="gray">Date:</Text> {date} · <Text color="gray">Status:</Text> {status}</Text>
                           <Text><Text color="gray">Stats:</Text> {fileStats}</Text>
                       </Box>
      -                

      -                {/* Navigator Part B */}

      -                {renderNavigator()}

      -                

      -                <Separator />

      -                

      +

      +                <Box marginY={1}>

      +                    {renderNavigator()}

      +                </Box>

      +
                       {/* Body */}
                       <Box marginY={1}>
                           {renderBody()}
                       </Box>
      -                

      -                <Separator />
                   </Box>
      -            

      -            {/* Footer */}

      -            <Box>

      -                {renderFooter()}

      -            </Box>

      -        </Box>

      +        </ScreenLayout>
           );
       };
       
    patchStrategy: standard-diff
  - type: write
    path: src/components/DashboardScreen.tsx
    content: >
      --- src/components/DashboardScreen.tsx

      +++ src/components/DashboardScreen.tsx

      @@ -1,11 +1,11 @@
       import React, { useState, useEffect, useRef } from 'react';
       import { Box, Text } from 'ink';
       import Spinner from 'ink-spinner';
      -import Separator from './Separator';
       import type { Transaction, TransactionStatus } from '../types/domain.types';
       import { useDashboardScreen } from '../hooks/useDashboardScreen';
       import { UI_CONFIG } from '../config/ui.config'; //
       import ActionFooter from './ActionFooter';
      +import ScreenLayout from './layout/ScreenLayout';
       import { DASHBOARD_FOOTER_ACTIONS, DASHBOARD_STATUS } from '../constants/dashboard.constants';
       import { TRANSACTION_STATUS_UI, FILE_CHANGE_ICONS } from '../constants/ui.constants';
       
      @@ -140,48 +140,43 @@
           };
           
           return (
      -        <Box flexDirection="column" height="100%">

      -            <Text color="cyan">▲ relaycode dashboard</Text>

      -            <Separator />

      -            <Box marginY={1}>

      -                {renderStatusBar()}

      -            </Box>

      -            

      -            {isModal && (

      -                <>

      -                    <ConfirmationContent
      transactionsToConfirm={transactionsToConfirm} />

      -                    <Separator />

      -                </>

      -            )}

      -            

      -            <Text bold underline> EVENT STREAM (Last 15 minutes)</Text>

      -            <Box flexDirection="column" marginTop={1}>

      -                {transactions.length === 0 && (

      -                     <Box paddingLeft={2}><Text color="gray">Listening
      for changes... no events yet.</Text></Box>

      +        <ScreenLayout

      +            title={<Text color="cyan">▲ relaycode dashboard</Text>}

      +            footer={renderFooter()}

      +        >

      +            <Box flexDirection="column" flexGrow={1}>

      +                <Box>

      +                    {renderStatusBar()}

      +                </Box>

      +                

      +                {isModal && (

      +                    <Box marginY={1}>

      +                        <ConfirmationContent
      transactionsToConfirm={transactionsToConfirm} />

      +                    </Box>
                       )}
      -                {transactions.slice(viewOffset, viewOffset +
      viewportHeight).map((tx, index) => {

      -                    const actualIndex = viewOffset + index;

      -                    const isExpanded = expandedTransactionId === tx.id;

      -                    const isNew = newTransactionIds.has(tx.id);

      -                    return (

      -                        <React.Fragment key={tx.id}>

      -                            <EventStreamItem

      -                                transaction={tx}

      -                                isSelected={!isModal && actualIndex ===
      selectedTransactionIndex}

      -                                isExpanded={isExpanded}

      -                                isNew={isNew}

      -                            />

      -                            {isExpanded && <ExpandedEventInfo
      transaction={tx} />}

      -                        </React.Fragment>

      -                    );

      -                })}

      +                

      +                <Box marginTop={1}><Text bold underline> EVENT STREAM
      (Last 15 minutes)</Text></Box>

      +                <Box flexDirection="column" marginTop={1} flexGrow={1}>

      +                    {transactions.length === 0 && (

      +                         <Box paddingLeft={2}><Text
      color="gray">Listening for changes... no events yet.</Text></Box>

      +                    )}

      +                    {transactions.slice(viewOffset, viewOffset +
      viewportHeight).map((tx, index) => {

      +                        const actualIndex = viewOffset + index;

      +                        const isExpanded = expandedTransactionId ===
      tx.id;

      +                        const isNew = newTransactionIds.has(tx.id);

      +                        return (

      +                            <React.Fragment key={tx.id}>

      +                                <EventStreamItem

      +                                    transaction={tx}

      +                                    isSelected={!isModal && actualIndex
      === selectedTransactionIndex}

      +                                    isExpanded={isExpanded}

      +                                    isNew={isNew}

      +                                />

      +                                {isExpanded && <ExpandedEventInfo
      transaction={tx} />}

      +                            </React.Fragment>

      +                        );

      +                    })}

      +                </Box>
                   </Box>
      -

      -            <Box marginTop={1}><Separator /></Box>

      -            {renderFooter()}

      -        </Box>

      +        </ScreenLayout>
           );
       };
       
    patchStrategy: standard-diff
  - type: write
    path: src/stores/copy.store.ts
    content: >
      --- src/stores/copy.store.ts

      +++ src/stores/copy.store.ts

      @@ -1,5 +1,4 @@
       import { create } from 'zustand';
      -import { moveIndex } from './navigation.utils';
       import { useViewStore } from './view.store';
       import { useNotificationStore } from './notification.store';
       import { LoggerService } from '../services/logger.service';
      @@ -12,7 +11,6 @@
       interface CopyState {
           title: string;
           items: CopyItem[];
      -    selectedIndex: number;
           selectedIds: Set<string>;
           lastCopiedMessage: string | null;
           onClose?: () => void;
      @@ -23,7 +21,6 @@
               openForReview: (transaction: Transaction, files: FileItem[], selectedFile?: FileItem) => void;
               openForDetail: (transaction: Transaction, selectedFile?: FileItem) => void;
               openForHistory: (transactions: Transaction[]) => void;
      -        setSelectedIndex: (index: number) => void;
               toggleSelection: () => void;
               toggleSelectionById: (id: string) => void;
               executeCopy: () => void;
      @@ -32,7 +29,6 @@
       export const useCopyStore = create<CopyState>((set, get) => ({
           title: '',
           items: [],
      -    selectedIndex: 0,
           selectedIds: new Set(),
           lastCopiedMessage: null,
           onClose: undefined,
      @@ -44,7 +40,6 @@
                   set({
                       title,
                       items,
      -                selectedIndex: 0,
                       selectedIds: defaultSelectedIds,
                       lastCopiedMessage: null,
                       onClose,
      @@ -71,11 +66,8 @@
                   const items = CopyService.getCopyItemsForHistory(transactions);
                   actions.open(title, items);
               },
      -        setSelectedIndex: (index) => set(state => ({

      -            selectedIndex: Math.max(0, Math.min(state.items.length - 1,
      index)),

      -        })),
               toggleSelection: () => set(state => {
      -            const currentItem = state.items[state.selectedIndex];

      +            const currentItem =
      useCopyScreen.getState().items[useCopyScreen.getState().selectedIndex];
                   if (!currentItem) return {};
                   const newSelectedIds = new Set(state.selectedIds);
                   if (newSelectedIds.has(currentItem.id)) {
    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useCopyScreen.tsx
    content: |
      --- src/hooks/useCopyScreen.tsx
      +++ src/hooks/useCopyScreen.tsx
      @@ -1,25 +1,30 @@
      +import { useState, useEffect } from 'react';
       import { useCopyStore } from '../stores/copy.store';
       import { useViewStore } from '../stores/view.store';
       import { useViewport } from './useViewport';
       import { UI_CONFIG } from '../config/ui.config';
       import { OVERLAYS } from '../constants/view.constants';
      -import { useListNavigator } from './useListNavigator';
      +import { useListNavigator } from './useListNavigator.js';
       
       export const useCopyScreen = () => {
      +    const [selectedIndex, setSelectedIndex] = useState(0);
      +
           const {
      -        title, items, selectedIndex, selectedIds, lastCopiedMessage,
      +        title, items, selectedIds, lastCopiedMessage,
               actions,
           } = useCopyStore(state => ({ ...state, actions: state.actions }));
           
      +    useEffect(() => setSelectedIndex(0), [items]);
      +
           const { viewOffset, viewportHeight } = useViewport({
               selectedIndex,
               itemCount: items.length,
               layoutConfig: UI_CONFIG.layout.copyScreen,
           });
       
      +
           useListNavigator({
               itemCount: items.length,
               viewportHeight,
               selectedIndex,
      -        onIndexChange: actions.setSelectedIndex,
      +        onIndexChange: setSelectedIndex,
               isActive: useViewStore.getState().activeOverlay === OVERLAYS.COPY,
               onKey: (input, key) => {
                   if (key.escape) {
    patchStrategy: standard-diff
  - type: write
    path: src/stores/dashboard.store.ts
    content: >
      --- src/stores/dashboard.store.ts

      +++ src/stores/dashboard.store.ts

      @@ -2,7 +2,6 @@
       import { useTransactionStore } from './transaction.store';
       import { DashboardService } from '../services/dashboard.service';
       import { DASHBOARD_STATUS } from '../constants/dashboard.constants';
      -import { moveIndex } from './navigation.utils';
       
       export type DashboardStatus = (typeof DASHBOARD_STATUS)[keyof typeof DASHBOARD_STATUS];
        
      @@ -12,8 +11,6 @@
           expandedTransactionId: string | null;
           actions: {
               togglePause: () => void;
      -        moveSelectionUp: () => void;

      -        moveSelectionDown: () => void;
               startApproveAll: () => void;
               confirmAction: () => Promise<void>;
               cancelAction: () => void;
      @@ -31,21 +28,6 @@
           actions: {
               togglePause: () => set(state => ({
                   status: state.status === DASHBOARD_STATUS.LISTENING ? DASHBOARD_STATUS.PAUSED : DASHBOARD_STATUS.LISTENING,
      -        })),

      -        moveSelectionUp: () => set(state => {

      -            const { transactions } = useTransactionStore.getState();

      -            return {

      -                selectedTransactionIndex:
      moveIndex(state.selectedTransactionIndex, 'up', transactions.length),

      -                expandedTransactionId: null,

      -            };

      -        }),

      -        moveSelectionDown: () => set(state => {

      -            const { transactions } = useTransactionStore.getState();

      -            return {

      -                selectedTransactionIndex:
      moveIndex(state.selectedTransactionIndex, 'down', transactions.length),

      -                expandedTransactionId: null,

      -            };
               })),
               startApproveAll: () => set(state => ({
                   status: DASHBOARD_STATUS.CONFIRM_APPROVE,
    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useDashboardScreen.tsx
    content: >
      --- src/hooks/useDashboardScreen.tsx

      +++ src/hooks/useDashboardScreen.tsx

      @@ -10,6 +10,7 @@
       import type { LayoutConfig } from './useLayout';
       import { DASHBOARD_STATUS } from '../constants/dashboard.constants';
       import { useViewport } from './useViewport';
      +import { useListNavigator } from './useListNavigator';
       
       export const useDashboardScreen = ({ layoutConfig }: { layoutConfig: LayoutConfig }) => {
           const {
      @@ -53,8 +54,6 @@
       
           const {
               togglePause,
      -        moveSelectionUp,

      -        moveSelectionDown,
               startApproveAll,
               confirmAction,
               cancelAction,
      @@ -69,57 +68,59 @@
           const isModal = status === DASHBOARD_STATUS.CONFIRM_APPROVE;
           const isProcessing = status === DASHBOARD_STATUS.APPROVING;
       
      -    useInput((input, key) => {

      -        if (isModal) {

      -            if (key.return) confirmAction();

      -            if (key.escape) cancelAction();

      -            return;

      -        }

      -

      -        if (isProcessing) return; // No input while processing

      -

      -        if (key.leftArrow) {

      -            if (expandedTransactionId) {

      -                toggleExpand();

      -            }

      -            return;

      -        }

      -        if (key.rightArrow) {

      -            if (transactions[selectedTransactionIndex] &&
      !expandedTransactionId) {

      -                toggleExpand();

      -            }

      -            return;

      -        }

      -

      -        if (key.upArrow) moveSelectionUp();

      -        if (key.downArrow) moveSelectionDown();

      -        

      -        if (key.return) {

      -            const selectedTx = transactions[selectedTransactionIndex];

      -            if (!selectedTx) return;

      -            

      -            const isExpanded = expandedTransactionId === selectedTx.id;

      -

      -            if (isExpanded) {

      -                if (selectedTx.status === 'PENDING') {

      -                   
      useReviewStore.getState().actions.load(selectedTx.id);

      -                    appActions.showReviewScreen();

      -                } else {

      -                   
      useDetailStore.getState().actions.load(selectedTx.id);

      -                    appActions.showTransactionDetailScreen();

      -                }

      -            } else {

      -                toggleExpand();

      -            }

      -        }

      -        

      -        if (input.toLowerCase() === 'p') togglePause();

      -        if (input.toLowerCase() === 'a' && pendingApprovals > 0)
      startApproveAll();

      -        if (input.toLowerCase() === 'c' && pendingCommits > 0) {

      -            commitActions.prepareCommitScreen();

      -            appActions.showGitCommitScreen();

      -        }

      -        if (input.toLowerCase() === 'l') {

      -            useHistoryStore.getState().actions.load();

      -            appActions.showTransactionHistoryScreen();

      -        }

      +    useInput((_input, key) => {

      +        if (key.return) confirmAction();

      +        if (key.escape) cancelAction();

      +    }, { isActive: isModal });

      +

      +    useListNavigator({

      +        itemCount: transactions.length,

      +        viewportHeight,

      +        selectedIndex: selectedTransactionIndex,

      +        onIndexChange: (index) => {

      +            useDashboardStore.getState().actions.setSelectedIndex(index);

      +           
      useDashboardStore.getState().actions.setExpandedTransactionId(null);

      +        },

      +        isActive: !isModal && !isProcessing,

      +        onKey: (input, key) => {

      +            if (key.leftArrow) {

      +                if (expandedTransactionId) toggleExpand();

      +                return;

      +            }

      +            if (key.rightArrow) {

      +                if (transactions[selectedTransactionIndex] &&
      !expandedTransactionId) toggleExpand();

      +                return;

      +            }

      +            if (key.return) {

      +                const selectedTx =
      transactions[selectedTransactionIndex];

      +                if (!selectedTx) return;

      +                

      +                const isExpanded = expandedTransactionId ===
      selectedTx.id;

      +

      +                if (isExpanded) {

      +                    if (selectedTx.status === 'PENDING') {

      +                       
      useReviewStore.getState().actions.load(selectedTx.id);

      +                        appActions.showReviewScreen();

      +                    } else {

      +                       
      useDetailStore.getState().actions.load(selectedTx.id);

      +                        appActions.showTransactionDetailScreen();

      +                    }

      +                } else {

      +                    toggleExpand();

      +                }

      +                return;

      +            }

      +            if (input.toLowerCase() === 'p') togglePause();

      +            if (input.toLowerCase() === 'a' && pendingApprovals > 0)
      startApproveAll();

      +            if (input.toLowerCase() === 'c' && pendingCommits > 0) {

      +                commitActions.prepareCommitScreen();

      +                appActions.showGitCommitScreen();

      +            }

      +            if (input.toLowerCase() === 'l') {

      +                useHistoryStore.getState().actions.load();

      +                appActions.showTransactionHistoryScreen();

      +            }

      +        },
           });
      +
           const transactionsToConfirm = status === DASHBOARD_STATUS.CONFIRM_APPROVE ? pendingTransactions : [];
       
           return {
    patchStrategy: standard-diff
  - type: write
    path: src/stores/review.store.ts
    content: >
      --- src/stores/review.store.ts

      +++ src/stores/review.store.ts

      @@ -3,7 +3,6 @@
       import { useTransactionStore } from './transaction.store';
       import { useViewStore } from './view.store';
       import { ReviewService, type SimulationResult } from '../services/review.service';
      -import { INITIAL_APPLY_STEPS, PATCH_STATUS, REVIEW_BODY_VIEWS } from
      '../constants/review.constants';

      -import { moveIndex } from './navigation.utils';

      +import { INITIAL_APPLY_STEPS, PATCH_STATUS, REVIEW_BODY_VIEWS,
      BULK_INSTRUCT_OPTIONS, BULK_REPAIR_OPTIONS } from
      '../constants/review.constants';
       import { sleep } from '../utils';
       import type { FileReviewStatus } from '../types/domain.types';
       
      @@ -37,8 +36,6 @@
       
           actions: {
               load: (transactionId: string, initialState?: Partial<Pick<ReviewState, 'bodyView' | 'selectedBulkRepairOptionIndex'>>) => void;
      -        moveSelectionUp: (listSize: number) => void;

      -        moveSelectionDown: (listSize: number) => void;
               setSelectedItemIndex: (index: number) => void;
               expandDiff: () => void;
               toggleBodyView: (view: Extract<
      @@ -118,12 +115,6 @@
                       ...initialState,
                   });
               },
      -        moveSelectionUp: (listSize) => set(state => {

      -            return { selectedItemIndex:
      moveIndex(state.selectedItemIndex, 'up', listSize) };

      -        }),

      -        moveSelectionDown: (listSize) => set(state => {

      -            return { selectedItemIndex:
      moveIndex(state.selectedItemIndex, 'down', listSize) };

      -        }),
               setSelectedItemIndex: (index) => set({ selectedItemIndex: index }),
               toggleBodyView: (view) => set(state => {
                   const transactionId = useViewStore.getState().selectedTransactionId;
      @@ -357,14 +348,14 @@
                   });
               },
               navigateBulkRepairUp: () => set(state => ({
      -            selectedBulkRepairOptionIndex:
      moveIndex(state.selectedBulkRepairOptionIndex, 'up', 4),

      +            selectedBulkRepairOptionIndex:
      (state.selectedBulkRepairOptionIndex - 1 + BULK_REPAIR_OPTIONS.length) %
      BULK_REPAIR_OPTIONS.length,
               })),
               navigateBulkRepairDown: () => set(state => ({
      -            selectedBulkRepairOptionIndex:
      moveIndex(state.selectedBulkRepairOptionIndex, 'down', 4),

      +            selectedBulkRepairOptionIndex:
      (state.selectedBulkRepairOptionIndex + 1) % BULK_REPAIR_OPTIONS.length,
               })),
               navigateBulkInstructUp: () => set(state => ({
      -            selectedBulkInstructOptionIndex:
      moveIndex(state.selectedBulkInstructOptionIndex, 'up', 4),

      +            selectedBulkInstructOptionIndex:
      (state.selectedBulkInstructOptionIndex - 1 + BULK_INSTRUCT_OPTIONS.length)
      % BULK_INSTRUCT_OPTIONS.length,
               })),
               navigateBulkInstructDown: () => set(state => ({
      -            selectedBulkInstructOptionIndex:
      moveIndex(state.selectedBulkInstructOptionIndex, 'down', 4),

      +            selectedBulkInstructOptionIndex:
      (state.selectedBulkInstructOptionIndex + 1) %
      BULK_INSTRUCT_OPTIONS.length,
               })),
           },
       }));
    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useReviewScreen.tsx
    content: |
      --- src/hooks/useReviewScreen.tsx
      +++ src/hooks/useReviewScreen.tsx
      @@ -9,6 +9,7 @@
       import { useContentViewport } from './useContentViewport';
       import { UI_CONFIG } from '../config/ui.config';
       import { REVIEW_BODY_VIEWS } from '../constants/review.constants';
      +import { useListNavigator } from './useListNavigator';
       import { useViewport } from './useViewport';
       
       type NavigableItem =
      @@ -107,8 +108,6 @@
           const scripts = transaction?.scripts || [];
       
           const {
      -        moveSelectionUp,
      -        moveSelectionDown,
               setSelectedItemIndex,
               expandDiff,
               toggleBodyView,
      @@ -282,10 +281,6 @@
                   return;
               }
       
      -        // Main View Navigation
      -        if (key.upArrow) moveSelectionUp(navigableItems.length);
      -        if (key.downArrow) moveSelectionDown(navigableItems.length);
      -
               const currentItem = navigableItems[selectedItemIndex];
       
               if (input === ' ') {
      @@ -340,24 +335,26 @@
               }
           };
       
      +    useListNavigator({
      +        itemCount: navigableItems.length,
      +        viewportHeight: listViewportHeight,
      +        selectedIndex: selectedItemIndex,
      +        onIndexChange: setSelectedItemIndex,
      +        isActive: bodyView === REVIEW_BODY_VIEWS.NONE,
      +        onKey: handleMainNavigationInput,
      +    });
      +
           useInput((input: string, key: Key) => {
      -        if (handleGlobalInput(input, key)) {
      -            return;
      -        }
      -
      -        // If we are in a scrollable body view, prioritize that input.
      -        if (handleContentScrollInput(key)) {
      -            return;
      -        }
      +        if (handleGlobalInput(input, key)) return;
      +        if (handleContentScrollInput(key)) return;
       
               switch (bodyView) {
                   case REVIEW_BODY_VIEWS.CONFIRM_HANDOFF: return handleHandoffConfirmInput(input, key);
                   case REVIEW_BODY_VIEWS.BULK_REPAIR: return handleBulkRepairInput(input, key);
                   case REVIEW_BODY_VIEWS.BULK_INSTRUCT: return handleBulkInstructInput(input, key);
                   case REVIEW_BODY_VIEWS.REASONING: return handleReasoningInput(input, key);
                   case REVIEW_BODY_VIEWS.SCRIPT_OUTPUT: return handleScriptOutputInput(input, key);
                   case REVIEW_BODY_VIEWS.DIFF: return handleDiffInput(input, key);
      -            default: return handleMainNavigationInput(input, key);
               }
      -    });
      +    }, { isActive: bodyView !== REVIEW_BODY_VIEWS.NONE });
       
           return {
               ...store,
    patchStrategy: standard-diff
snapshot:
  src/components/layout/ModalLayout.tsx: null
  src/components/layout/ScreenLayout.tsx: null
  src/components/ContentView.tsx: null
  src/components/ReasonScreen.tsx: >-
    import { Box, Text } from 'ink';


    interface ReasonScreenProps {
        reasoning: string,
        scrollIndex?: number,
        visibleLinesCount?: number, // if not provided, all lines are shown
    }


    const ReasonScreen = ({ reasoning, scrollIndex = 0, visibleLinesCount }:
    ReasonScreenProps) => {
        const lines = reasoning.split('\n');
        const visibleLines = visibleLinesCount ? lines.slice(scrollIndex, scrollIndex + visibleLinesCount) : lines;

        return (
            <Box flexDirection="column">
                <Text>REASONING</Text>
                <Box flexDirection="column" marginTop={1}>
                    {visibleLines.map((line, index) => <Text key={index}>{line}</Text>)}
                </Box>
            </Box>
        );
    };


    export default ReasonScreen;
  src/components/DiffScreen.tsx: >-
    import { Box, Text } from 'ink';

    import { UI_CONFIG } from '../config/ui.config';


    interface DiffScreenProps {
        filePath: string;
        diffContent: string;
        isExpanded: boolean;
        scrollIndex?: number;
        maxHeight?: number;
    }

    const DiffScreen = ({ filePath, diffContent, isExpanded, scrollIndex = 0,
    maxHeight }: DiffScreenProps) => {
        const lines = diffContent.split('\n');
        const COLLAPSE_THRESHOLD = UI_CONFIG.diffScreen.collapseThreshold;
        const COLLAPSE_SHOW_LINES = UI_CONFIG.diffScreen.collapseShowLines;

        const renderContent = () => {
            if (!isExpanded && lines.length > COLLAPSE_THRESHOLD) {
                const topLines = lines.slice(0, COLLAPSE_SHOW_LINES);
                const bottomLines = lines.slice(lines.length - COLLAPSE_SHOW_LINES);
                const hiddenLines = lines.length - (COLLAPSE_SHOW_LINES * 2);

                return (
                    <>
                        {topLines.map((line, i) => renderLine(line, i))}
                        <Text color="gray">... {hiddenLines} lines hidden ...</Text>
                        {bottomLines.map((line, i) => renderLine(line, i + topLines.length + 1))}
                    </>
                );
            }
            // Handle vertical scrolling for expanded view
            if (isExpanded && maxHeight) {
                const visibleLines = lines.slice(scrollIndex, scrollIndex + maxHeight);
                return visibleLines.map((line, i) => renderLine(line, scrollIndex + i));
            }
            return lines.map((line, i) => renderLine(line, i));
        };

        const renderLine = (line: string, key: number) => {
            let color = 'white';
            if (line.startsWith('+')) color = 'green';
            if (line.startsWith('-')) color = 'red';
            if (line.startsWith('@@')) color = 'cyan';
            return <Text key={key} color={color}>{line}</Text>;
        };

        return (
            <Box flexDirection="column">
                <Text>DIFF: {filePath}</Text>
                <Box flexDirection="column" marginTop={1}>
                    {renderContent()}
                </Box>
            </Box>
        );
    };


    export default DiffScreen;
  src/components/NotificationScreen.tsx: >-
    import { Box, Text } from 'ink';

    import { useNotificationScreen } from '../hooks/useNotificationScreen';

    import ActionFooter from './ActionFooter';

    import { NOTIFICATION_FOOTER_ACTIONS, NOTIFICATION_TYPE_CONFIG } from
    '../constants/notification.constants';


    const NotificationScreen = () => {
        const { notification, countdown } = useNotificationScreen();

        if (!notification) {
            return null;
        }

        const config = NOTIFICATION_TYPE_CONFIG[notification.type];

        return (
            <Box
                flexDirection="column"
                justifyContent="center"
                alignItems="center"
                width="100%"
                height="100%"
            >
                <Box
                    flexDirection="column"
                    paddingY={1}
                    width="80%"
                    backgroundColor="black"
                >
                    <Box paddingX={2} marginBottom={1} backgroundColor={config.color}>
                        <Text bold color="black">{config.title}</Text>
                    </Box>
                    <Box paddingX={2}>
                        <Text>{notification.message}</Text>
                    </Box>
                    <Box marginTop={1}>
                        <Box paddingX={2}>
                            <Text color="gray">(Dismissing in {countdown}s...)</Text>
                        </Box>
                    </Box>
                    <Box marginTop={1}>
                        <ActionFooter actions={NOTIFICATION_FOOTER_ACTIONS} />
                    </Box>
                </Box>
            </Box>
        );
    };


    export default NotificationScreen;
  src/components/CopyScreen.tsx: |-
    import { Box, Text } from 'ink';
    import Separator from './Separator';
    import { useStdoutDimensions } from '../utils';
    import ActionFooter from './ActionFooter';
    import { useCopyScreen } from '../hooks/useCopyScreen';
    import { COPY_SCREEN_FOOTER_ACTIONS } from '../constants/copy.constants';

    const CopyScreen = () => {
        const {
            title,
            itemsInView,
            selectedIndex,
            selectedIds,
            lastCopiedMessage,
            viewOffset,
        } = useCopyScreen();
        const [width] = useStdoutDimensions();

        return (
            <Box 
                width="100%"
                height="100%"
                flexDirection="column"
                justifyContent="center"
                alignItems="center"
            >
                <Box 
                    flexDirection="column" 
                    paddingX={2}
                    width="80%"
                >
                    <Text bold color="black" backgroundColor="yellow"> ▲ relaycode · COPY MODE </Text>
                    <Separator width={Math.floor(width * 0.8) - 4} />
                    <Box flexDirection="column" marginY={1}>
                        <Text>{title}</Text>
                        <Box flexDirection="column" marginTop={1}>
                            {itemsInView.map((item, index) => {
                                const isSelected = (index + viewOffset) === selectedIndex;
                                const isChecked = selectedIds.has(item.id);
                                return (
                                    <Text key={item.id} color={isSelected ? 'cyan' : undefined}>
                                        {isSelected ? '> ' : '  '}
                                        [{isChecked ? 'x' : ' '}] ({item.key}) {item.label}
                                    </Text>
                                );
                            })}
                        </Box>
                    </Box>
                    <Separator width={Math.floor(width * 0.8) - 4} />
                    {lastCopiedMessage && <Text color="green">✓ {lastCopiedMessage}</Text>}
                    <ActionFooter actions={COPY_SCREEN_FOOTER_ACTIONS}/>
                </Box>
            </Box>
        );
    };

    export default CopyScreen;
  src/components/DebugLogScreen.tsx: >-
    import { Box, Text } from 'ink';

    import TextInput from 'ink-text-input';

    import Separator from './Separator';

    import ActionFooter from './ActionFooter';

    import { useDebugLogScreen } from '../hooks/useDebugLogScreen';

    import { DEBUG_LOG_FOOTER_ACTIONS, DEBUG_LOG_MODES, LOG_LEVEL_COLORS,
    LOG_LEVEL_TAGS } from '../constants/log.constants';

    import type { LogEntry } from '../types/log.types';

    import { useStdoutDimensions } from '../utils';


    const LogEntryRow = ({ entry, isSelected }: { entry: LogEntry; isSelected:
    boolean }) => {
        const time = new Date(entry.timestamp).toISOString().split('T')[1]?.replace('Z', '');
        const color = LOG_LEVEL_COLORS[entry.level];
        const tagColors = LOG_LEVEL_TAGS[entry.level];

        return (
            <Text color={color}>
                {isSelected ? '> ' : '  '}
                <Text color="gray">{time}</Text>
                {' '}
                <Text bold color={tagColors.color} backgroundColor={tagColors.backgroundColor}>
                    {' '}{entry.level.padEnd(5, ' ')}{' '}
                </Text>
                {' '}
                {entry.message}
            </Text>
        );
    };


    const DebugLogScreen = () => {
        const {
            logsInView,
            logCount,
            filteredLogCount,
            selectedIndex,
            mode,
            filterQuery,
            setFilterQuery,
            viewOffset,
        } = useDebugLogScreen();
        const [width] = useStdoutDimensions();

        const renderFilter = () => (
            <Box>
                <Text>Filter: </Text>
                {mode === DEBUG_LOG_MODES.FILTER ? (
                    <TextInput
                        value={filterQuery}
                        onChange={setFilterQuery}
                        placeholder="Type to filter log messages..."
                    />
                ) : (
                    <Text color="gray">{filterQuery || '(none)'}</Text>
                )}
                <Box flexGrow={1} /> 
                <Text>
                    Showing {Math.min(viewOffset + 1, filteredLogCount)}-
                    {Math.min(viewOffset + logsInView.length, filteredLogCount)} of {filteredLogCount}
                </Text> 
            </Box>
        );

        const footerActions =
            mode === DEBUG_LOG_MODES.FILTER
                ? DEBUG_LOG_FOOTER_ACTIONS.FILTER_MODE
                : DEBUG_LOG_FOOTER_ACTIONS.LIST_MODE(logCount > 0);

        return (
            <Box
                flexDirection="column"
                width="100%"
                height="100%"
                paddingX={2}
                paddingY={1}
            >
                <Text bold color="black" backgroundColor="yellow"> ▲ relaycode · DEBUG LOG </Text>
                <Separator width={width - 4} />
                <Box marginY={1}>{renderFilter()}</Box>
                <Box flexDirection="column" flexGrow={1}>
                    {logsInView.map((entry, index) => (
                        <LogEntryRow
                            key={`${entry.timestamp}-${index}`}
                            entry={entry}
                            isSelected={selectedIndex === index + viewOffset}
                        />
                    ))}
                    {logCount > 0 && filteredLogCount === 0 && (
                        <Text color="gray">No logs match your filter.</Text>
                    )}
                    {logCount === 0 && (
                        <Text color="gray">No log entries yet. Waiting for system activity...</Text>
                    )}
                </Box>
                <Separator width={width - 4} />
                <ActionFooter actions={footerActions} />
            </Box>
        );
    };


    export default DebugLogScreen;
  src/components/GitCommitScreen.tsx: |-
    import { Box, Text } from 'ink';
    import Spinner from 'ink-spinner';
    import Separator from './Separator';
    import { useGitCommitScreen } from '../hooks/useGitCommitScreen';
    import ActionFooter from './ActionFooter';
    import { COMMIT_FOOTER_ACTIONS } from '../constants/commit.constants';

    const GitCommitScreen = () => {
        const { transactionsToCommit, finalCommitMessage, isCommitting, commitError } = useGitCommitScreen();

        const messageParts = finalCommitMessage.split('\n');
        const subject = messageParts[0] || '';
        const body = messageParts.slice(1).join('\n');

        const renderError = () => (
            <Box 
                flexDirection="column" 
                borderStyle="round" 
                borderColor="red" 
                paddingX={2} 
                marginY={1}
            >
                <Text bold color="red">COMMIT FAILED</Text>
                <Text wrap="wrap">The git operation failed. Please check the error message below and resolve any issues before retrying.</Text>
                <Box marginTop={1}>
                    <Text color="red">{commitError}</Text>
                </Box>
            </Box>
        );

        return (
            <Box flexDirection="column">
                <Text bold color="black" backgroundColor="yellow"> ▲ relaycode · GIT COMMIT </Text>
                <Separator />
                <Box marginY={1} flexDirection="column" paddingX={2}>
                    <Text>Found {transactionsToCommit.length} new transactions to commit since last git commit.</Text>
                    <Box marginTop={1} flexDirection="column">
                        <Text bold>TRANSACTIONS INCLUDED</Text>
                        {transactionsToCommit.map(tx => (
                            <Text key={tx.id}>- <Text color="gray">{tx.hash}</Text>: {tx.message}</Text>
                        ))}
                    </Box>
                </Box>
                <Separator />
                <Box marginY={1} flexDirection="column" paddingX={2}>
                    <Text bold>FINAL COMMIT MESSAGE</Text>
                    <Box marginTop={1} flexDirection="column">
                        <Text color="yellow">{subject}</Text>
                        {body ? <Text>{body}</Text> : null}
                    </Box>
                </Box>
                {commitError && renderError()}
                <Separator />
                {!commitError && <Box marginY={1} paddingX={2}>
                     <Text>This will run &apos;git add .&apos; and &apos;git commit&apos; with the message above.</Text>
                </Box>}
                <Separator />
                {isCommitting
                    ? <Text><Spinner type="dots"/> Committing... please wait.</Text>
                    : <ActionFooter actions={commitError ? COMMIT_FOOTER_ACTIONS.FAILURE : COMMIT_FOOTER_ACTIONS.BASE} />
                }
            </Box>
        );
    };

    export default GitCommitScreen;
  src/components/TransactionHistoryScreen.tsx: >-
    import { useMemo } from 'react';

    import { Box, Text } from 'ink';

    import TextInput from 'ink-text-input';

    import Spinner from 'ink-spinner';

    import Separator from './Separator';

    import type { Transaction, FileItem } from '../types/domain.types';

    import { useTransactionHistoryScreen } from
    '../hooks/useTransactionHistoryScreen';

    import { HISTORY_FOOTER_ACTIONS, BULK_ACTIONS_OPTIONS, HISTORY_VIEW_MODES }
    from '../constants/history.constants';

    import ActionFooter from './ActionFooter';

    import { TRANSACTION_STATUS_UI, FILE_CHANGE_ICONS } from
    '../constants/ui.constants';


    // --- Sub-components ---


    const ContentRow = ({ title, content, isSelected, isExpanded, isLoading }: {
        title: string;
        content: string;
        isSelected: boolean;
        isExpanded: boolean;
        isLoading: boolean;
    }) => {
        const icon = isExpanded ? '▾' : '▸';
        return (
            <Box flexDirection="column" paddingLeft={6}>
                <Text color={isSelected ? 'cyan' : undefined}>
                    {isSelected ? '> ' : '  '}{icon} {title}
                </Text>
                {isLoading && <Box paddingLeft={8}><Spinner type="dots" /></Box>}
                {isExpanded && !isLoading && (
                    <Box paddingLeft={8} flexDirection="column">
                        {(content || '').split('\n').map((line, i) => <Text key={i}>{line || ' '}</Text>)}
                    </Box>
                )}
            </Box>
        );
    };


    const DiffPreview = ({ diff }: { diff: string }) => {
        const lines = diff.split('\n');
        const previewLines = lines.slice(0, 5);
        const hiddenLines = lines.length > 5 ? lines.length - 5 : 0;

        return (
            <Box flexDirection="column" paddingLeft={8}>
                {previewLines.map((line, i) => {
                    let color = 'white';
                    if (line.startsWith('+')) color = 'green';
                    if (line.startsWith('-')) color = 'red';
                    if (line.startsWith('@@')) color = 'cyan';
                    return <Text key={i} color={color}>{line}</Text>;
                })}
                {hiddenLines > 0 && <Text color="gray">... {hiddenLines} lines hidden ...</Text>}
            </Box>
        );
    };


    const FileRow = ({ file, isSelected, isExpanded, isLoading }: {
        file: FileItem;
        isSelected: boolean;
        isExpanded: boolean;
        isLoading: boolean;
    }) => {
        const icon = isExpanded ? '▾' : '▸';

        return (
            <Box flexDirection="column" paddingLeft={6}>
                <Text color={isSelected ? 'cyan' : undefined}>
                    {isSelected ? '> ' : '  '}{' '}
                    {icon} {FILE_CHANGE_ICONS[file.type]} {file.path}
                </Text>
                {isLoading && <Box paddingLeft={8}><Spinner type="dots" /></Box>}
                {isExpanded && !isLoading && <DiffPreview diff={file.diff} />}
            </Box>
        );
    };


    const TransactionRow = ({
        tx,
        isSelected,
        isExpanded,
        isSelectedForAction,
        hasSelection,
    }: {
        tx: Transaction;
        isSelected: boolean;
        isExpanded: boolean;
        isSelectedForAction: boolean;
        hasSelection: boolean;
    }) => {
        const icon = isExpanded ? '▾' : '▸';
        const uiStatus = TRANSACTION_STATUS_UI[tx.status as keyof typeof TRANSACTION_STATUS_UI] || { text: tx.status, color: 'white' };

        const date = new Date(tx.timestamp).toISOString().split('T')[0];
        const selectionIndicator = isSelectedForAction ? '[x] ' : '[ ] ';
        
        return (
            <Box flexDirection="column" marginBottom={isExpanded ? 1 : 0}>
                <Text color={isSelected ? 'cyan' : undefined}>
                    {isSelected ? '> ' : '  '}
                    {hasSelection && selectionIndicator}
                    {icon} <Text color={uiStatus.color}>{uiStatus.text}</Text> · <Text color="gray">{tx.hash}</Text> · {date} ·{' '}
                    {tx.message}
                </Text>
                {isExpanded && (
                    <Box flexDirection="column" paddingLeft={8}>
                        {tx.stats && (
                            <Text color="gray">
                                Stats: {tx.stats.files} files, +{tx.stats.linesAdded}/-{tx.stats.linesRemoved}
                            </Text>
                        )}
                        <Text>Files:</Text>
                    </Box>
                )}
            </Box>
        );
    };


    const BulkActionsMode = ({ selectedForActionCount }: {
    selectedForActionCount: number }) => {
        return (
            <Box flexDirection="column" marginY={1}>
                <Text bold color="yellow">PERFORM BULK ACTION ON {selectedForActionCount} SELECTED ITEMS</Text>
                <Box marginY={1}>
                    <Text>This action is often irreversible. Are you sure?</Text>
                </Box>
                {BULK_ACTIONS_OPTIONS.map(opt => <Text key={opt}>{opt}</Text>)}
            </Box>
        );
    };


    // --- Main Component ---


    const TransactionHistoryScreen = () => {
        const {
            mode,
            filterQuery,
            selectedForAction,
            selectedItemPath,
            expandedIds,
            loadingPaths,
            actions,
            transactions,
            itemsInView,
            filterStatus,
            showingStatus,
            statsStatus,
            hasSelection,
        } = useTransactionHistoryScreen();

        const transactionsById = useMemo(() => new Map(transactions.map(tx => [tx.id, tx])), [transactions]);

        const renderFooter = () => {
            if (mode === HISTORY_VIEW_MODES.FILTER) {
                return <ActionFooter actions={HISTORY_FOOTER_ACTIONS.FILTER_MODE} />;
            }
            if (mode === HISTORY_VIEW_MODES.BULK_ACTIONS) {
                return <Text>{HISTORY_FOOTER_ACTIONS.BULK_MODE.text}</Text>;
            }
            
            const openActionLabel = selectedItemPath.includes('/file/') ? 'Open File' : 'Open YAML';
            return <ActionFooter actions={HISTORY_FOOTER_ACTIONS.LIST_MODE(openActionLabel, hasSelection)} />;
        };

        return (
            <Box flexDirection="column">
                <Text bold color="black" backgroundColor="yellow"> ▲ relaycode · TRANSACTION HISTORY </Text>
                <Separator />

                <Box>
                    <Text>Filter: </Text>
                    {mode === HISTORY_VIEW_MODES.FILTER ? (
                        <TextInput value={filterQuery} onChange={actions.setFilterQuery} />
                    ) : (
                        <Text>{filterStatus}</Text>
                    )}
                    <Text> · {showingStatus}</Text>
                    {statsStatus && <Text> · <Text color="magenta">{statsStatus}</Text></Text>}
                </Box>

                <Box flexDirection="column" marginY={1}>
                    {mode === HISTORY_VIEW_MODES.BULK_ACTIONS && <BulkActionsMode selectedForActionCount={selectedForAction.size} />}

                    {mode === HISTORY_VIEW_MODES.LIST && itemsInView.map(path => {
                        const txId = path.split('/')[0]!;
                        const tx = transactionsById.get(txId);
                        if (!tx) return <Text key={path}>Error: Missing TX {txId}</Text>;

                        // Is a transaction row
                        if (path === tx.id) {
                            return (
                                <TransactionRow
                                    key={path}
                                    tx={tx}
                                    isSelected={selectedItemPath === path}
                                    isExpanded={expandedIds.has(path)}
                                    isSelectedForAction={selectedForAction.has(tx.id)}
                                    hasSelection={hasSelection}
                                />
                            );
                        }

                        // Is a child row
                        const itemType = path.split('/')[1]!;
                        const isSelected = selectedItemPath === path;
                        const isExpanded = expandedIds.has(path);
                        const isLoading = loadingPaths.has(path);

                        if (itemType === 'file') {
                            const fileId = path.split('/')[2]!;
                            const file = tx.files?.find(f => f.id === fileId);
                            if (!file) return null;
                            return (
                                <FileRow
                                    key={path} file={file} isSelected={isSelected}
                                    isExpanded={isExpanded} isLoading={isLoading}
                                />
                            );
                        }

                        const contentMap = {
                            message: { title: 'Commit Message', content: tx.message || '' },
                            prompt: { title: 'Prompt', content: tx.prompt || '' },
                            reasoning: { title: 'Reasoning', content: tx.reasoning || '' },
                        };

                        const item = contentMap[itemType as keyof typeof contentMap];
                        if (!item) return null;

                        return (
                            <ContentRow
                                key={path}
                                {...item}
                                isSelected={isSelected}
                                isExpanded={isExpanded}
                                isLoading={isLoading}
                            />
                        );
                    })}
                </Box>

                <Separator />
                {renderFooter()}
            </Box>
        );
    };


    export default TransactionHistoryScreen;
  src/components/ReviewScreen.tsx: >-
    import { Box, Text } from 'ink';

    import Separator from './Separator';

    import DiffScreen from './DiffScreen';

    import ReasonScreen from './ReasonScreen';

    import type { ScriptResult, FileItem, FileChangeType } from
    '../types/domain.types';

    import { useReviewScreen } from '../hooks/useReviewScreen';

    import { REVIEW_BODY_VIEWS, REVIEW_FOOTER_ACTIONS, BULK_REPAIR_OPTIONS,
    BULK_INSTRUCT_OPTIONS } from '../constants/review.constants';

    import ActionFooter from './ActionFooter';

    import { FILE_STATUS_UI } from '../constants/ui.constants';


    // --- Sub-components ---


    const FileItemRow = ({ file, reviewState, isFocused }: {
        file: FileItem;
        reviewState: { status: string; error?: string; details?: string };
        isFocused: boolean;
    }) => {
        const ui = FILE_STATUS_UI[reviewState.status as keyof typeof FILE_STATUS_UI] || { icon: '[?]', color: 'gray' };

        const typeColor = (type: FileChangeType) => {
            switch (type) {
                case 'ADD': return 'green';
                case 'DEL': return 'red';
                case 'REN': return 'yellow';
                default: return 'white';
            }
        };

        const diffStats = <Text>(+<Text color="green">{file.linesAdded}</Text>/-<Text color="red">{file.linesRemoved}</Text>)</Text>;
        const strategy = file.strategy === 'standard-diff' ? 'diff' : file.strategy;
        const prefix = isFocused ? '> ' : '  ';
        const colorProps = isFocused ? { bold: true, color: 'cyan' } : {};

        if (reviewState.status === 'FAILED') {
            return (
                <Box>
                    <Text {...colorProps}>
                        {prefix}<Text color={ui.color}>{ui.icon} FAILED {file.path}</Text>
                        <Text color="red">    ({reviewState.error})</Text>
                    </Text>
                </Box>
            );
        }

        if (reviewState.status === 'AWAITING') {
            return (
                <Box>
                    <Text {...colorProps}>
                        {prefix}<Text color={ui.color}>{ui.icon} AWAITING {file.path}</Text>
                        <Text color="yellow">    ({reviewState.details})</Text>
                    </Text>
                </Box>
            );
        }

        if (reviewState.status === 'RE_APPLYING') {
            return (
                 <Box>
                    <Text {...colorProps}>
                        {prefix}<Text color={ui.color}>{ui.icon} RE-APPLYING... {file.path}</Text>
                        <Text color="cyan"> (using &apos;replace&apos; strategy)</Text>
                    </Text>
                </Box>
            );
        }

        return (
            <Box>
                <Text {...colorProps}>
                    {prefix}<Text color={ui.color}>{ui.icon}</Text> {file.type}{' '}
                    <Text color={typeColor(file.type)}>{file.path}</Text>{' '}
                    {diffStats} [{strategy}]
                </Text>
            </Box>
        );
    };


    const ScriptItemRow = ({
        script,
        isSelected,
        isExpanded,
    }: {
        script: ScriptResult;
        isSelected: boolean;
        isExpanded: boolean;
    }) => {
        const icon = script.success ? '✓' : '✗';
        const iconColor = script.success ? 'green' : 'red';
        const arrow = isExpanded ? '▾' : '▸';
        const prefix = isSelected ? '> ' : '  ';
        
        // Extract script type from command (e.g., "bun run test" -> "Post-Command", "bun run lint" -> "Linter")
        const scriptType = script.command.includes('test') ? 'Post-Command' : 
                          script.command.includes('lint') ? 'Linter' : 
                          'Script';

        return (
            <Box>
                <Text bold={isSelected} color={isSelected ? 'cyan' : undefined}>
                    {prefix}<Text color={iconColor}>{icon}</Text> {scriptType}: `{script.command}` ({script.duration}s) {arrow}{' '}
                    {script.summary}
                </Text>
            </Box>
        );
    };


    // --- Main Component ---


    const ReviewScreen = () => {
        const {
            transaction,
            files,
            scripts = [],
            patchStatus,
            selectedItemIndex,
            bodyView,
            isDiffExpanded,
            reasoningScrollIndex,
            scriptErrorIndex,
            fileReviewStates,
            numFiles,
            approvedFilesCount,
            totalLinesAdded,
            totalLinesRemoved,
            selectedBulkRepairOptionIndex,
            selectedBulkInstructOptionIndex,
            navigableItems,
            navigableItemsInView,
            viewOffset,
            contentScrollIndex,
            availableBodyHeight,
            hasRejectedFiles,
        } = useReviewScreen();

        if (!transaction) {
            return <Text>Loading review...</Text>;
        }
        const { hash, message, prompt = '', reasoning = '' } = transaction;

        const renderBody = () => {
            if (bodyView === REVIEW_BODY_VIEWS.NONE) return null;

            if (bodyView === REVIEW_BODY_VIEWS.REASONING) {
                const reasoningText = reasoning || '';
                const reasoningLinesCount = reasoningText.split('\n').length;
                const visibleLinesCount = 10;
                return (
                    <Box flexDirection="column">
                        <ReasonScreen
                            reasoning={reasoningText}
                            scrollIndex={contentScrollIndex}
                            visibleLinesCount={Math.max(1, availableBodyHeight)}
                        />
                        {reasoningLinesCount > visibleLinesCount && (
                            <Text color="gray">
                                Showing lines {reasoningScrollIndex + 1}-{Math.min(reasoningScrollIndex + visibleLinesCount, reasoningLinesCount)}{' '}
                                of {reasoningLinesCount}
                            </Text>
                        )}
                    </Box>
                );
            }
            
            if (bodyView === REVIEW_BODY_VIEWS.DIFF) {
                const currentItem = navigableItems[selectedItemIndex];
                const selectedFile = currentItem?.type === 'file' ? files.find(f => f.id === currentItem.id) : undefined;
                if (!selectedFile) return null;
                return (
                    <DiffScreen
                        filePath={selectedFile.path}
                        diffContent={selectedFile.diff}
                        isExpanded={isDiffExpanded}
                        scrollIndex={contentScrollIndex}
                        maxHeight={Math.max(1, availableBodyHeight)}
                    />
                );
            }

            if (bodyView === REVIEW_BODY_VIEWS.SCRIPT_OUTPUT) {
                 const currentItem = navigableItems[selectedItemIndex];
                 const scriptItems = navigableItems.filter((i): i is { type: 'script'; id: string } => i.type === 'script');
                 const scriptIndex = currentItem?.type === 'script'
                    ? scriptItems.findIndex(i => i.id === currentItem.id)
                    : -1;
                 const selectedScript = scripts[scriptIndex] || null;
                 if (!selectedScript) return null;
                 
                 const outputLines = selectedScript.output.split('\n');
                 const errorLines = outputLines.filter((line: string) =>
                    line.includes('Error') || line.includes('Warning'),
                 );
                 
                 return (
                    <Box flexDirection="column">
                        <Text>
                            {selectedScript.command.includes('lint') ? 'LINTER' : 'SCRIPT'} OUTPUT: `{selectedScript.command}`
                        </Text>
                        <Box marginTop={1} flexDirection="column">
                            {outputLines.map((line: string, index: number) => {
                                const isError = line.includes('Error');
                                const isWarning = line.includes('Warning');
                                const isHighlighted = errorLines[scriptErrorIndex] === line;
                                
                                return (
                                    <Text 
                                        key={index} 
                                        color={isError ? 'red' : isWarning ? 'yellow' : undefined}
                                        bold={isHighlighted}
                                        backgroundColor={isHighlighted ? 'blue' : undefined}
                                    >
                                        {line}
                                    </Text>
                                );
                            })}
                        </Box>
                        {errorLines.length > 0 && (
                            <Text color="gray">
                                Error {scriptErrorIndex + 1} of {errorLines.length} highlighted
                            </Text>
                        )}
                    </Box>
                 );
            }

            if (bodyView === REVIEW_BODY_VIEWS.CONFIRM_HANDOFF) {
                return (
                    <Box flexDirection="column" gap={1}>
                        <Text bold>HANDOFF TO EXTERNAL AGENT</Text>
                        <Box flexDirection="column">
                            <Text>This action will:</Text>
                            <Text>1. Copy a detailed prompt to your clipboard for an agentic AI.</Text>
                            <Text>2. Mark the current transaction as &apos;Handoff&apos; and close this review.</Text>
                            <Text>3. Assume that you and the external agent will complete the work.</Text>
                        </Box>
                        <Text>Relaycode will NOT wait for a new patch. This is a final action.</Text>
                        <Text bold color="yellow">Are you sure you want to proceed?</Text>
                    </Box>
                );
            }

            if (bodyView === REVIEW_BODY_VIEWS.BULK_REPAIR) {
                const failedFiles = files.filter((f: FileItem) => fileReviewStates.get(f.id)?.status === 'FAILED');

                return (
                    <Box flexDirection="column" gap={1}>
                        <Text bold>BULK REPAIR ACTION</Text>

                        <Box flexDirection="column">
                            <Text>The following {failedFiles.length} files failed to apply:</Text>
                            {failedFiles.map((file: FileItem) => (
                                <Text key={file.id}>- {file.path}</Text>
                            ))}
                        </Box>

                        <Text>How would you like to proceed?</Text>

                        <Box flexDirection="column">
                            {BULK_REPAIR_OPTIONS.map((opt, i) => (
                                <Text key={i} color={selectedBulkRepairOptionIndex === i ? 'cyan' : undefined}>
                                    {selectedBulkRepairOptionIndex === i ? '> ' : '  '}
                                    {opt}
                                </Text>
                            ))}
                        </Box>
                    </Box>
                );
            }

            if (bodyView === REVIEW_BODY_VIEWS.BULK_INSTRUCT) {
                const rejectedFiles = files.filter((f: FileItem) => fileReviewStates.get(f.id)?.status === 'REJECTED');

                return (
                    <Box flexDirection="column" gap={1}>
                        <Text bold>BULK INSTRUCTION ACTION</Text>

                        <Box flexDirection="column">
                            <Text>The following {rejectedFiles.length} files were rejected:</Text>
                            {rejectedFiles.map((file: FileItem) => (
                                <Text key={file.id}>- {file.path}</Text>
                            ))}
                        </Box>
                        <Box flexDirection="column" marginTop={1}>
                            {BULK_INSTRUCT_OPTIONS.map((opt, i) => (
                                <Text key={i} color={selectedBulkInstructOptionIndex === i ? 'cyan' : undefined}>
                                    {selectedBulkInstructOptionIndex === i ? '> ' : '  '}
                                    {opt}
                                </Text>
                            ))}
                        </Box>
                    </Box>
                );
            }

            return null;
        };

        const renderFooter = () => {
            // Contextual footer for body views
            if (bodyView === REVIEW_BODY_VIEWS.DIFF) return <ActionFooter actions={REVIEW_FOOTER_ACTIONS.DIFF_VIEW}/>;
            if (bodyView === REVIEW_BODY_VIEWS.REASONING) return <ActionFooter actions={REVIEW_FOOTER_ACTIONS.REASONING_VIEW}/>;
            if (bodyView === REVIEW_BODY_VIEWS.SCRIPT_OUTPUT) return <ActionFooter actions={REVIEW_FOOTER_ACTIONS.SCRIPT_OUTPUT_VIEW}/>;
            if (bodyView === REVIEW_BODY_VIEWS.BULK_REPAIR) return <Text>{REVIEW_FOOTER_ACTIONS.BULK_REPAIR_VIEW.text}</Text>;
            if (bodyView === REVIEW_BODY_VIEWS.BULK_INSTRUCT) return <Text>{REVIEW_FOOTER_ACTIONS.BULK_INSTRUCT_VIEW.text}</Text>;
            if (bodyView === REVIEW_BODY_VIEWS.CONFIRM_HANDOFF) return <ActionFooter actions={REVIEW_FOOTER_ACTIONS.HANDOFF_CONFIRM_VIEW}/>;

            // Dynamic Main footer
            const currentItem = navigableItems[selectedItemIndex];
            const hasFailedFiles = Array.from(fileReviewStates.values()).some(s => s.status === 'FAILED');
            const fileState = currentItem?.type === 'file' ? fileReviewStates.get(currentItem.id) : undefined;

            const footerConfig = {
                isFileSelected: currentItem?.type === 'file',
                fileStatus: fileState?.status as 'FAILED' | 'REJECTED' | 'OTHER' | undefined,
                currentItemType: currentItem?.type as 'file' | 'script' | 'reasoning' | 'prompt' | undefined,
                hasFailedFiles,
                hasRejectedFiles,
                hasApprovedFiles: approvedFilesCount > 0,
            };
            return <ActionFooter actions={REVIEW_FOOTER_ACTIONS.MAIN_VIEW(footerConfig)} />;
        };

        return (
            <Box flexDirection="column">
                {/* Header */}
                <Text bold color="black" backgroundColor="yellow"> ▲ relaycode · REVIEW </Text>
                <Separator />
                
                {/* Navigator Section */}
                <Box flexDirection="column" marginY={1}>
                    <Box flexDirection="column">
                        <Text>{hash} · {message}</Text>
                        <Box>
                            <Text>
                                (<Text color="green">+{totalLinesAdded}</Text>/<Text color="red">-{totalLinesRemoved}</Text>)
                                {' '}| {numFiles} Files · ({approvedFilesCount}/{numFiles} Appr)
                                {' '}| Showing {viewOffset + 1}-
                                {Math.min(viewOffset + navigableItemsInView.length, navigableItems.length)}{' '}
                                of {navigableItems.length}
                            </Text>
                            {patchStatus === 'PARTIAL_FAILURE' && scripts.length === 0 && (
                                <Text> · Scripts: SKIPPED</Text>
                            )}
                            {patchStatus === 'PARTIAL_FAILURE' && <Text color="red" bold> · MULTIPLE PATCHES FAILED</Text>}
                        </Box>
                    </Box>

                    <Box flexDirection="column" marginTop={1}>
                        <Text color={navigableItems[selectedItemIndex]?.type === 'prompt' ? 'cyan' : undefined}>
                            {navigableItems[selectedItemIndex]?.type === 'prompt' ? '> ' : '  '}
                            (P)rompt ▸ {(prompt || '').substring(0, 50)}...
                        </Text>
                        <Text color={navigableItems[selectedItemIndex]?.type === 'reasoning' ? 'cyan' : undefined}>
                            {navigableItems[selectedItemIndex]?.type === 'reasoning' ? '> ' : '  '}
                            (R)easoning ({(reasoning || '').split('\n\n').length} steps){' '}
                            {bodyView === REVIEW_BODY_VIEWS.REASONING ? '▾' : '▸'}{' '}
                            {((reasoning || '').split('\n')[0] ?? '').substring(0, 40)}...
                        </Text>
                    </Box>
                </Box>

                <Separator />

                {/* Script Results (if any) */}
                {scripts.length > 0 && navigableItemsInView.some(i => i.type === 'script') && (
                    <>
                        <Box flexDirection="column" marginY={1}>
                            {scripts.map((script: ScriptResult) => {
                                const itemInViewIndex = navigableItemsInView.findIndex(i => i.type === 'script' && i.id === script.command);
                                if (itemInViewIndex === -1) return null;
                                
                                const isSelected = selectedItemIndex === viewOffset + itemInViewIndex;
                                return (
                                    <ScriptItemRow key={script.command} script={script} isSelected={isSelected} isExpanded={bodyView === REVIEW_BODY_VIEWS.SCRIPT_OUTPUT && isSelected} />
                                );
                            })}
                        </Box>
                        <Separator />
                    </>
                )}
                
                {/* Files Section */}
                <Box flexDirection="column" marginY={1}>
                    <Text bold>FILES</Text>
                    {files.map((file: FileItem) => {
                        const itemInViewIndex = navigableItemsInView.findIndex(i => i.type === 'file' && i.id === file.id);
                        if (itemInViewIndex === -1) return null; // Only render if visible

                        const isFocused = selectedItemIndex === viewOffset + itemInViewIndex;
                        const reviewState = fileReviewStates.get(file.id);
                        
                        return (
                            <FileItemRow key={file.id} file={file} isFocused={isFocused} reviewState={reviewState || { status: 'AWAITING' }} />
                        );
                    })}
                </Box>
                
                <Separator />
                
                {/* Body Viewport */}
                {bodyView !== REVIEW_BODY_VIEWS.NONE && (
                    <>
                        <Box marginY={1}>
                            {renderBody()}
                        </Box>
                        <Separator />
                    </>
                )}

                {/* Footer */}
                <Box>
                    {renderFooter()}
                </Box>
            </Box>
        );
    };


    export default ReviewScreen;
  src/components/TransactionDetailScreen.tsx: >-
    import { Box, Text } from 'ink';

    import Separator from './Separator';

    import DiffScreen from './DiffScreen';

    import ReasonScreen from './ReasonScreen';

    import type { FileChangeType } from '../types/domain.types';

    import { useTransactionDetailScreen } from
    '../hooks/useTransactionDetailScreen';

    import { DETAIL_BODY_VIEWS, DETAIL_FOOTER_ACTIONS } from
    '../constants/detail.constants';

    import ActionFooter from './ActionFooter';

    import { FILE_CHANGE_ICONS } from '../constants/ui.constants';


    const RevertModal = ({ transactionHash }: { transactionHash: string }) => {
        return (
            <Box 
                borderStyle="round"
                borderColor="yellow"
                flexDirection="column"
                paddingX={2}
                width="80%"
                alignSelf='center'
            >
                <Text bold color="yellow" wrap="wrap" >REVERT THIS TRANSACTION?</Text>
                <Box height={1} />
                <Text wrap="wrap">This will create a NEW transaction that reverses all changes made by {transactionHash}. The original transaction record will be preserved.</Text>
                <Box height={1} />
                <Text wrap="wrap">Are you sure?</Text>
            </Box>
        );
    };


    const typeColor = (type: FileChangeType) => {
        switch (type) {
            case 'ADD': return 'green';
            case 'DEL': return 'red';
            case 'REN': return 'yellow';
            default: return 'white';
        }
    };


    const TransactionDetailScreen = () => {
        const {
            transaction, files,
            focusedItemPath, expandedItemPaths, bodyView, contentScrollIndex, availableBodyHeight,
        } = useTransactionDetailScreen();

        if (!transaction) {
            return <Text>Loading transaction...</Text>;
        }

        const renderNavigator = () => {
            const isPromptFocused = focusedItemPath === 'PROMPT';
            const isReasoningFocused = focusedItemPath === 'REASONING';
            const isFilesFocused = focusedItemPath.startsWith('FILES');
            
            const isPromptExpanded = expandedItemPaths.has('PROMPT');
            const isReasoningExpanded = expandedItemPaths.has('REASONING');
            const isFilesExpanded = expandedItemPaths.has('FILES');
            
            return (
                <Box flexDirection="column">
                    <Text color={isPromptFocused ? 'cyan' : undefined}>
                        {isPromptFocused ? '> ' : '  '}
                        {isPromptExpanded ? '▾' : '▸'} (<Text color="cyan" bold>P</Text>)rompt
                    </Text>
                    <Text color={isReasoningFocused ? 'cyan' : undefined}>
                        {isReasoningFocused ? '> ' : '  '}
                        {isReasoningExpanded ? '▾' : '▸'} (<Text color="cyan" bold>R</Text>)easoning{' '}
                        ({transaction.reasoning?.split('\n\n').length || 0} steps)
                    </Text>
                    <Text color={isFilesFocused ? 'cyan' : undefined}>
                        {isFilesFocused && !focusedItemPath.includes('/') ? '> ' : '  '}
                        {isFilesExpanded ? '▾' : '▸'} (<Text color="cyan" bold>F</Text>)iles ({files.length})
                    </Text>
                    {isFilesExpanded && (
                        <Box flexDirection="column" paddingLeft={2}>
                            {files.map((file) => {
                                 const fileId = `FILES/${file.id}`;
                                 const isFileSelected = focusedItemPath === fileId;
                                 const stats = file.type === 'DEL' ? ''
                                    : ` (+${file.linesAdded}/-${file.linesRemoved})`;
                                 return (
                                    <Text key={file.id} color={isFileSelected ? 'cyan' : undefined}>
                                        {isFileSelected ? '> ' : '  '}
                                        {FILE_CHANGE_ICONS[file.type]} <Text color={typeColor(file.type)}>{file.path}</Text>{stats}
                                    </Text>
                                );
                            })}
                        </Box>
                    )}
                </Box>
            );
        };

        const renderBody = () => {
            if (bodyView === DETAIL_BODY_VIEWS.NONE) {
                return <Text color="gray">(Press → to expand a section and view its contents)</Text>;
            }
            if (bodyView === DETAIL_BODY_VIEWS.PROMPT) {
                return (
                    <Box flexDirection="column">
                        <Text>PROMPT</Text>
                        <Box marginTop={1} flexDirection="column">
                            {(transaction.prompt || '').split('\n')
                                .slice(contentScrollIndex, contentScrollIndex + availableBodyHeight)
                                .map((line, i) => <Text key={i}>{line}</Text>)
                            }
                        </Box>
                    </Box>
                );
            }
            if (bodyView === DETAIL_BODY_VIEWS.REASONING) {
                if (!transaction.reasoning) return <Text color="gray">No reasoning provided.</Text>;
                return <ReasonScreen reasoning={transaction.reasoning} scrollIndex={contentScrollIndex} visibleLinesCount={Math.max(1, availableBodyHeight)} />;
            }
            if (bodyView === DETAIL_BODY_VIEWS.FILES_LIST) {
                 return <Text color="gray">(Select a file and press → to view the diff)</Text>;
            }
            if (bodyView === DETAIL_BODY_VIEWS.DIFF_VIEW) {
                const fileId = focusedItemPath.split('/')[1];
                const file = files.find(f => f.id === fileId);
                if (!file) return null;
                return <DiffScreen filePath={file.path} diffContent={file.diff} isExpanded={true} scrollIndex={contentScrollIndex} maxHeight={Math.max(1, availableBodyHeight)} />;
            }
            return null;
        };

        const renderFooter = () => {
            if (bodyView === DETAIL_BODY_VIEWS.REVERT_CONFIRM) {
                return <ActionFooter actions={DETAIL_FOOTER_ACTIONS.REVERT_CONFIRM} />;
            }
            
            const isFileFocused = focusedItemPath.includes('/');
            const openActionLabel = isFileFocused ? 'Open File' : 'Open YAML';
            const isRevertable = ['APPLIED', 'FAILED'].includes(transaction.status);
            const baseActions = DETAIL_FOOTER_ACTIONS.BASE({
                openActionLabel,
                isRevertable,
            });

            if (isFileFocused) { // Is a file
                if (bodyView === DETAIL_BODY_VIEWS.DIFF_VIEW) {
                    return <ActionFooter actions={[...DETAIL_FOOTER_ACTIONS.DIFF_VIEW, ...baseActions]} />;
                } else {
                    return <ActionFooter actions={[...DETAIL_FOOTER_ACTIONS.FILE_LIST_VIEW, ...baseActions]} />;
                }
            }
            
            if (expandedItemPaths.has(focusedItemPath)) {
                return <ActionFooter actions={[...DETAIL_FOOTER_ACTIONS.SECTION_EXPANDED, ...baseActions]} />;
            }
            return <ActionFooter actions={[...DETAIL_FOOTER_ACTIONS.SECTION_COLLAPSED, ...baseActions]} />;
        };

        const { message, timestamp, status } = transaction;
        const date = new Date(timestamp).toISOString().replace('T', ' ').substring(0, 19);
        const fileStats = `${files.length} Files · +${files.reduce((a, f) => a + f.linesAdded, 0)} lines, -${files.reduce((a, f) => a + f.linesRemoved, 0)} lines`;

        return (
            <Box flexDirection="column">
                {/* Header */}
                <Text bold color="black" backgroundColor="yellow"> ▲ relaycode · TRANSACTION DETAILS </Text>
                <Separator />
                
                {/* Modal takeover for Revert */}
                {bodyView === DETAIL_BODY_VIEWS.REVERT_CONFIRM && <RevertModal transactionHash={transaction.hash} />}
                
                {/* Main view */}
                <Box flexDirection="column" display={bodyView === DETAIL_BODY_VIEWS.REVERT_CONFIRM ? 'none' : 'flex'}>
                    {/* Navigator Part A */}
                    <Box flexDirection="column" marginY={1}>
                        <Text><Text color="gray">UUID:</Text> {transaction.id}</Text>
                        <Text><Text color="gray">Git:</Text> {message}</Text>
                        <Text><Text color="gray">Date:</Text> {date} · <Text color="gray">Status:</Text> {status}</Text>
                        <Text><Text color="gray">Stats:</Text> {fileStats}</Text>
                    </Box>
                    
                    {/* Navigator Part B */}
                    {renderNavigator()}
                    
                    <Separator />
                    
                    {/* Body */}
                    <Box marginY={1}>
                        {renderBody()}
                    </Box>
                    
                    <Separator />
                </Box>
                
                {/* Footer */}
                <Box>
                    {renderFooter()}
                </Box>
            </Box>
        );
    };


    export default TransactionDetailScreen;
  src/components/DashboardScreen.tsx: "import React, { useState, useEffect, useRef } from 'react';\nimport { Box, Text } from 'ink';\nimport Spinner from 'ink-spinner';\nimport Separator from './Separator';\nimport type { Transaction, TransactionStatus } from '../types/domain.types';\nimport { useDashboardScreen } from '../hooks/useDashboardScreen';\nimport { UI_CONFIG } from '../config/ui.config'; //\nimport ActionFooter from './ActionFooter';\nimport { DASHBOARD_FOOTER_ACTIONS, DASHBOARD_STATUS } from '../constants/dashboard.constants';\nimport { TRANSACTION_STATUS_UI, FILE_CHANGE_ICONS } from '../constants/ui.constants';\n\n// --- Sub-components & Helpers ---\n\nconst getStatusIcon = (status: TransactionStatus) => {\n    if (status === 'IN-PROGRESS' || status === 'COMMITTING') return <Spinner type=\"dots\" />;\n    const ui = TRANSACTION_STATUS_UI[status as keyof typeof TRANSACTION_STATUS_UI];\n    if (!ui) return <Text> </Text>;\n    return <Text color={ui.color}>{ui.text.split(' ')[0]}</Text>;\n};\n\nconst formatTimeAgo = (timestamp: number) => {\n    const seconds = Math.max(0, Math.floor((Date.now() - timestamp) / 1000));\n    if (seconds < 60) return `${seconds}s`;\n    const minutes = Math.floor(seconds / 60);\n    return `${minutes}m`;\n};\n\nconst ExpandedEventInfo = ({ transaction }: { transaction: Transaction }) => {\n    const stats = transaction.stats;\n    const files = transaction.files || [];\n\n    return (\n        <Box flexDirection=\"column\" paddingLeft={4} marginBottom={1} borderStyle=\"round\" borderLeft={true} borderTop={false} borderRight={false} borderBottom={false} borderColor=\"gray\">\n            {stats && (\n                <Text color=\"gray\">\n                    Stats: {stats.files} files, +{stats.linesAdded}/-{stats.linesRemoved}\n                </Text>\n            )}\n             <Box flexDirection=\"column\" paddingLeft={1}>\n                {files.map(file => (\n                     <Text key={file.id}>\n                        <Text color=\"gray\">{FILE_TYPE_MAP[file.type]}</Text> {file.path}\n                    </Text>\n                ))}\n             </Box>\n        </Box>\n    );\n};\n                        <Text color=\"gray\">{FILE_CHANGE_ICONS[file.type]}</Text> {file.path}\nconst EventStreamItem = React.memo(({ transaction, isSelected, isExpanded, isNew }: { transaction: Transaction, isSelected: boolean, isExpanded: boolean, isNew: boolean }) => {\n    const [isAnimatingIn, setIsAnimatingIn] = useState(isNew);\n    const [isStatusFlashing, setIsStatusFlashing] = useState(false);\n    const prevStatus = useRef(transaction.status);\n\n    useEffect(() => {\n        if (isNew) {\n            const timer = setTimeout(() => setIsAnimatingIn(false), 1000);\n            return () => clearTimeout(timer);\n        }\n    }, [isNew]);\n\n    useEffect(() => {\n        if (prevStatus.current !== transaction.status) {\n            setIsStatusFlashing(true);\n            const timer = setTimeout(() => setIsStatusFlashing(false), 500);\n            prevStatus.current = transaction.status;\n            return () => clearTimeout(timer);\n        }\n    }, [transaction.status]);\n\n    const icon = getStatusIcon(transaction.status);\n    const time = formatTimeAgo(transaction.timestamp).padEnd(5, ' ');\n    const statusText = transaction.status.padEnd(11, ' ');\n    const expandIcon = isExpanded ? '▾' : '▸';\n    \n    const messageNode =\n        transaction.status === 'IN-PROGRESS' || transaction.status === 'COMMITTING'\n            ? <Text color={isAnimatingIn ? 'yellow' : 'cyan'}>{transaction.message}</Text>\n            : transaction.message;\n    \n    const content = (\n        <Text>\n            {time} {expandIcon} <Text color={isStatusFlashing ? 'yellow' : undefined} bold={isStatusFlashing}>{icon} {statusText}</Text>{' '}\n            <Text color=\"gray\">{transaction.hash}</Text>\n            {' '}· {messageNode}\n        </Text>\n    );\n\n    if (isSelected) {\n        return <Text bold color={isAnimatingIn ? 'yellow' : 'cyan'}>{'> '}{content}</Text>;\n    }\n\n    return <Text color={isAnimatingIn ? 'yellow' : undefined}>{'  '}{content}</Text>;\n});\n\nconst ConfirmationContent = ({\n    transactionsToConfirm,\n}: {\n    transactionsToConfirm: Transaction[];\n}) => {\n    const actionText = 'APPROVE';\n    \n    return (\n        <Box flexDirection=\"column\" marginY={1} paddingLeft={2}>\n            <Text bold color=\"yellow\">{actionText} ALL PENDING TRANSACTIONS?</Text>\n            <Text>\n                The following {transactionsToConfirm.length} transaction(s) will be approved:\n            </Text>\n            <Box flexDirection=\"column\" paddingLeft={1} marginTop={1}>\n                {transactionsToConfirm.map(tx => (\n                    <Text key={tx.id}>- {tx.hash}: {tx.message}</Text>\n                ))}\n            </Box>\n        </Box>\n    );\n};\n\n// --- Main Component ---\n\nconst DashboardScreen = () => {\n    const {\n        status,\n        transactions,\n        selectedTransactionIndex,\n        pendingApprovals,\n        pendingCommits,\n        isModal,\n        isProcessing,\n        viewOffset,\n        viewportHeight,\n        transactionsToConfirm,\n        expandedTransactionId,\n        newTransactionIds,\n    } = useDashboardScreen({\n        layoutConfig: UI_CONFIG.layout.dashboard,\n    });\n\n    const renderStatusBar = () => {\n        let statusText: string;\n        let statusIcon: React.ReactNode;\n        switch (status) {\n            case DASHBOARD_STATUS.LISTENING: statusText = 'LISTENING'; statusIcon = <Text color=\"green\">●</Text>; break;\n            case DASHBOARD_STATUS.PAUSED: statusText = 'PAUSED'; statusIcon = <Text color=\"yellow\">||</Text>; break;\n            case DASHBOARD_STATUS.APPROVING: statusText = 'APPROVING...'; statusIcon = <Text color=\"cyan\"><Spinner type=\"dots\"/></Text>; break;\n            default: statusText = 'LISTENING'; statusIcon = <Text color=\"green\">●</Text>; //\n        }\n\n        let approvalStr: React.ReactNode = String(pendingApprovals).padStart(2, '0');\n        const commitStr: React.ReactNode = String(pendingCommits).padStart(2, '0');\n\n        if (status === DASHBOARD_STATUS.APPROVING) approvalStr = <Text color=\"cyan\">(<Spinner type=\"dots\"/>)</Text>;\n        if (status === DASHBOARD_STATUS.CONFIRM_APPROVE) {\n            approvalStr = <Text bold color=\"yellow\">┌ {approvalStr} ┐</Text>;\n        }\n        \n        return (\n            <Text>\n                STATUS: {statusIcon} {statusText} · APPROVALS: {approvalStr} · COMMITS: {commitStr}\n            </Text>\n        );\n    };\n\n    const renderFooter = () => {\n        if (isModal) return (\n            <ActionFooter actions={DASHBOARD_FOOTER_ACTIONS.MODAL}/>\n        );\n        if (isProcessing) return <Text>Processing... This may take a moment.</Text>;\n\n\t\treturn <ActionFooter actions={DASHBOARD_FOOTER_ACTIONS.STANDARD({\n            status,\n            hasPending: pendingApprovals > 0,\n            hasApplied: pendingCommits > 0,\n        })} />;\n    };\n    \n    return (\n        <Box flexDirection=\"column\" height=\"100%\">\n            <Text color=\"cyan\">▲ relaycode dashboard</Text>\n            <Separator />\n            <Box marginY={1}>\n                {renderStatusBar()}\n            </Box>\n            \n            {isModal && (\n                <>\n                    <ConfirmationContent transactionsToConfirm={transactionsToConfirm} />\n                    <Separator />\n                </>\n            )}\n            \n            <Text bold underline> EVENT STREAM (Last 15 minutes)</Text>\n            <Box flexDirection=\"column\" marginTop={1}>\n                {transactions.length === 0 && (\n                     <Box paddingLeft={2}><Text color=\"gray\">Listening for changes... no events yet.</Text></Box>\n                )}\n                {transactions.slice(viewOffset, viewOffset + viewportHeight).map((tx, index) => {\n                    const actualIndex = viewOffset + index;\n                    const isExpanded = expandedTransactionId === tx.id;\n                    const isNew = newTransactionIds.has(tx.id);\n                    return (\n                        <React.Fragment key={tx.id}>\n                            <EventStreamItem\n                                transaction={tx}\n                                isSelected={!isModal && actualIndex === selectedTransactionIndex}\n                                isExpanded={isExpanded}\n                                isNew={isNew}\n                            />\n                            {isExpanded && <ExpandedEventInfo transaction={tx} />}\n                        </React.Fragment>\n                    );\n                })}\n            </Box>\n\n            <Box marginTop={1}><Separator /></Box>\n            {renderFooter()}\n        </Box>\n    );\n};\n\nexport default DashboardScreen;"
  src/stores/copy.store.ts: |-
    import { create } from 'zustand';
    import { moveIndex } from './navigation.utils';
    import { useViewStore } from './view.store';
    import { useNotificationStore } from './notification.store';
    import { LoggerService } from '../services/logger.service';
    import { CopyService } from '../services/copy.service';
    import type { CopyItem } from '../types/copy.types';
    import type { Transaction, FileItem } from '../types/domain.types';

    export type { CopyItem };

    interface CopyState {
        title: string;
        items: CopyItem[];
        selectedIndex: number;
        selectedIds: Set<string>;
        lastCopiedMessage: string | null;
        onClose?: () => void;

        actions: {
            open: (title: string, items: CopyItem[], onClose?: () => void) => void;
            close: () => void;
            openForReview: (transaction: Transaction, files: FileItem[], selectedFile?: FileItem) => void;
            openForDetail: (transaction: Transaction, selectedFile?: FileItem) => void;
            openForHistory: (transactions: Transaction[]) => void;
            setSelectedIndex: (index: number) => void;
            toggleSelection: () => void;
            toggleSelectionById: (id: string) => void;
            executeCopy: () => void;
        };
    }

    export const useCopyStore = create<CopyState>((set, get) => ({
        title: '',
        items: [],
        selectedIndex: 0,
        selectedIds: new Set(),
        lastCopiedMessage: null,
        onClose: undefined,

        actions: {
            open: (title, items, onClose) => {
                const defaultSelectedIds = new Set(items.filter(i => i.isDefaultSelected).map(i => i.id));
                useViewStore.getState().actions.setActiveOverlay('copy');
                set({
                    title,
                    items,
                    selectedIndex: 0,
                    selectedIds: defaultSelectedIds,
                    lastCopiedMessage: null,
                    onClose,
                });
            },
            close: () => {
                useViewStore.getState().actions.setActiveOverlay('none');
                get().onClose?.();
                set({ items: [], onClose: undefined });
            },
            openForReview: (transaction, files, selectedFile) => {
                const { actions } = get();
                const title = 'Select data to copy from review:';
                const items = CopyService.getCopyItemsForReview(transaction, files, selectedFile);
                actions.open(title, items);
            },
            openForDetail: (transaction, selectedFile) => {
                const { actions } = get();
                const title = `Select data to copy from transaction ${transaction.hash}:`;
                const items = CopyService.getCopyItemsForDetail(transaction, selectedFile);
                actions.open(title, items);
            },
            openForHistory: (transactions) => {
                const { actions } = get();
                const title = `Select data to copy from ${transactions.length} transactions:`;
                const items = CopyService.getCopyItemsForHistory(transactions);
                actions.open(title, items);
            },
            setSelectedIndex: (index) => set(state => ({
                selectedIndex: Math.max(0, Math.min(state.items.length - 1, index)),
            })),
            toggleSelection: () => set(state => {
                const currentItem = state.items[state.selectedIndex];
                if (!currentItem) return {};
                const newSelectedIds = new Set(state.selectedIds);
                if (newSelectedIds.has(currentItem.id)) {
                    newSelectedIds.delete(currentItem.id);
                } else {
                    newSelectedIds.add(currentItem.id);
                }
                return { selectedIds: newSelectedIds };
            }),
            toggleSelectionById: (id: string) => set(state => {
                const newSelectedIds = new Set(state.selectedIds);
                if (newSelectedIds.has(id)) {
                    newSelectedIds.delete(id);
                } else {
                    newSelectedIds.add(id);
                }
                return { selectedIds: newSelectedIds };
            }),
            executeCopy: async () => {
                const { items, selectedIds } = get();
                const itemsToCopy = items.filter(i => selectedIds.has(i.id));
                if (itemsToCopy.length === 0) return;

                LoggerService.info(`Copying ${itemsToCopy.length} item(s) to clipboard.`);
                const dataPromises = itemsToCopy.map(item => item.getData());
                const resolvedData = await Promise.all(dataPromises);

                const content = itemsToCopy
                    .map((item, index) => `--- ${item.label} ---\n${resolvedData[index]}`)
                    .join('\n\n');
                const message = `Copied ${itemsToCopy.length} item(s) to clipboard.`;
                LoggerService.debug(`[CLIPBOARD MOCK] ${message}\n${content.substring(0, 200)}...`);
                useNotificationStore.getState().actions.show({
                    type: 'success',
                    title: 'Copied to Clipboard',
                    message,
                });
                set({ lastCopiedMessage: message });
            },
        },
    }));
  src/hooks/useCopyScreen.tsx: |-
    import { useCopyStore } from '../stores/copy.store';
    import { useViewStore } from '../stores/view.store';
    import { useViewport } from './useViewport';
    import { UI_CONFIG } from '../config/ui.config';
    import { OVERLAYS } from '../constants/view.constants';
    import { useListNavigator } from './useListNavigator';

    export const useCopyScreen = () => {
        const {
            title, items, selectedIndex, selectedIds, lastCopiedMessage,
            actions,
        } = useCopyStore(state => ({ ...state, actions: state.actions }));
        
        const { viewOffset, viewportHeight } = useViewport({
            selectedIndex,
            itemCount: items.length,
            layoutConfig: UI_CONFIG.layout.copyScreen,
        });

        useListNavigator({
            itemCount: items.length,
            viewportHeight,
            selectedIndex,
            onIndexChange: actions.setSelectedIndex,
            isActive: useViewStore.getState().activeOverlay === OVERLAYS.COPY,
            onKey: (input, key) => {
                if (key.escape) {
                    actions.close();
                    return;
                }
                if (input === ' ') {
                    actions.toggleSelection();
                    return;
                }
                if (key.return) {
                    actions.executeCopy();
                    return;
                }
                const item = items.find(i => i.key.toLowerCase() === input.toLowerCase());
                if (item) {
                    actions.toggleSelectionById(item.id);
                }
            },
        });

        const itemsInView = items.slice(viewOffset, viewOffset + viewportHeight);

        return {
            title,
            itemsInView,
            selectedIndex,
            selectedIds,
            lastCopiedMessage,
            viewOffset,
        };
    };
  src/stores/dashboard.store.ts: >-
    import { create } from 'zustand';

    import { useTransactionStore } from './transaction.store';

    import { DashboardService } from '../services/dashboard.service';

    import { DASHBOARD_STATUS } from '../constants/dashboard.constants';

    import { moveIndex } from './navigation.utils';


    export type DashboardStatus = (typeof DASHBOARD_STATUS)[keyof typeof
    DASHBOARD_STATUS];
     
    interface DashboardState {
        status: DashboardStatus;
        previousStatus: DashboardStatus;
        selectedTransactionIndex: number;
        expandedTransactionId: string | null;
        actions: {
            togglePause: () => void;
            moveSelectionUp: () => void;
            moveSelectionDown: () => void;
            startApproveAll: () => void;
            confirmAction: () => Promise<void>;
            cancelAction: () => void;
            setStatus: (status: DashboardStatus) => void;
            toggleExpand: () => void;
            setExpandedTransactionId: (id: string | null) => void;
            setSelectedIndex: (index: number) => void;
        };
    }


    export const useDashboardStore = create<DashboardState>((set, get) => ({
        status: DASHBOARD_STATUS.LISTENING,
        previousStatus: DASHBOARD_STATUS.LISTENING,
        selectedTransactionIndex: 0,
        expandedTransactionId: null,
        actions: {
            togglePause: () => set(state => ({
                status: state.status === DASHBOARD_STATUS.LISTENING ? DASHBOARD_STATUS.PAUSED : DASHBOARD_STATUS.LISTENING,
            })),
            moveSelectionUp: () => set(state => {
                const { transactions } = useTransactionStore.getState();
                return {
                    selectedTransactionIndex: moveIndex(state.selectedTransactionIndex, 'up', transactions.length),
                    expandedTransactionId: null,
                };
            }),
            moveSelectionDown: () => set(state => {
                const { transactions } = useTransactionStore.getState();
                return {
                    selectedTransactionIndex: moveIndex(state.selectedTransactionIndex, 'down', transactions.length),
                    expandedTransactionId: null,
                };
            }),
            startApproveAll: () => set(state => ({
                status: DASHBOARD_STATUS.CONFIRM_APPROVE,
                previousStatus: state.status,
            })),
            cancelAction: () => set(state => ({ status: state.previousStatus })),
            setStatus: (status) => set({ status }),
            confirmAction: async () => { // The `if` is redundant as this is only called from that state.
                const previousStatus = get().previousStatus;
                set({ status: DASHBOARD_STATUS.APPROVING });
                await DashboardService.approveAll();
                set({ status: previousStatus });
            },
            toggleExpand: () => {
                const { selectedTransactionIndex, expandedTransactionId } = get();
                const { transactions } = useTransactionStore.getState();
                const selectedTx = transactions[selectedTransactionIndex];
                if (!selectedTx) return;

                if (expandedTransactionId === selectedTx.id) {
                    set({ expandedTransactionId: null });
                } else {
                    set({ expandedTransactionId: selectedTx.id });
                }
            },
            setExpandedTransactionId: (id) => set({ expandedTransactionId: id }),
            setSelectedIndex: (index) => set({ selectedTransactionIndex: index }),
        },
    }));
  src/hooks/useDashboardScreen.tsx: >-
    import { useState, useEffect, useRef } from 'react';

    import { useInput } from 'ink';

    import { useDashboardStore } from '../stores/dashboard.store';

    import { useAppStore } from '../stores/app.store';

    import { useCommitStore } from '../stores/commit.store';

    import { useTransactionStore, selectTransactionsByStatus } from
    '../stores/transaction.store';

    import { useReviewStore } from '../stores/review.store';

    import { useDetailStore } from '../stores/detail.store';

    import { useHistoryStore } from '../stores/history.store';

    import type { LayoutConfig } from './useLayout';

    import { DASHBOARD_STATUS } from '../constants/dashboard.constants';

    import { useViewport } from './useViewport';


    export const useDashboardScreen = ({ layoutConfig }: { layoutConfig:
    LayoutConfig }) => {
        const {
            status,
            selectedTransactionIndex,
            expandedTransactionId,
        } = useDashboardStore();
        const transactions = useTransactionStore(s => s.transactions);
        const [newTransactionIds, setNewTransactionIds] = useState(new Set<string>());
        const prevTransactionIds = useRef(new Set(transactions.map(t => t.id)));

        const pendingTransactions = useTransactionStore(selectTransactionsByStatus('PENDING'));
        const appliedTransactions = useTransactionStore(selectTransactionsByStatus('APPLIED'));

        const { viewOffset, viewportHeight } = useViewport({
            selectedIndex: selectedTransactionIndex,
            itemCount: transactions.length,
            layoutConfig,
        });

        useEffect(() => {
            const currentIds = new Set(transactions.map(t => t.id));
            const newIds = new Set<string>();

            for (const id of currentIds) {
                if (!prevTransactionIds.current.has(id)) {
                    newIds.add(id);
                }
            }

            if (newIds.size > 0) {
                setNewTransactionIds(current => new Set([...current, ...newIds]));
                newIds.forEach(id => {
                    setTimeout(() => {
                        setNewTransactionIds(current => {
                            const next = new Set(current);
                            next.delete(id);
                            return next;
                        });
                    }, 1000);
                });
            }

            prevTransactionIds.current = currentIds;
        }, [transactions]);

        const {
            togglePause,
            moveSelectionUp,
            moveSelectionDown,
            startApproveAll,
            confirmAction,
            cancelAction,
            toggleExpand,
        } = useDashboardStore(s => s.actions);
        const appActions = useAppStore(s => s.actions);
        const commitActions = useCommitStore(s => s.actions);

        const pendingApprovals = pendingTransactions.length;
        const pendingCommits = appliedTransactions.length;

        const isModal = status === DASHBOARD_STATUS.CONFIRM_APPROVE;
        const isProcessing = status === DASHBOARD_STATUS.APPROVING;

        useInput((input, key) => {
            if (isModal) {
                if (key.return) confirmAction();
                if (key.escape) cancelAction();
                return;
            }

            if (isProcessing) return; // No input while processing

            if (key.leftArrow) {
                if (expandedTransactionId) {
                    toggleExpand();
                }
                return;
            }
            if (key.rightArrow) {
                if (transactions[selectedTransactionIndex] && !expandedTransactionId) {
                    toggleExpand();
                }
                return;
            }

            if (key.upArrow) moveSelectionUp();
            if (key.downArrow) moveSelectionDown();
            
            if (key.return) {
                const selectedTx = transactions[selectedTransactionIndex];
                if (!selectedTx) return;
                
                const isExpanded = expandedTransactionId === selectedTx.id;

                if (isExpanded) {
                    if (selectedTx.status === 'PENDING') {
                        useReviewStore.getState().actions.load(selectedTx.id);
                        appActions.showReviewScreen();
                    } else {
                        useDetailStore.getState().actions.load(selectedTx.id);
                        appActions.showTransactionDetailScreen();
                    }
                } else {
                    toggleExpand();
                }
            }
            
            if (input.toLowerCase() === 'p') togglePause();
            if (input.toLowerCase() === 'a' && pendingApprovals > 0) startApproveAll();
            if (input.toLowerCase() === 'c' && pendingCommits > 0) {
                commitActions.prepareCommitScreen();
                appActions.showGitCommitScreen();
            }
            if (input.toLowerCase() === 'l') {
                useHistoryStore.getState().actions.load();
                appActions.showTransactionHistoryScreen();
            }
        });
        const transactionsToConfirm = status === DASHBOARD_STATUS.CONFIRM_APPROVE ? pendingTransactions : [];

        return {
            status,
            transactions,
            selectedTransactionIndex,
            expandedTransactionId,
            pendingApprovals,
            pendingCommits,
            isModal,
            isProcessing,
            newTransactionIds,
            viewOffset,
            viewportHeight,
            transactionsToConfirm,
        };
    };
  src/stores/review.store.ts: >-
    import { create } from 'zustand';

    import { useAppStore } from './app.store';

    import { useTransactionStore } from './transaction.store';

    import { useViewStore } from './view.store';

    import { ReviewService, type SimulationResult } from
    '../services/review.service';

    import { INITIAL_APPLY_STEPS, PATCH_STATUS, REVIEW_BODY_VIEWS } from
    '../constants/review.constants';

    import { moveIndex } from './navigation.utils';

    import { sleep } from '../utils';

    import type { FileReviewStatus } from '../types/domain.types';


    export interface ApplyStep {
        id: string;
        title: string;
        status: 'pending' | 'active' | 'done' | 'failed' | 'skipped';
        details?: string;
        substeps?: ApplyStep[];
        startTime?: number;
        duration?: number;
    }


    export type ReviewBodyView = (typeof REVIEW_BODY_VIEWS)[keyof typeof
    REVIEW_BODY_VIEWS];

    export type PatchStatus = (typeof PATCH_STATUS)[keyof typeof PATCH_STATUS];

    export type ApplyUpdate =
        | { type: 'UPDATE_STEP'; payload: { id: string; status: ApplyStep['status']; duration?: number; details?: string } }
        | { type: 'ADD_SUBSTEP'; payload: { parentId: string; substep: Omit<ApplyStep, 'substeps'> } }
        | { type: 'UPDATE_SUBSTEP'; payload: { parentId: string; substepId: string; status: ApplyStep['status']; title?: string } };

    interface ReviewState {
        patchStatus: PatchStatus;
        applySteps: ApplyStep[];
        selectedItemIndex: number;
        bodyView: ReviewBodyView;
        isDiffExpanded: boolean;
        reasoningScrollIndex: number;
        scriptErrorIndex: number;
        processingStartTime: number | null;
        fileReviewStates: Map<string, { status: FileReviewStatus; error?: string; details?: string }>;

        selectedBulkRepairOptionIndex: number;
        selectedBulkInstructOptionIndex: number;
        isCancelling: boolean;
        isSkipping: boolean;

        actions: {
            load: (transactionId: string, initialState?: Partial<Pick<ReviewState, 'bodyView' | 'selectedBulkRepairOptionIndex'>>) => void;
            moveSelectionUp: (listSize: number) => void;
            moveSelectionDown: (listSize: number) => void;
            setSelectedItemIndex: (index: number) => void;
            expandDiff: () => void;
            toggleBodyView: (view: Extract<
                ReviewBodyView, 'bulk_instruct' |
                'diff' | 'reasoning' | 'script_output' | 'bulk_repair' | 'confirm_handoff'
            >) => void;
            setBodyView: (view: ReviewBodyView) => void;
            approve: () => void;
            startApplySimulation: (transactionId: string, scenario: 'success' | 'failure') => void;
            tryRepairFile: (fileId: string) => void;
            showBulkRepair: () => void;
            executeBulkRepairOption: (option: number) => Promise<void>;
            skipCurrentStep: () => void;
            resetSkip: () => void;
            tryInstruct: (fileId: string) => void;
            cancelProcessing: () => void;
            showBulkInstruct: () => void;
            executeBulkInstructOption: (option: number) => Promise<void>;
            confirmHandoff: () => void;
            scrollReasoningUp: () => void;
            scrollReasoningDown: () => void;
            navigateScriptErrorUp: () => void;
            navigateScriptErrorDown: () => void;
            updateApplyStep: (id: string, status: ApplyStep['status'], details?: string) => void;
            addApplySubstep: (parentId: string, substep: Omit<ApplyStep, 'substeps'>) => void;
            updateApplySubstep: (parentId: string, substepId: string, status: ApplyStep['status'], title?: string) => void;
            updateFileReviewStatus: (fileId: string, status: FileReviewStatus, error?: string, details?: string) => void;
            toggleFileApproval: (fileId: string) => void;
            rejectAllFiles: () => void;
            navigateBulkRepairUp: () => void;
            navigateBulkRepairDown: () => void;
            navigateBulkInstructUp: () => void;
            navigateBulkInstructDown: () => void;
        };
    }


    export const useReviewStore = create<ReviewState>((set, get) => ({
        patchStatus: PATCH_STATUS.SUCCESS,
        applySteps: INITIAL_APPLY_STEPS,
        selectedItemIndex: 0,
        bodyView: REVIEW_BODY_VIEWS.NONE,
        isDiffExpanded: false,
        reasoningScrollIndex: 0,
        scriptErrorIndex: 0,
        processingStartTime: null,
        fileReviewStates: new Map(),
        selectedBulkRepairOptionIndex: 0,
        selectedBulkInstructOptionIndex: 0,
        isCancelling: false,
        isSkipping: false,

        actions: {
            load: (transactionId, initialState) => {
                const transaction = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!transaction) return;

                // This logic is preserved from the deleted `prepareTransactionForReview`
                // to allow debug screens to jump directly to a pre-populated review state
                // without running the full simulation.
                const isFailureCase = transaction.id === '1';
                const fileReviewStates = new Map<string, { status: FileReviewStatus; error?: string }>();
                (transaction.files || []).forEach((file, index) => {
                    if (isFailureCase) {
                        const isFailedFile = index > 0;
                        const status = isFailedFile ? 'FAILED' : 'APPROVED';
                        const error = isFailedFile ? (index === 1 ? 'Hunk #1 failed to apply' : 'Context mismatch at line 92') : undefined;
                        fileReviewStates.set(file.id, { status, error });
                    } else {
                        fileReviewStates.set(file.id, { status: 'APPROVED' });
                    }
                });
                const patchStatus = isFailureCase ? 'PARTIAL_FAILURE' : 'SUCCESS';
                useViewStore.getState().actions.setSelectedTransactionId(transaction.id);
                set({
                    patchStatus,
                    fileReviewStates,
                    processingStartTime: null,
                    selectedItemIndex: 0,
                    bodyView: initialState?.bodyView ?? REVIEW_BODY_VIEWS.NONE,
                    isDiffExpanded: false,
                    reasoningScrollIndex: 0,
                    scriptErrorIndex: 0,
                    applySteps: JSON.parse(JSON.stringify(INITIAL_APPLY_STEPS)),
                    selectedBulkRepairOptionIndex: 0,
                    selectedBulkInstructOptionIndex: 0,
                    ...initialState,
                });
            },
            moveSelectionUp: (listSize) => set(state => {
                return { selectedItemIndex: moveIndex(state.selectedItemIndex, 'up', listSize) };
            }),
            moveSelectionDown: (listSize) => set(state => {
                return { selectedItemIndex: moveIndex(state.selectedItemIndex, 'down', listSize) };
            }),
            setSelectedItemIndex: (index) => set({ selectedItemIndex: index }),
            toggleBodyView: (view) => set(state => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                const files = tx?.files || [];
                if (view === 'diff' && state.selectedItemIndex >= files.length) return {};
                return {
                    bodyView: state.bodyView === view ? REVIEW_BODY_VIEWS.NONE : view,
                    isDiffExpanded: false,
                };
            }),
            setBodyView: (view) => set({ bodyView: view }),
            expandDiff: () => set(state => ({ isDiffExpanded: !state.isDiffExpanded })),
            approve: () => {
                const { selectedTransactionId } = useViewStore.getState();
                if (selectedTransactionId) {
                    useTransactionStore.getState().actions.updateTransactionStatus(selectedTransactionId, 'APPLIED');
                    useAppStore.getState().actions.showDashboardScreen();
                }
            },
            startApplySimulation: async (transactionId, scenario) => {
                const transaction = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!transaction?.files) return;

                const { showReviewProcessingScreen, showReviewScreen } = useAppStore.getState().actions;
                const { updateApplyStep, addApplySubstep, updateApplySubstep } = get().actions;

                useViewStore.getState().actions.setSelectedTransactionId(transaction.id);
                set({
                    applySteps: JSON.parse(JSON.stringify(INITIAL_APPLY_STEPS)),
                    processingStartTime: Date.now(),
                    isCancelling: false,
                    isSkipping: false,
                    fileReviewStates: new Map(), // Clear previous states
                });

                showReviewProcessingScreen();
                const simulationGenerator = ReviewService.runApplySimulation(transaction.files, scenario);
                let simulationResult: SimulationResult;

                // Manually iterate to get the return value from the async generator
                const iterator = simulationGenerator[Symbol.asyncIterator]();
                while (true) {
                    const { value, done } = await iterator.next();
                    if (done) {
                        simulationResult = value as SimulationResult;
                        break;
                    }
                    const update = value;
                    if (update.type === 'UPDATE_STEP') {
                        updateApplyStep(update.payload.id, update.payload.status, update.payload.details);
                    } else if (update.type === 'ADD_SUBSTEP') {
                        addApplySubstep(update.payload.parentId, update.payload.substep);
                    } else if (update.type === 'UPDATE_SUBSTEP') {
                        updateApplySubstep(update.payload.parentId, update.payload.substepId, update.payload.status, update.payload.title);
                    }
                }

                await sleep(1000);
                set({
                    processingStartTime: null,
                    fileReviewStates: simulationResult.fileReviewStates,
                    patchStatus: simulationResult.patchStatus,
                });
                showReviewScreen();
            },
            tryRepairFile: (fileId) => {
                const selectedTransactionId = useViewStore.getState().selectedTransactionId;
                const { fileReviewStates } = get();
                if (!selectedTransactionId) return;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                const file = tx?.files?.find(f => f.id === fileId);
                if (!file) return;

                const { status, error } = fileReviewStates.get(file.id) || {};
                if (status !== 'FAILED') return;
                
                ReviewService.tryRepairFile(file, error);
                get().actions.updateFileReviewStatus(file.id, 'AWAITING');
            },
            tryInstruct: (fileId) => {
                const selectedTransactionId = useViewStore.getState().selectedTransactionId;
                const { fileReviewStates } = get();
                if (!selectedTransactionId) return;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                const file = tx?.files?.find(f => f.id === fileId);
                if (!tx || !file) return;

                const { status } = fileReviewStates.get(file.id) || {};
                if (status !== 'REJECTED') return;
                
                ReviewService.tryInstructFile(file, tx);
                get().actions.updateFileReviewStatus(file.id, 'AWAITING', undefined, 'Instruction prompt copied!');
            },
            showBulkInstruct: () => get().actions.setBodyView('bulk_instruct'),
            cancelProcessing: () => set({ isCancelling: true }),
            skipCurrentStep: () => set({ isSkipping: true }),
            resetSkip: () => set({ isSkipping: false }),
            executeBulkInstructOption: async (option) => {
                const selectedTransactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                if (!tx?.files) return;

                const rejectedFiles = tx.files.filter(f => get().fileReviewStates.get(f.id)?.status === 'REJECTED');
                if (rejectedFiles.length === 0) {
                    set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                    return;
                }

                switch (option) {
                    case 1:
                        ReviewService.generateBulkInstructPrompt(rejectedFiles, tx);
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                        break;
                    case 2:
                        get().actions.setBodyView('confirm_handoff');
                        break;
                    case 3:
                        rejectedFiles.forEach(file => {
                            get().actions.updateFileReviewStatus(file.id, 'APPROVED');
                        });
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                        break;
                    default:
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                }
            },

            showBulkRepair: () => get().actions.toggleBodyView('bulk_repair'),
            executeBulkRepairOption: async (option) => {
                const selectedTransactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                if (!tx?.files) return;

                const failedFiles = tx.files.filter(f => get().fileReviewStates.get(f.id)?.status === 'FAILED');
                if (failedFiles.length === 0) {
                    set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                    return;
                }

                switch (option) {
                    case 1:
                        ReviewService.generateBulkRepairPrompt(failedFiles);
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                        break;
                    case 2: {
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                        failedFiles.forEach(f => get().actions.updateFileReviewStatus(f.id, 'RE_APPLYING'));
                        const results = await ReviewService.runBulkReapply(failedFiles);
                        results.forEach(result =>
                            get().actions.updateFileReviewStatus(
                                result.id, result.status, result.error,
                            ),
                        );
                        break;
                    }
                    case 3:
                        get().actions.setBodyView('confirm_handoff');
                        break;
                    case 4:
                        failedFiles.forEach(file => {
                            get().actions.updateFileReviewStatus(file.id, 'REJECTED');
                        });
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                        break;
                    default:
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                }
            },
            confirmHandoff: () => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!tx?.files) return;
                const { fileReviewStates } = get();
                ReviewService.generateHandoffPrompt(tx, fileReviewStates);
                ReviewService.performHandoff(tx.hash);
            },
            scrollReasoningUp: () => set(state => ({ reasoningScrollIndex: Math.max(0, state.reasoningScrollIndex - 1) })),
            scrollReasoningDown: () => set(state => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!tx?.reasoning) return {};
                const maxLines = tx.reasoning.split('\n').length;
                return { reasoningScrollIndex: Math.min(maxLines - 1, state.reasoningScrollIndex + 1) };
            }),
            navigateScriptErrorUp: () => set(state => ({ scriptErrorIndex: Math.max(0, state.scriptErrorIndex - 1) })),
            navigateScriptErrorDown: () => set(state => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!tx?.scripts || !tx?.files) return {};
                const selectedScript = tx.scripts[state.selectedItemIndex - tx.files.length];
                if (selectedScript?.output) {
                    const errorLines = selectedScript.output
                        .split('\n')
                        .filter(line => line.includes('Error') || line.includes('Warning'));
                    return { scriptErrorIndex: Math.min(errorLines.length - 1, state.scriptErrorIndex + 1) };
                }
                return {};
            }),
            updateApplyStep: (id, status, details) => {
                set(state => {
                    const newSteps = state.applySteps.map(s => {
                        if (s.id === id) {
                            const newStep: ApplyStep = { ...s, status };
                            if (status === 'active') {
                                newStep.startTime = Date.now();
                            } else if ((status === 'done' || status === 'failed' || status === 'skipped') && s.startTime) {
                                newStep.duration = (Date.now() - s.startTime) / 1000;
                            }
                            if (details !== undefined) newStep.details = details;
                            return newStep;
                        }
                        return s;
                    });
                    return { applySteps: newSteps };
                });
            },
            updateApplySubstep: (parentId, substepId, status, title) => {
                set(state => ({
                    applySteps: state.applySteps.map(s => {
                        if (s.id === parentId && s.substeps) {
                            const newSubsteps = s.substeps.map(sub => {
                                if (sub.id === substepId) {
                                    const newSub: ApplyStep = { ...sub, status };
                                    if (status === 'active') {
                                        newSub.startTime = Date.now();
                                    } else if ((status === 'done' || status === 'failed') && sub.startTime) {
                                        newSub.duration = (Date.now() - sub.startTime) / 1000;
                                    }
                                    if (title) newSub.title = title;
                                    return newSub;
                                }
                                return sub;
                            });
                            return { ...s, substeps: newSubsteps };
                        }
                        return s;
                    }),
                }));
            },
            addApplySubstep: (parentId, substep) => {
                set(state => ({
                    applySteps: state.applySteps.map(s => {
                        if (s.id === parentId) {
                            const newSubsteps = [...(s.substeps || []), substep as ApplyStep];
                            return { ...s, substeps: newSubsteps };
                        }
                        return s;
                    }),
                }));
            },
            updateFileReviewStatus: (fileId, status, error, details) => {
                set(state => {
                    const newStates = new Map(state.fileReviewStates);
                    newStates.set(fileId, { status, error, details });
                    return { fileReviewStates: newStates };
                });
            },
            toggleFileApproval: (fileId) => {
                set(state => {
                    const newStates = new Map(state.fileReviewStates);
                    const current = newStates.get(fileId);
                    if (current) {
                        const newStatus: FileReviewStatus = current.status === 'APPROVED' ? 'REJECTED' : 'APPROVED';
                        newStates.set(fileId, { status: newStatus, error: undefined, details: undefined });
                    }
                    return { fileReviewStates: newStates };
                });
            },
            rejectAllFiles: () => {
                set(state => {
                    const newStates = new Map(state.fileReviewStates);
                    for (const [fileId, reviewState] of newStates.entries()) {
                        if (reviewState.status === 'APPROVED') {
                            newStates.set(fileId, { status: 'REJECTED', error: undefined, details: undefined });
                        }
                    }
                    return { fileReviewStates: newStates };
                });
            },
            navigateBulkRepairUp: () => set(state => ({
                selectedBulkRepairOptionIndex: moveIndex(state.selectedBulkRepairOptionIndex, 'up', 4),
            })),
            navigateBulkRepairDown: () => set(state => ({
                selectedBulkRepairOptionIndex: moveIndex(state.selectedBulkRepairOptionIndex, 'down', 4),
            })),
            navigateBulkInstructUp: () => set(state => ({
                selectedBulkInstructOptionIndex: moveIndex(state.selectedBulkInstructOptionIndex, 'up', 4),
            })),
            navigateBulkInstructDown: () => set(state => ({
                selectedBulkInstructOptionIndex: moveIndex(state.selectedBulkInstructOptionIndex, 'down', 4),
            })),
        },
    }));
  src/hooks/useReviewScreen.tsx: >-
    import { useMemo } from 'react';

    import { useInput, type Key } from 'ink';

    import { useReviewStore } from '../stores/review.store';

    import { useAppStore } from '../stores/app.store';

    import { useNotificationStore } from '../stores/notification.store';

    import { useCopyStore } from '../stores/copy.store';

    import { useTransactionStore, selectSelectedTransaction } from
    '../stores/transaction.store';

    import type { FileItem } from '../types/domain.types';

    import { useLayout } from './useLayout';

    import { useContentViewport } from './useContentViewport';

    import { UI_CONFIG } from '../config/ui.config';

    import { REVIEW_BODY_VIEWS } from '../constants/review.constants';

    import { useViewport } from './useViewport';


    type NavigableItem =
        | { type: 'prompt' }
        | { type: 'reasoning' }
        | { type: 'script'; id: string }
        | { type: 'file'; id: string };

    export const useReviewScreen = () => {
        const store = useReviewStore();
        const {
            selectedItemIndex,
            bodyView,
            patchStatus,
            selectedBulkRepairOptionIndex,
            selectedBulkInstructOptionIndex,
        } = store;

        const transaction = useTransactionStore(selectSelectedTransaction);
        const { showDashboardScreen } = useAppStore(s => s.actions);

        const scriptCount = transaction?.scripts?.length || 0;
        const fileCount = transaction?.files?.length || 0;

        const layout = UI_CONFIG.layout.review;

        // Layout for the main navigable item list (prompt, reasoning, files, etc.)
        const mainListLayoutConfig = useMemo(() => ({
            header: layout.header,
            fixedRows: layout.fixedRows,
            marginsY: layout.marginsY,
            separators: layout.separators,
            footer: layout.footer,
            dynamicRows: {
                count: bodyView !== REVIEW_BODY_VIEWS.NONE ? layout.bodyHeightReservation : 0,
            },
        }), [bodyView, layout]);

        const { remainingHeight: listViewportHeight } = useLayout(mainListLayoutConfig);
        const { viewOffset } = useViewport({ selectedIndex: selectedItemIndex, itemCount: 100, layoutConfig: mainListLayoutConfig });

        // Layout for the body content (diff, reasoning, etc.)
        const bodyLayoutConfig = useMemo(() => ({
            header: layout.header,
            separators: layout.separators,
            fixedRows: 2, // meta
            marginsY: 1 + 1 + 1, // meta, scripts, files
            footer: 2,
            dynamicRows: { count: 2 + scriptCount + 1 + fileCount }, // prompt, reasoning, scripts, 'FILES' header, files
        }), [layout, scriptCount, fileCount]);

        const { remainingHeight: availableBodyHeight } = useLayout(bodyLayoutConfig);

        const navigableItems = useMemo((): NavigableItem[] => {
            if (!transaction) return [];
            const scriptItems: NavigableItem[] = (transaction.scripts || []).map(s => ({ type: 'script', id: s.command }));
            const fileItems: NavigableItem[] = (transaction.files || []).map(f => ({ type: 'file', id: f.id }));
            return [{ type: 'prompt' }, { type: 'reasoning' }, ...scriptItems, ...fileItems];
        }, [transaction]);

        const contentLineCount = useMemo(() => {
            const currentItem = navigableItems[selectedItemIndex];
            switch (bodyView) { //
                case REVIEW_BODY_VIEWS.REASONING:
                    return (transaction?.reasoning || '').split('\n').length;
                case REVIEW_BODY_VIEWS.DIFF: {
                    if (currentItem?.type !== 'file') return 0;
                    const selectedFile = (transaction?.files || []).find(f => f.id === currentItem.id);
                    return (selectedFile?.diff || '').split('\n').length;
                }
                case REVIEW_BODY_VIEWS.SCRIPT_OUTPUT: {
                    if (currentItem?.type !== 'script') return 0;
                    const selectedScript = (transaction?.scripts || []).find(s => s.command === currentItem.id);
                    return (selectedScript?.output || '').split('\n').length;
                }
                default: return 0;
            }
        }, [bodyView, navigableItems, selectedItemIndex, transaction]);
        const contentViewport = useContentViewport({ contentLineCount, viewportHeight: availableBodyHeight });

        const navigableItemsInView = navigableItems.slice(viewOffset, viewOffset + listViewportHeight);

        // Memoize files to prevent re-renders, fixing the exhaustive-deps lint warning.
        const files: FileItem[] = useMemo(() => transaction?.files || [], [transaction]);
        const fileReviewStates = useReviewStore(s => s.fileReviewStates);

        const reviewStats = useMemo(() => {
            const approvedFiles = files.filter(f => fileReviewStates.get(f.id)?.status === 'APPROVED');
            return {
                totalFiles: files.length,
                totalLinesAdded: files.reduce((sum, f) => sum + f.linesAdded, 0),
                totalLinesRemoved: files.reduce((sum, f) => sum + f.linesRemoved, 0),
                numFiles: files.length,
                approvedFilesCount: approvedFiles.length,
            };
        }, [files, fileReviewStates]);

        const hasRejectedFiles = useMemo(() => {
            if (!fileReviewStates) return false;
            return Array.from(fileReviewStates.values()).some(s => s.status === 'REJECTED');
        }, [fileReviewStates]);

        const { approvedFilesCount } = reviewStats;

        const isFileSelected = navigableItems[selectedItemIndex]?.type === 'file';

        const scripts = transaction?.scripts || [];

        const {
            moveSelectionUp,
            moveSelectionDown,
            setSelectedItemIndex,
            expandDiff,
            toggleBodyView,
            setBodyView,
            startApplySimulation,
            approve,
            tryRepairFile,
            tryInstruct,
            showBulkRepair,
            showBulkInstruct,
            executeBulkRepairOption,
            executeBulkInstructOption,
            confirmHandoff,
            scrollReasoningUp,
            scrollReasoningDown,
            navigateScriptErrorUp,
            navigateScriptErrorDown,
            toggleFileApproval,
            rejectAllFiles,
            navigateBulkRepairUp,
            navigateBulkRepairDown,
            navigateBulkInstructUp,
            navigateBulkInstructDown,
        } = store.actions;

        const openCopyMode = () => {
            if (!transaction) return;
            const currentItem = navigableItems[selectedItemIndex];
            const selectedFile = currentItem?.type === 'file' ? files.find(f => f.id === currentItem.id) : undefined;
            useCopyStore.getState().actions.openForReview(transaction, transaction.files || [], selectedFile);
        };

        const navigateToNextFile = () => {
            const nextFileIndex = navigableItems.findIndex(
                (item, index) => index > selectedItemIndex && item.type === 'file',
            );
            if (nextFileIndex !== -1) {
                setSelectedItemIndex(nextFileIndex);
            }
        };

        const navigateToPreviousFile = () => {
            // Find the last index of a file before the current one
            const prevFileIndex = navigableItems
                .slice(0, selectedItemIndex)
                .findLastIndex(item => item.type === 'file');

            if (prevFileIndex !== -1) {
                setSelectedItemIndex(prevFileIndex);
            }
        };

        // --- Input Handlers ---

        const handleGlobalInput = (input: string, key: Key): boolean => {
            if (input === '1' && transaction) { // For demo purposes
                startApplySimulation(transaction.id, 'success'); return true;
            }
            if (input === '2' && transaction) { // For demo purposes
                startApplySimulation(transaction.id, 'failure'); return true;
            }
            // The 'q' (quit/back) is now handled by the global hotkey hook.

            if (key.escape) {
                switch (bodyView) {
                    case REVIEW_BODY_VIEWS.BULK_REPAIR:
                    case REVIEW_BODY_VIEWS.CONFIRM_HANDOFF:
                    case REVIEW_BODY_VIEWS.BULK_INSTRUCT:
                        toggleBodyView(bodyView);
                        break;
                    default:
                        if (bodyView !== REVIEW_BODY_VIEWS.NONE) {
                            setBodyView(REVIEW_BODY_VIEWS.NONE);
                        }
                        break;
                }
                return true;
            }
            return false;
        };

        const handleHandoffConfirmInput = (_input: string, key: Key): void => {
            if (key.return) confirmHandoff();
        };

        const handleBulkRepairInput = (input: string, key: Key): void => {
            if (key.upArrow) navigateBulkRepairUp();
            if (key.downArrow) navigateBulkRepairDown();
            if (key.return) {
                executeBulkRepairOption(selectedBulkRepairOptionIndex + 1); // Options are 1-based
                return;
            }

            if (input >= '1' && input <= '4') {
                executeBulkRepairOption(parseInt(input));
            }
        };
        
        const handleBulkInstructInput = (input: string, key: Key): void => {
            if (key.upArrow) navigateBulkInstructUp();
            if (key.downArrow) navigateBulkInstructDown();
            if (key.return) {
                executeBulkInstructOption(selectedBulkInstructOptionIndex + 1); // Options are 1-based
                return;
            }

            if (input >= '1' && input <= '3') {
                executeBulkInstructOption(parseInt(input));
            }
        };

        const handleContentScrollInput = (key: Key): boolean => {
            const contentViews = [
                REVIEW_BODY_VIEWS.REASONING,
                REVIEW_BODY_VIEWS.SCRIPT_OUTPUT,
                REVIEW_BODY_VIEWS.DIFF,
            ] as const;
            if (!(contentViews as readonly string[]).includes(bodyView)) return false;

            if (key.upArrow && bodyView !== REVIEW_BODY_VIEWS.DIFF) {
                contentViewport.actions.scrollUp();
                return true;
            }
            if (key.downArrow && bodyView !== REVIEW_BODY_VIEWS.DIFF) {
                contentViewport.actions.scrollDown();
                return true;
            }
            if (key.pageUp) { contentViewport.actions.pageUp(); return true; }
            if (key.pageDown) { contentViewport.actions.pageDown(); return true; }
            return false;
        };

        const handleReasoningInput = (input: string, key: Key): void => {
            if (key.upArrow) scrollReasoningUp();
            if (key.downArrow) scrollReasoningDown();
            if (input.toLowerCase() === 'r') toggleBodyView(REVIEW_BODY_VIEWS.REASONING);
        };

        const handleScriptOutputInput = (input: string, key: Key): void => {
            if (input.toLowerCase() === 'j') navigateScriptErrorDown();
            if (input.toLowerCase() === 'k') navigateScriptErrorUp();
            if (key.return) toggleBodyView(REVIEW_BODY_VIEWS.SCRIPT_OUTPUT);
            if (input.toLowerCase() === 'c') { // TODO: this copy logic is not great.
                const currentItem = navigableItems[selectedItemIndex];
                const selectedScript = currentItem?.type === 'script' ? scripts.find(s => s.command === currentItem.id) : undefined;
                if (selectedScript) {
                    useNotificationStore.getState().actions.show({
                        type: 'success',
                        title: 'Copied to Clipboard',
                        message: `Copied script output for: ${selectedScript.command}`,
                    });
                }
            }
        };

        const handleDiffInput = (input: string, key: Key) => {
            if (key.upArrow) {
                navigateToPreviousFile();
                return;
            }
            if (key.downArrow) {
                navigateToNextFile();
                return;
            }
            if (input.toLowerCase() === 'x') expandDiff();
            if (input.toLowerCase() === 'd' || key.escape) toggleBodyView('diff');
        };

        const handleMainNavigationInput = (input: string, key: Key): void => {
            // Handle Shift+R for reject all
            if (key.shift && input.toLowerCase() === 'r') {
                if (approvedFilesCount > 0 && transaction) {
                    rejectAllFiles();
                }
                return;
            }

            // Main View Navigation
            if (key.upArrow) moveSelectionUp(navigableItems.length);
            if (key.downArrow) moveSelectionDown(navigableItems.length);

            const currentItem = navigableItems[selectedItemIndex];

            if (input === ' ') {
                if (currentItem?.type === 'file') {
                    const fileState = fileReviewStates.get(currentItem.id);
                    if (fileState && fileState.status !== 'FAILED') {
                        toggleFileApproval(currentItem.id);
                    }
                }
            }

            if (input.toLowerCase() === 'd' && currentItem?.type === 'file') {
                toggleBodyView(REVIEW_BODY_VIEWS.DIFF);
            }

            if (input.toLowerCase() === 'r') {
                toggleBodyView(REVIEW_BODY_VIEWS.REASONING);
            }

            if (key.return) { // Enter key
                if (currentItem?.type === 'file') {
                    toggleBodyView(REVIEW_BODY_VIEWS.DIFF);
                } else if (currentItem?.type === 'reasoning') {
                    toggleBodyView(REVIEW_BODY_VIEWS.REASONING);
                } else if (currentItem?.type === 'script') {
                    toggleBodyView(REVIEW_BODY_VIEWS.SCRIPT_OUTPUT);
                }
            }

            if (input.toLowerCase() === 'a') {
                if (approvedFilesCount > 0) {
                    approve();
                    showDashboardScreen();
                }
            }

            if (input.toLowerCase() === 'c') {
                openCopyMode();
            }

            if (input.toLowerCase() === 't') {
                if (key.shift) {
                    const hasFailedFiles = Array.from(fileReviewStates.values()).some(s => s.status === 'FAILED');
                    if (hasFailedFiles) showBulkRepair();
                } else if (currentItem?.type === 'file') {
                    const fileState = fileReviewStates.get(currentItem.id);
                    if (fileState?.status === 'FAILED') tryRepairFile(currentItem.id);
                }
            }

            if (input.toLowerCase() === 'i') {
                if (key.shift) {
                    if (hasRejectedFiles) showBulkInstruct();
                } else if (currentItem?.type === 'file') {
                    const fileState = fileReviewStates.get(currentItem.id);
                    if (fileState?.status === 'REJECTED') {
                        tryInstruct(currentItem.id);
                    }
                }
            }
        };

        useInput((input: string, key: Key) => {
            if (handleGlobalInput(input, key)) {
                return;
            }

            // If we are in a scrollable body view, prioritize that input.
            if (handleContentScrollInput(key)) {
                return;
            }

            switch (bodyView) {
                case REVIEW_BODY_VIEWS.CONFIRM_HANDOFF: return handleHandoffConfirmInput(input, key);
                case REVIEW_BODY_VIEWS.BULK_REPAIR: return handleBulkRepairInput(input, key);
                case REVIEW_BODY_VIEWS.BULK_INSTRUCT: return handleBulkInstructInput(input, key);
                case REVIEW_BODY_VIEWS.REASONING: return handleReasoningInput(input, key);
                case REVIEW_BODY_VIEWS.SCRIPT_OUTPUT: return handleScriptOutputInput(input, key);
                case REVIEW_BODY_VIEWS.DIFF: return handleDiffInput(input, key);
                default: return handleMainNavigationInput(input, key);
            }
        });

        return {
            ...store,
            fileReviewStates,
            selectedItemIndex,
            transaction,
            files,
            scripts,
            patchStatus,
            navigableItems,
            isFileSelected,
            navigableItemsInView,
            viewOffset,
            contentScrollIndex: contentViewport.scrollIndex,
            availableBodyHeight,
            selectedBulkRepairOptionIndex,
            selectedBulkInstructOptionIndex,
            ...reviewStats,
            hasRejectedFiles,
        };
    };
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 207
