uuid: c2945d9f-a65c-4f81-a77e-52b826e7a256
projectId: relaycode-tui
createdAt: '2025-09-25T22:48:20.865Z'
gitCommitMsg: >-
  feat(ui): implement scrolling and pagination in major screens

  Introduces comprehensive vertical scrolling and pagination capabilities across
  several key areas of the application to handle large amounts of data
  gracefully.

  - Refactors `DiffScreen` to support controlled scrolling. - Creates a new
  `useCopyScreen` hook to manage view logic and pagination
    for the copy overlay, and refactors the component to use it.
  - Adds `pageUp`/`pageDown` actions to the copy store. - Implements scrollable
  body content (Prompt, Reasoning, Diff) in the
    `TransactionDetailScreen`.
  - Implements both a paginated main list and scrollable body content in
    the `ReviewScreen`.
  - Updates associated hooks and input handlers to differentiate between
    list navigation and content scrolling.
promptSummary: >-
  Implement vertical scrolling and pagination in core components,
  `TransactionDetailScreen`, and `ReviewScreen`.
reasoning:
  - >-
    Here is the implementation of Part 1 and Part 2 of the master plan for
    vertical scrolling and pagination.
  - '### Part 1: Enhance Core Scrollable Components and Logic'
  - >-
    I'll start by making the `DiffScreen` component scrollable, adding
    pagination capabilities to the `copy.store`, creating a new `useCopyScreen`
    hook to manage the view logic, and refactoring the `CopyScreen` component to
    use this new hook.
  - First, I'll update `DiffScreen.tsx` to accept scrolling properties.
  - Next, I'll add page-up and page-down navigation actions to `copy.store.ts`.
  - >-
    Now, I'll create the new `useCopyScreen.tsx` hook to encapsulate the
    component's logic and handle pagination.
  - >-
    Finally for Part 1, I'll refactor `CopyScreen.tsx` to be a pure view
    component using the new hook.
  - '### Part 2: Implement Scrolling and Pagination in Major Screens'
  - >-
    Now I'll integrate scrolling and pagination into the
    `TransactionDetailScreen` and `ReviewScreen`, which are the most
    content-heavy parts of the application.
  - >-
    I'll start with the `TransactionDetailScreen`, updating its hook to manage
    body content scrolling.
  - >-
    Then, I'll update the `TransactionDetailScreen` component to pass down the
    new scrolling props.
  - >-
    Next, I'll perform a similar, more comprehensive update for
    `useReviewScreen.tsx` to handle both main list pagination and body content
    scrolling.
  - >-
    Finally, I'll update the `ReviewScreen` component to use the paginated data
    and pass scrolling props to its children.
  - >-
    This completes the requested changes, adding robust scrolling and pagination
    to the core and major screens of the application.
operations:
  - type: write
    path: src/components/DiffScreen.tsx
    content: >+
      --- src/components/DiffScreen.tsx

      +++ src/components/DiffScreen.tsx

      @@ -4,8 +4,10 @@
       interface DiffScreenProps {
           filePath: string;
           diffContent: string;
           isExpanded: boolean;
      +    scrollIndex?: number;

      +    maxHeight?: number;
       }
      -const DiffScreen = ({ filePath, diffContent, isExpanded }:
      DiffScreenProps) => {

      +const DiffScreen = ({ filePath, diffContent, isExpanded, scrollIndex = 0,
      maxHeight }: DiffScreenProps) => {
           const lines = diffContent.split('\n');
           const COLLAPSE_THRESHOLD = UI_CONFIG.diffScreen.collapseThreshold;
           const COLLAPSE_SHOW_LINES = UI_CONFIG.diffScreen.collapseShowLines;
      @@ -23,7 +25,12 @@
                       </>
                   );
               }
      -        return lines.map((line, i) => renderLine(line, i));

      +        // Handle vertical scrolling for expanded view

      +        if (isExpanded && maxHeight) {

      +            const visibleLines = lines.slice(scrollIndex, scrollIndex +
      maxHeight);

      +            return visibleLines.map((line, i) => renderLine(line,
      scrollIndex + i));

      +        }

      +        return lines.map((line, i) => renderLine(line, i));
           };
       
           const renderLine = (line: string, key: number) => {

    patchStrategy: standard-diff
  - type: write
    path: src/stores/copy.store.ts
    content: >+
      --- src/stores/copy.store.ts

      +++ src/stores/copy.store.ts

      @@ -21,6 +21,8 @@
               openForHistory: (transactions: Transaction[]) => void;
               navigateUp: () => void;
               navigateDown: () => void;
      +        navigatePageUp: (viewportHeight: number) => void;

      +        navigatePageDown: (viewportHeight: number) => void;
               toggleSelection: () => void;
               toggleSelectionById: (id: string) => void;
               executeCopy: () => void;
      @@ -75,6 +77,12 @@
               navigateDown: () => set(state => ({
                   selectedIndex: moveIndex(state.selectedIndex, 'down', state.items.length),
               })),
      +        navigatePageUp: (viewportHeight: number) => set(state => ({

      +            selectedIndex: Math.max(0, state.selectedIndex -
      viewportHeight),

      +        })),

      +        navigatePageDown: (viewportHeight: number) => set(state => ({

      +            selectedIndex: Math.min(state.items.length - 1,
      state.selectedIndex + viewportHeight),

      +        })),
               toggleSelection: () => set(state => {
                   const currentItem = state.items[state.selectedIndex];
                   if (!currentItem) return {};

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useCopyScreen.tsx
    content: |-
      import { useInput } from 'ink';
      import { useCopyStore } from '../stores/copy.store';
      import { useViewStore } from '../stores/view.store';
      import { useViewport } from './useViewport';

      // Header, separator, title, margin, separator, status, footer
      const RESERVED_ROWS = 8;

      export const useCopyScreen = () => {
          const activeOverlay = useViewStore(s => s.activeOverlay);
          const {
              title, items, selectedIndex, selectedIds, lastCopiedMessage,
              actions,
          } = useCopyStore(state => ({ ...state, actions: state.actions }));

          const { viewOffset, viewportHeight } = useViewport({
              selectedIndex,
              reservedRows: RESERVED_ROWS,
          });

          useInput((input, key) => {
              if (key.escape) {
                  actions.close();
                  return;
              }
              if (key.upArrow) {
                  actions.navigateUp();
                  return;
              }
              if (key.downArrow) {
                  actions.navigateDown();
                  return;
              }
              if (key.pageUp) {
                  actions.navigatePageUp(viewportHeight);
                  return;
              }
              if (key.pageDown) {
                  actions.navigatePageDown(viewportHeight);
                  return;
              }
              if (input === ' ') {
                  actions.toggleSelection();
                  return;
              }
              if (key.return) {
                  actions.executeCopy();
                  return;
              }
              
              const item = items.find(i => i.key.toLowerCase() === input.toLowerCase());
              if(item) {
                  actions.toggleSelectionById(item.id);
              }
          }, { isActive: activeOverlay === 'copy' });

          const itemsInView = items.slice(viewOffset, viewOffset + viewportHeight);

          return {
              title,
              itemsInView,
              selectedIndex,
              selectedIds,
              lastCopiedMessage,
              viewOffset,
          };
      };
    patchStrategy: replace
  - type: write
    path: src/components/CopyScreen.tsx
    content: >+
      --- src/components/CopyScreen.tsx

      +++ src/components/CopyScreen.tsx

      @@ -1,37 +1,18 @@

      -import { Box, Text, useInput } from 'ink';

      -import { useCopyStore } from '../stores/copy.store';

      +import { Box, Text } from 'ink';
       import Separator from './Separator';
      -import { useViewStore } from '../stores/view.store';
       import { useStdoutDimensions } from '../utils';
       import ActionFooter from './ActionFooter';
      +import { useCopyScreen } from '../hooks/useCopyScreen';
       
       const CopyScreen = () => {
      -    const activeOverlay = useViewStore(s => s.activeOverlay);
           const {
      -        title, items, selectedIndex, selectedIds, lastCopiedMessage,

      -        actions,

      -    } = useCopyStore(state => ({ ...state, actions: state.actions }));

      -

      -    useInput((input, key) => {

      -        if (key.escape) {

      -            actions.close();

      -            return;

      -        }

      -        if (key.upArrow) {

      -            actions.navigateUp();

      -            return;

      -        }

      -        if (key.downArrow) {

      -            actions.navigateDown();

      -            return;

      -        }

      -        if (input === ' ') {

      -            actions.toggleSelection();

      -            return;

      -        }

      -        if (key.return) {

      -            actions.executeCopy();

      -            return;

      -        }

      -        

      -        const item = items.find(i => i.key.toLowerCase() ===
      input.toLowerCase());

      -        if(item) {

      -            actions.toggleSelectionById(item.id);

      -        }

      -    }, { isActive: activeOverlay === 'copy' });

      +        title,

      +        itemsInView,

      +        selectedIndex,

      +        selectedIds,

      +        lastCopiedMessage,

      +        viewOffset,

      +    } = useCopyScreen();
           const [width] = useStdoutDimensions();
       
           return (
      @@ -53,8 +34,8 @@
                       <Box flexDirection="column" marginY={1}>
                           <Text>{title}</Text>
                           <Box flexDirection="column" marginTop={1}>
      -                        {items.map((item, index) => {

      -                            const isSelected = index === selectedIndex;

      +                        {itemsInView.map((item, index) => {

      +                            const isSelected = (index + viewOffset) ===
      selectedIndex;
                                   const isChecked = selectedIds.has(item.id);
                                   return (
                                       <Text key={item.id} color={isSelected ? 'cyan' : undefined}>
      @@ -67,7 +48,7 @@
                       <Separator width={Math.floor(width * 0.8) - 4} />
                       {lastCopiedMessage && <Text color="green">✓ {lastCopiedMessage}</Text>}
                       <ActionFooter actions={[
      -                    { key: '↑↓', label: 'Nav' },

      +                    { key: '↑↓/PgUp/PgDn', label: 'Nav' },
                           { key: 'Spc/Hotkey', label: 'Toggle' },
                           { key: 'Enter', label: 'Copy' },
                           { key: 'Esc', label: 'Close' },

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useTransactionDetailScreen.tsx
    content: >+
      --- src/hooks/useTransactionDetailScreen.tsx

      +++ src/hooks/useTransactionDetailScreen.tsx

      @@ -1,9 +1,11 @@
       import { useInput, type Key } from 'ink';
       import { useDetailStore } from '../stores/detail.store';
       import { useViewStore } from '../stores/view.store';
       import { useTransactionStore, selectSelectedTransaction } from '../stores/transaction.store';
      -import { useMemo } from 'react';

      +import { useMemo, useState, useEffect } from 'react';
       import { useCopyStore } from '../stores/copy.store';
       import { EditorService } from '../services/editor.service';
      +import { useStdoutDimensions } from '../utils';
       
       export const useTransactionDetailScreen = () => {
           const store = useDetailStore();
      @@ -17,6 +19,16 @@
               toggleRevertConfirm,
               confirmRevert,
           } = store.actions;
      +    const [contentScrollIndex, setContentScrollIndex] = useState(0);

      +    const [width, height] = useStdoutDimensions();

      +

      +    // Reset scroll when body view changes

      +    useEffect(() => {

      +        setContentScrollIndex(0);

      +    }, [store.bodyView]);

      +

      +    // Header(2) + Meta(4) + Navigator(3+) + Separator(1) + BodyMargin(1)
      + Separator(1) + Footer(1)

      +    const availableBodyHeight = Math.max(1, height - 13 -
      (transaction?.files?.length || 0));
       
           const openCopyMode = () => {
               if (!transaction) return;
      @@ -32,6 +44,40 @@
                   if (key.return) confirmRevert();
                   return;
               }
      +        

      +        // --- Content Scrolling ---

      +        if (store.bodyView === 'PROMPT' || store.bodyView === 'REASONING'
      || store.bodyView === 'DIFF_VIEW') {

      +             let contentLines = 0;

      +            if (store.bodyView === 'PROMPT') {

      +                contentLines = (transaction?.prompt ||
      '').split('\n').length;

      +            } else if (store.bodyView === 'REASONING') {

      +                contentLines = (transaction?.reasoning ||
      '').split('\n').length;

      +            } else if (store.bodyView === 'DIFF_VIEW') {

      +                const fileId = store.focusedItemPath.split('/')[1];

      +                const file = files.find(f => f.id === fileId);

      +                contentLines = (file?.diff || '').split('\n').length;

      +            }

      +            

      +            if (key.upArrow) {

      +                setContentScrollIndex(i => Math.max(0, i - 1));

      +                return;

      +            }

      +            if (key.downArrow) {

      +                setContentScrollIndex(i => Math.min(Math.max(0,
      contentLines - availableBodyHeight), i + 1));

      +                return;

      +            }

      +            if (key.pageUp) {

      +                setContentScrollIndex(i => Math.max(0, i -
      availableBodyHeight));

      +                return;

      +            }

      +            if (key.pageDown) {

      +                const newIndex = i + availableBodyHeight;

      +                setContentScrollIndex(i => Math.min(Math.max(0,
      contentLines - availableBodyHeight), newIndex));

      +                return;

      +            }

      +        }

      +
       
               // --- Main Input ---
               if (input.toLowerCase() === 'c') {
      @@ -55,10 +101,15 @@
                   }
               }
       
      -        if (key.upArrow) navigateUp();

      -        if (key.downArrow) navigateDown();

      -        if (key.return || key.rightArrow) expandOrDrillDown();

      -        if (key.escape || key.leftArrow) collapseOrBubbleUp();

      +        // Navigator movement only if not scrolling content

      +        if (store.bodyView !== 'PROMPT' && store.bodyView !== 'REASONING'
      && store.bodyView !== 'DIFF_VIEW') {

      +            if (key.upArrow) navigateUp();

      +            if (key.downArrow) navigateDown();

      +        }

      +        if (key.rightArrow) expandOrDrillDown();

      +        if (key.leftArrow) collapseOrBubbleUp();

      +        if (key.return) expandOrDrillDown();

      +        if (key.escape) collapseOrBubbleUp();
           }, { isActive: useViewStore.getState().activeOverlay === 'none' }); // Prevent input when copy overlay is open
       
           return {
      @@ -68,5 +119,7 @@
               focusedItemPath: store.focusedItemPath,
               expandedItemPaths: store.expandedItemPaths,
               bodyView: store.bodyView,
      +        contentScrollIndex,

      +        availableBodyHeight,
           };
       };

    patchStrategy: standard-diff
  - type: write
    path: src/components/TransactionDetailScreen.tsx
    content: >+
      --- src/components/TransactionDetailScreen.tsx

      +++ src/components/TransactionDetailScreen.tsx

      @@ -40,7 +40,7 @@
       const TransactionDetailScreen = () => {
           const {
               transaction, files,
      -        focusedItemPath, expandedItemPaths, bodyView,

      +        focusedItemPath, expandedItemPaths, bodyView, contentScrollIndex,
      availableBodyHeight,
           } = useTransactionDetailScreen();
       
           if (!transaction) {
      @@ -91,19 +91,26 @@
               }
               if (bodyView === 'PROMPT') {
                   return (
                       <Box flexDirection="column">
                           <Text>PROMPT</Text>
      -                    <Box
      marginTop={1}><Text>{transaction.prompt}</Text></Box>

      +                    <Box marginTop={1} flexDirection="column">

      +                        {(transaction.prompt || '').split('\n')

      +                            .slice(contentScrollIndex, contentScrollIndex
      + availableBodyHeight)

      +                            .map((line, i) => <Text
      key={i}>{line}</Text>)

      +                        }

      +                    </Box>
                       </Box>
                   );
               }
               if (bodyView === 'REASONING') {
                   if (!transaction.reasoning) return <Text color="gray">No reasoning provided.</Text>;
      -            return <ReasonScreen reasoning={transaction.reasoning} />;

      +            return <ReasonScreen reasoning={transaction.reasoning}
      scrollIndex={contentScrollIndex} visibleLinesCount={availableBodyHeight}
      />;
               }
               if (bodyView === 'FILES_LIST') {
                    return <Text color="gray">(Select a file and press → to view the diff)</Text>;
               }
               if (bodyView === 'DIFF_VIEW') {
                   const fileId = focusedItemPath.split('/')[1];
                   const file = files.find(f => f.id === fileId);
                   if (!file) return null;
      -            return <DiffScreen filePath={file.path}
      diffContent={file.diff} isExpanded={true} />;

      +            return <DiffScreen filePath={file.path}
      diffContent={file.diff} isExpanded={true} scrollIndex={contentScrollIndex}
      maxHeight={availableBodyHeight} />;
               }
               return null;
           };

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useReviewScreen.tsx
    content: >+
      --- src/hooks/useReviewScreen.tsx

      +++ src/hooks/useReviewScreen.tsx

      @@ -1,10 +1,12 @@

      -import { useMemo } from 'react';

      +import { useMemo, useState, useEffect } from 'react';
       import { useInput, type Key } from 'ink';
       import { useReviewStore } from '../stores/review.store';
       import { useAppStore } from '../stores/app.store';
       import { useCopyStore } from '../stores/copy.store';
       import { useTransactionStore, selectSelectedTransaction } from '../stores/transaction.store';
       import type { FileItem } from '../types/domain.types';
      +import { useViewport } from './useViewport';

      +import { useStdoutDimensions } from '../utils';
       
       type NavigableItem =
           | { type: 'prompt' }
      @@ -24,6 +26,20 @@
       
           const transaction = useTransactionStore(selectSelectedTransaction);
           const { showDashboardScreen } = useAppStore(s => s.actions);
      +    const [contentScrollIndex, setContentScrollIndex] = useState(0);

      +    const [height] = useStdoutDimensions();

      +

      +    // Reset scroll when body view changes

      +    useEffect(() => {

      +        setContentScrollIndex(0);

      +    }, [bodyView]);

      +

      +    // Header(2) + Meta(3) + Prompt/Reasoning(2) + Separator(1) +
      Scripts(N) + Separator(1) + FilesHeader(1) + Separator(1) + BodyMargin(1)
      + Footer(1)

      +    const RESERVED_ROWS_MAIN = 13 + (transaction?.scripts?.length || 0);

      +    const { viewOffset, viewportHeight } = useViewport({ selectedIndex:
      selectedItemIndex, reservedRows: RESERVED_ROWS_MAIN });

      +

      +    // For body content, it's simpler

      +    const availableBodyHeight = Math.max(1, height - (RESERVED_ROWS_MAIN
      + (transaction?.files?.length || 0)));
       
           const navigableItems = useMemo((): NavigableItem[] => {
               if (!transaction) return [];
      @@ -32,6 +48,8 @@
               return [{ type: 'prompt' }, { type: 'reasoning' }, ...scriptItems, ...fileItems];
           }, [transaction]);
       
      +    const navigableItemsInView = navigableItems.slice(viewOffset,
      viewOffset + viewportHeight);

      +
           // Memoize files to prevent re-renders, fixing the exhaustive-deps lint warning.
           const files: FileItem[] = useMemo(() => transaction?.files || [], [transaction]);
           const fileReviewStates = useReviewStore(s => s.fileReviewStates);
      @@ -148,6 +166,28 @@
               }
           };
       
      +    const handleContentScrollInput = (key: Key): boolean => {

      +        const contentViews = ['reasoning', 'script_output', 'diff'];

      +        if (!contentViews.includes(bodyView)) return false;

      +

      +        if (key.upArrow) {

      +            setContentScrollIndex(i => Math.max(0, i - 1));

      +            return true;

      +        }

      +        if (key.downArrow) {

      +            // This is a simplification; a real implementation would need
      content length.

      +            setContentScrollIndex(i => i + 1);

      +            return true;

      +        }

      +        if (key.pageUp) {

      +            setContentScrollIndex(i => Math.max(0, i -
      availableBodyHeight));

      +            return true;

      +        }

      +        if (key.pageDown) {

      +            setContentScrollIndex(i => i + availableBodyHeight);

      +            return true;

      +        }

      +        return false;

      +    };

      +
           const handleReasoningInput = (input: string, key: Key): void => {
               if (key.upArrow) scrollReasoningUp();
               if (key.downArrow) scrollReasoningDown();
      @@ -259,6 +299,11 @@
                   return;
               }
       
      +        // If we are in a scrollable body view, prioritize that input.

      +        if (handleContentScrollInput(key)) {

      +            return;

      +        }

      +
               switch (bodyView) {
                   case 'confirm_handoff': return handleHandoffConfirmInput(input, key);
                   case 'bulk_repair': return handleBulkRepairInput(input, key);
      @@ -282,6 +327,10 @@
               patchStatus,
               navigableItems,
               isFileSelected,
      +        navigableItemsInView,

      +        viewOffset,

      +        contentScrollIndex,

      +        availableBodyHeight,
               selectedBulkRepairOptionIndex,
               selectedBulkInstructOptionIndex,
               ...reviewStats,

    patchStrategy: standard-diff
  - type: write
    path: src/components/ReviewScreen.tsx
    content: >+
      --- src/components/ReviewScreen.tsx

      +++ src/components/ReviewScreen.tsx

      @@ -134,10 +134,13 @@
               selectedBulkRepairOptionIndex,
               selectedBulkInstructOptionIndex,
               navigableItems,
      +        navigableItemsInView,

      +        viewOffset,

      +        contentScrollIndex,

      +        availableBodyHeight,
               hasRejectedFiles,
           } = useReviewScreen();
       
           if (!transaction) {
               return <Text>Loading review...</Text>;
           }
      @@ -155,8 +158,8 @@
                       <Box flexDirection="column">
                           <ReasonScreen
                               reasoning={reasoningText}
      -                        scrollIndex={reasoningScrollIndex}

      -                        visibleLinesCount={visibleLinesCount}

      +                        scrollIndex={contentScrollIndex}

      +                        visibleLinesCount={availableBodyHeight}
                           />
                           {reasoningLinesCount > visibleLinesCount && (
                               <Text color="gray">
      @@ -176,6 +179,8 @@
                           filePath={selectedFile.path}
                           diffContent={selectedFile.diff}
                           isExpanded={isDiffExpanded}
      +                    scrollIndex={contentScrollIndex}

      +                    maxHeight={availableBodyHeight}
                       />
                   );
               }
      @@ -194,7 +199,9 @@
                    
                    return (
                       <Box flexDirection="column">
      -                    <Text>{selectedScript.command.includes('lint') ?
      'LINTER' : 'SCRIPT'} OUTPUT: `{selectedScript.command}`</Text>

      +                    <Text>

      +                        {selectedScript.command.includes('lint') ?
      'LINTER' : 'SCRIPT'} OUTPUT: `{selectedScript.command}`

      +                    </Text>
                           <Box marginTop={1} flexDirection="column">
                               {outputLines.map((line: string, index: number) => {
                                   const isError = line.includes('Error');
      @@ -348,7 +355,8 @@
                       <Box flexDirection="column">
                           <Text>{hash} · {message}</Text>
                           <Text>
      -                        (<Text
      color="green">+{totalLinesAdded}</Text>/<Text
      color="red">-{totalLinesRemoved}</Text>) · {numFiles} Files ·
      {approvedFilesCount}/{numFiles} Approved

      +                        (<Text
      color="green">+{totalLinesAdded}</Text>/<Text
      color="red">-{totalLinesRemoved}</Text>) · {numFiles} Files ·
      ({approvedFilesCount}/{numFiles} Appr)

      +                        · Showing {viewOffset + 1}-{Math.min(viewOffset +
      navigableItemsInView.length, navigableItems.length)} of
      {navigableItems.length}
                               {patchStatus === 'PARTIAL_FAILURE' && scripts.length === 0 && <Text> · Scripts: SKIPPED</Text>}
                               {patchStatus === 'PARTIAL_FAILURE' && <Text color="red" bold> · MULTIPLE PATCHES FAILED</Text>}
                           </Text>
      @@ -370,53 +378,39 @@
                   <Separator />
       
                   {/* Script Results (if any) */}
      -            {scripts.length > 0 && navigableItems.some(i => i.type ===
      'script') && (

      +            {scripts.length > 0 && navigableItemsInView.some(i => i.type
      === 'script') && (
                       <>
                           <Box flexDirection="column" marginY={1}>
      -                        {scripts.map((script: ScriptResult) => (

      -                            (() => {

      -                                const navItemIndex =
      navigableItems.findIndex(i => {

      -                                    if (i.type === 'script') {

      -                                        return i.id === script.command;

      -                                    }

      -                                    return false;

      -                                });

      -                                const isSelected = selectedItemIndex ===
      navItemIndex;

      -                                return (

      -                                    <ScriptItemRow

      -                                        key={script.command}

      -                                        script={script}

      -                                        isSelected={isSelected}

      -                                        isExpanded={bodyView ===
      'script_output' && isSelected}

      -                                    />

      -                                );

      -                            })()

      -                        ))}

      +                        {scripts.map((script: ScriptResult) => {

      +                            const itemInViewIndex =
      navigableItemsInView.findIndex(i => i.type === 'script' && i.id ===
      script.command);

      +                            if (itemInViewIndex === -1) return null; //
      Only render if visible

      +                            

      +                            const isSelected = selectedItemIndex ===
      viewOffset + itemInViewIndex;

      +                            return (

      +                                <ScriptItemRow key={script.command}
      script={script} isSelected={isSelected} isExpanded={bodyView ===
      'script_output' && isSelected} />

      +                            );

      +                        })}
                           </Box>
                           <Separator />
                       </>
                   )}
      -

      +            
                   {/* Files Section */}
                   <Box flexDirection="column" marginY={1}>
                       <Text bold>FILES</Text>
                       {files.map((file: FileItem) => {
      -                    const navItemIndex = navigableItems.findIndex(i => {

      -                        if (i.type === 'file') {

      -                            return i.id === file.id;

      -                        }

      -                        return false;

      -                    });

      -                    const isFocused = selectedItemIndex === navItemIndex;

      +                    const itemInViewIndex =
      navigableItemsInView.findIndex(i => i.type === 'file' && i.id ===
      file.id);

      +                    if (itemInViewIndex === -1) return null; // Only
      render if visible

      +

      +                    const isFocused = selectedItemIndex === viewOffset +
      itemInViewIndex;
                           const reviewState = fileReviewStates.get(file.id);
      +                    
                           return (
                               <FileItemRow
      -                            key={file.id}

      -                            file={file}

      -                            isFocused={isFocused}

      +                            key={file.id} file={file}
      isFocused={isFocused}
                                   reviewStatus={reviewState?.status || 'AWAITING'}
                                   reviewError={reviewState?.error}
                                   reviewDetails={reviewState?.details}
                               />
                           );
                       })}

    patchStrategy: standard-diff
snapshot:
  src/hooks/useCopyScreen.tsx: null
  src/components/DiffScreen.tsx: >-
    import { Box, Text } from 'ink';

    import { UI_CONFIG } from '../config/ui.config';


    interface DiffScreenProps {
        filePath: string;
        diffContent: string;
        isExpanded: boolean;
    }

    const DiffScreen = ({ filePath, diffContent, isExpanded }: DiffScreenProps)
    => {
        const lines = diffContent.split('\n');
        const COLLAPSE_THRESHOLD = UI_CONFIG.diffScreen.collapseThreshold;
        const COLLAPSE_SHOW_LINES = UI_CONFIG.diffScreen.collapseShowLines;

        const renderContent = () => {
            if (!isExpanded && lines.length > COLLAPSE_THRESHOLD) {
                const topLines = lines.slice(0, COLLAPSE_SHOW_LINES);
                const bottomLines = lines.slice(lines.length - COLLAPSE_SHOW_LINES);
                const hiddenLines = lines.length - (COLLAPSE_SHOW_LINES * 2);

                return (
                    <>
                        {topLines.map((line, i) => renderLine(line, i))}
                        <Text color="gray">... {hiddenLines} lines hidden ...</Text>
                        {bottomLines.map((line, i) => renderLine(line, i + topLines.length + 1))}
                    </>
                );
            }
            return lines.map((line, i) => renderLine(line, i));
        };

        const renderLine = (line: string, key: number) => {
            let color = 'white';
            if (line.startsWith('+')) color = 'green';
            if (line.startsWith('-')) color = 'red';
            if (line.startsWith('@@')) color = 'cyan';
            return <Text key={key} color={color}>{line}</Text>;
        };

        return (
            <Box flexDirection="column">
                <Text>DIFF: {filePath}</Text>
                <Box flexDirection="column" marginTop={1}>
                    {renderContent()}
                </Box>
            </Box>
        );
    };


    export default DiffScreen;
  src/components/CopyScreen.tsx: |-
    import { Box, Text, useInput } from 'ink';
    import { useCopyStore } from '../stores/copy.store';
    import Separator from './Separator';
    import { useViewStore } from '../stores/view.store';
    import { useStdoutDimensions } from '../utils';
    import ActionFooter from './ActionFooter';

    const CopyScreen = () => {
        const activeOverlay = useViewStore(s => s.activeOverlay);
        const {
            title, items, selectedIndex, selectedIds, lastCopiedMessage,
            actions,
        } = useCopyStore(state => ({ ...state, actions: state.actions }));

        useInput((input, key) => {
            if (key.escape) {
                actions.close();
                return;
            }
            if (key.upArrow) {
                actions.navigateUp();
                return;
            }
            if (key.downArrow) {
                actions.navigateDown();
                return;
            }
            if (input === ' ') {
                actions.toggleSelection();
                return;
            }
            if (key.return) {
                actions.executeCopy();
                return;
            }
            
            const item = items.find(i => i.key.toLowerCase() === input.toLowerCase());
            if(item) {
                actions.toggleSelectionById(item.id);
            }
        }, { isActive: activeOverlay === 'copy' });
        const [width] = useStdoutDimensions();

        return (
            <Box 
                width="100%"
                height="100%"
                flexDirection="column"
                justifyContent="center"
                alignItems="center"
            >
                <Box 
                    flexDirection="column" 
                    borderStyle="round" 
                    borderColor="yellow" 
                    paddingX={2}
                    width="80%"
                >
                    <Text bold color="yellow">▲ relaycode · copy mode</Text>
                    <Separator width={Math.floor(width * 0.8) - 4} />
                    <Box flexDirection="column" marginY={1}>
                        <Text>{title}</Text>
                        <Box flexDirection="column" marginTop={1}>
                            {items.map((item, index) => {
                                const isSelected = index === selectedIndex;
                                const isChecked = selectedIds.has(item.id);
                                return (
                                    <Text key={item.id} color={isSelected ? 'cyan' : undefined}>
                                        {isSelected ? '> ' : '  '}
                                        [{isChecked ? 'x' : ' '}] ({item.key}) {item.label}
                                    </Text>
                                );
                            })}
                        </Box>
                    </Box>
                    <Separator width={Math.floor(width * 0.8) - 4} />
                    {lastCopiedMessage && <Text color="green">✓ {lastCopiedMessage}</Text>}
                    <ActionFooter actions={[
                        { key: '↑↓', label: 'Nav' },
                        { key: 'Spc/Hotkey', label: 'Toggle' },
                        { key: 'Enter', label: 'Copy' },
                        { key: 'Esc', label: 'Close' },
                    ]}/>
                </Box>
            </Box>
        );
    };

    export default CopyScreen;
  src/stores/copy.store.ts: |-
    import { create } from 'zustand';
    import { moveIndex } from './navigation.utils';
    import { useViewStore } from './view.store';
    import { LoggerService } from '../services/logger.service';
    import { CopyService } from '../services/copy.service';
    import type { CopyItem } from '../types/copy.types';
    import type { Transaction, FileItem } from '../types/domain.types';

    export type { CopyItem };

    interface CopyState {
        title: string;
        items: CopyItem[];
        selectedIndex: number;
        selectedIds: Set<string>;
        lastCopiedMessage: string | null;
        onClose?: () => void;

        actions: {
            open: (title: string, items: CopyItem[], onClose?: () => void) => void;
            close: () => void;
            openForReview: (transaction: Transaction, files: FileItem[], selectedFile?: FileItem) => void;
            openForDetail: (transaction: Transaction, selectedFile?: FileItem) => void;
            openForHistory: (transactions: Transaction[]) => void;
            navigateUp: () => void;
            navigateDown: () => void;
            toggleSelection: () => void;
            toggleSelectionById: (id: string) => void;
            executeCopy: () => void;
        };
    }

    export const useCopyStore = create<CopyState>((set, get) => ({
        title: '',
        items: [],
        selectedIndex: 0,
        selectedIds: new Set(),
        lastCopiedMessage: null,
        onClose: undefined,

        actions: {
            open: (title, items, onClose) => {
                const defaultSelectedIds = new Set(items.filter(i => i.isDefaultSelected).map(i => i.id));
                useViewStore.getState().actions.setActiveOverlay('copy');
                set({
                    title,
                    items,
                    selectedIndex: 0,
                    selectedIds: defaultSelectedIds,
                    lastCopiedMessage: null,
                    onClose,
                });
            },
            close: () => {
                useViewStore.getState().actions.setActiveOverlay('none');
                get().onClose?.();
                set({ items: [], onClose: undefined });
            },
            openForReview: (transaction, files, selectedFile) => {
                const { actions } = get();
                const title = 'Select data to copy from review:';
                const items = CopyService.getCopyItemsForReview(transaction, files, selectedFile);
                actions.open(title, items);
            },
            openForDetail: (transaction, selectedFile) => {
                const { actions } = get();
                const title = `Select data to copy from transaction ${transaction.hash}:`;
                const items = CopyService.getCopyItemsForDetail(transaction, selectedFile);
                actions.open(title, items);
            },
            openForHistory: (transactions) => {
                const { actions } = get();
                const title = `Select data to copy from ${transactions.length} transactions:`;
                const items = CopyService.getCopyItemsForHistory(transactions);
                actions.open(title, items);
            },
            navigateUp: () => set(state => ({
                selectedIndex: moveIndex(state.selectedIndex, 'up', state.items.length),
            })),
            navigateDown: () => set(state => ({
                selectedIndex: moveIndex(state.selectedIndex, 'down', state.items.length),
            })),
            toggleSelection: () => set(state => {
                const currentItem = state.items[state.selectedIndex];
                if (!currentItem) return {};
                const newSelectedIds = new Set(state.selectedIds);
                if (newSelectedIds.has(currentItem.id)) {
                    newSelectedIds.delete(currentItem.id);
                } else {
                    newSelectedIds.add(currentItem.id);
                }
                return { selectedIds: newSelectedIds };
            }),
            toggleSelectionById: (id: string) => set(state => {
                const newSelectedIds = new Set(state.selectedIds);
                if (newSelectedIds.has(id)) {
                    newSelectedIds.delete(id);
                } else {
                    newSelectedIds.add(id);
                }
                return { selectedIds: newSelectedIds };
            }),
            executeCopy: async () => {
                const { items, selectedIds } = get();
                const itemsToCopy = items.filter(i => selectedIds.has(i.id));
                if (itemsToCopy.length === 0) return;

                LoggerService.info(`Copying ${itemsToCopy.length} item(s) to clipboard.`);
                const dataPromises = itemsToCopy.map(item => item.getData());
                const resolvedData = await Promise.all(dataPromises);

                const content = itemsToCopy
                    .map((item, index) => `--- ${item.label} ---\n${resolvedData[index]}`)
                    .join('\n\n');
                const message = `Copied ${itemsToCopy.length} item(s) to clipboard.`;
                LoggerService.debug(`[CLIPBOARD MOCK] ${message}\n${content.substring(0, 200)}...`);
                set({ lastCopiedMessage: message });
            },
        },
    }));
  src/hooks/useTransactionDetailScreen.tsx: >-
    import { useInput, type Key } from 'ink';

    import { useDetailStore } from '../stores/detail.store';

    import { useViewStore } from '../stores/view.store';

    import { useTransactionStore, selectSelectedTransaction } from
    '../stores/transaction.store';

    import { useMemo } from 'react';

    import { useCopyStore } from '../stores/copy.store';

    import { EditorService } from '../services/editor.service';


    export const useTransactionDetailScreen = () => {
        const store = useDetailStore();
        const transaction = useTransactionStore(selectSelectedTransaction);
        const files = useMemo(() => transaction?.files || [], [transaction]);

        const {
            navigateUp,
            navigateDown,
            expandOrDrillDown,
            collapseOrBubbleUp,
            toggleRevertConfirm,
            confirmRevert,
        } = store.actions;

        const openCopyMode = () => {
            if (!transaction) return;
            const { focusedItemPath } = store;
            const fileId = focusedItemPath.split('/')[1];
            const selectedFile = fileId ? files.find(f => f.id === fileId) : undefined;
            useCopyStore.getState().actions.openForDetail(transaction, selectedFile);
        };

        useInput((input: string, key: Key) => {
            if (store.bodyView === 'REVERT_CONFIRM') {
                if (key.escape) toggleRevertConfirm();
                if (key.return) confirmRevert();
                return;
            }

            // --- Main Input ---
            if (input.toLowerCase() === 'c') {
                openCopyMode();
                return;
            }
            if (input.toLowerCase() === 'u') {
                toggleRevertConfirm();
                return;
            }
            if (input.toLowerCase() === 'o') {
                if (!transaction) return;
                const { focusedItemPath } = store;
                if (focusedItemPath.includes('/')) { // Is a file
                    const fileId = focusedItemPath.split('/')[1];
                    const file = files.find(f => f.id === fileId);
                    if (file) EditorService.openFileInEditor(file.path);
                } else { // Is a section, open the transaction YAML
                    const yamlPath = EditorService.getTransactionYamlPath(transaction.hash);
                    EditorService.openFileInEditor(yamlPath);
                }
            }

            if (key.upArrow) navigateUp();
            if (key.downArrow) navigateDown();
            if (key.return || key.rightArrow) expandOrDrillDown();
            if (key.escape || key.leftArrow) collapseOrBubbleUp();
        }, { isActive: useViewStore.getState().activeOverlay === 'none' }); // Prevent input when copy overlay is open

        return {
            transaction,
            files,
            focusedItemPath: store.focusedItemPath,
            expandedItemPaths: store.expandedItemPaths,
            bodyView: store.bodyView,
        };
    };
  src/components/TransactionDetailScreen.tsx: >-
    import { Box, Text } from 'ink';

    import Separator from './Separator';

    import DiffScreen from './DiffScreen';

    import ReasonScreen from './ReasonScreen';

    import { useTransactionDetailScreen } from
    '../hooks/useTransactionDetailScreen';

    import type { FileChangeType } from '../types/domain.types';

    import ActionFooter from './ActionFooter';

    import type { ActionItem } from '../types/actions.types';


    const getFileChangeTypeIcon = (type: FileChangeType) => {
        switch (type) {
            case 'MOD': return '[MOD]';
            case 'ADD': return '[ADD]';
            case 'DEL': return '[DEL]';
            case 'REN': return '[REN]';
        }
    };


    const RevertModal = ({ transactionHash }: { transactionHash: string }) => {
        return (
            <Box 
                borderStyle="round"
                borderColor="yellow"
                flexDirection="column"
                paddingX={2}
                width="80%"
                alignSelf='center'
            >
                <Text bold color="yellow" wrap="wrap" >REVERT THIS TRANSACTION?</Text>
                <Box height={1} />
                <Text wrap="wrap">This will create a NEW transaction that reverses all changes made by {transactionHash}. The original transaction record will be preserved.</Text>
                <Box height={1} />
                <Text wrap="wrap">Are you sure?</Text>
            </Box>
        );
    };


    const TransactionDetailScreen = () => {
        const {
            transaction, files,
            focusedItemPath, expandedItemPaths, bodyView,
        } = useTransactionDetailScreen();

        if (!transaction) {
            return <Text>Loading transaction...</Text>;
        }

        const renderNavigator = () => {
            const isPromptFocused = focusedItemPath === 'PROMPT';
            const isReasoningFocused = focusedItemPath === 'REASONING';
            const isFilesFocused = focusedItemPath.startsWith('FILES');
            
            const isPromptExpanded = expandedItemPaths.has('PROMPT');
            const isReasoningExpanded = expandedItemPaths.has('REASONING');
            const isFilesExpanded = expandedItemPaths.has('FILES');
            
            return (
                <Box flexDirection="column">
                    <Text color={isPromptFocused ? 'cyan' : undefined}>
                        {isPromptFocused ? '> ' : '  '}
                        {isPromptExpanded ? '▾' : '▸'} (P)rompt
                    </Text>
                    <Text color={isReasoningFocused ? 'cyan' : undefined}>
                        {isReasoningFocused ? '> ' : '  '}
                        {isReasoningExpanded ? '▾' : '▸'} (R)easoning ({transaction.reasoning?.split('\n\n').length || 0} steps)
                    </Text>
                    <Text color={isFilesFocused ? 'cyan' : undefined}>
                        {isFilesFocused && !focusedItemPath.includes('/') ? '> ' : '  '}
                        {isFilesExpanded ? '▾' : '▸'} (F)iles ({files.length})
                    </Text>
                    {isFilesExpanded && (
                        <Box flexDirection="column" paddingLeft={2}>
                            {files.map((file) => {
                                 const fileId = `FILES/${file.id}`;
                                 const isFileSelected = focusedItemPath === fileId;
                                 const stats = file.type === 'DEL' ? '' : ` (+${file.linesAdded}/-${file.linesRemoved})`;
                                 return (
                                    <Text key={file.id} color={isFileSelected ? 'cyan' : undefined}>
                                        {isFileSelected ? '> ' : '  '}
                                        {`${getFileChangeTypeIcon(file.type)} ${file.path}${stats}`}
                                    </Text>
                                );
                            })}
                        </Box>
                    )}
                </Box>
            );
        };

        const renderBody = () => {
            if (bodyView === 'NONE') {
                return <Text color="gray">(Press → to expand a section and view its contents)</Text>;
            }
            if (bodyView === 'PROMPT') {
                return (
                    <Box flexDirection="column">
                        <Text>PROMPT</Text>
                        <Box marginTop={1}><Text>{transaction.prompt}</Text></Box>
                    </Box>
                );
            }
            if (bodyView === 'REASONING') {
                if (!transaction.reasoning) return <Text color="gray">No reasoning provided.</Text>;
                return <ReasonScreen reasoning={transaction.reasoning} />;
            }
            if (bodyView === 'FILES_LIST') {
                 return <Text color="gray">(Select a file and press → to view the diff)</Text>;
            }
            if (bodyView === 'DIFF_VIEW') {
                const fileId = focusedItemPath.split('/')[1];
                const file = files.find(f => f.id === fileId);
                if (!file) return null;
                return <DiffScreen filePath={file.path} diffContent={file.diff} isExpanded={true} />;
            }
            return null;
        };

        const renderFooter = () => {
            if (bodyView === 'REVERT_CONFIRM') {
                return <ActionFooter actions={[
                    { key: 'Enter', label: 'Confirm Revert' },
                    { key: 'Esc', label: 'Cancel' },
                ]} />;
            }
            
            const isFileFocused = focusedItemPath.includes('/');
            const baseActions: ActionItem[] = [
                { key: 'C', label: 'Copy' },
                { key: 'O', label: isFileFocused ? 'Open File' : 'Open YAML' },
                { key: 'U', label: 'Undo' },
                { key: 'Q', label: 'Quit/Back' },
            ];
            let contextualActions: ActionItem[] = [];

            if (isFileFocused) { // Is a file
                if (bodyView === 'DIFF_VIEW') {
                    contextualActions = [
                        { key: '↑↓', label: 'Nav Files' },
                        { key: '←', label: 'Back to List' },
                    ];
                } else {
                    contextualActions = [
                        { key: '↑↓', label: 'Nav Files' },
                        { key: '→', label: 'View Diff' },
                        { key: '←', label: 'Back to Sections' },
                    ];
                }
                return <ActionFooter actions={[...contextualActions, ...baseActions]} />;
            }
            
            if (expandedItemPaths.has(focusedItemPath)) {
                contextualActions = [
                    { key: '↑↓', label: 'Nav/Scroll' },
                    { key: '→', label: 'Drill In' },
                    { key: '←', label: 'Collapse' },
                ];
            } else {
                contextualActions = [
                    { key: '↑↓', label: 'Nav' },
                    { key: '→', label: 'Expand' },
                ];
            }
            return <ActionFooter actions={[...contextualActions, ...baseActions]} />;
        };

        const { message, timestamp, status } = transaction;
        const date = new Date(timestamp).toISOString().replace('T', ' ').substring(0, 19);
        const fileStats = `${files.length} Files · +${files.reduce((a, f) => a + f.linesAdded, 0)} lines, -${files.reduce((a, f) => a + f.linesRemoved, 0)} lines`;

        return (
            <Box flexDirection="column">
                {/* Header */}
                <Text>▲ relaycode transaction details</Text>
                <Separator />
                
                {/* Modal takeover for Revert */}
                {bodyView === 'REVERT_CONFIRM' && <RevertModal transactionHash={transaction.hash} />}
                
                {/* Main view */}
                <Box flexDirection="column" display={bodyView === 'REVERT_CONFIRM' ? 'none' : 'flex'}>
                    {/* Navigator Part A */}
                    <Box flexDirection="column" marginY={1}>
                        <Text>UUID: {transaction.id}</Text>
                        <Text>Git: {message}</Text>
                        <Text>Date: {date} · Status: {status}</Text>
                        <Text>Stats: {fileStats}</Text>
                    </Box>
                    
                    {/* Navigator Part B */}
                    {renderNavigator()}
                    
                    <Separator />
                    
                    {/* Body */}
                    <Box marginY={1}>
                        {renderBody()}
                    </Box>
                    
                    <Separator />
                </Box>
                
                {/* Footer */}
                <Box>
                    {renderFooter()}
                </Box>
            </Box>
        );
    };


    export default TransactionDetailScreen;
  src/hooks/useReviewScreen.tsx: >-
    import { useMemo } from 'react';

    import { useInput, type Key } from 'ink';

    import { useReviewStore } from '../stores/review.store';

    import { useAppStore } from '../stores/app.store';

    import { useCopyStore } from '../stores/copy.store';

    import { useTransactionStore, selectSelectedTransaction } from
    '../stores/transaction.store';

    import type { FileItem } from '../types/domain.types';


    type NavigableItem =
        | { type: 'prompt' }
        | { type: 'reasoning' }
        | { type: 'script'; id: string }
        | { type: 'file'; id: string };

    export const useReviewScreen = () => {
        const store = useReviewStore();
        const {
            selectedItemIndex,
            bodyView,
            patchStatus,
            selectedBulkRepairOptionIndex,
            selectedBulkInstructOptionIndex,
        } = store;

        const transaction = useTransactionStore(selectSelectedTransaction);
        const { showDashboardScreen } = useAppStore(s => s.actions);

        const navigableItems = useMemo((): NavigableItem[] => {
            if (!transaction) return [];
            const scriptItems: NavigableItem[] = (transaction.scripts || []).map(s => ({ type: 'script', id: s.command }));
            const fileItems: NavigableItem[] = (transaction.files || []).map(f => ({ type: 'file', id: f.id }));
            return [{ type: 'prompt' }, { type: 'reasoning' }, ...scriptItems, ...fileItems];
        }, [transaction]);

        // Memoize files to prevent re-renders, fixing the exhaustive-deps lint warning.
        const files: FileItem[] = useMemo(() => transaction?.files || [], [transaction]);
        const fileReviewStates = useReviewStore(s => s.fileReviewStates);

        const reviewStats = useMemo(() => {
            const approvedFiles = files.filter(f => fileReviewStates.get(f.id)?.status === 'APPROVED');
            return {
                totalFiles: files.length,
                totalLinesAdded: files.reduce((sum, f) => sum + f.linesAdded, 0),
                totalLinesRemoved: files.reduce((sum, f) => sum + f.linesRemoved, 0),
                numFiles: files.length,
                approvedFilesCount: approvedFiles.length,
            };
        }, [files, fileReviewStates]);

        const hasRejectedFiles = useMemo(() => {
            if (!fileReviewStates) return false;
            return Array.from(fileReviewStates.values()).some(s => s.status === 'REJECTED');
        }, [fileReviewStates]);

        const { approvedFilesCount } = reviewStats;

        const isFileSelected = navigableItems[selectedItemIndex]?.type === 'file';

        const scripts = transaction?.scripts || [];

        const {
            moveSelectionUp,
            moveSelectionDown,
            expandDiff,
            toggleBodyView,
            setBodyView,
            startApplySimulation,
            approve,
            tryRepairFile,
            tryInstruct,
            showBulkRepair,
            showBulkInstruct,
            executeBulkRepairOption,
            executeBulkInstructOption,
            confirmHandoff,
            scrollReasoningUp,
            scrollReasoningDown,
            navigateScriptErrorUp,
            navigateScriptErrorDown,
            toggleFileApproval,
            rejectAllFiles,
            navigateBulkRepairUp,
            navigateBulkRepairDown,
            navigateBulkInstructUp,
            navigateBulkInstructDown,
        } = store.actions;

        const openCopyMode = () => {
            if (!transaction) return;
            const currentItem = navigableItems[selectedItemIndex];
            const selectedFile = currentItem?.type === 'file' ? files.find(f => f.id === currentItem.id) : undefined;
            useCopyStore.getState().actions.openForReview(transaction, transaction.files || [], selectedFile);
        };

        // --- Input Handlers ---

        const handleGlobalInput = (input: string, key: Key): boolean => {
            if (input === '1') { // For demo purposes
                startApplySimulation('success'); return true;
            }
            if (input === '2') { // For demo purposes
                startApplySimulation('failure'); return true;
            }
            // The 'q' (quit/back) is now handled by the global hotkey hook.

            if (key.escape) {
                if (bodyView === 'bulk_repair' || bodyView === 'confirm_handoff' || bodyView === 'bulk_instruct') {
                    toggleBodyView(bodyView);
                } else if (bodyView !== 'none') {
                    setBodyView('none');
                }
                return true;
            }
            return false;
        };

        const handleHandoffConfirmInput = (_input: string, key: Key): void => {
            if (key.return) confirmHandoff();
        };

        const handleBulkRepairInput = (input: string, key: Key): void => {
            if (key.upArrow) navigateBulkRepairUp();
            if (key.downArrow) navigateBulkRepairDown();
            if (key.return) {
                executeBulkRepairOption(selectedBulkRepairOptionIndex + 1); // Options are 1-based
                return;
            }

            if (input >= '1' && input <= '4') {
                executeBulkRepairOption(parseInt(input));
            }
        };
        
        const handleBulkInstructInput = (input: string, key: Key): void => {
            if (key.upArrow) navigateBulkInstructUp();
            if (key.downArrow) navigateBulkInstructDown();
            if (key.return) {
                executeBulkInstructOption(selectedBulkInstructOptionIndex + 1); // Options are 1-based
                return;
            }

            if (input >= '1' && input <= '3') {
                executeBulkInstructOption(parseInt(input));
            }
        };

        const handleReasoningInput = (input: string, key: Key): void => {
            if (key.upArrow) scrollReasoningUp();
            if (key.downArrow) scrollReasoningDown();
            if (input.toLowerCase() === 'r') toggleBodyView('reasoning');
        };

        const handleScriptOutputInput = (input: string, key: Key): void => {
            if (input.toLowerCase() === 'j') navigateScriptErrorDown();
            if (input.toLowerCase() === 'k') navigateScriptErrorUp();
            if (key.return) toggleBodyView('script_output');
            if (input.toLowerCase() === 'c') { // TODO: this copy logic is not great.
                const currentItem = navigableItems[selectedItemIndex];
                const selectedScript = currentItem?.type === 'script' ? scripts.find(s => s.command === currentItem.id) : undefined;
                if (selectedScript) {
                    // eslint-disable-next-line no-console
                    console.log(`[CLIPBOARD] Copied script output: ${selectedScript.command}`);
                }
            }
        };

        const handleDiffInput = (input: string) => {
            if (input.toLowerCase() === 'x') expandDiff();
            if (input.toLowerCase() === 'd') toggleBodyView('diff');
        };

        const handleMainNavigationInput = (input: string, key: Key): void => {
            // Handle Shift+R for reject all
            if (key.shift && input.toLowerCase() === 'r') {
                if (approvedFilesCount > 0 && transaction) {
                    rejectAllFiles();
                }
                return;
            }

            // Main View Navigation
            if (key.upArrow) moveSelectionUp(navigableItems.length);
            if (key.downArrow) moveSelectionDown(navigableItems.length);

            const currentItem = navigableItems[selectedItemIndex];

            if (input === ' ') {
                if (currentItem?.type === 'file') {
                    const fileState = fileReviewStates.get(currentItem.id);
                    if (fileState && fileState.status !== 'FAILED') {
                        toggleFileApproval(currentItem.id);
                    }
                }
            }

            if (input.toLowerCase() === 'd' && currentItem?.type === 'file') {
                toggleBodyView('diff');
            }

            if (input.toLowerCase() === 'r') {
                toggleBodyView('reasoning');
            }

            if (key.return) { // Enter key
                if (currentItem?.type === 'file') {
                    toggleBodyView('diff');
                } else if (currentItem?.type === 'reasoning') {
                    toggleBodyView('reasoning');
                } else if (currentItem?.type === 'script') {
                    toggleBodyView('script_output');
                }
            }

            if (input.toLowerCase() === 'a') {
                if (approvedFilesCount > 0) {
                    approve();
                    showDashboardScreen();
                }
            }

            if (input.toLowerCase() === 'c') {
                openCopyMode();
            }

            if (input.toLowerCase() === 't') {
                if (key.shift) {
                    const hasFailedFiles = Array.from(fileReviewStates.values()).some(s => s.status === 'FAILED');
                    if (hasFailedFiles) showBulkRepair();
                } else if (currentItem?.type === 'file') {
                    const fileState = fileReviewStates.get(currentItem.id);
                    if (fileState?.status === 'FAILED') tryRepairFile(currentItem.id);
                }
            }

            if (input.toLowerCase() === 'i') {
                if (key.shift) {
                    if (hasRejectedFiles) showBulkInstruct();
                } else if (currentItem?.type === 'file') {
                    const fileState = fileReviewStates.get(currentItem.id);
                    if (fileState?.status === 'REJECTED') {
                        tryInstruct(currentItem.id);
                    }
                }
            }
        };

        useInput((input: string, key: Key) => {
            if (handleGlobalInput(input, key)) {
                return;
            }

            switch (bodyView) {
                case 'confirm_handoff': return handleHandoffConfirmInput(input, key);
                case 'bulk_repair': return handleBulkRepairInput(input, key);
                case 'bulk_instruct': return handleBulkInstructInput(input, key);
                case 'reasoning': return handleReasoningInput(input, key);
                case 'script_output': return handleScriptOutputInput(input, key);
                case 'diff': return handleDiffInput(input);
                default: return handleMainNavigationInput(input, key);
            }
        });

        return {
            ...store,
            fileReviewStates,
            selectedItemIndex,
            transaction,
            files,
            scripts,
            patchStatus,
            navigableItems,
            isFileSelected,
            selectedBulkRepairOptionIndex,
            selectedBulkInstructOptionIndex,
            ...reviewStats,
            hasRejectedFiles,
        };
    };
  src/components/ReviewScreen.tsx: >-
    import { Box, Text } from 'ink';

    import Separator from './Separator';

    import DiffScreen from './DiffScreen';

    import ReasonScreen from './ReasonScreen';

    import type { ScriptResult, FileItem, FileChangeType } from
    '../types/domain.types';

    import { useReviewScreen } from '../hooks/useReviewScreen';

    import ActionFooter from './ActionFooter';

    import type { ActionItem } from '../types/actions.types';


    // --- Sub-components ---


    const FileItemRow = ({ file, reviewStatus, reviewError, reviewDetails,
    isFocused }: {
        file: FileItem;
        reviewStatus: string;
        reviewError?: string;
        reviewDetails?: string;
        isFocused: boolean;
    }) => {
        let icon;
        let iconColor;
        switch (reviewStatus) {
            case 'APPROVED': icon = '[✓]'; iconColor = 'green'; break;
            case 'REJECTED': icon = '[✗]'; iconColor = 'red'; break;
            case 'FAILED': icon = '[!]'; iconColor = 'red'; break;
            case 'AWAITING': icon = '[●]'; iconColor = 'yellow'; break;
            case 'RE_APPLYING': icon = '[●]'; iconColor = 'cyan'; break;
        }

        const typeColor = (type: FileChangeType) => {
            switch (type) {
                case 'ADD': return 'green';
                case 'DEL': return 'red';
                case 'REN': return 'yellow';
                default: return 'white';
            }
        };

        const diffStats = <Text>(+<Text color="green">{file.linesAdded}</Text>/-<Text color="red">{file.linesRemoved}</Text>)</Text>;
        const strategy = file.strategy === 'standard-diff' ? 'diff' : file.strategy;
        const prefix = isFocused ? '> ' : '  ';
        const colorProps = isFocused ? { bold: true, color: 'cyan' } : {};

        if (reviewStatus === 'FAILED') {
            return (
                <Box>
                    <Text {...colorProps}>
                        {prefix}<Text color={iconColor}>{icon} FAILED {file.path}</Text>
                        <Text color="red">    ({reviewError})</Text>
                    </Text>
                </Box>
            );
        }

        if (reviewStatus === 'AWAITING') {
            return (
                <Box>
                    <Text {...colorProps}>
                        {prefix}<Text color={iconColor}>{icon} AWAITING {file.path}</Text>
                        <Text color="yellow">    ({reviewDetails})</Text>
                    </Text>
                </Box>
            );
        }

        if (reviewStatus === 'RE_APPLYING') {
            return (
                 <Box>
                    <Text {...colorProps}>
                        {prefix}<Text color={iconColor}>{icon} RE-APPLYING... {file.path}</Text>
                        <Text color="cyan"> (using &apos;replace&apos; strategy)</Text>
                    </Text>
                </Box>
            );
        }

        return (
            <Box>
                <Text {...colorProps}>
                    {prefix}<Text color={iconColor}>{icon}</Text> {file.type}{' '}
                    <Text color={typeColor(file.type)}>{file.path}</Text>{' '}
                    {diffStats} [{strategy}]
                </Text>
            </Box>
        );
    };


    const ScriptItemRow = ({
        script,
        isSelected,
        isExpanded,
    }: {
        script: ScriptResult;
        isSelected: boolean;
        isExpanded: boolean;
    }) => {
        const icon = script.success ? '✓' : '✗';
        const iconColor = script.success ? 'green' : 'red';
        const arrow = isExpanded ? '▾' : '▸';
        const prefix = isSelected ? '> ' : '  ';
        
        // Extract script type from command (e.g., "bun run test" -> "Post-Command", "bun run lint" -> "Linter")
        const scriptType = script.command.includes('test') ? 'Post-Command' : 
                          script.command.includes('lint') ? 'Linter' : 
                          'Script';

        return (
            <Box>
                <Text bold={isSelected} color={isSelected ? 'cyan' : undefined}>
                    {prefix}<Text color={iconColor}>{icon}</Text> {scriptType}: `{script.command}` ({script.duration}s) {arrow}{' '}
                    {script.summary}
                </Text>
            </Box>
        );
    };


    // --- Main Component ---


    const ReviewScreen = () => {
        const {
            transaction,
            files,
            scripts = [],
            patchStatus,
            selectedItemIndex,
            bodyView,
            isDiffExpanded,
            reasoningScrollIndex,
            scriptErrorIndex,
            fileReviewStates,
            numFiles,
            approvedFilesCount,
            totalLinesAdded,
            totalLinesRemoved,
            selectedBulkRepairOptionIndex,
            selectedBulkInstructOptionIndex,
            navigableItems,
            hasRejectedFiles,
        } = useReviewScreen();

        if (!transaction) {
            return <Text>Loading review...</Text>;
        }
        const { hash, message, prompt = '', reasoning = '' } = transaction;

        const renderBody = () => {
            if (bodyView === 'none') return null;

            if (bodyView === 'reasoning') {
                const reasoningText = reasoning || '';
                const reasoningLinesCount = reasoningText.split('\n').length;
                const visibleLinesCount = 10;
                return (
                    <Box flexDirection="column">
                        <ReasonScreen
                            reasoning={reasoningText}
                            scrollIndex={reasoningScrollIndex}
                            visibleLinesCount={visibleLinesCount}
                        />
                        {reasoningLinesCount > visibleLinesCount && (
                            <Text color="gray">
                                Showing lines {reasoningScrollIndex + 1}-{Math.min(reasoningScrollIndex + visibleLinesCount, reasoningLinesCount)}{' '}
                                of {reasoningLinesCount}
                            </Text>
                        )}
                    </Box>
                );
            }
            
            if (bodyView === 'diff') {
                const currentItem = navigableItems[selectedItemIndex];
                const selectedFile = currentItem?.type === 'file' ? files.find(f => f.id === currentItem.id) : undefined;
                if (!selectedFile) return null;
                return (
                    <DiffScreen
                        filePath={selectedFile.path}
                        diffContent={selectedFile.diff}
                        isExpanded={isDiffExpanded}
                    />
                );
            }

            if (bodyView === 'script_output') {
                 const currentItem = navigableItems[selectedItemIndex];
                 const scriptItems = navigableItems.filter((i): i is { type: 'script'; id: string } => i.type === 'script');
                 const scriptIndex = currentItem?.type === 'script'
                    ? scriptItems.findIndex(i => i.id === currentItem.id)
                    : -1;
                 const selectedScript = scripts[scriptIndex] || null;
                 if (!selectedScript) return null;
                 
                 const outputLines = selectedScript.output.split('\n');
                 const errorLines = outputLines.filter((line: string) =>
                    line.includes('Error') || line.includes('Warning'),
                 );
                 
                 return (
                    <Box flexDirection="column">
                        <Text>{selectedScript.command.includes('lint') ? 'LINTER' : 'SCRIPT'} OUTPUT: `{selectedScript.command}`</Text>
                        <Box marginTop={1} flexDirection="column">
                            {outputLines.map((line: string, index: number) => {
                                const isError = line.includes('Error');
                                const isWarning = line.includes('Warning');
                                const isHighlighted = errorLines[scriptErrorIndex] === line;
                                
                                return (
                                    <Text 
                                        key={index} 
                                        color={isError ? 'red' : isWarning ? 'yellow' : undefined}
                                        bold={isHighlighted}
                                        backgroundColor={isHighlighted ? 'blue' : undefined}
                                    >
                                        {line}
                                    </Text>
                                );
                            })}
                        </Box>
                        {errorLines.length > 0 && (
                            <Text color="gray">
                                Error {scriptErrorIndex + 1} of {errorLines.length} highlighted
                            </Text>
                        )}
                    </Box>
                 );
            }

            if (bodyView === 'confirm_handoff') {
                return (
                    <Box flexDirection="column" gap={1}>
                        <Text bold>HANDOFF TO EXTERNAL AGENT</Text>
                        <Box flexDirection="column">
                            <Text>This action will:</Text>
                            <Text>1. Copy a detailed prompt to your clipboard for an agentic AI.</Text>
                            <Text>2. Mark the current transaction as &apos;Handoff&apos; and close this review.</Text>
                            <Text>3. Assume that you and the external agent will complete the work.</Text>
                        </Box>
                        <Text>Relaycode will NOT wait for a new patch. This is a final action.</Text>
                        <Text bold color="yellow">Are you sure you want to proceed?</Text>
                    </Box>
                );
            }

            if (bodyView === 'bulk_repair') {
                const failedFiles = files.filter((f: FileItem) => fileReviewStates.get(f.id)?.status === 'FAILED');
                const repairOptions = [
                    '(1) Copy Bulk Re-apply Prompt (for single-shot AI)',
                    '(2) Bulk Change Strategy & Re-apply',
                    '(3) Handoff to External Agent',
                    '(4) Bulk Abandon All Failed Files',
                    '(Esc) Cancel',
                ];

                return (
                    <Box flexDirection="column" gap={1}>
                        <Text bold>BULK REPAIR ACTION</Text>

                        <Box flexDirection="column">
                            <Text>The following {failedFiles.length} files failed to apply:</Text>
                            {failedFiles.map((file: FileItem) => (
                                <Text key={file.id}>- {file.path}</Text>
                            ))}
                        </Box>

                        <Text>How would you like to proceed?</Text>

                        <Box flexDirection="column">
                            {repairOptions.map((opt, i) => (
                                <Text key={i} color={selectedBulkRepairOptionIndex === i ? 'cyan' : undefined}>
                                    {selectedBulkRepairOptionIndex === i ? '> ' : '  '}
                                    {opt}
                                </Text>
                            ))}
                        </Box>
                    </Box>
                );
            }

            if (bodyView === 'bulk_instruct') {
                const rejectedFiles = files.filter((f: FileItem) => fileReviewStates.get(f.id)?.status === 'REJECTED');
                const instructOptions = [
                    '(1) Copy Bulk Re-instruct Prompt (for single-shot AI)',
                    '(2) Handoff to External Agent',
                    '(3) Bulk Un-reject All Files (revert to original)',
                    '(4) Cancel',
                ];

                return (
                    <Box flexDirection="column" gap={1}>
                        <Text bold>BULK INSTRUCTION ACTION</Text>

                        <Box flexDirection="column">
                            <Text>The following {rejectedFiles.length} files were rejected:</Text>
                            {rejectedFiles.map((file: FileItem) => (
                                <Text key={file.id}>- {file.path}</Text>
                            ))}
                        </Box>
                        <Box flexDirection="column" marginTop={1}>
                            {instructOptions.map((opt, i) => (
                                <Text key={i} color={selectedBulkInstructOptionIndex === i ? 'cyan' : undefined}>
                                    {selectedBulkInstructOptionIndex === i ? '> ' : '  '}
                                    {opt}
                                </Text>
                            ))}
                        </Box>
                    </Box>
                );
            }

            return null;
        };

        const renderFooter = () => {
            // Contextual footer for body views
            if (bodyView === 'diff') {
                return <ActionFooter actions={[
                    { key: '↑↓', label: 'Nav' },
                    { key: 'X', label: 'Expand' },
                    { key: 'D/Esc', label: 'Back' },
                ]}/>;
            }
            if (bodyView === 'reasoning') {
                return <ActionFooter actions={[
                    { key: '↑↓', label: 'Scroll Text' },
                    { key: 'R', label: 'Collapse View' },
                    { key: 'C', label: 'Copy Mode' },
                ]}/>;
            }
            if (bodyView === 'script_output') {
                return <ActionFooter actions={[
                    { key: '↑↓', label: 'Nav' },
                    { key: 'J↓/K↑', label: 'Next/Prev Error' },
                    { key: 'C', label: 'Copy Output' },
                    { key: 'Ent/Esc', label: 'Back' },
                ]}/>;
            }
            if (bodyView === 'bulk_repair') {
                return <Text>Use (↑↓) Nav · (Enter) Select · (1-4) Jump · (Esc) Cancel</Text>;
            }
            if (bodyView === 'bulk_instruct') {
                return <Text>Use (↑↓) Nav · (Enter) Select · (1-4) Jump · (Esc) Cancel</Text>;
            }
            if (bodyView === 'confirm_handoff') {
                return <ActionFooter actions={[
                    { key: 'Enter', label: 'Confirm Handoff' },
                    { key: 'Esc', label: 'Cancel' },
                ]}/>;
            }

            // Main footer
            const actions: ActionItem[] = [{ key: '↑↓', label: 'Nav' }];

            const currentItem = navigableItems[selectedItemIndex];
            
            if (currentItem?.type === 'file') {
                const selectedFile = files.find(f => f.id === currentItem.id);
                const fileState = fileReviewStates.get(currentItem.id);
                if (fileState?.status !== 'FAILED') {
                    actions.push({ key: 'Spc', label: 'Toggle' });
                }
                actions.push({ key: 'D', label: 'Diff' });
                
                // Add repair options for failed files
                if (selectedFile && fileState?.status === 'FAILED') {
                    actions.push({ key: 'T', label: 'Try Repair' });
                }
                if (selectedFile && fileState?.status === 'REJECTED') {
                    actions.push({ key: 'I', label: 'Instruct' });
                }
            } else if (currentItem?.type === 'script') {
                actions.push({ key: 'Ent', label: 'Expand Details' });
            } else { // Prompt or Reasoning
                actions.push({ key: 'Ent', label: 'Expand' });
            }

            if (currentItem?.type !== 'reasoning') {
                actions.push({ key: 'R', label: 'Reasoning' });
            }

            // Add bulk repair if there are failed files
            const hasFailedFiles = Array.from(fileReviewStates.values()).some(s => s.status === 'FAILED');
            if (hasFailedFiles) {
                actions.push({ key: 'Shift+T', label: 'Bulk Repair' });
            }
            // Add bulk instruct if there are rejected files
            if (hasRejectedFiles) {
                actions.push({ key: 'Shift+I', label: 'Bulk Instruct' });
            }
            
            actions.push({ key: 'C', label: 'Copy' });

            if (approvedFilesCount > 0) {
                actions.push({ key: 'A', label: 'Approve' });
            }

            if (Array.from(fileReviewStates.values()).some(s => s.status === 'APPROVED' || s.status === 'FAILED')) {
                actions.push({ key: 'Shift+R', label: 'Reject All' });
            }
            actions.push({ key: 'Q', label: 'Quit' });

            return <ActionFooter actions={actions} />;
        };

        return (
            <Box flexDirection="column">
                {/* Header */}
                <Text color="cyan">▲ relaycode review</Text>
                <Separator />
                
                {/* Navigator Section */}
                <Box flexDirection="column" marginY={1}>
                    <Box flexDirection="column">
                        <Text>{hash} · {message}</Text>
                        <Text>
                            (<Text color="green">+{totalLinesAdded}</Text>/<Text color="red">-{totalLinesRemoved}</Text>) · {numFiles} Files · {approvedFilesCount}/{numFiles} Approved
                            {patchStatus === 'PARTIAL_FAILURE' && scripts.length === 0 && <Text> · Scripts: SKIPPED</Text>}
                            {patchStatus === 'PARTIAL_FAILURE' && <Text color="red" bold> · MULTIPLE PATCHES FAILED</Text>}
                        </Text>
                    </Box>

                    <Box flexDirection="column" marginTop={1}>
                        <Text color={navigableItems[selectedItemIndex]?.type === 'prompt' ? 'cyan' : undefined}>
                            {navigableItems[selectedItemIndex]?.type === 'prompt' ? '> ' : '  '}
                            (P)rompt ▸ {(prompt || '').substring(0, 60)}...
                        </Text>
                        <Text color={navigableItems[selectedItemIndex]?.type === 'reasoning' ? 'cyan' : undefined}>
                            {navigableItems[selectedItemIndex]?.type === 'reasoning' ? '> ' : '  '}
                            (R)easoning ({(reasoning || '').split('\n\n').length} steps) {bodyView === 'reasoning' ? '▾' : '▸'}{' '}
                            {((reasoning || '').split('\n')[0] ?? '').substring(0, 50)}...
                        </Text>
                    </Box>
                </Box>

                <Separator />

                {/* Script Results (if any) */}
                {scripts.length > 0 && navigableItems.some(i => i.type === 'script') && (
                    <>
                        <Box flexDirection="column" marginY={1}>
                            {scripts.map((script: ScriptResult) => (
                                (() => {
                                    const navItemIndex = navigableItems.findIndex(i => {
                                        if (i.type === 'script') {
                                            return i.id === script.command;
                                        }
                                        return false;
                                    });
                                    const isSelected = selectedItemIndex === navItemIndex;
                                    return (
                                        <ScriptItemRow
                                            key={script.command}
                                            script={script}
                                            isSelected={isSelected}
                                            isExpanded={bodyView === 'script_output' && isSelected}
                                        />
                                    );
                                })()
                            ))}
                        </Box>
                        <Separator />
                    </>
                )}

                {/* Files Section */}
                <Box flexDirection="column" marginY={1}>
                    <Text bold>FILES</Text>
                    {files.map((file: FileItem) => {
                        const navItemIndex = navigableItems.findIndex(i => {
                            if (i.type === 'file') {
                                return i.id === file.id;
                            }
                            return false;
                        });
                        const isFocused = selectedItemIndex === navItemIndex;
                        const reviewState = fileReviewStates.get(file.id);
                        return (
                            <FileItemRow
                                key={file.id}
                                file={file}
                                isFocused={isFocused}
                                reviewStatus={reviewState?.status || 'AWAITING'}
                                reviewError={reviewState?.error}
                                reviewDetails={reviewState?.details}
                            />
                        );
                    })}
                </Box>
                
                <Separator />
                
                {/* Body Viewport */}
                {bodyView !== 'none' && (
                    <>
                        <Box marginY={1}>
                            {renderBody()}
                        </Box>
                        <Separator />
                    </>
                )}

                {/* Footer */}
                <Box>
                    {renderFooter()}
                </Box>
            </Box>
        );
    };


    export default ReviewScreen;
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 152
