uuid: eed9452b-c0ca-4b09-b6bb-37597334b07f
projectId: relaycode-tui
createdAt: '2025-09-26T00:39:09.280Z'
gitCommitMsg: >-
  refactor(constants): extract all hardcoded strings and constants

  Centralizes application constants, UI configurations, and static text into the
  `src/constants` and `src/config` directories. This comprehensive refactoring
  eliminates magic strings and numbers across components, hooks, and services.

  - Creates new constant files for each primary feature area (Dashboard, Debug,
  History, Commit, Splash, etc.). - Moves static `layoutConfig` objects from
  hooks into `ui.config.ts`. - Moves prompt generation logic from
  `review.service.ts` into `review.constants.ts`. - Refactors all relevant files
  to import and use the new centralized constants. - Improves maintainability
  and code clarity by providing a single source of truth for static values.
promptSummary: The user requested to extract all constants into dedicated constants files.
reasoning:
  - Executing the refactoring plan to centralize constants and configurations.
  - >-
    First, I will create the new constant files to establish the single sources
    of truth.
  - Next, I'll augment the existing constants files and the UI config.
  - Now I will refactor all the application files to use these new constants.
  - >-
    I have created all new files and applied all patches. This completes the
    refactoring as requested.
operations:
  - type: write
    path: src/constants/commit.constants.ts
    content: |-
      import type { ActionItem } from '../types/actions.types';

      export const SCREEN_TITLE = '▲ relaycode git commit';

      export const TEXTS = {
          TRANSACTIONS_INCLUDED: 'TRANSACTIONS INCLUDED',
          FINAL_COMMIT_MESSAGE: 'FINAL COMMIT MESSAGE',
          GIT_COMMAND_INFO: 'This will run \'git add .\' and \'git commit\' with the message above.',
          COUNT_PREFIX: (count: number) => `Found ${count} new transactions to commit since last git commit.`,
      };

      export const FOOTER_ACTIONS: ActionItem[] = [
          { key: 'Enter', label: 'Confirm & Commit' },
          { key: 'Esc', label: 'Cancel' },
      ];
    patchStrategy: replace
  - type: write
    path: src/constants/dashboard.constants.ts
    content: |-
      import type { ActionItem } from '../types/actions.types';

      export const SCREEN_TITLE = '▲ relaycode dashboard';
      export const EVENT_STREAM_HEADER = ' EVENT STREAM (Last 15 minutes)';

      export const getFooterActions = (isPaused: boolean): ActionItem[] => [
          { key: '↑↓', label: 'Nav' },
          { key: '→/Ent', label: 'View' },
          { key: '←', label: 'Collapse' },
          { key: 'L', label: 'Log' },
          { key: 'A', label: 'Approve All' },
          { key: 'C', label: 'Commit' },
          { key: 'P', label: isPaused ? 'Resume' : 'Pause' },
          { key: 'Q', label: 'Quit' },
      ];

      export const MODAL_FOOTER_ACTIONS: ActionItem[] = [
          { key: 'Enter', label: 'Confirm' },
          { key: 'Esc', label: 'Cancel' },
      ];
    patchStrategy: replace
  - type: write
    path: src/constants/debug.constants.ts
    content: |-
      import type { ActionItem } from '../types/actions.types';

      export const LOG_SCREEN_TITLE = '▲ relaycode · DEBUG LOG';
      export const MENU_SCREEN_TITLE = '▲ relaycode · DEBUG MENU';

      export const LOG_LEVEL_COLORS = {
          DEBUG: 'gray',
          INFO: 'white',
          WARN: 'yellow',
          ERROR: 'red',
      };

      export const LOG_LEVEL_TAGS = {
          DEBUG: { color: 'white', backgroundColor: 'gray' },
          INFO: { color: 'black', backgroundColor: 'cyan' },
          WARN: { color: 'black', backgroundColor: 'yellow' },
          ERROR: { color: 'white', backgroundColor: 'red' },
      };

      export const LOG_FOOTER_ACTIONS = {
          FILTER: [{ key: 'Enter/Esc', label: 'Apply & Close Filter' }],
          LIST: [
              { key: '↑↓/PgUp/PgDn', label: 'Scroll' },
              { key: 'F', label: 'Filter' },
              { key: 'C', label: 'Clear' },
              { key: 'Esc/Ctrl+L', label: 'Close' },
          ],
      };

      export const MENU_FOOTER_ACTIONS: ActionItem[] = [
          { key: '↑↓/PgUp/PgDn', label: 'Nav' },
          { key: '1-9,a-z', label: 'Jump' },
          { key: 'Enter', label: 'Select' },
          { key: 'Esc/Ctrl+B', label: 'Close' },
      ];

      export const MOCK_CLIPBOARD_CONTENTS = [
          'feat(dashboard): implement new UI components',
          'const clipboardy = require(\'clipboardy\');',
          'diff --git a/src/App.tsx b/src/App.tsx\nindex 12345..67890 100644\n--- a/src/App.tsx\n+++ b/src/App.tsx\n@@ -1,5 +1,6 @@\n import React from \'react\';',
          'All changes have been applied successfully. You can now commit them.',
          '{\n  "id": "123",\n  "status": "PENDING"\n}',
          'Can you refactor this to use a switch statement?',
      ];

      export const DEBUG_COMMAND = 'debug-screen';
      export const DEBUG_SCREENS = {
          DASHBOARD: 'DashboardScreen',
          GIT_COMMIT: 'GitCommitScreen',
          REVIEW_PROCESSING: 'ReviewProcessingScreen',
          REVIEW: 'ReviewScreen',
          TRANSACTION_DETAIL: 'TransactionDetailScreen',
          TRANSACTION_HISTORY: 'TransactionHistoryScreen',
          INITIALIZATION: 'InitializationScreen',
          SPLASH: 'SplashScreen',
          DEBUG_MENU: 'DebugMenu',
          DEBUG_LOG: 'DebugLogScreen',
      } as const;
    patchStrategy: replace
  - type: write
    path: src/constants/history.constants.ts
    content: >-
      import { Text } from 'ink';

      import type { ActionItem } from '../types/actions.types';


      export const SCREEN_TITLE = '▲ relaycode transaction history';


      export const STATUS_MAP = {
          COMMITTED: <Text color="green">✓ Committed</Text>,
          HANDOFF: <Text color="magenta">→ Handoff</Text>,
          REVERTED: <Text color="gray">↩ Reverted</Text>,
          APPLIED: <Text color="blue">✓ Applied</Text>,
          PENDING: <Text color="yellow">? Pending</Text>,
          FAILED: <Text color="red">✗ Failed</Text>,
      } as const;


      export const TYPE_MAP = { MOD: '[MOD]', ADD: '[ADD]', DEL: '[DEL]', REN:
      '[REN]' } as const;


      export const BULK_ACTIONS_MODAL_TEXTS = {
          TITLE: (count: number) => `PERFORM BULK ACTION ON ${count} SELECTED ITEMS`,
          WARNING: 'This action is often irreversible. Are you sure?',
          OPTIONS: [
              '(1) Revert Selected Transactions',
              '(2) Mark as \'Git Committed\'',
              '(3) Delete Selected Transactions (from Relaycode history)',
              '(Esc) Cancel',
          ],
      };


      export const FOOTER_TEXTS = {
          FILTER_MODE: '(Enter) Apply Filter & Return      (Esc) Cancel',
          BULK_MODE: 'Choose an option [1-3] or (Esc) Cancel',
      };


      export const getListFooterActions = (openActionLabel: string,
      hasSelection: boolean): ActionItem[] => {
          const actions: ActionItem[] = [
              { key: '↑↓/PgUp/PgDn', label: 'Nav' },
              { key: '→', label: 'Expand' },
              { key: '←', label: 'Collapse' },
              { key: 'Spc', label: 'Select' },
              { key: 'Ent', label: 'Details' },
              { key: 'O', label: openActionLabel },
              { key: 'F', label: 'Filter' },
          ];

          if (hasSelection) {
              actions.push({ key: 'C', label: 'Copy' }, { key: 'B', label: 'Bulk' });
          }
          return actions;
      };
    patchStrategy: replace
  - type: write
    path: src/constants/log.constants.ts
    content: export const MAX_LOGS = 200;
    patchStrategy: replace
  - type: write
    path: src/constants/splash.constants.ts
    content: >-
      export const SCREEN_TITLE = '▲ relaycode';

      export const LOGO = `
               ░█▀▄░█▀▀░█░░░█▀█░█░█░█▀▀░█▀█░█▀▄░█▀▀
               ░█▀▄░█▀▀░█░░░█▀█░░█░░█░░░█░█░█░█░█▀▀
               ░▀░▀░▀▀▀░▀▀▀░▀▀▀░▀▀▀░▀░▀░░▀░░▀▀▀░▀▀▀
      `;

      export const TAGLINE_PRIMARY = 'A zero-friction, AI-native patch engine.';

      export const TAGLINE_SECONDARY = 'Built by Arman and contributors ·
      https://relay.noca.pro';
    patchStrategy: replace
  - type: write
    path: src/config/ui.config.ts
    content: >+
      --- src/config/ui.config.ts

      +++ src/config/ui.config.ts

      @@ -8,10 +8,12 @@
           },
           dashboard: {
               reservedRows: 9, // Non-event stream vertical space (header, footer, etc.)
      +        layout: { header: 1, separators: 2, fixedRows: 2, marginsY: 3,
      footer: 2 },
           },
           history: {
               reservedRows: 8, // Non-content vertical space (header, footer, filter)
      +        layout: { header: 1, separators: 2, fixedRows: 1, marginsY: 1,
      footer: 2 },
           },
           splash: {
               initialCountdown: 3, // Seconds before auto-skip
      @@ ... @@
           footer: {
               horizontalPadding: 2, // Minimum space from the left/right edges of the screen
               actionSeparator: ' · ',
           },
      +    copyScreen: {

      +        layout: { header: 1, separators: 2, fixedRows: 2, marginsY: 1,
      footer: 1 },

      +    },

      +    debugLog: {

      +        layout: { paddingY: 2, header: 1, separators: 2, fixedRows: 1,
      marginsY: 1, footer: 1 },

      +    },

      +    debugMenu: {

      +        layout: { paddingY: 2, header: 1, separators: 2, footer: 1 },

      +    },
       } as const;

    patchStrategy: standard-diff
  - type: write
    path: src/constants/copy.constants.ts
    content: |+
      --- src/constants/copy.constants.ts
      +++ src/constants/copy.constants.ts
      @@ -1,5 +1,7 @@
       /**
        * Constants for the Copy/Clipboard feature.
        */
      +import type { ActionItem } from '../types/actions.types';
      +
       export const COPYABLE_ITEMS = {
           UUID: 'UUID',
           MESSAGE: 'Git Message',
      @@ ... @@
           DIFFS: 'Diffs',
           UUIDS: 'UUIDs',
       } as const;
      +
      +export const SCREEN_TITLE = '▲ relaycode · copy mode';
      +
      +export const FOOTER_ACTIONS: ActionItem[] = [
      +    { key: '↑↓/PgUp/PgDn', label: 'Nav' },
      +    { key: 'Spc/Hotkey', label: 'Toggle' },
      +    { key: 'Enter', label: 'Copy' },
      +    { key: 'Esc', label: 'Close' },
      +];

    patchStrategy: standard-diff
  - type: write
    path: src/constants/detail.constants.ts
    content: >+
      --- src/constants/detail.constants.ts

      +++ src/constants/detail.constants.ts

      @@ -1,5 +1,9 @@
       /**
        * Constants for the Transaction Detail screen.
        */
      +import type { ActionItem } from '../types/actions.types';

      +import type { FileChangeType } from '../types/domain.types';

      +
       export const NAVIGATOR_SECTIONS = {
           PROMPT: 'PROMPT',
           REASONING: 'REASONING',
      @@ ... @@
           REVERT_CONFIRM: 'REVERT_CONFIRM',
           NONE: 'NONE',
       } as const;
      +

      +export const SCREEN_TITLE = '▲ relaycode transaction details';

      +export const REASONING_HEADER = 'REASONING';

      +export const DIFF_HEADER_PREFIX = 'DIFF: ';

      +export const DIFF_COLLAPSED_TEXT = (hiddenLines: number) => `...
      ${hiddenLines} lines hidden ...`;

      +

      +export const FILE_CHANGE_TYPE_ICONS: Record<FileChangeType, string> = {

      +    MOD: '[MOD]',

      +    ADD: '[ADD]',

      +    DEL: '[DEL]',

      +    REN: '[REN]',

      +};

      +

      +export const REVERT_MODAL_FOOTER_ACTIONS: ActionItem[] = [

      +    { key: 'Enter', label: 'Confirm Revert' },

      +    { key: 'Esc', label: 'Cancel' },

      +];

      +

      +export const getBaseFooterActions = (isFileFocused: boolean):
      ActionItem[] => [

      +    { key: 'C', label: 'Copy' },

      +    { key: 'O', label: isFileFocused ? 'Open File' : 'Open YAML' },

      +    { key: 'U', label: 'Undo' },

      +    { key: 'Q', label: 'Quit/Back' },

      +];

    patchStrategy: standard-diff
  - type: write
    path: src/constants/review.constants.ts
    content: >+
      --- src/constants/review.constants.ts

      +++ src/constants/review.constants.ts

      @@ -1,5 +1,6 @@
       import type { ApplyStep } from '../stores/review.store';
      +import type { FileItem, Transaction, FileReviewStatus } from
      '../types/domain.types';
       
       /**
        * Constants for the Review screen and process.
      @@ ... @@
           { id: 'post-command', title: 'Running post-command script...', status: 'pending', substeps: [] },
           { id: 'linter', title: 'Analyzing changes with linter...', status: 'pending', substeps: [] },
       ];
      +

      +export const SCREEN_TITLE = '▲ relaycode review';

      +export const PROCESSING_SCREEN_TITLE = '▲ relaycode apply';

      +

      +export const BULK_REPAIR_OPTIONS = [

      +    '(1) Copy Bulk Re-apply Prompt (for single-shot AI)',

      +    '(2) Bulk Change Strategy & Re-apply',

      +    '(3) Handoff to External Agent',

      +    '(4) Bulk Abandon All Failed Files',

      +    '(Esc) Cancel',

      +];

      +

      +export const BULK_INSTRUCT_OPTIONS = [

      +    '(1) Copy Bulk Re-instruct Prompt (for single-shot AI)',

      +    '(2) Handoff to External Agent',

      +    '(3) Bulk Un-reject All Files (revert to original)',

      +    '(4) Cancel',

      +];

      +

      +// All prompt generation logic is moved here from review.service.ts

      +export const PROMPT_TEMPLATES = {

      +    generateBulkRepairPrompt: (failedFiles: FileItem[]): string => {

      +        return `The previous patch failed to apply to MULTIPLE files.
      Please generate a new, corrected patch that addresses all the files listed
      below.

      +

      +IMPORTANT: The response MUST contain a complete code block for EACH file
      that needs to be fixed.

      +

      +${failedFiles.map(file => `--- FILE: ${file.path} ---

      +Strategy: ${file.strategy}

      +Error: Hunk #1 failed to apply // This is a mock error

      +

      +ORIGINAL CONTENT:

      +---

      +// ... original content of ${file.path} ...

      +---

      +

      +FAILED PATCH:

      +---

      +${file.diff || '// ... failed diff ...'}

      +---

      +`).join('\n')}

      +

      +Please analyze all failed files and provide a complete, corrected
      response.`;

      +    },

      +    generateHandoffPrompt: (

      +        transaction: Transaction,

      +        fileReviewStates: Map<

      +            string, { status: FileReviewStatus; error?: string; details?:
      string }

      +        >,

      +    ): string => {

      +        const successfulFiles = (transaction.files || []).filter(f =>
      fileReviewStates.get(f.id)?.status === 'APPROVED');

      +        const failedFiles = (transaction.files || []).filter(f =>
      ['FAILED', 'REJECTED'].includes(fileReviewStates.get(f.id)?.status ||
      ''));

      +

      +        return `I am handing off a failed automated code transaction to
      you. Your task is to act as my programming assistant and complete the
      planned changes.

      +

      +The full plan for this transaction is detailed in the YAML file located
      at: .relay/transactions/${transaction.hash}.yml. Please use this file as
      your primary source of truth for the overall goal.

      +

      +Here is the current status of the transaction:

      +

      +--- TRANSACTION SUMMARY ---

      +Goal: ${transaction.message}

      +Reasoning:

      +${transaction.reasoning || ''}

      +

      +--- CURRENT FILE STATUS ---

      +SUCCESSFUL CHANGES (already applied, no action needed):

      +${successfulFiles.map(f => `- MODIFIED: ${f.path}`).join('\n') || ' 
      (None)'}

      +

      +FAILED CHANGES (these are the files you need to fix):

      +${failedFiles.map(f => `- FAILED: ${f.path} (Error:
      ${fileReviewStates.get(f.id)?.error})`).join('\n')}

      +

      +Your job is to now work with me to fix the FAILED files and achieve the
      original goal of the transaction. Please start by asking me which file you
      should work on first.`;

      +    },

      +    generateSingleFileRepairPrompt: (file: FileItem, error?: string):
      string => {

      +        return `The patch failed to apply to ${file.path}. Please
      generate a corrected patch.

      +

      +Error: ${error || 'Unknown error'}

      +Strategy: ${file.strategy}

      +

      +ORIGINAL CONTENT:

      +---

      +// ... original file content would be here ...

      +---

      +

      +FAILED PATCH:

      +---

      +${file.diff || '// ... failed diff would be here ...'}

      +---

      +

      +Please provide a corrected patch that addresses the error.`;

      +    },

      +    generateSingleFileInstructPrompt: (file: FileItem, transaction:
      Transaction): string => {

      +        return `The user REJECTED the last proposed change for the file
      \`${file.path}\`.

      +

      +The original high-level goal was:

      +---

      +${transaction.prompt || transaction.message}

      +---

      +

      +The rejected change was:

      +---

      +${file.diff || '// ... rejected diff would be here ...'}

      +---

      +

      +Please provide an alternative solution for \`${file.path}\` that still
      accomplishes the original goal.

      +The response MUST be a complete, corrected patch for this file.`;

      +    },

      +    generateBulkInstructPrompt: (rejectedFiles: FileItem[], transaction:
      Transaction): string => {

      +        // Mock implementation for demo. In a real scenario, this would
      generate a more complex prompt.

      +        const fileList = rejectedFiles.map(f => `-
      ${f.path}`).join('\n');

      +        // eslint-disable-next-line no-console

      +        console.log(`[CLIPBOARD] Copied bulk instruction prompt for
      ${rejectedFiles.length} files.`);

      +        return `The user has rejected changes in multiple files for the
      goal: "${transaction.message}".\n\nThe rejected files
      are:\n${fileList}\n\nPlease provide an alternative patch for all of
      them.`;

      +    },

      +};

    patchStrategy: standard-diff
  - type: write
    path: index.tsx
    content: >+
      --- index.tsx

      +++ index.tsx

      @@ ... @@
       import { useReviewStore } from './src/stores/review.store';
       import { useTransactionStore } from './src/stores/transaction.store';
       import { useCommitStore } from './src/stores/commit.store';
      +import { DEBUG_COMMAND, DEBUG_SCREENS } from
      './src/constants/debug.constants';
       
       const main = () => {
           // Initialize stores
           useTransactionStore.getState().actions.loadTransactions();
           const args = process.argv.slice(2);
       
      -    if (args[0] === 'debug-screen' && args[1]) {

      +    if (args[0] === DEBUG_COMMAND && args[1]) {
               const screenName = args[1].replace(/\.tsx$/, '');
               const { actions: appActions } = useAppStore.getState();
       
               switch (screenName) {
      -            case 'DashboardScreen':

      +            case DEBUG_SCREENS.DASHBOARD:
                       appActions.showDashboardScreen();
                       break;
      -            case 'GitCommitScreen':

      +            case DEBUG_SCREENS.GIT_COMMIT:
                       useCommitStore.getState().actions.prepareCommitScreen();
                       appActions.showGitCommitScreen();
                       break;
      -            case 'ReviewProcessingScreen':

      +            case DEBUG_SCREENS.REVIEW_PROCESSING:
                       useReviewStore.getState().actions.load('1');
                       appActions.showReviewProcessingScreen();
                       break;
      -            case 'ReviewScreen':

      +            case DEBUG_SCREENS.REVIEW:
                       useReviewStore.getState().actions.load('1');
                       appActions.showReviewScreen();
                       break;
      -            case 'TransactionDetailScreen':

      +            case DEBUG_SCREENS.TRANSACTION_DETAIL:
                       useDetailStore.getState().actions.load('3');
                       appActions.showTransactionDetailScreen();
                       break;
      -            case 'TransactionHistoryScreen':

      +            case DEBUG_SCREENS.TRANSACTION_HISTORY:
                       useHistoryStore.getState().actions.load();
                       appActions.showTransactionHistoryScreen();
                       break;
      -            case 'InitializationScreen':

      +            case DEBUG_SCREENS.INITIALIZATION:
                        appActions.showInitScreen();
                        break;
      -            case 'SplashScreen':

      +            case DEBUG_SCREENS.SPLASH:
                        appActions.showSplashScreen();
                        break;
      -            case 'DebugMenu':

      +            case DEBUG_SCREENS.DEBUG_MENU:
                       appActions.showDashboardScreen();
                       useViewStore.getState().actions.setActiveOverlay('debug');
                       break;
      -            case 'DebugLogScreen':

      +            case DEBUG_SCREENS.DEBUG_LOG:
                       appActions.showDashboardScreen();
                       useViewStore.getState().actions.setActiveOverlay('log');
                       break;
                   default:
                       process.stderr.write(`Unknown debug screen: ${args[1]}\n`);

    patchStrategy: standard-diff
  - type: write
    path: src/components/CopyScreen.tsx
    content: >+
      --- src/components/CopyScreen.tsx

      +++ src/components/CopyScreen.tsx

      @@ -3,6 +3,7 @@
       import { useStdoutDimensions } from '../utils';
       import ActionFooter from './ActionFooter';
       import { useCopyScreen } from '../hooks/useCopyScreen';
      +import { SCREEN_TITLE, FOOTER_ACTIONS } from
      '../constants/copy.constants';
       
       const CopyScreen = () => {
           const {
      @@ ... @@
                       paddingX={2}
                       width="80%"
                   >
      -                <Text bold color="yellow">▲ relaycode · copy mode</Text>

      +                <Text bold color="yellow">{SCREEN_TITLE}</Text>
                       <Separator width={Math.floor(width * 0.8) - 4} />
                       <Box flexDirection="column" marginY={1}>
                           <Text>{title}</Text>
      @@ ... @@
                       </Box>
                       <Separator width={Math.floor(width * 0.8) - 4} />
                       {lastCopiedMessage && <Text color="green">✓ {lastCopiedMessage}</Text>}
      -                <ActionFooter actions={[

      -                    { key: '↑↓/PgUp/PgDn', label: 'Nav' },

      -                    { key: 'Spc/Hotkey', label: 'Toggle' },

      -                    { key: 'Enter', label: 'Copy' },

      -                    { key: 'Esc', label: 'Close' },

      -                ]}/>

      +                <ActionFooter actions={FOOTER_ACTIONS}/>
                   </Box>
               </Box>
           );

    patchStrategy: standard-diff
  - type: write
    path: src/components/DashboardScreen.tsx
    content: "--- src/components/DashboardScreen.tsx\n+++ src/components/DashboardScreen.tsx\n@@ ... @@\n import Separator from './Separator';\n import type { Transaction, TransactionStatus, FileChangeType } from '../types/domain.types';\n import { useDashboardScreen } from '../hooks/useDashboardScreen';\n-import { UI_CONFIG } from '../config/ui.config';\n-import type { LayoutConfig } from '../hooks/useLayout';\n import ActionFooter from './ActionFooter';\n-import type { ActionItem } from '../types/actions.types';\n+import { SCREEN_TITLE, EVENT_STREAM_HEADER, getFooterActions, MODAL_FOOTER_ACTIONS } from '../constants/dashboard.constants';\n+import { UI_CONFIG } from '../config/ui.config';\n \n // --- Sub-components & Helpers ---\n \n@@ ... @@\n     const {\n         status,\n         transactions,\n@@ ... @@\n         viewportHeight,\n         transactionsToConfirm,\n         expandedTransactionId,\n     } = useDashboardScreen({\n-        layoutConfig: {\n-            header: 1,\n-            separators: 2,\n-            fixedRows: 1 + 1, // status bar, event stream header\n-            marginsY: 1 + 1 + 1, // status bar, event stream list, separator\n-            footer: 2,\n-            // Non-event stream vertical space (header, footer, etc.)\n-        },\n+        layoutConfig: UI_CONFIG.dashboard.layout,\n     });\n \n     const renderStatusBar = () => {\n@@ ... @@\n     };\n \n     const renderFooter = () => {\n-        if (isModal) return (\n-            <ActionFooter actions={[\n-                { key: 'Enter', label: 'Confirm' },\n-                { key: 'Esc', label: 'Cancel' },\n-            ]}/>\n-        );\n+        if (isModal) return <ActionFooter actions={MODAL_FOOTER_ACTIONS}/>;\n         if (isProcessing) return <Text>Processing... This may take a moment.</Text>;\n \n-        const footerActions: ActionItem[] = [\n-            { key: '↑↓', label: 'Nav' },\n-            { key: '→/Ent', label: 'View' },\n-            { key: '←', label: 'Collapse' },\n-            { key: 'L', label: 'Log' },\n-            { key: 'A', label: 'Approve All' },\n-            { key: 'C', label: 'Commit' },\n-            { key: 'P', label: status === 'PAUSED' ? 'Resume' : 'Pause' },\n-            { key: 'Q', label: 'Quit' },\n-        ];\n-\t\treturn <ActionFooter actions={footerActions} />;\n+        const footerActions = getFooterActions(status === 'PAUSED');\n+\t\treturn <ActionFooter actions={footerActions}/>;\n     };\n     \n     return (\n         <Box flexDirection=\"column\" height=\"100%\">\n-            <Text color=\"cyan\">▲ relaycode dashboard</Text>\n+            <Text color=\"cyan\">{SCREEN_TITLE}</Text>\n             <Separator />\n             <Box marginY={1}>\n                 {renderStatusBar()}\n@@ ... @@\n                 </>\n             )}\n             \n-            <Text bold underline> EVENT STREAM (Last 15 minutes)</Text>\n+            <Text bold underline>{EVENT_STREAM_HEADER}</Text>\n             <Box flexDirection=\"column\" marginTop={1}>\n                 {transactions.length === 0 && (\n                      <Box paddingLeft={2}><Text color=\"gray\">Listening for changes... no events yet.</Text></Box>\n\n"
    patchStrategy: standard-diff
  - type: write
    path: src/components/DebugLogScreen.tsx
    content: >+
      --- src/components/DebugLogScreen.tsx

      +++ src/components/DebugLogScreen.tsx

      @@ ... @@
       import Separator from './Separator';
       import ActionFooter from './ActionFooter';
       import { useDebugLogScreen } from '../hooks/useDebugLogScreen';
       import type { LogEntry } from '../types/log.types';
       import { useStdoutDimensions } from '../utils';
      +import { LOG_SCREEN_TITLE, LOG_LEVEL_COLORS, LOG_LEVEL_TAGS,
      LOG_FOOTER_ACTIONS } from '../constants/debug.constants';
       
      -const LogLevelColors = {

      -    DEBUG: 'gray',

      -    INFO: 'white',

      -    WARN: 'yellow',

      -    ERROR: 'red',

      -};

      -

      -const LogLevelTag = {

      -    DEBUG: { color: 'white', backgroundColor: 'gray' },

      -    INFO: { color: 'black', backgroundColor: 'cyan' },

      -    WARN: { color: 'black', backgroundColor: 'yellow' },

      -    ERROR: { color: 'white', backgroundColor: 'red' },

      -};

      -
       const LogEntryRow = ({ entry, isSelected }: { entry: LogEntry; isSelected: boolean }) => {
           const time = new Date(entry.timestamp).toISOString().split('T')[1]?.replace('Z', '');
      -    const color = LogLevelColors[entry.level];

      -    const tagColors = LogLevelTag[entry.level];

      +    const color = LOG_LEVEL_COLORS[entry.level];

      +    const tagColors = LOG_LEVEL_TAGS[entry.level];
       
           return (
               <Text color={color}>
      @@ ... @@
           const [width] = useStdoutDimensions();
       
           const renderFilter = () => (
      @@ ... @@
               </Box>
           );
       
      -    const footerActions =

      -        mode === 'FILTER'

      -            ? [{ key: 'Enter/Esc', label: 'Apply & Close Filter' }]

      -            : [

      -                  { key: '↑↓/PgUp/PgDn', label: 'Scroll' },

      -                  { key: 'F', label: 'Filter' },

      -                  { key: 'C', label: 'Clear' },

      -                  { key: 'Esc/Ctrl+L', label: 'Close' },

      -              ];

      +    const footerActions = mode === 'FILTER' ? LOG_FOOTER_ACTIONS.FILTER :
      LOG_FOOTER_ACTIONS.LIST;
       
           return (
               <Box
      @@ ... @@
                   paddingX={2}
                   paddingY={1}
               >
      -            <Text bold color="black" backgroundColor="yellow"> ▲
      relaycode · DEBUG LOG </Text>

      +            <Text bold color="black" backgroundColor="yellow">
      {LOG_SCREEN_TITLE} </Text>
                   <Separator width={width - 4} />
                   <Box marginY={1}>{renderFilter()}</Box>
                   <Box flexDirection="column" flexGrow={1}>

    patchStrategy: standard-diff
  - type: write
    path: src/components/DebugMenu.tsx
    content: >+
      --- src/components/DebugMenu.tsx

      +++ src/components/DebugMenu.tsx

      @@ ... @@
       import { useDebugMenu } from '../hooks/useDebugMenu';
       import { useStdoutDimensions } from '../utils';
       import ActionFooter from './ActionFooter';
      +import { MENU_SCREEN_TITLE, MENU_FOOTER_ACTIONS } from
      '../constants/debug.constants';
       
       const getKeyForIndex = (index: number): string => {
           if (index < 9) {
      @@ ... @@
                   paddingX={2}
                   paddingY={1}
               >
      -            <Text bold color="black" backgroundColor="yellow"> ▲
      relaycode · DEBUG MENU </Text>

      +            <Text bold color="black" backgroundColor="yellow">
      {MENU_SCREEN_TITLE} </Text>
                   <Separator width={width - 4} />
                   <Box flexDirection="column" marginY={1}>
                       {menuItems.map((item, index) => {
      @@ ... @@
                   </Box>
                   <Separator width={width - 4} />
                   <Box>
      -                <ActionFooter actions={[

      -                    { key: '↑↓/PgUp/PgDn', label: 'Nav' },

      -                    { key: '1-9,a-z', label: 'Jump' },

      -                    { key: 'Enter', label: 'Select' },

      -                    { key: 'Esc/Ctrl+B', label: 'Close' },

      -                ]}/>

      +                <ActionFooter actions={MENU_FOOTER_ACTIONS}/>
                       <Box flexGrow={1} />
                       <Text>
                           {Math.min(viewOffset + 1, totalItems)}-

    patchStrategy: standard-diff
  - type: write
    path: src/components/DiffScreen.tsx
    content: >+
      --- src/components/DiffScreen.tsx

      +++ src/components/DiffScreen.tsx

      @@ ... @@
       import { Box, Text } from 'ink';
       import { UI_CONFIG } from '../config/ui.config';
      +import { DIFF_HEADER_PREFIX, DIFF_COLLAPSED_TEXT } from
      '../constants/detail.constants';
       
       interface DiffScreenProps {
           filePath: string;
      @@ ... @@
                   const topLines = lines.slice(0, COLLAPSE_SHOW_LINES);
                   const bottomLines = lines.slice(lines.length - COLLAPSE_SHOW_LINES);
                   const hiddenLines = lines.length - (COLLAPSE_SHOW_LINES * 2);
       
                   return (
                       <>
                           {topLines.map((line, i) => renderLine(line, i))}
      -                    <Text color="gray">... {hiddenLines} lines hidden
      ...</Text>

      +                    <Text
      color="gray">{DIFF_COLLAPSED_TEXT(hiddenLines)}</Text>
                           {bottomLines.map((line, i) => renderLine(line, i + topLines.length + 1))}
                       </>
                   );
      @@ ... @@
       
           return (
               <Box flexDirection="column">
      -            <Text>DIFF: {filePath}</Text>

      +            <Text>{DIFF_HEADER_PREFIX}{filePath}</Text>
                   <Box flexDirection="column" marginTop={1}>
                       {renderContent()}
                   </Box>

    patchStrategy: standard-diff
  - type: write
    path: src/components/GitCommitScreen.tsx
    content: >+
      --- src/components/GitCommitScreen.tsx

      +++ src/components/GitCommitScreen.tsx

      @@ ... @@
       import Separator from './Separator';
       import { useGitCommitScreen } from '../hooks/useGitCommitScreen';
       import ActionFooter from './ActionFooter';
      +import { SCREEN_TITLE, TEXTS, FOOTER_ACTIONS } from
      '../constants/commit.constants';
       
       const GitCommitScreen = () => {
           const { transactionsToCommit, finalCommitMessage, isCommitting } = useGitCommitScreen();
      @@ ... @@
       
           return (
               <Box flexDirection="column">
      -            <Text color="cyan">▲ relaycode git commit</Text>

      +            <Text color="cyan">{SCREEN_TITLE}</Text>
                   <Separator />
                   <Box marginY={1} flexDirection="column" paddingX={2}>
      -                <Text>Found {transactionsToCommit.length} new
      transactions to commit since last git commit.</Text>

      +               
      <Text>{TEXTS.COUNT_PREFIX(transactionsToCommit.length)}</Text>
                       <Box marginTop={1} flexDirection="column">
      -                    <Text bold>TRANSACTIONS INCLUDED</Text>

      +                    <Text bold>{TEXTS.TRANSACTIONS_INCLUDED}</Text>
                           {transactionLines}
                       </Box>
                   </Box>
                   <Separator />
                   <Box marginY={1} flexDirection="column" paddingX={2}>
      -                <Text bold>FINAL COMMIT MESSAGE</Text>

      +                <Text bold>{TEXTS.FINAL_COMMIT_MESSAGE}</Text>
                       <Box marginTop={1}>
                           <Text>{finalCommitMessage}</Text>
                       </Box>
                   </Box>
                   <Separator />
                   <Box marginY={1} paddingX={2}>
      -                 <Text>This will run &apos;git add .&apos; and &apos;git
      commit&apos; with the message above.</Text>

      +                 <Text>{TEXTS.GIT_COMMAND_INFO}</Text>
                   </Box>
                   <Separator />
                   {isCommitting
                       ? <Text><Spinner type="dots"/> Committing... please wait.</Text>
      -                : <ActionFooter actions={[

      -                    { key: 'Enter', label: 'Confirm & Commit' },

      -                    { key: 'Esc', label: 'Cancel' },

      -                ]}/>

      +                : <ActionFooter actions={FOOTER_ACTIONS}/>
                   }
               </Box>
           );

    patchStrategy: standard-diff
  - type: write
    path: src/components/ReasonScreen.tsx
    content: |+
      --- src/components/ReasonScreen.tsx
      +++ src/components/ReasonScreen.tsx
      @@ ... @@
       import { Box, Text } from 'ink';
      +import { REASONING_HEADER } from '../constants/detail.constants';
       
       interface ReasonScreenProps {
           reasoning: string,
      @@ ... @@
       
           return (
               <Box flexDirection="column">
      -            <Text>REASONING</Text>
      +            <Text>{REASONING_HEADER}</Text>
                   <Box flexDirection="column" marginTop={1}>
                       {visibleLines.map((line, index) => <Text key={index}>{line}</Text>)}
                   </Box>

    patchStrategy: standard-diff
  - type: write
    path: src/components/ReviewProcessingScreen.tsx
    content: |+
      --- src/components/ReviewProcessingScreen.tsx
      +++ src/components/ReviewProcessingScreen.tsx
      @@ ... @@
       import { useTransactionStore } from '../stores/transaction.store';
       import { useViewStore } from '../stores/view.store';
       import { useReviewStore, type ApplyStep } from '../stores/review.store';
       import Separator from './Separator';
      +import { PROCESSING_SCREEN_TITLE } from '../constants/review.constants';
       
       const ApplyStepRow = ({ step, isSubstep = false }: { step: ApplyStep; isSubstep?: boolean }) => {
           if (isSubstep) {
      @@ ... @@
           }
       
           return (
               <Box flexDirection="column">
      -            <Text color="cyan">▲ relaycode apply</Text>
      +            <Text color="cyan">{PROCESSING_SCREEN_TITLE}</Text>
                   <Separator />
                   <Box marginY={1} flexDirection="column">
                       <Text>Applying patch {transaction.hash}... ({transaction.message})</Text>

    patchStrategy: standard-diff
  - type: write
    path: src/components/ReviewScreen.tsx
    content: >+
      --- src/components/ReviewScreen.tsx

      +++ src/components/ReviewScreen.tsx

      @@ ... @@
       import DiffScreen from './DiffScreen';
       import ReasonScreen from './ReasonScreen';
       import type { ScriptResult, FileItem, FileChangeType } from '../types/domain.types';
       import { useReviewScreen } from '../hooks/useReviewScreen';
       import ActionFooter from './ActionFooter';
       import type { ActionItem } from '../types/actions.types';
      +import { SCREEN_TITLE, BULK_REPAIR_OPTIONS, BULK_INSTRUCT_OPTIONS } from
      '../constants/review.constants';
       
       // --- Sub-components ---
       
      @@ ... @@
                       <Box flexDirection="column">
      -                    <Text>

      -                        {selectedScript.command.includes('lint') ?
      'LINTER' : 'SCRIPT'} OUTPUT: `{selectedScript.command}`

      -                    </Text>

      +                    <Text>{selectedScript.command.includes('lint') ?
      'LINTER' : 'SCRIPT'} OUTPUT: `{selectedScript.command}`</Text>
                           <Box marginTop={1} flexDirection="column">
                               {outputLines.map((line: string, index: number) => {
                                   const isError = line.includes('Error');
      @@ ... @@
               if (bodyView === 'bulk_repair') {
                   const failedFiles = files.filter((f: FileItem) => fileReviewStates.get(f.id)?.status === 'FAILED');
      -            const repairOptions = [

      -                '(1) Copy Bulk Re-apply Prompt (for single-shot AI)',

      -                '(2) Bulk Change Strategy & Re-apply',

      -                '(3) Handoff to External Agent',

      -                '(4) Bulk Abandon All Failed Files',

      -                '(Esc) Cancel',

      -            ];
       
                   return (
                       <Box flexDirection="column" gap={1}>
      @@ ... @@
       
                           <Text>How would you like to proceed?</Text>
       
                           <Box flexDirection="column">
      -                        {repairOptions.map((opt, i) => (

      +                        {BULK_REPAIR_OPTIONS.map((opt, i) => (
                                   <Text key={i} color={selectedBulkRepairOptionIndex === i ? 'cyan' : undefined}>
                                       {selectedBulkRepairOptionIndex === i ? '> ' : '  '}
                                       {opt}
      @@ ... @@
       
               if (bodyView === 'bulk_instruct') {
                   const rejectedFiles = files.filter((f: FileItem) => fileReviewStates.get(f.id)?.status === 'REJECTED');
      -            const instructOptions = [

      -                '(1) Copy Bulk Re-instruct Prompt (for single-shot AI)',

      -                '(2) Handoff to External Agent',

      -                '(3) Bulk Un-reject All Files (revert to original)',

      -                '(4) Cancel',

      -            ];
       
                   return (
                       <Box flexDirection="column" gap={1}>
      @@ ... @@
                           </Box>
                           <Box flexDirection="column" marginTop={1}>
      -                        {instructOptions.map((opt, i) => (

      +                        {BULK_INSTRUCT_OPTIONS.map((opt, i) => (
                                   <Text key={i} color={selectedBulkInstructOptionIndex === i ? 'cyan' : undefined}>
                                       {selectedBulkInstructOptionIndex === i ? '> ' : '  '}
                                       {opt}
      @@ ... @@
           return (
               <Box flexDirection="column">
                   {/* Header */}
      -            <Text color="cyan">▲ relaycode review</Text>

      +            <Text color="cyan">{SCREEN_TITLE}</Text>
                   <Separator />
                   
                   {/* Navigator Section */}

    patchStrategy: standard-diff
  - type: write
    path: src/components/SplashScreen.tsx
    content: >+
      --- src/components/SplashScreen.tsx

      +++ src/components/SplashScreen.tsx

      @@ ... @@
       import { Box, Text } from 'ink';
       import Separator from './Separator';
       import { useSplashScreen } from '../hooks/useSplashScreen';
      +import { SCREEN_TITLE, LOGO, TAGLINE_PRIMARY, TAGLINE_SECONDARY } from
      '../constants/splash.constants';
       
       const SplashScreen = () => {
           const { countdown } = useSplashScreen();
      -    const logo = `

      -         ░█▀▄░█▀▀░█░░░█▀█░█░█░█▀▀░█▀█░█▀▄░█▀▀

      -         ░█▀▄░█▀▀░█░░░█▀█░░█░░█░░░█░█░█░█░█▀▀

      -         ░▀░▀░▀▀▀░▀▀▀░▀▀▀░▀▀▀░▀░▀░░▀░░▀▀▀░▀▀▀

      -`;
       
           return (
               <Box flexDirection="column">
      -            <Text color="cyan">▲ relaycode</Text>

      +            <Text color="cyan">{SCREEN_TITLE}</Text>
                   <Separator />
      -            <Text color="cyan">{logo}</Text>

      +            <Text color="cyan">{LOGO}</Text>
                   <Box flexDirection="column" alignItems="center">
      -                <Text italic>A zero-friction, AI-native patch
      engine.</Text>

      -                <Text italic color="gray">Built by Arman and contributors
      · <Text underline>https://relay.noca.pro</Text></Text>

      +                <Text italic>{TAGLINE_PRIMARY}</Text>

      +                <Text italic color="gray">{TAGLINE_SECONDARY}</Text>
                   </Box>
                   
                   <Box flexDirection="row" justifyContent="space-around" width="100%" marginTop={1}>

    patchStrategy: standard-diff
  - type: write
    path: src/components/TransactionDetailScreen.tsx
    content: >+
      --- src/components/TransactionDetailScreen.tsx

      +++ src/components/TransactionDetailScreen.tsx

      @@ ... @@
       import DiffScreen from './DiffScreen';
       import ReasonScreen from './ReasonScreen';
       import { useTransactionDetailScreen } from '../hooks/useTransactionDetailScreen';
      -import type { FileChangeType } from '../types/domain.types';
       import ActionFooter from './ActionFooter';
       import type { ActionItem } from '../types/actions.types';
      +import {

      +    SCREEN_TITLE,

      +    FILE_CHANGE_TYPE_ICONS,

      +    REVERT_MODAL_FOOTER_ACTIONS,

      +    getBaseFooterActions,

      +} from '../constants/detail.constants';
       
      -const getFileChangeTypeIcon = (type: FileChangeType) => {

      -    switch (type) {

      -        case 'MOD': return '[MOD]';

      -        case 'ADD': return '[ADD]';

      -        case 'DEL': return '[DEL]';

      -        case 'REN': return '[REN]';

      -    }

      -};

      -
       const RevertModal = ({ transactionHash }: { transactionHash: string }) => {
           return (
               <Box 
      @@ ... @@
               if (bodyView === 'REVERT_CONFIRM') {
      -            return <ActionFooter actions={[

      -                { key: 'Enter', label: 'Confirm Revert' },

      -                { key: 'Esc', label: 'Cancel' },

      -            ]} />;

      +            return <ActionFooter actions={REVERT_MODAL_FOOTER_ACTIONS}
      />;
               }
               
               const isFileFocused = focusedItemPath.includes('/');
      -        const baseActions: ActionItem[] = [

      -            { key: 'C', label: 'Copy' },

      -            { key: 'O', label: isFileFocused ? 'Open File' : 'Open YAML'
      },

      -            { key: 'U', label: 'Undo' },

      -            { key: 'Q', label: 'Quit/Back' },

      -        ];

      +        const baseActions = getBaseFooterActions(isFileFocused);
               let contextualActions: ActionItem[] = [];
       
               if (isFileFocused) { // Is a file
      @@ ... @@
           return (
               <Box flexDirection="column">
                   {/* Header */}
      -            <Text>▲ relaycode transaction details</Text>

      +            <Text>{SCREEN_TITLE}</Text>
                   <Separator />
                   
                   {/* Modal takeover for Revert */}
      @@ ... @@
                                    return (
                                       <Text key={file.id} color={isFileSelected ? 'cyan' : undefined}>
                                           {isFileSelected ? '> ' : '  '}
      -                                    {getFileChangeTypeIcon(file.type)}
      {file.path}{stats}

      +                                    {FILE_CHANGE_TYPE_ICONS[file.type]}
      {file.path}{stats}
                                       </Text>
                                   );
                               })}

    patchStrategy: standard-diff
  - type: write
    path: src/components/TransactionHistoryScreen.tsx
    content: >+
      --- src/components/TransactionHistoryScreen.tsx

      +++ src/components/TransactionHistoryScreen.tsx

      @@ ... @@
       import ActionFooter from './ActionFooter';
       import type { ActionItem } from '../types/actions.types';
      +import {

      +    SCREEN_TITLE,

      +    STATUS_MAP,

      +    TYPE_MAP,

      +    BULK_ACTIONS_MODAL_TEXTS,

      +    FOOTER_TEXTS,

      +    getListFooterActions,

      +} from '../constants/history.constants';
       
       // --- Sub-components ---
       
      @@ ... @@
           isSelected: boolean;
           isExpanded: boolean;
           isLoading: boolean;
       }) => {
      -    const typeMap = { MOD: '[MOD]', ADD: '[ADD]', DEL: '[DEL]', REN:
      '[REN]' };

      -    
           return (
               <Box flexDirection="column" paddingLeft={6}>
                   <Text color={isSelected ? 'cyan' : undefined}>
                       {isSelected ? '> ' : '  '}
      -                {icon} {typeMap[file.type]} {file.path}

      +                {icon} {TYPE_MAP[file.type]} {file.path}
                   </Text>
                   {isLoading && <Box paddingLeft={8}><Spinner type="dots" /></Box>}
                   {isExpanded && !isLoading && <DiffPreview diff={file.diff} />}
      @@ ... @@
           isSelectedForAction: boolean;
           hasSelection: boolean;
       }) => {
           const icon = isExpanded ? '▾' : '▸';
      -    const statusMap = {

      -        COMMITTED: <Text color="green">✓ Committed</Text>,

      -        HANDOFF: <Text color="magenta">→ Handoff</Text>,

      -        REVERTED: <Text color="gray">↩ Reverted</Text>,

      -        APPLIED: <Text color="blue">✓ Applied</Text>,

      -        PENDING: <Text color="yellow">? Pending</Text>,

      -        FAILED: <Text color="red">✗ Failed</Text>,

      -    };
           const date = new Date(tx.timestamp).toISOString().split('T')[0];
           const selectionIndicator = isSelectedForAction ? '[x] ' : '[ ] ';
           
      -    const statusDisplay = statusMap[tx.status as keyof typeof statusMap]
      || tx.status;

      +    const statusDisplay = STATUS_MAP[tx.status as keyof typeof
      STATUS_MAP] || tx.status;
       
           return (
               <Box flexDirection="column" marginBottom={isExpanded ? 1 : 0}>
      @@ ... @@
       const BulkActionsMode = ({ selectedForActionCount }: { selectedForActionCount: number }) => {
           return (
               <Box flexDirection="column" marginY={1}>
      -            <Text bold color="yellow">PERFORM BULK ACTION ON
      {selectedForActionCount} SELECTED ITEMS</Text>

      +            <Text bold
      color="yellow">{BULK_ACTIONS_MODAL_TEXTS.TITLE(selectedForActionCount)}</Text>
                   <Box marginY={1}>
      -                <Text>This action is often irreversible. Are you
      sure?</Text>

      +                <Text>{BULK_ACTIONS_MODAL_TEXTS.WARNING}</Text>
                   </Box>
      -            <Text>(1) Revert Selected Transactions</Text>

      -            <Text>(2) Mark as &apos;Git Committed&apos;</Text>

      -            <Text>(3) Delete Selected Transactions (from Relaycode
      history)</Text>

      -            <Text>(Esc) Cancel</Text>

      +            {BULK_ACTIONS_MODAL_TEXTS.OPTIONS.map(opt => <Text
      key={opt}>{opt}</Text>)}
               </Box>
           );
       };
      @@ ... @@
               statsStatus,
               hasSelection,
           } = useTransactionHistoryScreen({
      -        layoutConfig: {

      -            header: 1,

      -            separators: 2, // after header, after list

      -            fixedRows: 1, // filter row

      -            marginsY: 1, // for list

      -            footer: 2,

      -        },

      +        layoutConfig: UI_CONFIG.history.layout,
           });
       
           const transactionsById = useMemo(() => new Map(transactions.map(tx => [tx.id, tx])), [transactions]);
       
           const renderFooter = () => {
      -        if (mode === 'FILTER') return <Text>(Enter) Apply Filter &
      Return      (Esc) Cancel</Text>; 

      -        if (mode === 'BULK_ACTIONS') return <Text>Choose an option [1-3]
      or (Esc) Cancel</Text>;

      +        if (mode === 'FILTER') return
      <Text>{FOOTER_TEXTS.FILTER_MODE}</Text>; 

      +        if (mode === 'BULK_ACTIONS') return
      <Text>{FOOTER_TEXTS.BULK_MODE}</Text>;
               
               const openActionLabel = selectedItemPath.includes('/file/') ? 'Open File' : 'Open YAML';
      -        const footerActions: ActionItem[] = [

      -            { key: '↑↓/PgUp/PgDn', label: 'Nav' },

      -            { key: '→', label: 'Expand' },

      -            { key: '←', label: 'Collapse' },

      -            { key: 'Spc', label: 'Select' },

      -            { key: 'Ent', label: 'Details' },

      -            { key: 'O', label: openActionLabel },

      -            { key: 'F', label: 'Filter' },

      -        ];

      -

      -        if (selectedForAction.size > 0) {

      -            footerActions.push({ key: 'C', label: 'Copy' }, { key: 'B',
      label: 'Bulk' });

      -        }

      -        return <ActionFooter actions={footerActions} />;

      +        const footerActions = getListFooterActions(openActionLabel,
      hasSelection);

      +        return <ActionFooter actions={footerActions}/>;
           };
       
           return (
               <Box flexDirection="column">
      -            <Text color="cyan">▲ relaycode transaction history</Text>

      +            <Text color="cyan">{SCREEN_TITLE}</Text>
                   <Separator />
       
                   <Box>

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useCopyScreen.tsx
    content: >+
      --- src/hooks/useCopyScreen.tsx

      +++ src/hooks/useCopyScreen.tsx

      @@ ... @@
       import { useCopyStore } from '../stores/copy.store';
       import { useViewStore } from '../stores/view.store';
       import { useViewport } from './useViewport';
      -import type { LayoutConfig } from './useLayout';

      +import { UI_CONFIG } from '../config/ui.config';
       
       export const useCopyScreen = () => {
           const activeOverlay = useViewStore(s => s.activeOverlay);
      @@ ... @@
               actions,
           } = useCopyStore(state => ({ ...state, actions: state.actions }));
           
      -    // Header, separator, title, margin, separator, status, footer

      -    const layoutConfig: LayoutConfig = { header: 1, separators: 2,
      fixedRows: 2, marginsY: 1, footer: 1 };

      -    
           const { viewOffset, viewportHeight } = useViewport({
               selectedIndex,
      -        layoutConfig,

      +        layoutConfig: UI_CONFIG.copyScreen.layout,
           });
       
           useInput((input, key) => {

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useDebugLogScreen.tsx
    content: >+
      --- src/hooks/useDebugLogScreen.tsx

      +++ src/hooks/useDebugLogScreen.tsx

      @@ ... @@
       import { useViewStore } from '../stores/view.store';
       import { useViewport } from './useViewport';
       import { LoggerService } from '../services/logger.service';
      -import type { LayoutConfig } from './useLayout';
       import { moveIndex } from '../stores/navigation.utils';
      +import { UI_CONFIG } from '../config/ui.config';
       
       export const useDebugLogScreen = () => {
           const logs = useLogStore(s => s.logs);
      @@ ... @@
               }
           }, [filteredLogs.length, selectedIndex]);
       
      -    // Header, borders, footer, filter line

      -    const layoutConfig: LayoutConfig = { paddingY: 2, header: 1,
      separators: 2, fixedRows: 1, marginsY: 1, footer: 1 };

      -
           const { viewOffset, viewportHeight } = useViewport({
               selectedIndex,
      -        layoutConfig,

      +        layoutConfig: UI_CONFIG.debugLog.layout,
           });
       
           useInput((input, key) => {

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useDebugMenu.tsx
    content: >+
      --- src/hooks/useDebugMenu.tsx

      +++ src/hooks/useDebugMenu.tsx

      @@ ... @@
       import { useTransactionStore } from '../stores/transaction.store';
       import { moveIndex } from '../stores/navigation.utils';
      -import type { LayoutConfig } from './useLayout';
       import { useViewport } from './useViewport';
      +import { UI_CONFIG } from '../config/ui.config';
       export type { MenuItem } from '../types/debug.types';
       
       const useDebugMenuActions = () => {
      @@ ... @@
       export const useDebugMenu = () => {
           const [selectedIndex, setSelectedIndex] = useState(0);
           const { menuItems } = useDebugMenuActions();
       
      -    const layoutConfig: LayoutConfig = { paddingY: 2, header: 1,
      separators: 2, footer: 1 };

      -
           const { viewOffset, viewportHeight } = useViewport({
               selectedIndex,
      -        layoutConfig,

      +        layoutConfig: UI_CONFIG.debugMenu.layout,
           });
           
           useInput((input, key) => {

    patchStrategy: standard-diff
  - type: write
    path: src/services/logger.service.ts
    content: >+
      --- src/services/logger.service.ts

      +++ src/services/logger.service.ts

      @@ -1,17 +1,8 @@
       import { useLogStore } from '../stores/log.store';
      +import { MOCK_CLIPBOARD_CONTENTS } from '../constants/debug.constants';
       
       let simulatorInterval: ReturnType<typeof setInterval> | null = null;
       
      -const mockClipboardContents = [

      -    'feat(dashboard): implement new UI components',

      -    'const clipboardy = require(\'clipboardy\');',

      -    'diff --git a/src/App.tsx b/src/App.tsx\nindex 12345..67890
      100644\n--- a/src/App.tsx\n+++ b/src/App.tsx\n@@ -1,5 +1,6 @@\n import
      React from \'react\';',

      -    'All changes have been applied successfully. You can now commit
      them.',

      -    '{\n  "id": "123",\n  "status": "PENDING"\n}',

      -    'Can you refactor this to use a switch statement?',

      -];
       let currentClipboardIndex = 0;
       
       const startSimulator = () => {
      @@ ... @@
               } else if (random < 0.8) {
                   LoggerService.debug('No clipboard change detected.');
               } else {
      -            const newContent =
      mockClipboardContents[currentClipboardIndex]!;

      -            currentClipboardIndex = (currentClipboardIndex + 1) %
      mockClipboardContents.length;

      +            const newContent =
      MOCK_CLIPBOARD_CONTENTS[currentClipboardIndex]!;

      +            currentClipboardIndex = (currentClipboardIndex + 1) %
      MOCK_CLIPBOARD_CONTENTS.length;
                   const excerpt = newContent.replace(/\n/g, ' ').substring(0, 50).trim();
                   LoggerService.info(`Clipboard content changed. Excerpt: "${excerpt}..."`);
               }

    patchStrategy: standard-diff
  - type: write
    path: src/services/review.service.ts
    content: >+
      --- src/services/review.service.ts

      +++ src/services/review.service.ts

      @@ -2,54 +2,8 @@
       import { useAppStore } from '../stores/app.store';
       import { sleep } from '../utils';
       import type { ApplyUpdate, PatchStatus } from '../stores/review.store';
       import type { Transaction, FileItem, FileReviewStatus } from '../types/domain.types';
      -

      -const generateBulkRepairPrompt = (failedFiles: FileItem[]): string => {

      -    return `The previous patch failed to apply to MULTIPLE files. Please
      generate a new, corrected patch that addresses all the files listed below.

      -

      -IMPORTANT: The response MUST contain a complete code block for EACH file
      that needs to be fixed.

      -

      -${failedFiles.map(file => `--- FILE: ${file.path} ---

      -Strategy: ${file.strategy}

      -Error: Hunk #1 failed to apply // This is a mock error

      -

      -ORIGINAL CONTENT:

      ----

      -// ... original content of ${file.path} ...

      ----

      -

      -FAILED PATCH:

      ----

      -${file.diff || '// ... failed diff ...'}

      ----

      -`).join('\n')}

      -

      -Please analyze all failed files and provide a complete, corrected
      response.`;

      -};

      -

      -const generateHandoffPrompt = (

      -    transaction: Transaction,

      -    fileReviewStates: Map<

      -        string, { status: FileReviewStatus; error?: string; details?:
      string }

      -    >,

      -): string => {

      -    const successfulFiles = (transaction.files || []).filter(f =>
      fileReviewStates.get(f.id)?.status === 'APPROVED');

      -    const failedFiles = (transaction.files || []).filter(f => ['FAILED',
      'REJECTED'].includes(fileReviewStates.get(f.id)?.status || ''));

      -

      -    return `I am handing off a failed automated code transaction to you.
      Your task is to act as my programming assistant and complete the planned
      changes.

      -

      -The full plan for this transaction is detailed in the YAML file located
      at: .relay/transactions/${transaction.hash}.yml. Please use this file as
      your primary source of truth for the overall goal.

      -

      -Here is the current status of the transaction:

      -

      ---- TRANSACTION SUMMARY ---

      -Goal: ${transaction.message}

      -Reasoning:

      -${transaction.reasoning || ''}

      -

      ---- CURRENT FILE STATUS ---

      -SUCCESSFUL CHANGES (already applied, no action needed):

      -${successfulFiles.map(f => `- MODIFIED: ${f.path}`).join('\n') || ' 
      (None)'}

      -

      -FAILED CHANGES (these are the files you need to fix):

      -${failedFiles.map(f => `- FAILED: ${f.path} (Error:
      ${fileReviewStates.get(f.id)?.error})`).join('\n')}

      -

      -Your job is to now work with me to fix the FAILED files and achieve the
      original goal of the transaction. Please start by asking me which file you
      should work on first.`;

      -};

      +import { PROMPT_TEMPLATES } from '../constants/review.constants';
       
       const performHandoff = (hash: string) => {
           // This is a bit of a hack to find the right transaction to update in the demo
      @@ ... @@
               yield { type: 'UPDATE_STEP', payload: { id: 'linter', status: 'skipped', details: 'Skipped due to patch application failure' } };
       
               await sleep(500);
           }
       }
       
       const prepareTransactionForReview = (
      @@ ... @@
           });
           return { patchStatus: isFailureCase ? 'PARTIAL_FAILURE' : 'SUCCESS', fileReviewStates };
       };
       
      -const generateSingleFileRepairPrompt = (file: FileItem, error?: string):
      string => {

      -    return `The patch failed to apply to ${file.path}. Please generate a
      corrected patch.

      -

      -Error: ${error || 'Unknown error'}

      -Strategy: ${file.strategy}

      -

      -ORIGINAL CONTENT:

      ----

      -// ... original file content would be here ...

      ----

      -

      -FAILED PATCH:

      ----

      -${file.diff || '// ... failed diff would be here ...'}

      ----

      -

      -Please provide a corrected patch that addresses the error.`;

      -};

      -
       const tryRepairFile = (file: FileItem, error?: string): FileItem => {
      -    const repairPrompt = generateSingleFileRepairPrompt(file, error);

      +    const repairPrompt =
      PROMPT_TEMPLATES.generateSingleFileRepairPrompt(file, error);
           // In a real app: clipboardy.writeSync(repairPrompt)
           // eslint-disable-next-line no-console
           console.log(`[CLIPBOARD MOCK] Copied repair prompt for: ${file.path}`, repairPrompt);
       
           return file;
       };
       
      -const generateSingleFileInstructPrompt = (file: FileItem, transaction:
      Transaction): string => {

      -    return `The user REJECTED the last proposed change for the file
      \`${file.path}\`.

      -

      -The original high-level goal was:

      ----

      -${transaction.prompt || transaction.message}

      ----

      -

      -The rejected change was:

      ----

      -${file.diff || '// ... rejected diff would be here ...'}

      ----

      -

      -Please provide an alternative solution for \`${file.path}\` that still
      accomplishes the original goal.

      -The response MUST be a complete, corrected patch for this file.`;

      -};

      -
       const tryInstructFile = (file: FileItem, transaction: Transaction): void => {
      -    const instructPrompt = generateSingleFileInstructPrompt(file,
      transaction);

      +    const instructPrompt =
      PROMPT_TEMPLATES.generateSingleFileInstructPrompt(file, transaction);
           // In a real app: clipboardy.writeSync(instructPrompt)
           // eslint-disable-next-line no-console
           console.log(`[CLIPBOARD MOCK] Copied instruction prompt for: ${file.path}`, instructPrompt);
       };
       
      -const generateBulkInstructPrompt = (rejectedFiles: FileItem[],
      transaction: Transaction): string => {

      -    // Mock implementation for demo. In a real scenario, this would
      generate a more complex prompt.

      -    const fileList = rejectedFiles.map(f => `- ${f.path}`).join('\n');

      -    // eslint-disable-next-line no-console

      -    console.log(`[CLIPBOARD] Copied bulk instruction prompt for
      ${rejectedFiles.length} files.`);

      -    return `The user has rejected changes in multiple files for the goal:
      "${transaction.message}".\n\nThe rejected files
      are:\n${fileList}\n\nPlease provide an alternative patch for all of
      them.`;

      -};

      -
       const runBulkReapply = async (
           failedFiles: FileItem[],
       ): Promise<{ id: string; status: FileReviewStatus; error?: string }[]> => {
      @@ ... @@
               }
           });
       };
       
       export const ReviewService = {
           prepareTransactionForReview,
      -    generateBulkRepairPrompt,

      -    generateBulkInstructPrompt,

      -    generateHandoffPrompt,
           performHandoff,
           runApplySimulation,
      -    generateSingleFileRepairPrompt,
           tryRepairFile,
      -    generateSingleFileInstructPrompt,
           tryInstructFile,
           runBulkReapply,
       };

    patchStrategy: standard-diff
  - type: write
    path: src/stores/log.store.ts
    content: |+
      --- src/stores/log.store.ts
      +++ src/stores/log.store.ts
      @@ -1,7 +1,6 @@
       import { create } from 'zustand';
       import type { LogEntry, LogLevel } from '../types/log.types';
      -
      -const MAX_LOGS = 200;
      +import { MAX_LOGS } from '../constants/log.constants';
       
       interface LogState {
           logs: LogEntry[];

    patchStrategy: standard-diff
  - type: write
    path: src/stores/review.store.ts
    content: >+
      --- src/stores/review.store.ts

      +++ src/stores/review.store.ts

      @@ -4,7 +4,7 @@
       import { useViewStore } from './view.store';
       import { ReviewService } from '../services/review.service';
       import { moveIndex } from './navigation.utils';
      -import { INITIAL_APPLY_STEPS } from '../constants/review.constants';

      +import { INITIAL_APPLY_STEPS, PROMPT_TEMPLATES } from
      '../constants/review.constants';
       import type { FileReviewStatus } from '../types/domain.types';
       
       export interface ApplyStep {
      @@ ... @@
                   // For this simulation, we'll assume it transitions back, but the action itself doesn't need to do it.
                   // This avoids a direct dependency from the store to app-level navigation.
               },
               tryRepairFile: (fileId) => {
      -            const selectedTransactionId =
      useViewStore.getState().selectedTransactionId;
                   const { fileReviewStates } = get();
      -            if (!selectedTransactionId) return;

      -            const tx = useTransactionStore.getState().transactions.find(t
      => t.id === selectedTransactionId);

      +            const tx = useTransactionStore.getState().transactions.find(t
      => t.id === useViewStore.getState().selectedTransactionId);
                   const file = tx?.files?.find(f => f.id === fileId);
                   if (!file) return;
       
      @@ ... @@
               },
               tryInstruct: (fileId) => {
      -            const selectedTransactionId =
      useViewStore.getState().selectedTransactionId;
                   const { fileReviewStates } = get();
      -            if (!selectedTransactionId) return;

      -            const tx = useTransactionStore.getState().transactions.find(t
      => t.id === selectedTransactionId);

      +            const tx = useTransactionStore.getState().transactions.find(t
      => t.id === useViewStore.getState().selectedTransactionId);
                   const file = tx?.files?.find(f => f.id === fileId);
                   if (!tx || !file) return;
       
      @@ ... @@
               },
               showBulkInstruct: () => get().actions.setBodyView('bulk_instruct'),
               executeBulkInstructOption: async (option) => {
      -            const selectedTransactionId =
      useViewStore.getState().selectedTransactionId;

      -            const tx = useTransactionStore.getState().transactions.find(t
      => t.id === selectedTransactionId);

      +            const tx = useTransactionStore.getState().transactions.find(t
      => t.id === useViewStore.getState().selectedTransactionId);
                   if (!tx?.files) return;
       
                   const rejectedFiles = tx.files.filter(f => get().fileReviewStates.get(f.id)?.status === 'REJECTED');
      @@ ... @@
       
                   switch (option) {
                       case 1:
      -                   
      ReviewService.generateBulkInstructPrompt(rejectedFiles, tx);

      +                   
      PROMPT_TEMPLATES.generateBulkInstructPrompt(rejectedFiles, tx);
                           set({ bodyView: 'none' });
                           break;
                       case 2:
      @@ ... @@
       
               showBulkRepair: () => get().actions.toggleBodyView('bulk_repair'),
               executeBulkRepairOption: async (option) => {
      -            const selectedTransactionId =
      useViewStore.getState().selectedTransactionId;

      -            const tx = useTransactionStore.getState().transactions.find(t
      => t.id === selectedTransactionId);

      +            const tx = useTransactionStore.getState().transactions.find(t
      => t.id === useViewStore.getState().selectedTransactionId);
                   if (!tx?.files) return;
       
                   const failedFiles = tx.files.filter(f => get().fileReviewStates.get(f.id)?.status === 'FAILED');
      @@ ... @@
       
                   switch (option) {
                       case 1:
      -                    ReviewService.generateBulkRepairPrompt(failedFiles);

      +                   
      PROMPT_TEMPLATES.generateBulkRepairPrompt(failedFiles);
                           set({ bodyView: 'none' });
                           break;
                       case 2: {
      @@ ... @@
               },
               confirmHandoff: () => {
      -            const transactionId =
      useViewStore.getState().selectedTransactionId;

      -            const tx = useTransactionStore.getState().transactions.find(t
      => t.id === transactionId);

      +            const tx = useTransactionStore.getState().transactions.find(t
      => t.id === useViewStore.getState().selectedTransactionId);
                   if (!tx?.files) return;
                   const { fileReviewStates } = get();
      -            ReviewService.generateHandoffPrompt(tx, fileReviewStates);

      +            PROMPT_TEMPLATES.generateHandoffPrompt(tx, fileReviewStates);
                   ReviewService.performHandoff(tx.hash);
               },
               scrollReasoningUp: () => set(state => ({ reasoningScrollIndex: Math.max(0, state.reasoningScrollIndex - 1) })),

    patchStrategy: standard-diff
snapshot:
  src/constants/commit.constants.ts: null
  src/constants/dashboard.constants.ts: null
  src/constants/debug.constants.ts: null
  src/constants/history.constants.ts: null
  src/constants/log.constants.ts: null
  src/constants/splash.constants.ts: null
  src/config/ui.config.ts: |-
    /**
     * Centralized UI configuration.
     * This object is the single source of truth for layout constants, thresholds,
     * and other UI-related magic numbers.
     */
    export const UI_CONFIG = {
        diffScreen: {
            collapseThreshold: 20, // Lines before collapsing
            collapseShowLines: 8,  // Lines to show at top/bottom when collapsed
        },
        dashboard: {
            reservedRows: 9, // Non-event stream vertical space (header, footer, etc.)
        },
        history: {
            reservedRows: 8, // Non-content vertical space (header, footer, filter)
        },
        splash: {
            initialCountdown: 3, // Seconds before auto-skip
        },
        footer: {
            horizontalPadding: 2, // Minimum space from the left/right edges of the screen
            actionSeparator: ' · ',
        },
    } as const;
  src/constants/copy.constants.ts: |-
    /**
     * Constants for the Copy/Clipboard feature.
     */
    export const COPYABLE_ITEMS = {
        UUID: 'UUID',
        MESSAGE: 'Git Message',
        PROMPT: 'Prompt',
        REASONING: 'Reasoning',
        FILE_DIFF: 'Diff for',
        ALL_DIFFS: 'All Diffs',
        CONTEXT_FILES: 'Context Files (latest)',
        FULL_YAML: 'Full YAML representation',
        // For multi-selection contexts
        MESSAGES: 'Git Messages',
        PROMPTS: 'Prompts',
        REASONINGS: 'Reasonings',
        DIFFS: 'Diffs',
        UUIDS: 'UUIDs',
    } as const;
  src/constants/detail.constants.ts: |-
    /**
     * Constants for the Transaction Detail screen.
     */
    export const NAVIGATOR_SECTIONS = {
        PROMPT: 'PROMPT',
        REASONING: 'REASONING',
        FILES: 'FILES',
    } as const;

    export const DETAIL_BODY_VIEWS = {
        PROMPT: 'PROMPT',
        REASONING: 'REASONING',
        FILES_LIST: 'FILES_LIST',
        DIFF_VIEW: 'DIFF_VIEW',
        REVERT_CONFIRM: 'REVERT_CONFIRM',
        NONE: 'NONE',
    } as const;
  src/constants/review.constants.ts: |-
    import type { ApplyStep } from '../stores/review.store';

    /**
     * Constants for the Review screen and process.
     */
    export const INITIAL_APPLY_STEPS: ApplyStep[] = [
        { id: 'snapshot', title: 'Reading initial file snapshot...', status: 'pending' },
        { id: 'memory', title: 'Applying operations to memory...', status: 'pending', substeps: [] },
        { id: 'post-command', title: 'Running post-command script...', status: 'pending', substeps: [] },
        { id: 'linter', title: 'Analyzing changes with linter...', status: 'pending', substeps: [] },
    ];
  index.tsx: |-
    import { render } from 'ink';
    import App from './src/App';
    import { useAppStore } from './src/stores/app.store';
    import { useViewStore } from './src/stores/view.store';
    import { useDetailStore } from './src/stores/detail.store';
    import { useHistoryStore } from './src/stores/history.store';
    import { useReviewStore } from './src/stores/review.store';
    import { useTransactionStore } from './src/stores/transaction.store';
    import { useCommitStore } from './src/stores/commit.store';

    const main = () => {
        // Initialize stores
        useTransactionStore.getState().actions.loadTransactions();
        const args = process.argv.slice(2);

        if (args[0] === 'debug-screen' && args[1]) {
            const screenName = args[1].replace(/\.tsx$/, '');
            const { actions: appActions } = useAppStore.getState();

            switch (screenName) {
                case 'DashboardScreen':
                    appActions.showDashboardScreen();
                    break;
                case 'GitCommitScreen':
                    useCommitStore.getState().actions.prepareCommitScreen();
                    appActions.showGitCommitScreen();
                    break;
                case 'ReviewProcessingScreen':
                    useReviewStore.getState().actions.load('1');
                    appActions.showReviewProcessingScreen();
                    break;
                case 'ReviewScreen':
                    useReviewStore.getState().actions.load('1');
                    appActions.showReviewScreen();
                    break;
                case 'TransactionDetailScreen':
                    useDetailStore.getState().actions.load('3');
                    appActions.showTransactionDetailScreen();
                    break;
                case 'TransactionHistoryScreen':
                    useHistoryStore.getState().actions.load();
                    appActions.showTransactionHistoryScreen();
                    break;
                case 'InitializationScreen':
                     appActions.showInitScreen();
                     break;
                case 'SplashScreen':
                     appActions.showSplashScreen();
                     break;
                case 'DebugMenu':
                    appActions.showDashboardScreen();
                    useViewStore.getState().actions.setActiveOverlay('debug');
                    break;
                case 'DebugLogScreen':
                    appActions.showDashboardScreen();
                    useViewStore.getState().actions.setActiveOverlay('log');
                    break;
                default:
                    process.stderr.write(`Unknown debug screen: ${args[1]}\n`);
                    process.exit(1);
            }
        }

        // Check if we're running in an interactive terminal
        if (process.stdin.isTTY && process.stdout.isTTY) {
            // eslint-disable-next-line no-console
            console.clear();
            render(<App />);
        } else {
            process.stderr.write('Interactive terminal required. Please run in a terminal that supports raw input mode.\n');
            process.exit(1);
        }
    };

    main();
  src/components/CopyScreen.tsx: |-
    import { Box, Text } from 'ink';
    import Separator from './Separator';
    import { useStdoutDimensions } from '../utils';
    import ActionFooter from './ActionFooter';
    import { useCopyScreen } from '../hooks/useCopyScreen';

    const CopyScreen = () => {
        const {
            title,
            itemsInView,
            selectedIndex,
            selectedIds,
            lastCopiedMessage,
            viewOffset,
        } = useCopyScreen();
        const [width] = useStdoutDimensions();

        return (
            <Box 
                width="100%"
                height="100%"
                flexDirection="column"
                justifyContent="center"
                alignItems="center"
            >
                <Box 
                    flexDirection="column" 
                    paddingX={2}
                    width="80%"
                >
                    <Text bold color="yellow">▲ relaycode · copy mode</Text>
                    <Separator width={Math.floor(width * 0.8) - 4} />
                    <Box flexDirection="column" marginY={1}>
                        <Text>{title}</Text>
                        <Box flexDirection="column" marginTop={1}>
                            {itemsInView.map((item, index) => {
                                const isSelected = (index + viewOffset) === selectedIndex;
                                const isChecked = selectedIds.has(item.id);
                                return (
                                    <Text key={item.id} color={isSelected ? 'cyan' : undefined}>
                                        {isSelected ? '> ' : '  '}
                                        [{isChecked ? 'x' : ' '}] ({item.key}) {item.label}
                                    </Text>
                                );
                            })}
                        </Box>
                    </Box>
                    <Separator width={Math.floor(width * 0.8) - 4} />
                    {lastCopiedMessage && <Text color="green">✓ {lastCopiedMessage}</Text>}
                    <ActionFooter actions={[
                        { key: '↑↓/PgUp/PgDn', label: 'Nav' },
                        { key: 'Spc/Hotkey', label: 'Toggle' },
                        { key: 'Enter', label: 'Copy' },
                        { key: 'Esc', label: 'Close' },
                    ]}/>
                </Box>
            </Box>
        );
    };

    export default CopyScreen;
  src/components/DashboardScreen.tsx: "import React from 'react';\nimport { Box, Text } from 'ink';\nimport Spinner from 'ink-spinner';\nimport Separator from './Separator';\nimport type { Transaction, TransactionStatus, FileChangeType } from '../types/domain.types';\nimport { useDashboardScreen } from '../hooks/useDashboardScreen';\nimport { UI_CONFIG } from '../config/ui.config';\nimport type { LayoutConfig } from '../hooks/useLayout';\nimport ActionFooter from './ActionFooter';\nimport type { ActionItem } from '../types/actions.types';\n\n// --- Sub-components & Helpers ---\n\nconst getStatusIcon = (status: TransactionStatus) => {\n    switch (status) {\n        case 'PENDING': return <Text color=\"yellow\">?</Text>;\n        case 'APPLIED': return <Text color=\"green\">✓</Text>;\n        case 'COMMITTED': return <Text color=\"blue\">→</Text>;\n        case 'HANDOFF': return <Text color=\"magenta\">→</Text>;\n        case 'FAILED': return <Text color=\"red\">✗</Text>;\n        case 'REVERTED': return <Text color=\"gray\">↩</Text>;\n        case 'IN-PROGRESS': return <Spinner type=\"dots\" />;\n        default: return <Text> </Text>;\n    }\n};\n\nconst getFileChangeTypeIcon = (type: FileChangeType) => {\n    switch (type) {\n        case 'MOD': return '[MOD]';\n        case 'ADD': return '[ADD]';\n        case 'DEL': return '[DEL]';\n        case 'REN': return '[REN]';\n    }\n};\n\nconst formatTimeAgo = (timestamp: number) => {\n    const seconds = Math.floor((Date.now() - timestamp) / 1000);\n    if (seconds < 60) return `${seconds}s`;\n    const minutes = Math.floor(seconds / 60);\n    return `${minutes}m`;\n};\n\nconst ExpandedEventInfo = ({ transaction }: { transaction: Transaction }) => {\n    const stats = transaction.stats;\n    const files = transaction.files || [];\n\n    return (\n        <Box flexDirection=\"column\" paddingLeft={4} marginBottom={1} borderStyle=\"round\" borderLeft={true} borderTop={false} borderRight={false} borderBottom={false} borderColor=\"gray\">\n            {stats && (\n                <Text color=\"gray\">\n                    Stats: {stats.files} files, +{stats.linesAdded}/-{stats.linesRemoved}\n                </Text>\n            )}\n             <Box flexDirection=\"column\" paddingLeft={1}>\n                {files.map(file => (\n                     <Text key={file.id}>\n                        <Text color=\"gray\">{getFileChangeTypeIcon(file.type)}</Text> {file.path}\n                    </Text>\n                ))}\n             </Box>\n        </Box>\n    );\n};\n\nconst EventStreamItem = ({ transaction, isSelected, isExpanded }: { transaction: Transaction, isSelected: boolean, isExpanded: boolean }) => {\n    const icon = getStatusIcon(transaction.status);\n    const time = formatTimeAgo(transaction.timestamp).padEnd(5, ' ');\n    const statusText = transaction.status.padEnd(11, ' ');\n    const expandIcon = isExpanded ? '▾' : '▸';\n    \n    const messageNode = transaction.status === 'IN-PROGRESS'\n        ? <Text color=\"cyan\">{transaction.message}</Text>\n        : transaction.message;\n    \n    const content = (\n        <Text>\n            {time} {expandIcon} {icon} {statusText}{' '}\n            <Text color=\"gray\">{transaction.hash}</Text>\n            {' '}· {messageNode}\n        </Text>\n    );\n\n    return isSelected ? <Text bold color=\"cyan\">{'> '}{content}</Text> : <Text>{'  '}{content}</Text>;\n};\n\nconst ConfirmationContent = ({\n    transactionsToConfirm,\n}: {\n    transactionsToConfirm: Transaction[];\n}) => {\n    const actionText = 'APPROVE';\n    \n    return (\n        <Box flexDirection=\"column\" marginY={1} paddingLeft={2}>\n            <Text bold color=\"yellow\">{actionText} ALL PENDING TRANSACTIONS?</Text>\n            <Text>\n                The following {transactionsToConfirm.length} transaction(s) will be approved:\n            </Text>\n            <Box flexDirection=\"column\" paddingLeft={1} marginTop={1}>\n                {transactionsToConfirm.map(tx => (\n                    <Text key={tx.id}>- {tx.hash}: {tx.message}</Text>\n                ))}\n            </Box>\n        </Box>\n    );\n};\n\n// --- Main Component ---\n\nconst DashboardScreen = () => {\n    const {\n        status,\n        transactions,\n        selectedTransactionIndex,\n        pendingApprovals,\n        pendingCommits,\n        isModal,\n        isProcessing,\n        viewOffset,\n        viewportHeight,\n        transactionsToConfirm,\n        expandedTransactionId,\n    } = useDashboardScreen({\n        layoutConfig: {\n            header: 1,\n            separators: 2,\n            fixedRows: 1 + 1, // status bar, event stream header\n            marginsY: 1 + 1 + 1, // status bar, event stream list, separator\n            footer: 2,\n            // Non-event stream vertical space (header, footer, etc.)\n        },\n    });\n\n    const renderStatusBar = () => {\n        let statusText: string;\n        let statusIcon: React.ReactNode;\n        switch (status) {\n            case 'LISTENING': statusText = 'LISTENING'; statusIcon = <Text color=\"green\">●</Text>; break;\n            case 'PAUSED': statusText = 'PAUSED'; statusIcon = <Text color=\"yellow\">||</Text>; break;\n            case 'APPROVING': statusText = 'APPROVING...'; statusIcon = <Text color=\"cyan\"><Spinner type=\"dots\"/></Text>; break;\n            default: statusText = 'LISTENING'; statusIcon = <Text color=\"green\">●</Text>;\n        }\n\n        let approvalStr: React.ReactNode = String(pendingApprovals).padStart(2, '0');\n        const commitStr: React.ReactNode = String(pendingCommits).padStart(2, '0');\n\n        if (status === 'APPROVING') approvalStr = <Text color=\"cyan\">(<Spinner type=\"dots\"/>)</Text>;\n        if (status === 'CONFIRM_APPROVE') {\n            approvalStr = <Text bold color=\"yellow\">┌ {approvalStr} ┐</Text>;\n        }\n        \n        return (\n            <Text>\n                STATUS: {statusIcon} {statusText} · APPROVALS: {approvalStr} · COMMITS: {commitStr}\n            </Text>\n        );\n    };\n\n    const renderFooter = () => {\n        if (isModal) return (\n            <ActionFooter actions={[\n                { key: 'Enter', label: 'Confirm' },\n                { key: 'Esc', label: 'Cancel' },\n            ]}/>\n        );\n        if (isProcessing) return <Text>Processing... This may take a moment.</Text>;\n\n        const footerActions: ActionItem[] = [\n            { key: '↑↓', label: 'Nav' },\n            { key: '→/Ent', label: 'View' },\n            { key: '←', label: 'Collapse' },\n            { key: 'L', label: 'Log' },\n            { key: 'A', label: 'Approve All' },\n            { key: 'C', label: 'Commit' },\n            { key: 'P', label: status === 'PAUSED' ? 'Resume' : 'Pause' },\n            { key: 'Q', label: 'Quit' },\n        ];\n\t\treturn <ActionFooter actions={footerActions} />;\n    };\n    \n    return (\n        <Box flexDirection=\"column\" height=\"100%\">\n            <Text color=\"cyan\">▲ relaycode dashboard</Text>\n            <Separator />\n            <Box marginY={1}>\n                {renderStatusBar()}\n            </Box>\n            \n            {isModal && (\n                <>\n                    <ConfirmationContent transactionsToConfirm={transactionsToConfirm} />\n                    <Separator />\n                </>\n            )}\n            \n            <Text bold underline> EVENT STREAM (Last 15 minutes)</Text>\n            <Box flexDirection=\"column\" marginTop={1}>\n                {transactions.length === 0 && (\n                     <Box paddingLeft={2}><Text color=\"gray\">Listening for changes... no events yet.</Text></Box>\n                )}\n                {transactions.slice(viewOffset, viewOffset + viewportHeight).map((tx, index) => {\n                    const actualIndex = viewOffset + index;\n                    const isExpanded = expandedTransactionId === tx.id;\n                    return (\n                        <React.Fragment key={tx.id}>\n                            <EventStreamItem\n                                transaction={tx}\n                                isSelected={!isModal && actualIndex === selectedTransactionIndex}\n                                isExpanded={isExpanded}\n                            />\n                            {isExpanded && <ExpandedEventInfo transaction={tx} />}\n                        </React.Fragment>\n                    );\n                })}\n            </Box>\n\n            <Box marginTop={1}><Separator /></Box>\n            {renderFooter()}\n        </Box>\n    );\n};\n\nexport default DashboardScreen;"
  src/components/DebugLogScreen.tsx: >-
    import { Box, Text } from 'ink';

    import TextInput from 'ink-text-input';

    import Separator from './Separator';

    import ActionFooter from './ActionFooter';

    import { useDebugLogScreen } from '../hooks/useDebugLogScreen';

    import type { LogEntry } from '../types/log.types';

    import { useStdoutDimensions } from '../utils';


    const LogLevelColors = {
        DEBUG: 'gray',
        INFO: 'white',
        WARN: 'yellow',
        ERROR: 'red',
    };


    const LogLevelTag = {
        DEBUG: { color: 'white', backgroundColor: 'gray' },
        INFO: { color: 'black', backgroundColor: 'cyan' },
        WARN: { color: 'black', backgroundColor: 'yellow' },
        ERROR: { color: 'white', backgroundColor: 'red' },
    };


    const LogEntryRow = ({ entry, isSelected }: { entry: LogEntry; isSelected:
    boolean }) => {
        const time = new Date(entry.timestamp).toISOString().split('T')[1]?.replace('Z', '');
        const color = LogLevelColors[entry.level];
        const tagColors = LogLevelTag[entry.level];

        return (
            <Text color={color}>
                {isSelected ? '> ' : '  '}
                <Text color="gray">{time}</Text>
                {' '}
                <Text bold color={tagColors.color} backgroundColor={tagColors.backgroundColor}>
                    {' '}{entry.level.padEnd(5, ' ')}{' '}
                </Text>
                {' '}
                {entry.message}
            </Text>
        );
    };


    const DebugLogScreen = () => {
        const {
            logsInView,
            logCount,
            filteredLogCount,
            selectedIndex,
            mode,
            filterQuery,
            setFilterQuery,
            viewOffset,
        } = useDebugLogScreen();
        const [width] = useStdoutDimensions();

        const renderFilter = () => (
            <Box>
                <Text>Filter: </Text>
                {mode === 'FILTER' ? (
                    <TextInput
                        value={filterQuery}
                        onChange={setFilterQuery}
                        placeholder="Type to filter log messages..."
                    />
                ) : (
                    <Text color="gray">{filterQuery || '(none)'}</Text>
                )}
                <Box flexGrow={1} /> 
                <Text>
                    Showing {Math.min(viewOffset + 1, filteredLogCount)}-
                    {Math.min(viewOffset + logsInView.length, filteredLogCount)} of {filteredLogCount}
                </Text> 
            </Box>
        );

        const footerActions =
            mode === 'FILTER'
                ? [{ key: 'Enter/Esc', label: 'Apply & Close Filter' }]
                : [
                      { key: '↑↓/PgUp/PgDn', label: 'Scroll' },
                      { key: 'F', label: 'Filter' },
                      { key: 'C', label: 'Clear' },
                      { key: 'Esc/Ctrl+L', label: 'Close' },
                  ];

        return (
            <Box
                flexDirection="column"
                width="100%"
                height="100%"
                paddingX={2}
                paddingY={1}
            >
                <Text bold color="black" backgroundColor="yellow"> ▲ relaycode · DEBUG LOG </Text>
                <Separator width={width - 4} />
                <Box marginY={1}>{renderFilter()}</Box>
                <Box flexDirection="column" flexGrow={1}>
                    {logsInView.map((entry, index) => (
                        <LogEntryRow
                            key={`${entry.timestamp}-${index}`}
                            entry={entry}
                            isSelected={selectedIndex === index + viewOffset}
                        />
                    ))}
                    {logCount > 0 && filteredLogCount === 0 && (
                        <Text color="gray">No logs match your filter.</Text>
                    )}
                    {logCount === 0 && (
                        <Text color="gray">No log entries yet. Waiting for system activity...</Text>
                    )}
                </Box>
                <Separator width={width - 4} />
                <ActionFooter actions={footerActions} />
            </Box>
        );
    };


    export default DebugLogScreen;
  src/components/DebugMenu.tsx: |-
    import { Box, Text } from 'ink';
    import Separator from './Separator';
    import { useDebugMenu } from '../hooks/useDebugMenu';
    import { useStdoutDimensions } from '../utils';
    import ActionFooter from './ActionFooter';

    const getKeyForIndex = (index: number): string => {
        if (index < 9) {
            return (index + 1).toString();
        }
        return String.fromCharCode('a'.charCodeAt(0) + (index - 9));
    };

    const DebugMenu = () => {
        const { selectedIndex, menuItems, viewOffset, totalItems } = useDebugMenu();
        const [width] = useStdoutDimensions();

        return (
            <Box
                flexDirection="column"
                width="100%"
                paddingX={2}
                paddingY={1}
            >
                <Text bold color="black" backgroundColor="yellow"> ▲ relaycode · DEBUG MENU </Text>
                <Separator width={width - 4} />
                <Box flexDirection="column" marginY={1}>
                    {menuItems.map((item, index) => {
                        const absoluteIndex = index + viewOffset;
                        return (
                            <Text key={item.title} color={selectedIndex === absoluteIndex ? 'cyan' : undefined}>
                                {selectedIndex === absoluteIndex ? '> ' : '  '}
                                ({getKeyForIndex(absoluteIndex)}) {item.title}
                            </Text>
                        );
                    })}
                </Box>
                <Separator width={width - 4} />
                <Box>
                    <ActionFooter actions={[
                        { key: '↑↓/PgUp/PgDn', label: 'Nav' },
                        { key: '1-9,a-z', label: 'Jump' },
                        { key: 'Enter', label: 'Select' },
                        { key: 'Esc/Ctrl+B', label: 'Close' },
                    ]}/>
                    <Box flexGrow={1} />
                    <Text>
                        {Math.min(viewOffset + 1, totalItems)}-
                        {Math.min(viewOffset + menuItems.length, totalItems)} of {totalItems}
                    </Text>
                </Box>
            </Box>
        );
    };

    export default DebugMenu;
  src/components/DiffScreen.tsx: >-
    import { Box, Text } from 'ink';

    import { UI_CONFIG } from '../config/ui.config';


    interface DiffScreenProps {
        filePath: string;
        diffContent: string;
        isExpanded: boolean;
        scrollIndex?: number;
        maxHeight?: number;
    }

    const DiffScreen = ({ filePath, diffContent, isExpanded, scrollIndex = 0,
    maxHeight }: DiffScreenProps) => {
        const lines = diffContent.split('\n');
        const COLLAPSE_THRESHOLD = UI_CONFIG.diffScreen.collapseThreshold;
        const COLLAPSE_SHOW_LINES = UI_CONFIG.diffScreen.collapseShowLines;

        const renderContent = () => {
            if (!isExpanded && lines.length > COLLAPSE_THRESHOLD) {
                const topLines = lines.slice(0, COLLAPSE_SHOW_LINES);
                const bottomLines = lines.slice(lines.length - COLLAPSE_SHOW_LINES);
                const hiddenLines = lines.length - (COLLAPSE_SHOW_LINES * 2);

                return (
                    <>
                        {topLines.map((line, i) => renderLine(line, i))}
                        <Text color="gray">... {hiddenLines} lines hidden ...</Text>
                        {bottomLines.map((line, i) => renderLine(line, i + topLines.length + 1))}
                    </>
                );
            }
            // Handle vertical scrolling for expanded view
            if (isExpanded && maxHeight) {
                const visibleLines = lines.slice(scrollIndex, scrollIndex + maxHeight);
                return visibleLines.map((line, i) => renderLine(line, scrollIndex + i));
            }
            return lines.map((line, i) => renderLine(line, i));
        };

        const renderLine = (line: string, key: number) => {
            let color = 'white';
            if (line.startsWith('+')) color = 'green';
            if (line.startsWith('-')) color = 'red';
            if (line.startsWith('@@')) color = 'cyan';
            return <Text key={key} color={color}>{line}</Text>;
        };

        return (
            <Box flexDirection="column">
                <Text>DIFF: {filePath}</Text>
                <Box flexDirection="column" marginTop={1}>
                    {renderContent()}
                </Box>
            </Box>
        );
    };


    export default DiffScreen;
  src/components/GitCommitScreen.tsx: |-
    import { Box, Text } from 'ink';
    import Spinner from 'ink-spinner';
    import Separator from './Separator';
    import { useGitCommitScreen } from '../hooks/useGitCommitScreen';
    import ActionFooter from './ActionFooter';

    const GitCommitScreen = () => {
        const { transactionsToCommit, finalCommitMessage, isCommitting } = useGitCommitScreen();

        const transactionLines = transactionsToCommit.map(tx => (
            <Text key={tx.id}>- {tx.hash}: {tx.message}</Text>
        ));

        return (
            <Box flexDirection="column">
                <Text color="cyan">▲ relaycode git commit</Text>
                <Separator />
                <Box marginY={1} flexDirection="column" paddingX={2}>
                    <Text>Found {transactionsToCommit.length} new transactions to commit since last git commit.</Text>
                    <Box marginTop={1} flexDirection="column">
                        <Text bold>TRANSACTIONS INCLUDED</Text>
                        {transactionLines}
                    </Box>
                </Box>
                <Separator />
                <Box marginY={1} flexDirection="column" paddingX={2}>
                    <Text bold>FINAL COMMIT MESSAGE</Text>
                    <Box marginTop={1}>
                        <Text>{finalCommitMessage}</Text>
                    </Box>
                </Box>
                <Separator />
                <Box marginY={1} paddingX={2}>
                     <Text>This will run &apos;git add .&apos; and &apos;git commit&apos; with the message above.</Text>
                </Box>
                <Separator />
                {isCommitting
                    ? <Text><Spinner type="dots"/> Committing... please wait.</Text>
                    : <ActionFooter actions={[
                        { key: 'Enter', label: 'Confirm & Commit' },
                        { key: 'Esc', label: 'Cancel' },
                    ]}/>
                }
            </Box>
        );
    };

    export default GitCommitScreen;
  src/components/ReasonScreen.tsx: >-
    import { Box, Text } from 'ink';


    interface ReasonScreenProps {
        reasoning: string,
        scrollIndex?: number,
        visibleLinesCount?: number, // if not provided, all lines are shown
    }


    const ReasonScreen = ({ reasoning, scrollIndex = 0, visibleLinesCount }:
    ReasonScreenProps) => {
        const lines = reasoning.split('\n');
        const visibleLines = visibleLinesCount ? lines.slice(scrollIndex, scrollIndex + visibleLinesCount) : lines;

        return (
            <Box flexDirection="column">
                <Text>REASONING</Text>
                <Box flexDirection="column" marginTop={1}>
                    {visibleLines.map((line, index) => <Text key={index}>{line}</Text>)}
                </Box>
            </Box>
        );
    };


    export default ReasonScreen;
  src/components/ReviewProcessingScreen.tsx: >-
    import { Box, Text } from 'ink';

    import { useTransactionStore } from '../stores/transaction.store';

    import { useViewStore } from '../stores/view.store';

    import { useReviewStore, type ApplyStep } from '../stores/review.store';

    import Separator from './Separator';


    const ApplyStepRow = ({ step, isSubstep = false }: { step: ApplyStep;
    isSubstep?: boolean }) => {
        if (isSubstep) {
            let color;
            if (step.status === 'done' && step.title.startsWith('[✓]')) color = 'green';
            if (step.status === 'failed') color = 'red';

            return (
                <Text color={color}>
                    {'     └─ '}{step.title}
                </Text>
            );
        }

        let symbol;
        let color;
        switch (step.status) {
            case 'pending': symbol = '( )'; break;
            case 'active': symbol = '(●)'; color = 'cyan'; break;
            case 'done': symbol = '[✓]'; color = 'green'; break;
            case 'failed': symbol = '[!]'; color = 'red'; break;
            case 'skipped': symbol = '(-)'; color = 'gray'; break;
        }

        return (
            <Box flexDirection="column">
                <Text>
                    <Text color={color}>{symbol}</Text> {step.title} {step.duration && !isSubstep && `(${step.duration}s)`}
                </Text>
                {step.details && (
                    <Text color="gray">
                        {'     └─ '}{step.details}
                    </Text>
                )}
                {step.substeps?.map((sub: ApplyStep, i: number) => (
                    <ApplyStepRow key={i} step={sub} isSubstep={true} />
                ))}
            </Box>
        );
    };


    const ReviewProcessingScreen = () => {
        const selectedTransactionId = useViewStore(s => s.selectedTransactionId);
        const { patchStatus, applySteps } = useReviewStore(state => ({
            patchStatus: state.patchStatus,
            applySteps: state.applySteps,
        }));
        const transaction = useTransactionStore(s => s.transactions.find(t => t.id === selectedTransactionId));

        const totalDuration = applySteps.reduce((acc: number, step: ApplyStep) => acc + (step.duration || 0), 0);
        const failureCase = patchStatus === 'PARTIAL_FAILURE';
        const footerText = failureCase
            ? `Elapsed: ${totalDuration.toFixed(1)}s · Transitioning to repair workflow...`
            : `Elapsed: ${totalDuration.toFixed(1)}s · Processing... Please wait.`;

        if (!transaction) {
            return <Text>Loading...</Text>;
        }

        return (
            <Box flexDirection="column">
                <Text color="cyan">▲ relaycode apply</Text>
                <Separator />
                <Box marginY={1} flexDirection="column">
                    <Text>Applying patch {transaction.hash}... ({transaction.message})</Text>
                    <Box flexDirection="column" marginTop={1} gap={1}>
                        {applySteps.map((step: ApplyStep) => <ApplyStepRow key={step.id} step={step} />)}
                    </Box>
                </Box>
                <Separator />
                <Text>{footerText}</Text>
            </Box>
        );
    };


    export default ReviewProcessingScreen;
  src/components/ReviewScreen.tsx: >-
    import { Box, Text } from 'ink';

    import Separator from './Separator';

    import DiffScreen from './DiffScreen';

    import ReasonScreen from './ReasonScreen';

    import type { ScriptResult, FileItem, FileChangeType } from
    '../types/domain.types';

    import { useReviewScreen } from '../hooks/useReviewScreen';

    import ActionFooter from './ActionFooter';

    import type { ActionItem } from '../types/actions.types';


    // --- Sub-components ---


    const FileItemRow = ({ file, reviewStatus, reviewError, reviewDetails,
    isFocused }: {
        file: FileItem;
        reviewStatus: string;
        reviewError?: string;
        reviewDetails?: string;
        isFocused: boolean;
    }) => {
        let icon;
        let iconColor;
        switch (reviewStatus) {
            case 'APPROVED': icon = '[✓]'; iconColor = 'green'; break;
            case 'REJECTED': icon = '[✗]'; iconColor = 'red'; break;
            case 'FAILED': icon = '[!]'; iconColor = 'red'; break;
            case 'AWAITING': icon = '[●]'; iconColor = 'yellow'; break;
            case 'RE_APPLYING': icon = '[●]'; iconColor = 'cyan'; break;
        }

        const typeColor = (type: FileChangeType) => {
            switch (type) {
                case 'ADD': return 'green';
                case 'DEL': return 'red';
                case 'REN': return 'yellow';
                default: return 'white';
            }
        };

        const diffStats = <Text>(+<Text color="green">{file.linesAdded}</Text>/-<Text color="red">{file.linesRemoved}</Text>)</Text>;
        const strategy = file.strategy === 'standard-diff' ? 'diff' : file.strategy;
        const prefix = isFocused ? '> ' : '  ';
        const colorProps = isFocused ? { bold: true, color: 'cyan' } : {};

        if (reviewStatus === 'FAILED') {
            return (
                <Box>
                    <Text {...colorProps}>
                        {prefix}<Text color={iconColor}>{icon} FAILED {file.path}</Text>
                        <Text color="red">    ({reviewError})</Text>
                    </Text>
                </Box>
            );
        }

        if (reviewStatus === 'AWAITING') {
            return (
                <Box>
                    <Text {...colorProps}>
                        {prefix}<Text color={iconColor}>{icon} AWAITING {file.path}</Text>
                        <Text color="yellow">    ({reviewDetails})</Text>
                    </Text>
                </Box>
            );
        }

        if (reviewStatus === 'RE_APPLYING') {
            return (
                 <Box>
                    <Text {...colorProps}>
                        {prefix}<Text color={iconColor}>{icon} RE-APPLYING... {file.path}</Text>
                        <Text color="cyan"> (using &apos;replace&apos; strategy)</Text>
                    </Text>
                </Box>
            );
        }

        return (
            <Box>
                <Text {...colorProps}>
                    {prefix}<Text color={iconColor}>{icon}</Text> {file.type}{' '}
                    <Text color={typeColor(file.type)}>{file.path}</Text>{' '}
                    {diffStats} [{strategy}]
                </Text>
            </Box>
        );
    };


    const ScriptItemRow = ({
        script,
        isSelected,
        isExpanded,
    }: {
        script: ScriptResult;
        isSelected: boolean;
        isExpanded: boolean;
    }) => {
        const icon = script.success ? '✓' : '✗';
        const iconColor = script.success ? 'green' : 'red';
        const arrow = isExpanded ? '▾' : '▸';
        const prefix = isSelected ? '> ' : '  ';
        
        // Extract script type from command (e.g., "bun run test" -> "Post-Command", "bun run lint" -> "Linter")
        const scriptType = script.command.includes('test') ? 'Post-Command' : 
                          script.command.includes('lint') ? 'Linter' : 
                          'Script';

        return (
            <Box>
                <Text bold={isSelected} color={isSelected ? 'cyan' : undefined}>
                    {prefix}<Text color={iconColor}>{icon}</Text> {scriptType}: `{script.command}` ({script.duration}s) {arrow}{' '}
                    {script.summary}
                </Text>
            </Box>
        );
    };


    // --- Main Component ---


    const ReviewScreen = () => {
        const {
            transaction,
            files,
            scripts = [],
            patchStatus,
            selectedItemIndex,
            bodyView,
            isDiffExpanded,
            reasoningScrollIndex,
            scriptErrorIndex,
            fileReviewStates,
            numFiles,
            approvedFilesCount,
            totalLinesAdded,
            totalLinesRemoved,
            selectedBulkRepairOptionIndex,
            selectedBulkInstructOptionIndex,
            navigableItems,
            navigableItemsInView,
            viewOffset,
            contentScrollIndex,
            availableBodyHeight,
            hasRejectedFiles,
        } = useReviewScreen();

        if (!transaction) {
            return <Text>Loading review...</Text>;
        }
        const { hash, message, prompt = '', reasoning = '' } = transaction;

        const renderBody = () => {
            if (bodyView === 'none') return null;

            if (bodyView === 'reasoning') {
                const reasoningText = reasoning || '';
                const reasoningLinesCount = reasoningText.split('\n').length;
                const visibleLinesCount = 10;
                return (
                    <Box flexDirection="column">
                        <ReasonScreen
                            reasoning={reasoningText}
                            scrollIndex={contentScrollIndex}
                            visibleLinesCount={Math.max(1, availableBodyHeight)}
                        />
                        {reasoningLinesCount > visibleLinesCount && (
                            <Text color="gray">
                                Showing lines {reasoningScrollIndex + 1}-{Math.min(reasoningScrollIndex + visibleLinesCount, reasoningLinesCount)}{' '}
                                of {reasoningLinesCount}
                            </Text>
                        )}
                    </Box>
                );
            }
            
            if (bodyView === 'diff') {
                const currentItem = navigableItems[selectedItemIndex];
                const selectedFile = currentItem?.type === 'file' ? files.find(f => f.id === currentItem.id) : undefined;
                if (!selectedFile) return null;
                return (
                    <DiffScreen
                        filePath={selectedFile.path}
                        diffContent={selectedFile.diff}
                        isExpanded={isDiffExpanded}
                        scrollIndex={contentScrollIndex}
                        maxHeight={Math.max(1, availableBodyHeight)}
                    />
                );
            }

            if (bodyView === 'script_output') {
                 const currentItem = navigableItems[selectedItemIndex];
                 const scriptItems = navigableItems.filter((i): i is { type: 'script'; id: string } => i.type === 'script');
                 const scriptIndex = currentItem?.type === 'script'
                    ? scriptItems.findIndex(i => i.id === currentItem.id)
                    : -1;
                 const selectedScript = scripts[scriptIndex] || null;
                 if (!selectedScript) return null;
                 
                 const outputLines = selectedScript.output.split('\n');
                 const errorLines = outputLines.filter((line: string) =>
                    line.includes('Error') || line.includes('Warning'),
                 );
                 
                 return (
                    <Box flexDirection="column">
                        <Text>
                            {selectedScript.command.includes('lint') ? 'LINTER' : 'SCRIPT'} OUTPUT: `{selectedScript.command}`
                        </Text>
                        <Box marginTop={1} flexDirection="column">
                            {outputLines.map((line: string, index: number) => {
                                const isError = line.includes('Error');
                                const isWarning = line.includes('Warning');
                                const isHighlighted = errorLines[scriptErrorIndex] === line;
                                
                                return (
                                    <Text 
                                        key={index} 
                                        color={isError ? 'red' : isWarning ? 'yellow' : undefined}
                                        bold={isHighlighted}
                                        backgroundColor={isHighlighted ? 'blue' : undefined}
                                    >
                                        {line}
                                    </Text>
                                );
                            })}
                        </Box>
                        {errorLines.length > 0 && (
                            <Text color="gray">
                                Error {scriptErrorIndex + 1} of {errorLines.length} highlighted
                            </Text>
                        )}
                    </Box>
                 );
            }

            if (bodyView === 'confirm_handoff') {
                return (
                    <Box flexDirection="column" gap={1}>
                        <Text bold>HANDOFF TO EXTERNAL AGENT</Text>
                        <Box flexDirection="column">
                            <Text>This action will:</Text>
                            <Text>1. Copy a detailed prompt to your clipboard for an agentic AI.</Text>
                            <Text>2. Mark the current transaction as &apos;Handoff&apos; and close this review.</Text>
                            <Text>3. Assume that you and the external agent will complete the work.</Text>
                        </Box>
                        <Text>Relaycode will NOT wait for a new patch. This is a final action.</Text>
                        <Text bold color="yellow">Are you sure you want to proceed?</Text>
                    </Box>
                );
            }

            if (bodyView === 'bulk_repair') {
                const failedFiles = files.filter((f: FileItem) => fileReviewStates.get(f.id)?.status === 'FAILED');
                const repairOptions = [
                    '(1) Copy Bulk Re-apply Prompt (for single-shot AI)',
                    '(2) Bulk Change Strategy & Re-apply',
                    '(3) Handoff to External Agent',
                    '(4) Bulk Abandon All Failed Files',
                    '(Esc) Cancel',
                ];

                return (
                    <Box flexDirection="column" gap={1}>
                        <Text bold>BULK REPAIR ACTION</Text>

                        <Box flexDirection="column">
                            <Text>The following {failedFiles.length} files failed to apply:</Text>
                            {failedFiles.map((file: FileItem) => (
                                <Text key={file.id}>- {file.path}</Text>
                            ))}
                        </Box>

                        <Text>How would you like to proceed?</Text>

                        <Box flexDirection="column">
                            {repairOptions.map((opt, i) => (
                                <Text key={i} color={selectedBulkRepairOptionIndex === i ? 'cyan' : undefined}>
                                    {selectedBulkRepairOptionIndex === i ? '> ' : '  '}
                                    {opt}
                                </Text>
                            ))}
                        </Box>
                    </Box>
                );
            }

            if (bodyView === 'bulk_instruct') {
                const rejectedFiles = files.filter((f: FileItem) => fileReviewStates.get(f.id)?.status === 'REJECTED');
                const instructOptions = [
                    '(1) Copy Bulk Re-instruct Prompt (for single-shot AI)',
                    '(2) Handoff to External Agent',
                    '(3) Bulk Un-reject All Files (revert to original)',
                    '(4) Cancel',
                ];

                return (
                    <Box flexDirection="column" gap={1}>
                        <Text bold>BULK INSTRUCTION ACTION</Text>

                        <Box flexDirection="column">
                            <Text>The following {rejectedFiles.length} files were rejected:</Text>
                            {rejectedFiles.map((file: FileItem) => (
                                <Text key={file.id}>- {file.path}</Text>
                            ))}
                        </Box>
                        <Box flexDirection="column" marginTop={1}>
                            {instructOptions.map((opt, i) => (
                                <Text key={i} color={selectedBulkInstructOptionIndex === i ? 'cyan' : undefined}>
                                    {selectedBulkInstructOptionIndex === i ? '> ' : '  '}
                                    {opt}
                                </Text>
                            ))}
                        </Box>
                    </Box>
                );
            }

            return null;
        };

        const renderFooter = () => {
            // Contextual footer for body views
            if (bodyView === 'diff') {
                return <ActionFooter actions={[
                    { key: '↑↓', label: 'Nav' },
                    { key: 'X', label: 'Expand' },
                    { key: 'D/Esc', label: 'Back' },
                ]}/>;
            }
            if (bodyView === 'reasoning') {
                return <ActionFooter actions={[
                    { key: '↑↓', label: 'Scroll Text' },
                    { key: 'R', label: 'Collapse View' },
                    { key: 'C', label: 'Copy Mode' },
                ]}/>;
            }
            if (bodyView === 'script_output') {
                return <ActionFooter actions={[
                    { key: '↑↓', label: 'Nav' },
                    { key: 'J↓/K↑', label: 'Next/Prev Error' },
                    { key: 'C', label: 'Copy Output' },
                    { key: 'Ent/Esc', label: 'Back' },
                ]}/>;
            }
            if (bodyView === 'bulk_repair') {
                return <Text>Use (↑↓) Nav · (Enter) Select · (1-4) Jump · (Esc) Cancel</Text>;
            }
            if (bodyView === 'bulk_instruct') {
                return <Text>Use (↑↓) Nav · (Enter) Select · (1-4) Jump · (Esc) Cancel</Text>;
            }
            if (bodyView === 'confirm_handoff') {
                return <ActionFooter actions={[
                    { key: 'Enter', label: 'Confirm Handoff' },
                    { key: 'Esc', label: 'Cancel' },
                ]}/>;
            }

            // Main footer
            const actions: ActionItem[] = [{ key: '↑↓', label: 'Nav' }];

            const currentItem = navigableItems[selectedItemIndex];
            
            if (currentItem?.type === 'file') {
                const selectedFile = files.find(f => f.id === currentItem.id);
                const fileState = fileReviewStates.get(currentItem.id);
                if (fileState?.status !== 'FAILED') {
                    actions.push({ key: 'Spc', label: 'Toggle' });
                }
                actions.push({ key: 'D', label: 'Diff' });
                
                // Add repair options for failed files
                if (selectedFile && fileState?.status === 'FAILED') {
                    actions.push({ key: 'T', label: 'Try Repair' });
                }
                if (selectedFile && fileState?.status === 'REJECTED') {
                    actions.push({ key: 'I', label: 'Instruct' });
                }
            } else if (currentItem?.type === 'script') {
                actions.push({ key: 'Ent', label: 'Expand Details' });
            } else { // Prompt or Reasoning
                actions.push({ key: 'Ent', label: 'Expand' });
            }

            if (currentItem?.type !== 'reasoning') {
                actions.push({ key: 'R', label: 'Reasoning' });
            }

            // Add bulk repair if there are failed files
            const hasFailedFiles = Array.from(fileReviewStates.values()).some(s => s.status === 'FAILED');
            if (hasFailedFiles) {
                actions.push({ key: 'Shift+T', label: 'Bulk Repair' });
            }
            // Add bulk instruct if there are rejected files
            if (hasRejectedFiles) {
                actions.push({ key: 'Shift+I', label: 'Bulk Instruct' });
            }
            
            actions.push({ key: 'C', label: 'Copy' });

            if (approvedFilesCount > 0) {
                actions.push({ key: 'A', label: 'Approve' });
            }

            if (Array.from(fileReviewStates.values()).some(s => s.status === 'APPROVED' || s.status === 'FAILED')) {
                actions.push({ key: 'Shift+R', label: 'Reject All' });
            }
            actions.push({ key: 'Q', label: 'Quit' });

            return <ActionFooter actions={actions} />;
        };

        return (
            <Box flexDirection="column">
                {/* Header */}
                <Text color="cyan">▲ relaycode review</Text>
                <Separator />
                
                {/* Navigator Section */}
                <Box flexDirection="column" marginY={1}>
                    <Box flexDirection="column">
                        <Text>{hash} · {message}</Text>
                        <Text>
                            (<Text color="green">+{totalLinesAdded}</Text>/<Text color="red">-{totalLinesRemoved}</Text>
                            ) · {numFiles} Files · ({approvedFilesCount}/{numFiles} Appr)
                            · Showing {viewOffset + 1}-
                            {Math.min(viewOffset + navigableItemsInView.length, navigableItems.length)} of {navigableItems.length}
                            {patchStatus === 'PARTIAL_FAILURE' && scripts.length === 0 && <Text> · Scripts: SKIPPED</Text>}
                            {patchStatus === 'PARTIAL_FAILURE' && <Text color="red" bold> · MULTIPLE PATCHES FAILED</Text>}
                        </Text>
                    </Box>

                    <Box flexDirection="column" marginTop={1}>
                        <Text color={navigableItems[selectedItemIndex]?.type === 'prompt' ? 'cyan' : undefined}>
                            {navigableItems[selectedItemIndex]?.type === 'prompt' ? '> ' : '  '}
                            (P)rompt ▸ {(prompt || '').substring(0, 60)}...
                        </Text>
                        <Text color={navigableItems[selectedItemIndex]?.type === 'reasoning' ? 'cyan' : undefined}>
                            {navigableItems[selectedItemIndex]?.type === 'reasoning' ? '> ' : '  '}
                            (R)easoning ({(reasoning || '').split('\n\n').length} steps) {bodyView === 'reasoning' ? '▾' : '▸'}{' '}
                            {((reasoning || '').split('\n')[0] ?? '').substring(0, 50)}...
                        </Text>
                    </Box>
                </Box>

                <Separator />

                {/* Script Results (if any) */}
                {scripts.length > 0 && navigableItemsInView.some(i => i.type === 'script') && (
                    <>
                        <Box flexDirection="column" marginY={1}>
                            {scripts.map((script: ScriptResult) => {
                                const itemInViewIndex = navigableItemsInView.findIndex(i => i.type === 'script' && i.id === script.command);
                                if (itemInViewIndex === -1) return null; // Only render if visible
                                
                                const isSelected = selectedItemIndex === viewOffset + itemInViewIndex;
                                return (
                                    <ScriptItemRow key={script.command} script={script} isSelected={isSelected} isExpanded={bodyView === 'script_output' && isSelected} />
                                );
                            })}
                        </Box>
                        <Separator />
                    </>
                )}
                
                {/* Files Section */}
                <Box flexDirection="column" marginY={1}>
                    <Text bold>FILES</Text>
                    {files.map((file: FileItem) => {
                        const itemInViewIndex = navigableItemsInView.findIndex(i => i.type === 'file' && i.id === file.id);
                        if (itemInViewIndex === -1) return null; // Only render if visible

                        const isFocused = selectedItemIndex === viewOffset + itemInViewIndex;
                        const reviewState = fileReviewStates.get(file.id);
                        
                        return (
                            <FileItemRow
                                key={file.id} file={file} isFocused={isFocused}
                                reviewStatus={reviewState?.status || 'AWAITING'}
                                reviewError={reviewState?.error}
                                reviewDetails={reviewState?.details}
                            />
                        );
                    })}
                </Box>
                
                <Separator />
                
                {/* Body Viewport */}
                {bodyView !== 'none' && (
                    <>
                        <Box marginY={1}>
                            {renderBody()}
                        </Box>
                        <Separator />
                    </>
                )}

                {/* Footer */}
                <Box>
                    {renderFooter()}
                </Box>
            </Box>
        );
    };


    export default ReviewScreen;
  src/components/SplashScreen.tsx: |-
    import { Box, Text } from 'ink';
    import Separator from './Separator';
    import { useSplashScreen } from '../hooks/useSplashScreen';

    const SplashScreen = () => {
        const { countdown } = useSplashScreen();
        const logo = `
             ░█▀▄░█▀▀░█░░░█▀█░█░█░█▀▀░█▀█░█▀▄░█▀▀
             ░█▀▄░█▀▀░█░░░█▀█░░█░░█░░░█░█░█░█░█▀▀
             ░▀░▀░▀▀▀░▀▀▀░▀▀▀░▀▀▀░▀░▀░░▀░░▀▀▀░▀▀▀
    `;

        return (
            <Box flexDirection="column">
                <Text color="cyan">▲ relaycode</Text>
                <Separator />
                <Text color="cyan">{logo}</Text>
                <Box flexDirection="column" alignItems="center">
                    <Text italic>A zero-friction, AI-native patch engine.</Text>
                    <Text italic color="gray">Built by Arman and contributors · <Text underline>https://relay.noca.pro</Text></Text>
                </Box>
                
                <Box flexDirection="row" justifyContent="space-around" width="100%" marginTop={1}>
                    <Box flexDirection="column" width="45%">
                        <Text>Version 1.1.5</Text>
                        <Text>─────────────────────────</Text>
                        <Text>relaycode</Text>
                        <Text>relaycode-core</Text>
                        <Text>apply-multi-diff</Text>
                        <Text>konro</Text>
                    </Box>
                     <Box flexDirection="column" width="45%">
                        <Text>Build Timestamps</Text>
                        <Text>─────────────────────────</Text>
                        <Text>2025-09-20 13:58:05</Text>
                        <Text>2025-09-20 10:59:05</Text>
                        <Text>(versioned)</Text>
                        <Text>(versioned)</Text>
                    </Box>
                </Box>
                
                <Box marginTop={1}><Separator /></Box>
                <Text>If you love this workflow, check out <Text underline>https://www.noca.pro</Text> for the full</Text>
                <Text>web app with repo-wide visual context, history, and rollback.</Text>
                <Text><Text color="cyan" bold>(V)</Text>isit noca.pro</Text>
                <Separator />
                <Text>Follow <Text color="cyan" bold>(X)</Text> · Join <Text color="cyan" bold>(D)</Text>iscord · Star on <Text color="cyan" bold>(G)</Text>itHub</Text>
                <Separator />
                <Text>Loading... {countdown} (<Text color="gray">Press any key to skip</Text>)</Text>
            </Box>
        );
    };

    export default SplashScreen;
  src/components/TransactionDetailScreen.tsx: >-
    import { Box, Text } from 'ink';

    import Separator from './Separator';

    import DiffScreen from './DiffScreen';

    import ReasonScreen from './ReasonScreen';

    import { useTransactionDetailScreen } from
    '../hooks/useTransactionDetailScreen';

    import type { FileChangeType } from '../types/domain.types';

    import ActionFooter from './ActionFooter';

    import type { ActionItem } from '../types/actions.types';


    const getFileChangeTypeIcon = (type: FileChangeType) => {
        switch (type) {
            case 'MOD': return '[MOD]';
            case 'ADD': return '[ADD]';
            case 'DEL': return '[DEL]';
            case 'REN': return '[REN]';
        }
    };


    const RevertModal = ({ transactionHash }: { transactionHash: string }) => {
        return (
            <Box 
                borderStyle="round"
                borderColor="yellow"
                flexDirection="column"
                paddingX={2}
                width="80%"
                alignSelf='center'
            >
                <Text bold color="yellow" wrap="wrap" >REVERT THIS TRANSACTION?</Text>
                <Box height={1} />
                <Text wrap="wrap">This will create a NEW transaction that reverses all changes made by {transactionHash}. The original transaction record will be preserved.</Text>
                <Box height={1} />
                <Text wrap="wrap">Are you sure?</Text>
            </Box>
        );
    };


    const TransactionDetailScreen = () => {
        const {
            transaction, files,
            focusedItemPath, expandedItemPaths, bodyView, contentScrollIndex, availableBodyHeight,
        } = useTransactionDetailScreen();

        if (!transaction) {
            return <Text>Loading transaction...</Text>;
        }

        const renderNavigator = () => {
            const isPromptFocused = focusedItemPath === 'PROMPT';
            const isReasoningFocused = focusedItemPath === 'REASONING';
            const isFilesFocused = focusedItemPath.startsWith('FILES');
            
            const isPromptExpanded = expandedItemPaths.has('PROMPT');
            const isReasoningExpanded = expandedItemPaths.has('REASONING');
            const isFilesExpanded = expandedItemPaths.has('FILES');
            
            return (
                <Box flexDirection="column">
                    <Text color={isPromptFocused ? 'cyan' : undefined}>
                        {isPromptFocused ? '> ' : '  '}
                        {isPromptExpanded ? '▾' : '▸'} (P)rompt
                    </Text>
                    <Text color={isReasoningFocused ? 'cyan' : undefined}>
                        {isReasoningFocused ? '> ' : '  '}
                        {isReasoningExpanded ? '▾' : '▸'} (R)easoning ({transaction.reasoning?.split('\n\n').length || 0} steps)
                    </Text>
                    <Text color={isFilesFocused ? 'cyan' : undefined}>
                        {isFilesFocused && !focusedItemPath.includes('/') ? '> ' : '  '}
                        {isFilesExpanded ? '▾' : '▸'} (F)iles ({files.length})
                    </Text>
                    {isFilesExpanded && (
                        <Box flexDirection="column" paddingLeft={2}>
                            {files.map((file) => {
                                 const fileId = `FILES/${file.id}`;
                                 const isFileSelected = focusedItemPath === fileId;
                                 const stats = file.type === 'DEL'
                                    ? ''
                                    : ` (+${file.linesAdded}/-${file.linesRemoved})`;
                                 return (
                                    <Text key={file.id} color={isFileSelected ? 'cyan' : undefined}>
                                        {isFileSelected ? '> ' : '  '}
                                        {getFileChangeTypeIcon(file.type)} {file.path}{stats}
                                    </Text>
                                );
                            })}
                        </Box>
                    )}
                </Box>
            );
        };

        const renderBody = () => {
            if (bodyView === 'NONE') {
                return <Text color="gray">(Press → to expand a section and view its contents)</Text>;
            }
            if (bodyView === 'PROMPT') {
                return (
                    <Box flexDirection="column">
                        <Text>PROMPT</Text>
                        <Box marginTop={1} flexDirection="column">
                            {(transaction.prompt || '').split('\n')
                                .slice(contentScrollIndex, contentScrollIndex + availableBodyHeight)
                                .map((line, i) => <Text key={i}>{line}</Text>)
                            }
                        </Box>
                    </Box>
                );
            }
            if (bodyView === 'REASONING') {
                if (!transaction.reasoning) return <Text color="gray">No reasoning provided.</Text>;
                return <ReasonScreen reasoning={transaction.reasoning} scrollIndex={contentScrollIndex} visibleLinesCount={Math.max(1, availableBodyHeight)} />;
            }
            if (bodyView === 'FILES_LIST') {
                 return <Text color="gray">(Select a file and press → to view the diff)</Text>;
            }
            if (bodyView === 'DIFF_VIEW') {
                const fileId = focusedItemPath.split('/')[1];
                const file = files.find(f => f.id === fileId);
                if (!file) return null;
                return <DiffScreen filePath={file.path} diffContent={file.diff} isExpanded={true} scrollIndex={contentScrollIndex} maxHeight={Math.max(1, availableBodyHeight)} />;
            }
            return null;
        };

        const renderFooter = () => {
            if (bodyView === 'REVERT_CONFIRM') {
                return <ActionFooter actions={[
                    { key: 'Enter', label: 'Confirm Revert' },
                    { key: 'Esc', label: 'Cancel' },
                ]} />;
            }
            
            const isFileFocused = focusedItemPath.includes('/');
            const baseActions: ActionItem[] = [
                { key: 'C', label: 'Copy' },
                { key: 'O', label: isFileFocused ? 'Open File' : 'Open YAML' },
                { key: 'U', label: 'Undo' },
                { key: 'Q', label: 'Quit/Back' },
            ];
            let contextualActions: ActionItem[] = [];

            if (isFileFocused) { // Is a file
                if (bodyView === 'DIFF_VIEW') {
                    contextualActions = [
                        { key: '↑↓', label: 'Nav Files' },
                        { key: '←', label: 'Back to List' },
                    ];
                } else {
                    contextualActions = [
                        { key: '↑↓', label: 'Nav Files' },
                        { key: '→', label: 'View Diff' },
                        { key: '←', label: 'Back to Sections' },
                    ];
                }
                return <ActionFooter actions={[...contextualActions, ...baseActions]} />;
            }
            
            if (expandedItemPaths.has(focusedItemPath)) {
                contextualActions = [
                    { key: '↑↓', label: 'Nav/Scroll' },
                    { key: '→', label: 'Drill In' },
                    { key: '←', label: 'Collapse' },
                ];
            } else {
                contextualActions = [
                    { key: '↑↓', label: 'Nav' },
                    { key: '→', label: 'Expand' },
                ];
            }
            return <ActionFooter actions={[...contextualActions, ...baseActions]} />;
        };

        const { message, timestamp, status } = transaction;
        const date = new Date(timestamp).toISOString().replace('T', ' ').substring(0, 19);
        const fileStats = `${files.length} Files · +${files.reduce((a, f) => a + f.linesAdded, 0)} lines, -${files.reduce((a, f) => a + f.linesRemoved, 0)} lines`;

        return (
            <Box flexDirection="column">
                {/* Header */}
                <Text>▲ relaycode transaction details</Text>
                <Separator />
                
                {/* Modal takeover for Revert */}
                {bodyView === 'REVERT_CONFIRM' && <RevertModal transactionHash={transaction.hash} />}
                
                {/* Main view */}
                <Box flexDirection="column" display={bodyView === 'REVERT_CONFIRM' ? 'none' : 'flex'}>
                    {/* Navigator Part A */}
                    <Box flexDirection="column" marginY={1}>
                        <Text>UUID: {transaction.id}</Text>
                        <Text>Git: {message}</Text>
                        <Text>Date: {date} · Status: {status}</Text>
                        <Text>Stats: {fileStats}</Text>
                    </Box>
                    
                    {/* Navigator Part B */}
                    {renderNavigator()}
                    
                    <Separator />
                    
                    {/* Body */}
                    <Box marginY={1}>
                        {renderBody()}
                    </Box>
                    
                    <Separator />
                </Box>
                
                {/* Footer */}
                <Box>
                    {renderFooter()}
                </Box>
            </Box>
        );
    };


    export default TransactionDetailScreen;
  src/components/TransactionHistoryScreen.tsx: >-
    import { useMemo } from 'react';

    import { Box, Text } from 'ink';

    import TextInput from 'ink-text-input';

    import Spinner from 'ink-spinner';

    import Separator from './Separator';

    import type { Transaction, FileItem } from '../types/domain.types';

    import { useTransactionHistoryScreen } from
    '../hooks/useTransactionHistoryScreen';

    import type { LayoutConfig } from '../hooks/useLayout';

    import ActionFooter from './ActionFooter';

    import type { ActionItem } from '../types/actions.types';


    // --- Sub-components ---


    const ContentRow = ({ title, content, isSelected, isExpanded, isLoading }: {
        title: string;
        content: string;
        isSelected: boolean;
        isExpanded: boolean;
        isLoading: boolean;
    }) => {
        const icon = isExpanded ? '▾' : '▸';
        return (
            <Box flexDirection="column" paddingLeft={6}>
                <Text color={isSelected ? 'cyan' : undefined}>
                    {isSelected ? '> ' : '  '}{icon} {title}
                </Text>
                {isLoading && <Box paddingLeft={8}><Spinner type="dots" /></Box>}
                {isExpanded && !isLoading && (
                    <Box paddingLeft={8} flexDirection="column">
                        {(content || '').split('\n').map((line, i) => <Text key={i}>{line || ' '}</Text>)}
                    </Box>
                )}
            </Box>
        );
    };


    const DiffPreview = ({ diff }: { diff: string }) => {
        const lines = diff.split('\n');
        const previewLines = lines.slice(0, 5);
        const hiddenLines = lines.length > 5 ? lines.length - 5 : 0;

        return (
            <Box flexDirection="column" paddingLeft={8}>
                {previewLines.map((line, i) => {
                    let color = 'white';
                    if (line.startsWith('+')) color = 'green';
                    if (line.startsWith('-')) color = 'red';
                    if (line.startsWith('@@')) color = 'cyan';
                    return <Text key={i} color={color}>{line}</Text>;
                })}
                {hiddenLines > 0 && <Text color="gray">... {hiddenLines} lines hidden ...</Text>}
            </Box>
        );
    };


    const FileRow = ({ file, isSelected, isExpanded, isLoading }: {
        file: FileItem;
        isSelected: boolean;
        isExpanded: boolean;
        isLoading: boolean;
    }) => {
        const icon = isExpanded ? '▾' : '▸';
        const typeMap = { MOD: '[MOD]', ADD: '[ADD]', DEL: '[DEL]', REN: '[REN]' };
        
        return (
            <Box flexDirection="column" paddingLeft={6}>
                <Text color={isSelected ? 'cyan' : undefined}>
                    {isSelected ? '> ' : '  '}
                    {icon} {typeMap[file.type]} {file.path}
                </Text>
                {isLoading && <Box paddingLeft={8}><Spinner type="dots" /></Box>}
                {isExpanded && !isLoading && <DiffPreview diff={file.diff} />}
            </Box>
        );
    };


    const TransactionRow = ({
        tx,
        isSelected,
        isExpanded,
        isSelectedForAction,
        hasSelection,
    }: {
        tx: Transaction;
        isSelected: boolean;
        isExpanded: boolean;
        isSelectedForAction: boolean;
        hasSelection: boolean;
    }) => {
        const icon = isExpanded ? '▾' : '▸';
        const statusMap = {
            COMMITTED: <Text color="green">✓ Committed</Text>,
            HANDOFF: <Text color="magenta">→ Handoff</Text>,
            REVERTED: <Text color="gray">↩ Reverted</Text>,
            APPLIED: <Text color="blue">✓ Applied</Text>,
            PENDING: <Text color="yellow">? Pending</Text>,
            FAILED: <Text color="red">✗ Failed</Text>,
        };
        const date = new Date(tx.timestamp).toISOString().split('T')[0];
        const selectionIndicator = isSelectedForAction ? '[x] ' : '[ ] ';
        
        const statusDisplay = statusMap[tx.status as keyof typeof statusMap] || tx.status;

        return (
            <Box flexDirection="column" marginBottom={isExpanded ? 1 : 0}>
                <Text color={isSelected ? 'cyan' : undefined}>
                    {isSelected ? '> ' : '  '}
                    {hasSelection && selectionIndicator}
                    {icon} {statusDisplay} · {tx.hash} · {date} ·{' '}
                    {tx.message}
                </Text>
                {isExpanded && (
                    <Box flexDirection="column" paddingLeft={8}>
                        {tx.stats && (
                            <Text color="gray">
                                Stats: {tx.stats.files} files, +{tx.stats.linesAdded}/-{tx.stats.linesRemoved}
                            </Text>
                        )}
                        <Text>Files:</Text>
                    </Box>
                )}
            </Box>
        );
    };


    const BulkActionsMode = ({ selectedForActionCount }: {
    selectedForActionCount: number }) => {
        return (
            <Box flexDirection="column" marginY={1}>
                <Text bold color="yellow">PERFORM BULK ACTION ON {selectedForActionCount} SELECTED ITEMS</Text>
                <Box marginY={1}>
                    <Text>This action is often irreversible. Are you sure?</Text>
                </Box>
                <Text>(1) Revert Selected Transactions</Text>
                <Text>(2) Mark as &apos;Git Committed&apos;</Text>
                <Text>(3) Delete Selected Transactions (from Relaycode history)</Text>
                <Text>(Esc) Cancel</Text>
            </Box>
        );
    };


    // --- Main Component ---


    const TransactionHistoryScreen = () => {
        const {
            mode,
            filterQuery,
            selectedForAction,
            selectedItemPath,
            expandedIds,
            loadingPaths,
            actions,
            transactions,
            itemsInView,
            filterStatus,
            showingStatus,
            statsStatus,
            hasSelection,
        } = useTransactionHistoryScreen({
            layoutConfig: {
                header: 1,
                separators: 2, // after header, after list
                fixedRows: 1, // filter row
                marginsY: 1, // for list
                footer: 2,
            },
        });

        const transactionsById = useMemo(() => new Map(transactions.map(tx => [tx.id, tx])), [transactions]);

        const renderFooter = () => {
            if (mode === 'FILTER') return <Text>(Enter) Apply Filter & Return      (Esc) Cancel</Text>; 
            if (mode === 'BULK_ACTIONS') return <Text>Choose an option [1-3] or (Esc) Cancel</Text>;
            
            const openActionLabel = selectedItemPath.includes('/file/') ? 'Open File' : 'Open YAML';
            const footerActions: ActionItem[] = [
                { key: '↑↓/PgUp/PgDn', label: 'Nav' },
                { key: '→', label: 'Expand' },
                { key: '←', label: 'Collapse' },
                { key: 'Spc', label: 'Select' },
                { key: 'Ent', label: 'Details' },
                { key: 'O', label: openActionLabel },
                { key: 'F', label: 'Filter' },
            ];

            if (selectedForAction.size > 0) {
                footerActions.push({ key: 'C', label: 'Copy' }, { key: 'B', label: 'Bulk' });
            }
            return <ActionFooter actions={footerActions} />;
        };

        return (
            <Box flexDirection="column">
                <Text color="cyan">▲ relaycode transaction history</Text>
                <Separator />

                <Box>
                    <Text>Filter: </Text>
                    {mode === 'FILTER' ? (
                        <TextInput value={filterQuery} onChange={actions.setFilterQuery} />
                    ) : (
                        <Text>{filterStatus}</Text>
                    )}
                    <Text> · {showingStatus}</Text>
                    {statsStatus && <Text> · {statsStatus}</Text>}
                </Box>

                <Box flexDirection="column" marginY={1}>
                    {mode === 'BULK_ACTIONS' && <BulkActionsMode selectedForActionCount={selectedForAction.size} />}

                    {mode === 'LIST' && itemsInView.map(path => {
                        const txId = path.split('/')[0]!;
                        const tx = transactionsById.get(txId);
                        if (!tx) return <Text key={path}>Error: Missing TX {txId}</Text>;

                        // Is a transaction row
                        if (path === tx.id) {
                            return (
                                <TransactionRow
                                    key={path}
                                    tx={tx}
                                    isSelected={selectedItemPath === path}
                                    isExpanded={expandedIds.has(path)}
                                    isSelectedForAction={selectedForAction.has(tx.id)}
                                    hasSelection={hasSelection}
                                />
                            );
                        }

                        // Is a child row
                        const itemType = path.split('/')[1]!;
                        const isSelected = selectedItemPath === path;
                        const isExpanded = expandedIds.has(path);
                        const isLoading = loadingPaths.has(path);

                        if (itemType === 'file') {
                            const fileId = path.split('/')[2]!;
                            const file = tx.files?.find(f => f.id === fileId);
                            if (!file) return null;
                            return (
                                <FileRow
                                    key={path} file={file} isSelected={isSelected}
                                    isExpanded={isExpanded} isLoading={isLoading}
                                />
                            );
                        }

                        const contentMap = {
                            message: { title: 'Commit Message', content: tx.message || '' },
                            prompt: { title: 'Prompt', content: tx.prompt || '' },
                            reasoning: { title: 'Reasoning', content: tx.reasoning || '' },
                        };

                        const item = contentMap[itemType as keyof typeof contentMap];
                        if (!item) return null;

                        return (
                            <ContentRow
                                key={path}
                                {...item}
                                isSelected={isSelected}
                                isExpanded={isExpanded}
                                isLoading={isLoading}
                            />
                        );
                    })}
                </Box>

                <Separator />
                {renderFooter()}
            </Box>
        );
    };


    export default TransactionHistoryScreen;
  src/hooks/useCopyScreen.tsx: |-
    import { useInput } from 'ink';
    import { useCopyStore } from '../stores/copy.store';
    import { useViewStore } from '../stores/view.store';
    import { useViewport } from './useViewport';
    import type { LayoutConfig } from './useLayout';

    export const useCopyScreen = () => {
        const activeOverlay = useViewStore(s => s.activeOverlay);
        const {
            title, items, selectedIndex, selectedIds, lastCopiedMessage,
            actions,
        } = useCopyStore(state => ({ ...state, actions: state.actions }));
        
        // Header, separator, title, margin, separator, status, footer
        const layoutConfig: LayoutConfig = { header: 1, separators: 2, fixedRows: 2, marginsY: 1, footer: 1 };
        
        const { viewOffset, viewportHeight } = useViewport({
            selectedIndex,
            layoutConfig,
        });

        useInput((input, key) => {
            if (key.escape) {
                actions.close();
                return;
            }
            if (key.upArrow) {
                actions.navigateUp();
                return;
            }
            if (key.downArrow) {
                actions.navigateDown();
                return;
            }
            if (key.pageUp) {
                actions.navigatePageUp(viewportHeight);
                return;
            }
            if (key.pageDown) {
                actions.navigatePageDown(viewportHeight);
                return;
            }
            if (input === ' ') {
                actions.toggleSelection();
                return;
            }
            if (key.return) {
                actions.executeCopy();
                return;
            }
            
            const item = items.find(i => i.key.toLowerCase() === input.toLowerCase());
            if(item) {
                actions.toggleSelectionById(item.id);
            }
        }, { isActive: activeOverlay === 'copy' });

        const itemsInView = items.slice(viewOffset, viewOffset + viewportHeight);

        return {
            title,
            itemsInView,
            selectedIndex,
            selectedIds,
            lastCopiedMessage,
            viewOffset,
        };
    };
  src/hooks/useDebugLogScreen.tsx: |-
    import { useState, useEffect, useMemo } from 'react';
    import { useInput } from 'ink';
    import { useLogStore } from '../stores/log.store';
    import { useViewStore } from '../stores/view.store';
    import { useViewport } from './useViewport';
    import { LoggerService } from '../services/logger.service';
    import type { LayoutConfig } from './useLayout';
    import { moveIndex } from '../stores/navigation.utils';

    export const useDebugLogScreen = () => {
        const logs = useLogStore(s => s.logs);
        const clearLogs = useLogStore(s => s.actions.clearLogs);
        const setActiveOverlay = useViewStore(s => s.actions.setActiveOverlay);

        const [selectedIndex, setSelectedIndex] = useState(0);
        const [mode, setMode] = useState<'LIST' | 'FILTER'>('LIST');
        const [filterQuery, setFilterQuery] = useState('');

        const filteredLogs = useMemo(() => logs.filter(log =>
            log.message.toLowerCase().includes(filterQuery.toLowerCase()),
        ), [logs, filterQuery]);

        // Reset index to top when filter changes
        useEffect(() => {
            setSelectedIndex(0);
        }, [filterQuery]);

        // Clamp index if it's out of bounds after logs change for other reasons
        useEffect(() => {
            if (selectedIndex >= filteredLogs.length) {
                setSelectedIndex(Math.max(0, filteredLogs.length - 1));
            }
        }, [filteredLogs.length, selectedIndex]);

        // Header, borders, footer, filter line
        const layoutConfig: LayoutConfig = { paddingY: 2, header: 1, separators: 2, fixedRows: 1, marginsY: 1, footer: 1 };

        const { viewOffset, viewportHeight } = useViewport({
            selectedIndex,
            layoutConfig,
        });

        useInput((input, key) => {
            if (mode === 'FILTER') {
                if (key.escape || key.return) {
                    setMode('LIST');
                }
                return;
            }

            if (key.escape) {
                setActiveOverlay('none');
                return;
            }
            if (key.upArrow) {
                setSelectedIndex(i => moveIndex(i, 'up', filteredLogs.length));
                return;
            }
            if (key.downArrow) {
                setSelectedIndex(i => moveIndex(i, 'down', filteredLogs.length));
                return;
            }
            if (key.pageUp) {
                setSelectedIndex(i => Math.max(0, i - viewportHeight));
                return;
            }
            if (key.pageDown) {
                setSelectedIndex(i => Math.min(filteredLogs.length - 1, i + viewportHeight));
                return;
            }
            if (input.toLowerCase() === 'c') {
                clearLogs();
                setFilterQuery('');
                setSelectedIndex(0);
                return;
            }
            if (input.toLowerCase() === 'f') {
                setMode('FILTER');
            }
        });

        useEffect(() => {
            LoggerService.startSimulator();
            return () => {
                LoggerService.stopSimulator();
            };
        }, []);

        const logsInView = filteredLogs.slice(viewOffset, viewOffset + viewportHeight);

        return {
            logsInView,
            logCount: logs.length,
            filteredLogCount: filteredLogs.length,
            selectedIndex,
            mode,
            filterQuery,
            setFilterQuery,
            viewOffset,
        };
    };
  src/hooks/useDebugMenu.tsx: |-
    import { useState } from 'react';
    import { useInput } from 'ink';
    import { useAppStore } from '../stores/app.store';
    import { useViewStore } from '../stores/view.store';
    import { useDashboardStore } from '../stores/dashboard.store';
    import { useReviewStore } from '../stores/review.store';
    import { useDetailStore } from '../stores/detail.store';
    import { useHistoryStore } from '../stores/history.store';
    import { useInitStore } from '../stores/init.store';
    import { useCommitStore } from '../stores/commit.store';
    import { useCopyStore } from '../stores/copy.store';
    import type { MenuItem } from '../types/debug.types';
    import { useTransactionStore } from '../stores/transaction.store';
    import { moveIndex } from '../stores/navigation.utils';
    import type { LayoutConfig } from './useLayout';
    import { useViewport } from './useViewport';
    export type { MenuItem } from '../types/debug.types';

    const useDebugMenuActions = () => {
        const { actions: appActions } = useAppStore();
        const { actions: initActions } = useInitStore();
        const { actions: commitActions } = useCommitStore();
        const { actions: dashboardActions } = useDashboardStore();
        const { actions: reviewActions } = useReviewStore();
        const { actions: detailActions } = useDetailStore();
        const { actions: historyActions } = useHistoryStore();

        const menuItems: MenuItem[] = [
            {
                title: 'View Debug Log',
                action: () => useViewStore.getState().actions.setActiveOverlay('log'),
            },
            {
                title: 'Splash Screen',
                action: () => appActions.showSplashScreen(),
            },
            {
                title: 'Init: Analyze Phase',
                action: () => {
                    initActions.setPhase('ANALYZE');
                    appActions.showInitScreen();
                },
            },
            {
                title: 'Init: Interactive Phase',
                action: () => {
                    initActions.setPhase('INTERACTIVE');
                    appActions.showInitScreen();
                },
            },
            {
                title: 'Init: Finalize Phase',
                action: () => {
                    initActions.setPhase('FINALIZE');
                    appActions.showInitScreen();
                },
            },
            {
                title: 'Dashboard: Listening',
                action: () => {
                    dashboardActions.setStatus('LISTENING');
                    appActions.showDashboardScreen();
                },
            },
            {
                title: 'Dashboard: Confirm Approve',
                action: () => {
                    dashboardActions.startApproveAll();
                    appActions.showDashboardScreen();
                },
            },
            {
                title: 'Dashboard: Approving',
                action: () => {
                    dashboardActions.setStatus('APPROVING');
                    appActions.showDashboardScreen();
                },
            },
            {
                title: 'Dashboard: Expanded View',
                action: () => {
                    dashboardActions.setStatus('LISTENING');
                    dashboardActions.setExpandedTransactionId('1');
                    appActions.showDashboardScreen();
                },
            },
            {
                title: 'Review: Partial Failure (Default)',
                action: () => {
                    reviewActions.load('1');
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Success',
                action: () => {
                    reviewActions.load('2');
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Diff View',
                action: () => {
                    reviewActions.load('1');
                    reviewActions.setBodyView('diff');
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Reasoning View',
                action: () => {
                    reviewActions.load('1', { bodyView: 'reasoning' });
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Copy Mode',
                action: () => {
                    reviewActions.load('1');
                    appActions.showReviewScreen();
                    const tx = useTransactionStore.getState().transactions.find(t => t.id === '1');
                    if (!tx) return;
                    // On load, selected index is 0, so we can assume the first file.
                    const selectedFile = tx.files && tx.files.length > 0
                        ? tx.files[0]
                        : undefined;
                    useCopyStore.getState().actions.openForReview(tx, tx.files || [], selectedFile);
                },
            },
            {
                title: 'Review: Script Output',
                action: () => {
                    reviewActions.load('2');
                    appActions.showReviewScreen();
                    reviewActions.setBodyView('script_output');
                },
            },
            {
                title: 'Review: Bulk Repair',
                action: () => {
                    reviewActions.load('1', { bodyView: 'bulk_repair' });
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Bulk Repair (Navigable)',
                action: () => {
                    reviewActions.load('1', { bodyView: 'bulk_repair', selectedBulkRepairOptionIndex: 1 });
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Bulk Instruct',
                action: () => {
                    reviewActions.load('2'); // Load success case
                    // Reject some files to enable the workflow
                    reviewActions.toggleFileApproval('2-1');
                    reviewActions.toggleFileApproval('2-2');
                    reviewActions.showBulkInstruct();
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Handoff Confirm',
                action: () => {
                    reviewActions.load('1', { bodyView: 'confirm_handoff' });
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review Processing',
                action: () => {
                    reviewActions.load('2'); // Use tx '2' which has scripts
                    appActions.showReviewProcessingScreen();
                },
            },
            {
                title: 'Git Commit Screen',
                action: () => {
                    commitActions.prepareCommitScreen();
                    appActions.showGitCommitScreen();
                },
            },
            {
                title: 'Transaction Detail Screen',
                action: () => {
                    // The dashboard store has transactions, we'll just pick one.
                    detailActions.load('3'); // 'feat: implement new dashboard UI'
                    appActions.showTransactionDetailScreen();
                },
            },
            {
                title: 'Detail: Copy Mode',
                action: () => {
                    detailActions.load('3');
                    appActions.showTransactionDetailScreen();
                    const tx = useTransactionStore.getState().transactions.find(t => t.id === '3');
                    if (!tx) return;
                    const selectedFile = tx.files?.[0];
                    useCopyStore.getState().actions.openForDetail(tx, selectedFile);
                },
            },
            {
                title: 'Detail: Diff View (for File Open action)',
                action: () => {
                    detailActions.load('3', {
                        focusedItemPath: 'FILES/3-1',
                        bodyView: 'DIFF_VIEW',
                        expandedItemPaths: new Set(['FILES']),
                    });
                    appActions.showTransactionDetailScreen();
                },
            },
            {
                title: 'Detail: Revert Confirm',
                action: () => {
                    detailActions.load('3', { bodyView: 'REVERT_CONFIRM' });
                    appActions.showTransactionDetailScreen();
                },
            },
            {
                title: 'Transaction History Screen',
                action: () => {
                    historyActions.load();
                    appActions.showTransactionHistoryScreen();
                },
            },
            {
                title: 'History: L1 Drilldown (Content)',
                action: () => {
                    historyActions.prepareDebugState('l1-drill-content');
                    appActions.showTransactionHistoryScreen();
                },
            },
            {
                title: 'History: L2 Drilldown (Reasoning)',
                action: () => {
                    historyActions.prepareDebugState('l2-drill-reasoning');
                    appActions.showTransactionHistoryScreen();
                },
            },
            {
                title: 'History: L2 Drilldown (for File Open action)',
                action: () => {
                    historyActions.prepareDebugState('l2-drill-diff');
                    appActions.showTransactionHistoryScreen();
                },
            },
            {
                title: 'History: Filter Mode',
                action: () => {
                    historyActions.prepareDebugState('filter');
                    appActions.showTransactionHistoryScreen();
                },
            },
            {
                title: 'History: Copy Mode',
                action: () => {
                    historyActions.prepareDebugState('copy');
                    appActions.showTransactionHistoryScreen();
                    const { transactions } = useTransactionStore.getState();
                    const { selectedForAction } = useHistoryStore.getState();
                    const txsToCopy = transactions.filter(tx => selectedForAction.has(tx.id));
                    useCopyStore.getState().actions.openForHistory(txsToCopy);
                },
            },
            {
                title: 'History: Bulk Actions Mode',
                action: () => {
                    historyActions.prepareDebugState('bulk');
                    appActions.showTransactionHistoryScreen();
                },
            },
        ];
        return { menuItems };
    };

    export const useDebugMenu = () => {
        const [selectedIndex, setSelectedIndex] = useState(0);
        const { menuItems } = useDebugMenuActions();

        const layoutConfig: LayoutConfig = { paddingY: 2, header: 1, separators: 2, footer: 1 };

        const { viewOffset, viewportHeight } = useViewport({
            selectedIndex,
            layoutConfig,
        });
        
        useInput((input, key) => {
            if (key.upArrow) {
                setSelectedIndex(i => moveIndex(i, 'up', menuItems.length));
                return;
            }
            if (key.downArrow) {
                setSelectedIndex(i => moveIndex(i, 'down', menuItems.length));
                return;
            }
            if (key.pageUp) {
                setSelectedIndex(i => Math.max(0, i - viewportHeight));
                return;
            }
            if (key.pageDown) {
                setSelectedIndex(i => Math.min(menuItems.length - 1, i + viewportHeight));
                return;
            }
            if (key.return) {
                const item = menuItems[selectedIndex];
                if (item) {
                    item.action();
                    useViewStore.getState().actions.setActiveOverlay('none');
                }
                return;
            }
            if (key.escape) {
                useViewStore.getState().actions.setActiveOverlay('none');
                return;
            }

            // No ctrl/meta keys for selection shortcuts, and only single characters
            if (key.ctrl || key.meta || input.length !== 1) return;

            if (input >= '1' && input <= '9') {
                const targetIndex = parseInt(input, 10) - 1;
                if (targetIndex < menuItems.length) {
                    setSelectedIndex(targetIndex);
                }
            } else if (input.toLowerCase() >= 'a' && input.toLowerCase() <= 'z') {
                const targetIndex = 9 + (input.toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0));
                if (targetIndex < menuItems.length) {
                    setSelectedIndex(targetIndex);
                }
            }
        });

        const menuItemsInView = menuItems.slice(viewOffset, viewOffset + viewportHeight);

        return {
            selectedIndex,
            menuItems: menuItemsInView,
            viewOffset,
            totalItems: menuItems.length,
        };
    };
  src/services/logger.service.ts: >-
    import { useLogStore } from '../stores/log.store';


    let simulatorInterval: ReturnType<typeof setInterval> | null = null;


    const mockClipboardContents = [
        'feat(dashboard): implement new UI components',
        'const clipboardy = require(\'clipboardy\');',
        'diff --git a/src/App.tsx b/src/App.tsx\nindex 12345..67890 100644\n--- a/src/App.tsx\n+++ b/src/App.tsx\n@@ -1,5 +1,6 @@\n import React from \'react\';',
        'All changes have been applied successfully. You can now commit them.',
        '{\n  "id": "123",\n  "status": "PENDING"\n}',
        'Can you refactor this to use a switch statement?',
    ];

    let currentClipboardIndex = 0;


    const startSimulator = () => {
        if (simulatorInterval) return;

        // Initial burst of logs to populate the view
        LoggerService.info('Log simulator started.');
        LoggerService.debug('Initializing clipboard watcher...');
        setTimeout(() => LoggerService.debug('Clipboard watcher active.'), 250);

        simulatorInterval = setInterval(() => {
            const random = Math.random();
            if (random < 0.6) {
                LoggerService.debug('Clipboard watcher polling...');
            } else if (random < 0.8) {
                LoggerService.debug('No clipboard change detected.');
            } else {
                const newContent = mockClipboardContents[currentClipboardIndex]!;
                currentClipboardIndex = (currentClipboardIndex + 1) % mockClipboardContents.length;
                const excerpt = newContent.replace(/\n/g, ' ').substring(0, 50).trim();
                LoggerService.info(`Clipboard content changed. Excerpt: "${excerpt}..."`);
            }
        }, 2000);
    };


    const stopSimulator = () => {
        if (simulatorInterval) {
            clearInterval(simulatorInterval);
            simulatorInterval = null;
            LoggerService.info('Log simulator stopped.');
        }
    };


    const debug = (message: string) =>
    useLogStore.getState().actions.addLog('DEBUG', message);

    const info = (message: string) =>
    useLogStore.getState().actions.addLog('INFO', message);

    const warn = (message: string) =>
    useLogStore.getState().actions.addLog('WARN', message);

    const error = (message: string) =>
    useLogStore.getState().actions.addLog('ERROR', message);



    export const LoggerService = {
        debug,
        info,
        warn,
        error,
        startSimulator,
        stopSimulator,
    };
  src/services/review.service.ts: >-
    import { useTransactionStore } from '../stores/transaction.store';

    import { useAppStore } from '../stores/app.store';

    import { sleep } from '../utils';

    import type { ApplyUpdate, PatchStatus } from '../stores/review.store';

    import type { Transaction, FileItem, FileReviewStatus } from
    '../types/domain.types';


    const generateBulkRepairPrompt = (failedFiles: FileItem[]): string => {
        return `The previous patch failed to apply to MULTIPLE files. Please generate a new, corrected patch that addresses all the files listed below.

    IMPORTANT: The response MUST contain a complete code block for EACH file
    that needs to be fixed.


    ${failedFiles.map(file => `--- FILE: ${file.path} ---

    Strategy: ${file.strategy}

    Error: Hunk #1 failed to apply // This is a mock error


    ORIGINAL CONTENT:

    ---

    // ... original content of ${file.path} ...

    ---


    FAILED PATCH:

    ---

    ${file.diff || '// ... failed diff ...'}

    ---

    `).join('\n')}


    Please analyze all failed files and provide a complete, corrected
    response.`;

    };


    const generateHandoffPrompt = (
        transaction: Transaction,
        fileReviewStates: Map<
            string, { status: FileReviewStatus; error?: string; details?: string }
        >,
    ): string => {
        const successfulFiles = (transaction.files || []).filter(f => fileReviewStates.get(f.id)?.status === 'APPROVED');
        const failedFiles = (transaction.files || []).filter(f => ['FAILED', 'REJECTED'].includes(fileReviewStates.get(f.id)?.status || ''));

        return `I am handing off a failed automated code transaction to you. Your task is to act as my programming assistant and complete the planned changes.

    The full plan for this transaction is detailed in the YAML file located at:
    .relay/transactions/${transaction.hash}.yml. Please use this file as your
    primary source of truth for the overall goal.


    Here is the current status of the transaction:


    --- TRANSACTION SUMMARY ---

    Goal: ${transaction.message}

    Reasoning:

    ${transaction.reasoning || ''}


    --- CURRENT FILE STATUS ---

    SUCCESSFUL CHANGES (already applied, no action needed):

    ${successfulFiles.map(f => `- MODIFIED: ${f.path}`).join('\n') || ' 
    (None)'}


    FAILED CHANGES (these are the files you need to fix):

    ${failedFiles.map(f => `- FAILED: ${f.path} (Error:
    ${fileReviewStates.get(f.id)?.error})`).join('\n')}


    Your job is to now work with me to fix the FAILED files and achieve the
    original goal of the transaction. Please start by asking me which file you
    should work on first.`;

    };


    const performHandoff = (hash: string) => {
        // This is a bit of a hack to find the right transaction to update in the demo
        const txToUpdate = useTransactionStore.getState().transactions.find(tx => tx.hash === hash);
        if (txToUpdate) {
            useTransactionStore.getState().actions.updateTransactionStatus(txToUpdate.id, 'HANDOFF');
        }

        useAppStore.getState().actions.showDashboardScreen();
    };


    async function* runApplySimulation(scenario: 'success' | 'failure'):
    AsyncGenerator<ApplyUpdate> {
        if (scenario === 'success') {
            yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'active' } }; await sleep(100);
            yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'done', duration: 0.1 } };

            yield { type: 'UPDATE_STEP', payload: { id: 'memory', status: 'active' } }; await sleep(100);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 's1', title: '[✓] write: src/core/clipboard.ts (strategy: replace)', status: 'done' } } };
            await sleep(100);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 's2', title: '[✓] write: src/utils/shell.ts (strategy: standard-diff)', status: 'done' } } };
            yield { type: 'UPDATE_STEP', payload: { id: 'memory', status: 'done', duration: 0.3 } };

            yield { type: 'UPDATE_STEP', payload: { id: 'post-command', status: 'active' } }; await sleep(1300);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'post-command', substep: { id: 's3', title: '`bun run test` ... Passed', status: 'done' } } };
            yield { type: 'UPDATE_STEP', payload: { id: 'post-command', status: 'done', duration: 2.3 } };

            yield { type: 'UPDATE_STEP', payload: { id: 'linter', status: 'active' } }; await sleep(1200);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'linter', substep: { id: 's4', title: '`bun run lint` ... 0 Errors', status: 'done' } } };
            yield { type: 'UPDATE_STEP', payload: { id: 'linter', status: 'done', duration: 1.2 } };

            await sleep(500);

        } else { // failure scenario
            yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'active' } }; await sleep(100);
            yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'done', duration: 0.1 } };

            yield { type: 'UPDATE_STEP', payload: { id: 'memory', status: 'active' } }; await sleep(100);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 'f1', title: '[✓] write: src/core/transaction.ts (strategy: replace)', status: 'done' } } };
            await sleep(100);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 'f2', title: '[!] failed: src/utils/logger.ts (Hunk #1 failed to apply)', status: 'failed' } } };
            await sleep(100);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 'f3', title: '[!] failed: src/commands/apply.ts (Context mismatch at line 92)', status: 'failed' } } };
            yield { type: 'UPDATE_STEP', payload: { id: 'memory', status: 'done', duration: 0.5 } };

            await sleep(100);
            yield { type: 'UPDATE_STEP', payload: { id: 'post-command', status: 'skipped', details: 'Skipped due to patch application failure' } };
            await sleep(100);
            yield { type: 'UPDATE_STEP', payload: { id: 'linter', status: 'skipped', details: 'Skipped due to patch application failure' } };

            await sleep(500);
        }
    }


    const prepareTransactionForReview = (
        transaction: Transaction,
    ): {
        patchStatus: PatchStatus;
        fileReviewStates: Map<string, { status: FileReviewStatus; error?: string }>;
    } => {
        // This simulates the backend determining which files failed or succeeded and sets it ONCE on load.
        // For this demo, tx '1' is the failure case, any other is success.
        const isFailureCase = transaction.id === '1';
        const fileReviewStates = new Map<string, { status: FileReviewStatus; error?: string }>();

        (transaction.files || []).forEach((file, index) => {
            if (isFailureCase) {
                const isFailedFile = index > 0;
                const status = isFailedFile ? 'FAILED' : 'APPROVED';
                const error = isFailedFile ? (index === 1 ? 'Hunk #1 failed to apply' : 'Context mismatch at line 92') : undefined;
                fileReviewStates.set(file.id, { status, error });
            } else {
                fileReviewStates.set(file.id, { status: 'APPROVED' });
            }
        });
        return { patchStatus: isFailureCase ? 'PARTIAL_FAILURE' : 'SUCCESS', fileReviewStates };
    };


    const generateSingleFileRepairPrompt = (file: FileItem, error?: string):
    string => {
        return `The patch failed to apply to ${file.path}. Please generate a corrected patch.

    Error: ${error || 'Unknown error'}

    Strategy: ${file.strategy}


    ORIGINAL CONTENT:

    ---

    // ... original file content would be here ...

    ---


    FAILED PATCH:

    ---

    ${file.diff || '// ... failed diff would be here ...'}

    ---


    Please provide a corrected patch that addresses the error.`;

    };


    const tryRepairFile = (file: FileItem, error?: string): FileItem => {
        const repairPrompt = generateSingleFileRepairPrompt(file, error);
        // In a real app: clipboardy.writeSync(repairPrompt)
        // eslint-disable-next-line no-console
        console.log(`[CLIPBOARD MOCK] Copied repair prompt for: ${file.path}`, repairPrompt);

        return file;
    };


    const generateSingleFileInstructPrompt = (file: FileItem, transaction:
    Transaction): string => {
        return `The user REJECTED the last proposed change for the file \`${file.path}\`.

    The original high-level goal was:

    ---

    ${transaction.prompt || transaction.message}

    ---


    The rejected change was:

    ---

    ${file.diff || '// ... rejected diff would be here ...'}

    ---


    Please provide an alternative solution for \`${file.path}\` that still
    accomplishes the original goal.

    The response MUST be a complete, corrected patch for this file.`;

    };


    const tryInstructFile = (file: FileItem, transaction: Transaction): void =>
    {
        const instructPrompt = generateSingleFileInstructPrompt(file, transaction);
        // In a real app: clipboardy.writeSync(instructPrompt)
        // eslint-disable-next-line no-console
        console.log(`[CLIPBOARD MOCK] Copied instruction prompt for: ${file.path}`, instructPrompt);
    };


    const generateBulkInstructPrompt = (rejectedFiles: FileItem[], transaction:
    Transaction): string => {
        // Mock implementation for demo. In a real scenario, this would generate a more complex prompt.
        const fileList = rejectedFiles.map(f => `- ${f.path}`).join('\n');
        // eslint-disable-next-line no-console
        console.log(`[CLIPBOARD] Copied bulk instruction prompt for ${rejectedFiles.length} files.`);
        return `The user has rejected changes in multiple files for the goal: "${transaction.message}".\n\nThe rejected files are:\n${fileList}\n\nPlease provide an alternative patch for all of them.`;
    };


    const runBulkReapply = async (
        failedFiles: FileItem[],
    ): Promise<{ id: string; status: FileReviewStatus; error?: string }[]> => {
        await sleep(1500); // Simulate re-apply

        // Mock a mixed result
        let first = true;
        return failedFiles.map(file => {
            if (first) {
                first = false;
                return { id: file.id, status: 'APPROVED' as const };
            } else {
                return {
                    id: file.id,
                    status: 'FAILED' as const,
                    error: "'replace' failed: markers not found",
                };
            }
        });
    };


    export const ReviewService = {
        prepareTransactionForReview,
        generateBulkRepairPrompt,
        generateBulkInstructPrompt,
        generateHandoffPrompt,
        performHandoff,
        runApplySimulation,
        generateSingleFileRepairPrompt,
        tryRepairFile,
        generateSingleFileInstructPrompt,
        tryInstructFile,
        runBulkReapply,
    };
  src/stores/log.store.ts: |-
    import { create } from 'zustand';
    import type { LogEntry, LogLevel } from '../types/log.types';

    const MAX_LOGS = 200;

    interface LogState {
        logs: LogEntry[];
        actions: {
            addLog: (level: LogLevel, message: string) => void;
            clearLogs: () => void;
        };
    }

    export const useLogStore = create<LogState>((set) => ({
        logs: [],
        actions: {
            addLog: (level, message) => {
                set(state => {
                    const newLog: LogEntry = {
                        level,
                        message,
                        timestamp: Date.now(),
                    };
                    // Prepend new log and trim the array to max size
                    const updatedLogs = [newLog, ...state.logs].slice(0, MAX_LOGS);
                    return { logs: updatedLogs };
                });
            },
            clearLogs: () => set({ logs: [] }),
        },
    }));
  src/stores/review.store.ts: >-
    import { create } from 'zustand';

    import { useAppStore } from './app.store';

    import { useTransactionStore } from './transaction.store';

    import { useViewStore } from './view.store';

    import { ReviewService } from '../services/review.service';

    import { moveIndex } from './navigation.utils';

    import { INITIAL_APPLY_STEPS } from '../constants/review.constants';

    import type { FileReviewStatus } from '../types/domain.types';


    export interface ApplyStep {
        id: string;
        title: string;
        status: 'pending' | 'active' | 'done' | 'failed' | 'skipped';
        details?: string;
        substeps?: ApplyStep[];
        duration?: number;
    }

    export type ReviewBodyView = 'diff' | 'reasoning' | 'script_output' |
    'bulk_repair' | 'confirm_handoff' | 'bulk_instruct' | 'none';

    export type PatchStatus = 'SUCCESS' | 'PARTIAL_FAILURE';

    export type ApplyUpdate =
        | { type: 'UPDATE_STEP'; payload: { id: string; status: ApplyStep['status']; duration?: number; details?: string } }
        | { type: 'ADD_SUBSTEP'; payload: { parentId: string; substep: Omit<ApplyStep, 'substeps'> } };

    interface ReviewState {
        patchStatus: PatchStatus;
        applySteps: ApplyStep[];
        selectedItemIndex: number;
        bodyView: ReviewBodyView;
        isDiffExpanded: boolean;
        reasoningScrollIndex: number;
        scriptErrorIndex: number;
        fileReviewStates: Map<string, { status: FileReviewStatus; error?: string; details?: string }>;

        selectedBulkRepairOptionIndex: number;
        selectedBulkInstructOptionIndex: number;

        actions: {
            load: (transactionId: string, initialState?: Partial<Pick<ReviewState, 'bodyView' | 'selectedBulkRepairOptionIndex'>>) => void;
            moveSelectionUp: (listSize: number) => void;
            moveSelectionDown: (listSize: number) => void;
            expandDiff: () => void;
            toggleBodyView: (view: Extract<
                ReviewBodyView, 'bulk_instruct' |
                'diff' | 'reasoning' | 'script_output' | 'bulk_repair' | 'confirm_handoff'
            >) => void;
            setBodyView: (view: ReviewBodyView) => void;
            approve: () => void;
            startApplySimulation: (scenario: 'success' | 'failure') => void;
            tryRepairFile: (fileId: string) => void;
            showBulkRepair: () => void;
            executeBulkRepairOption: (option: number) => Promise<void>;
            tryInstruct: (fileId: string) => void;
            showBulkInstruct: () => void;
            executeBulkInstructOption: (option: number) => Promise<void>;
            confirmHandoff: () => void;
            scrollReasoningUp: () => void;
            scrollReasoningDown: () => void;
            navigateScriptErrorUp: () => void;
            navigateScriptErrorDown: () => void;
            updateApplyStep: (id: string, status: ApplyStep['status'], duration?: number, details?: string) => void;
            addApplySubstep: (parentId: string, substep: Omit<ApplyStep, 'substeps'>) => void;
            updateFileReviewStatus: (fileId: string, status: FileReviewStatus, error?: string, details?: string) => void;
            toggleFileApproval: (fileId: string) => void;
            rejectAllFiles: () => void;
            navigateBulkRepairUp: () => void;
            navigateBulkRepairDown: () => void;
            navigateBulkInstructUp: () => void;
            navigateBulkInstructDown: () => void;
        };
    }


    export const useReviewStore = create<ReviewState>((set, get) => ({
        patchStatus: 'SUCCESS',
        applySteps: INITIAL_APPLY_STEPS,
        selectedItemIndex: 0,
        bodyView: 'none',
        isDiffExpanded: false,
        reasoningScrollIndex: 0,
        scriptErrorIndex: 0,
        fileReviewStates: new Map(),
        selectedBulkRepairOptionIndex: 0,
        selectedBulkInstructOptionIndex: 0,

        actions: {
            load: (transactionId, initialState) => {
                const transaction = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!transaction) return;
                
                const { patchStatus, fileReviewStates } = ReviewService.prepareTransactionForReview(transaction);

                useViewStore.getState().actions.setSelectedTransactionId(transaction.id);
                set({
                    patchStatus,
                    fileReviewStates,
                    selectedItemIndex: 0,
                    bodyView: initialState?.bodyView ?? 'none',
                    isDiffExpanded: false,
                    reasoningScrollIndex: 0,
                    scriptErrorIndex: 0,
                    applySteps: JSON.parse(JSON.stringify(INITIAL_APPLY_STEPS)),
                    selectedBulkRepairOptionIndex: 0,
                    selectedBulkInstructOptionIndex: 0,
                    ...initialState,
                });
            },
            moveSelectionUp: (listSize) => set(state => {
                return { selectedItemIndex: moveIndex(state.selectedItemIndex, 'up', listSize) };
            }),
            moveSelectionDown: (listSize) => set(state => {
                return { selectedItemIndex: moveIndex(state.selectedItemIndex, 'down', listSize) };
            }),
            toggleBodyView: (view) => set(state => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                const files = tx?.files || [];
                if (view === 'diff' && state.selectedItemIndex >= files.length) return {};
                return {
                    bodyView: state.bodyView === view ? 'none' : view,
                    isDiffExpanded: false,
                };
            }),
            setBodyView: (view) => set({ bodyView: view }),
            expandDiff: () => set(state => ({ isDiffExpanded: !state.isDiffExpanded })),
            approve: () => {
                const { selectedTransactionId } = useViewStore.getState();
                if (selectedTransactionId) {
                    useTransactionStore.getState().actions.updateTransactionStatus(selectedTransactionId, 'APPLIED');
                    useAppStore.getState().actions.showDashboardScreen();
                }
            },
            startApplySimulation: async (scenario) => {
                const { showReviewProcessingScreen } = useAppStore.getState().actions;
                const { updateApplyStep, addApplySubstep } = get().actions;
                set({ applySteps: JSON.parse(JSON.stringify(INITIAL_APPLY_STEPS)) });
                showReviewProcessingScreen();
                const simulationGenerator = ReviewService.runApplySimulation(scenario);
                for await (const update of simulationGenerator) {
                    if (update.type === 'UPDATE_STEP') {
                        updateApplyStep(
                            update.payload.id,
                            update.payload.status,
                            update.payload.duration,
                            update.payload.details,
                        );
                    } else if (update.type === 'ADD_SUBSTEP') {
                        addApplySubstep(update.payload.parentId, update.payload.substep);
                    }
                }
                // Transition back to review screen is handled by the processing screen component or a separate flow
                // For this simulation, we'll assume it transitions back, but the action itself doesn't need to do it.
                // This avoids a direct dependency from the store to app-level navigation.
            },
            tryRepairFile: (fileId) => {
                const selectedTransactionId = useViewStore.getState().selectedTransactionId;
                const { fileReviewStates } = get();
                if (!selectedTransactionId) return;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                const file = tx?.files?.find(f => f.id === fileId);
                if (!file) return;

                const { status, error } = fileReviewStates.get(file.id) || {};
                if (status !== 'FAILED') return;
                
                ReviewService.tryRepairFile(file, error);
                get().actions.updateFileReviewStatus(file.id, 'AWAITING');
            },
            tryInstruct: (fileId) => {
                const selectedTransactionId = useViewStore.getState().selectedTransactionId;
                const { fileReviewStates } = get();
                if (!selectedTransactionId) return;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                const file = tx?.files?.find(f => f.id === fileId);
                if (!tx || !file) return;

                const { status } = fileReviewStates.get(file.id) || {};
                if (status !== 'REJECTED') return;
                
                ReviewService.tryInstructFile(file, tx);
                get().actions.updateFileReviewStatus(file.id, 'AWAITING', undefined, 'Instruction prompt copied!');
            },
            showBulkInstruct: () => get().actions.setBodyView('bulk_instruct'),
            executeBulkInstructOption: async (option) => {
                const selectedTransactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                if (!tx?.files) return;

                const rejectedFiles = tx.files.filter(f => get().fileReviewStates.get(f.id)?.status === 'REJECTED');
                if (rejectedFiles.length === 0) {
                    set({ bodyView: 'none' });
                    return;
                }

                switch (option) {
                    case 1:
                        ReviewService.generateBulkInstructPrompt(rejectedFiles, tx);
                        set({ bodyView: 'none' });
                        break;
                    case 2:
                        get().actions.setBodyView('confirm_handoff');
                        break;
                    case 3:
                        rejectedFiles.forEach(file => {
                            get().actions.updateFileReviewStatus(file.id, 'APPROVED');
                        });
                        set({ bodyView: 'none' });
                        break;
                    default:
                        set({ bodyView: 'none' });
                }
            },

            showBulkRepair: () => get().actions.toggleBodyView('bulk_repair'),
            executeBulkRepairOption: async (option) => {
                const selectedTransactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                if (!tx?.files) return;

                const failedFiles = tx.files.filter(f => get().fileReviewStates.get(f.id)?.status === 'FAILED');
                if (failedFiles.length === 0) {
                    set({ bodyView: 'none' });
                    return;
                }

                switch (option) {
                    case 1:
                        ReviewService.generateBulkRepairPrompt(failedFiles);
                        set({ bodyView: 'none' });
                        break;
                    case 2: {
                        set({ bodyView: 'none' });
                        failedFiles.forEach(f => get().actions.updateFileReviewStatus(f.id, 'RE_APPLYING'));
                        const results = await ReviewService.runBulkReapply(failedFiles);
                        results.forEach(result =>
                            get().actions.updateFileReviewStatus(
                                result.id, result.status, result.error,
                            ),
                        );
                        break;
                    }
                    case 3:
                        get().actions.setBodyView('confirm_handoff');
                        break;
                    case 4:
                        failedFiles.forEach(file => {
                            get().actions.updateFileReviewStatus(file.id, 'REJECTED');
                        });
                        set({ bodyView: 'none' });
                        break;
                    default:
                        set({ bodyView: 'none' });
                }
            },
            confirmHandoff: () => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!tx?.files) return;
                const { fileReviewStates } = get();
                ReviewService.generateHandoffPrompt(tx, fileReviewStates);
                ReviewService.performHandoff(tx.hash);
            },
            scrollReasoningUp: () => set(state => ({ reasoningScrollIndex: Math.max(0, state.reasoningScrollIndex - 1) })),
            scrollReasoningDown: () => set(state => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!tx?.reasoning) return {};
                const maxLines = tx.reasoning.split('\n').length;
                return { reasoningScrollIndex: Math.min(maxLines - 1, state.reasoningScrollIndex + 1) };
            }),
            navigateScriptErrorUp: () => set(state => ({ scriptErrorIndex: Math.max(0, state.scriptErrorIndex - 1) })),
            navigateScriptErrorDown: () => set(state => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!tx?.scripts || !tx?.files) return {};
                const selectedScript = tx.scripts[state.selectedItemIndex - tx.files.length];
                if (selectedScript?.output) {
                    const errorLines = selectedScript.output
                        .split('\n')
                        .filter(line => line.includes('Error') || line.includes('Warning'));
                    return { scriptErrorIndex: Math.min(errorLines.length - 1, state.scriptErrorIndex + 1) };
                }
                return {};
            }),
            updateApplyStep: (id, status, duration, details) => {
                set(state => ({
                    applySteps: state.applySteps.map(s => {
                        if (s.id === id) {
                            const newStep = { ...s, status };
                            if (duration !== undefined) newStep.duration = duration;
                            if (details !== undefined) newStep.details = details;
                            return newStep;
                        }
                        return s;
                    }),
                }));
            },
            addApplySubstep: (parentId, substep) => {
                set(state => ({
                    applySteps: state.applySteps.map(s => {
                        if (s.id === parentId) {
                            const newSubsteps = [...(s.substeps || []), substep as ApplyStep];
                            return { ...s, substeps: newSubsteps };
                        }
                        return s;
                    }),
                }));
            },
            updateFileReviewStatus: (fileId, status, error, details) => {
                set(state => {
                    const newStates = new Map(state.fileReviewStates);
                    newStates.set(fileId, { status, error, details });
                    return { fileReviewStates: newStates };
                });
            },
            toggleFileApproval: (fileId) => {
                set(state => {
                    const newStates = new Map(state.fileReviewStates);
                    const current = newStates.get(fileId);
                    if (current) {
                        const newStatus: FileReviewStatus = current.status === 'APPROVED' ? 'REJECTED' : 'APPROVED';
                        newStates.set(fileId, { status: newStatus, error: undefined, details: undefined });
                    }
                    return { fileReviewStates: newStates };
                });
            },
            rejectAllFiles: () => {
                set(state => {
                    const newStates = new Map(state.fileReviewStates);
                    for (const [fileId, reviewState] of newStates.entries()) {
                        if (reviewState.status === 'APPROVED') {
                            newStates.set(fileId, { status: 'REJECTED', error: undefined, details: undefined });
                        }
                    }
                    return { fileReviewStates: newStates };
                });
            },
            navigateBulkRepairUp: () => set(state => ({
                selectedBulkRepairOptionIndex: moveIndex(state.selectedBulkRepairOptionIndex, 'up', 4),
            })),
            navigateBulkRepairDown: () => set(state => ({
                selectedBulkRepairOptionIndex: moveIndex(state.selectedBulkRepairOptionIndex, 'down', 4),
            })),
            navigateBulkInstructUp: () => set(state => ({
                selectedBulkInstructOptionIndex: moveIndex(state.selectedBulkInstructOptionIndex, 'up', 4),
            })),
            navigateBulkInstructDown: () => set(state => ({
                selectedBulkInstructOptionIndex: moveIndex(state.selectedBulkInstructOptionIndex, 'down', 4),
            })),
        },
    }));
approved: false
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: undone
id: 162
