uuid: 139e83cd-ab81-422d-a2d9-13e5362e53ef
projectId: relaycode-tui
createdAt: '2025-09-25T06:00:41.523Z'
gitCommitMsg: >-
  fix(lint): resolve tsc and eslint errors

  Corrects several issues identified by the build and linting process: - Fixes a
  critical syntax error in `ReviewScreen.tsx` caused by a duplicated component
  definition line. - Resolves a `max-len` warning in `DashboardScreen.tsx` by
  refactoring the footer for better readability. - Fixes a `no-unused-vars`
  error in `review.service.ts` by renaming a variable to follow the project's
  linting conventions for unused variables.
promptSummary: Fix TSC and ESLint errors from previous turn.
reasoning:
  - >-
    I apologize for the syntax and linting errors in the previous turn. A
    meticulous craftsman always cleans up their workspace. Here are the fixes.
  - >-
    First, I will correct the syntax error in `src/components/ReviewScreen.tsx`.
    I inadvertently duplicated a line while applying the previous patch. A
    `search-replace` is the most precise way to fix this.
  - >-
    Next, I'll address the `max-len` warning in
    `src/components/DashboardScreen.tsx` by breaking the long footer text into
    multiple, more readable lines.
  - >-
    Finally, I'll fix the unused variable error in
    `src/services/review.service.ts` by renaming the variable to
    `_instructPrompt` to satisfy the linter rule for intentionally unused
    variables, and I'll update the corresponding comment for consistency.
  - These changes should resolve all the reported TSC and ESLint errors.
operations:
  - type: write
    path: src/components/ReviewScreen.tsx
    content: >
      <<<<<<< SEARCH

      const FileItemRow = ({ file, reviewStatus, reviewError, isFocused }: {

      const FileItemRow = ({ file, reviewStatus, reviewError, reviewDetails,
      isFocused }: {
          file: FileItem;
      =======

      const FileItemRow = ({ file, reviewStatus, reviewError, reviewDetails,
      isFocused }: {
          file: FileItem;
      >>>>>>> REPLACE
    patchStrategy: search-replace
  - type: write
    path: src/components/DashboardScreen.tsx
    content: "--- src/components/DashboardScreen.tsx\n+++ src/components/DashboardScreen.tsx\n@@ -165,9 +165,11 @@\n \t\t\t? <Text>(<Text color=\"cyan\" bold>P</Text>)resume</Text>\n \t\t\t: <Text>(<Text color=\"cyan\" bold>P</Text>)ause</Text>;\n \t\treturn (\n-            <Text color=\"gray\">\n-                (<Text color=\"cyan\" bold>↑↓</Text>) Nav · (<Text color=\"cyan\" bold>→</Text>/Ent) View · (<Text color=\"cyan\" bold>←</Text>) Collapse · (<Text color=\"cyan\" bold>L</Text>)og · (<Text color=\"cyan\" bold>A</Text>)pprove All · (<Text color=\"cyan\" bold>C</Text>)ommit · {pauseAction} · (<Text color=\"cyan\" bold>Q</Text>)uit\n-            </Text>\n+            <Text color=\"gray\">(<Text color=\"cyan\" bold>↑↓</Text>) Nav · (<Text color=\"cyan\" bold>→</Text>/Ent) View · \n+(<Text color=\"cyan\" bold>←</Text>) Collapse · (<Text color=\"cyan\" bold>L</Text>)og · \n+(<Text color=\"cyan\" bold>A</Text>)pprove All · (<Text color=\"cyan\" bold>C</Text>)ommit · \n+{pauseAction} · (<Text color=\"cyan\" bold>Q</Text>)uit</Text>\n         );\n     };\n     \n     return (\n"
    patchStrategy: standard-diff
  - type: write
    path: src/services/review.service.ts
    content: >
      <<<<<<< SEARCH

      const tryInstructFile = (file: FileItem, transaction: Transaction): void
      => {
          const instructPrompt = generateSingleFileInstructPrompt(file, transaction);
          // In a real app: clipboardy.writeSync(instructPrompt)
          // eslint-disable-next-line no-console
          console.log(`[CLIPBOARD] Copied instruction prompt for: ${file.path}`);
      };

      =======

      const tryInstructFile = (file: FileItem, transaction: Transaction): void
      => {
          const _instructPrompt = generateSingleFileInstructPrompt(file, transaction);
          // In a real app: clipboardy.writeSync(_instructPrompt)
          // eslint-disable-next-line no-console
          console.log(`[CLIPBOARD] Copied instruction prompt for: ${file.path}`);
      };

      >>>>>>> REPLACE
    patchStrategy: search-replace
snapshot:
  src/components/ReviewScreen.tsx: >-
    import { Box, Text } from 'ink';

    import Separator from './Separator';

    import DiffScreen from './DiffScreen';

    import ReasonScreen from './ReasonScreen';

    import type { ScriptResult, FileItem, FileChangeType } from
    '../types/domain.types';

    import { useReviewScreen } from '../hooks/useReviewScreen';


    // --- Sub-components ---


    const FileItemRow = ({ file, reviewStatus, reviewError, isFocused }: {

    const FileItemRow = ({ file, reviewStatus, reviewError, reviewDetails,
    isFocused }: {
        file: FileItem;
        reviewStatus: string;
        reviewError?: string;
        reviewDetails?: string;
        isFocused: boolean;
    }) => {
        let icon;
        let iconColor;
        switch (reviewStatus) {
            case 'APPROVED': icon = '[✓]'; iconColor = 'green'; break;
            case 'REJECTED': icon = '[✗]'; iconColor = 'red'; break;
            case 'FAILED': icon = '[!]'; iconColor = 'red'; break;
            case 'AWAITING': icon = '[●]'; iconColor = 'yellow'; break;
            case 'RE_APPLYING': icon = '[●]'; iconColor = 'cyan'; break;
        }

        const typeColor = (type: FileChangeType) => {
            switch (type) {
                case 'ADD': return 'green';
                case 'DEL': return 'red';
                case 'REN': return 'yellow';
                default: return 'white';
            }
        };

        const diffStats = <Text>(+<Text color="green">{file.linesAdded}</Text>/-<Text color="red">{file.linesRemoved}</Text>)</Text>;
        const strategy = file.strategy === 'standard-diff' ? 'diff' : file.strategy;
        const prefix = isFocused ? '> ' : '  ';
        const colorProps = isFocused ? { bold: true, color: 'cyan' } : {};

        if (reviewStatus === 'FAILED') {
            return (
                <Box>
                    <Text {...colorProps}>
                        {prefix}<Text color={iconColor}>{icon} FAILED {file.path}</Text>
                        <Text color="red">    ({reviewError})</Text>
                    </Text>
                </Box>
            );
        }

        if (reviewStatus === 'AWAITING') {
            return (
                <Box>
                    <Text {...colorProps}>
                        {prefix}<Text color={iconColor}>{icon} AWAITING {file.path}</Text>
                        <Text color="yellow">    ({reviewDetails})</Text>
                    </Text>
                </Box>
            );
        }

        if (reviewStatus === 'RE_APPLYING') {
            return (
                 <Box>
                    <Text {...colorProps}>
                        {prefix}<Text color={iconColor}>{icon} RE-APPLYING... {file.path}</Text>
                        <Text color="cyan"> (using &apos;replace&apos; strategy)</Text>
                    </Text>
                </Box>
            );
        }

        return (
            <Box>
                <Text {...colorProps}>
                    {prefix}<Text color={iconColor}>{icon}</Text> {file.type}{' '}
                    <Text color={typeColor(file.type)}>{file.path}</Text>{' '}
                    {diffStats} [{strategy}]
                </Text>
            </Box>
        );
    };


    const ScriptItemRow = ({
        script,
        isSelected,
        isExpanded,
    }: {
        script: ScriptResult;
        isSelected: boolean;
        isExpanded: boolean;
    }) => {
        const icon = script.success ? '✓' : '✗';
        const iconColor = script.success ? 'green' : 'red';
        const arrow = isExpanded ? '▾' : '▸';
        const prefix = isSelected ? '> ' : '  ';
        
        // Extract script type from command (e.g., "bun run test" -> "Post-Command", "bun run lint" -> "Linter")
        const scriptType = script.command.includes('test') ? 'Post-Command' : 
                          script.command.includes('lint') ? 'Linter' : 
                          'Script';

        return (
            <Box>
                <Text bold={isSelected} color={isSelected ? 'cyan' : undefined}>
                    {prefix}<Text color={iconColor}>{icon}</Text> {scriptType}: `{script.command}` ({script.duration}s) {arrow}{' '}
                    {script.summary}
                </Text>
            </Box>
        );
    };


    // --- Main Component ---


    const ReviewScreen = () => {
        const {
            transaction,
            files,
            scripts = [],
            patchStatus,
            selectedItemIndex,
            bodyView,
            isDiffExpanded,
            reasoningScrollIndex,
            scriptErrorIndex,
            fileReviewStates,
            numFiles,
            approvedFilesCount,
            totalLinesAdded,
            totalLinesRemoved,
            selectedBulkRepairOptionIndex,
            selectedBulkInstructOptionIndex,
            navigableItems,
            hasRejectedFiles,
        } = useReviewScreen();

        if (!transaction) {
            return <Text>Loading review...</Text>;
        }
        const { hash, message, prompt = '', reasoning = '' } = transaction;

        const renderBody = () => {
            if (bodyView === 'none') return null;

            if (bodyView === 'reasoning') {
                const reasoningText = reasoning || '';
                const reasoningLinesCount = reasoningText.split('\n').length;
                const visibleLinesCount = 10;
                return (
                    <Box flexDirection="column">
                        <ReasonScreen
                            reasoning={reasoningText}
                            scrollIndex={reasoningScrollIndex}
                            visibleLinesCount={visibleLinesCount}
                        />
                        {reasoningLinesCount > visibleLinesCount && (
                            <Text color="gray">
                                Showing lines {reasoningScrollIndex + 1}-{Math.min(reasoningScrollIndex + visibleLinesCount, reasoningLinesCount)}{' '}
                                of {reasoningLinesCount}
                            </Text>
                        )}
                    </Box>
                );
            }
            
            if (bodyView === 'diff') {
                const currentItem = navigableItems[selectedItemIndex];
                const selectedFile = currentItem?.type === 'file' ? files.find(f => f.id === currentItem.id) : undefined;
                if (!selectedFile) return null;
                return (
                    <DiffScreen
                        filePath={selectedFile.path}
                        diffContent={selectedFile.diff}
                        isExpanded={isDiffExpanded}
                    />
                );
            }

            if (bodyView === 'script_output') {
                 const currentItem = navigableItems[selectedItemIndex];
                 const scriptItems = navigableItems.filter((i): i is { type: 'script'; id: string } => i.type === 'script');
                 const scriptIndex = currentItem?.type === 'script'
                    ? scriptItems.findIndex(i => i.id === currentItem.id)
                    : -1;
                 const selectedScript = scripts[scriptIndex] || null;
                 if (!selectedScript) return null;
                 
                 const outputLines = selectedScript.output.split('\n');
                 const errorLines = outputLines.filter((line: string) =>
                    line.includes('Error') || line.includes('Warning'),
                 );
                 
                 return (
                    <Box flexDirection="column">
                        <Text>{selectedScript.command.includes('lint') ? 'LINTER' : 'SCRIPT'} OUTPUT: `{selectedScript.command}`</Text>
                        <Box marginTop={1} flexDirection="column">
                            {outputLines.map((line: string, index: number) => {
                                const isError = line.includes('Error');
                                const isWarning = line.includes('Warning');
                                const isHighlighted = errorLines[scriptErrorIndex] === line;
                                
                                return (
                                    <Text 
                                        key={index} 
                                        color={isError ? 'red' : isWarning ? 'yellow' : undefined}
                                        bold={isHighlighted}
                                        backgroundColor={isHighlighted ? 'blue' : undefined}
                                    >
                                        {line}
                                    </Text>
                                );
                            })}
                        </Box>
                        {errorLines.length > 0 && (
                            <Text color="gray">
                                Error {scriptErrorIndex + 1} of {errorLines.length} highlighted
                            </Text>
                        )}
                    </Box>
                 );
            }

            if (bodyView === 'confirm_handoff') {
                return (
                    <Box flexDirection="column" gap={1}>
                        <Text bold>HANDOFF TO EXTERNAL AGENT</Text>
                        <Box flexDirection="column">
                            <Text>This action will:</Text>
                            <Text>1. Copy a detailed prompt to your clipboard for an agentic AI.</Text>
                            <Text>2. Mark the current transaction as &apos;Handoff&apos; and close this review.</Text>
                            <Text>3. Assume that you and the external agent will complete the work.</Text>
                        </Box>
                        <Text>Relaycode will NOT wait for a new patch. This is a final action.</Text>
                        <Text bold color="yellow">Are you sure you want to proceed?</Text>
                    </Box>
                );
            }

            if (bodyView === 'bulk_repair') {
                const failedFiles = files.filter((f: FileItem) => fileReviewStates.get(f.id)?.status === 'FAILED');
                const repairOptions = [
                    '(1) Copy Bulk Re-apply Prompt (for single-shot AI)',
                    '(2) Bulk Change Strategy & Re-apply',
                    '(3) Handoff to External Agent',
                    '(4) Bulk Abandon All Failed Files',
                    '(Esc) Cancel',
                ];

                return (
                    <Box flexDirection="column" gap={1}>
                        <Text bold>BULK REPAIR ACTION</Text>

                        <Box flexDirection="column">
                            <Text>The following {failedFiles.length} files failed to apply:</Text>
                            {failedFiles.map((file: FileItem) => (
                                <Text key={file.id}>- {file.path}</Text>
                            ))}
                        </Box>

                        <Text>How would you like to proceed?</Text>

                        <Box flexDirection="column">
                            {repairOptions.map((opt, i) => (
                                <Text key={i} color={selectedBulkRepairOptionIndex === i ? 'cyan' : undefined}>
                                    {selectedBulkRepairOptionIndex === i ? '> ' : '  '}
                                    {opt}
                                </Text>
                            ))}
                        </Box>
                    </Box>
                );
            }

            if (bodyView === 'bulk_instruct') {
                const rejectedFiles = files.filter((f: FileItem) => fileReviewStates.get(f.id)?.status === 'REJECTED');
                const instructOptions = [
                    '(1) Copy Bulk Re-instruct Prompt (for single-shot AI)',
                    '(2) Handoff to External Agent',
                    '(3) Bulk Un-reject All Files (revert to original)',
                    '(4) Cancel',
                ];

                return (
                    <Box flexDirection="column" gap={1}>
                        <Text bold>BULK INSTRUCTION ACTION</Text>

                        <Box flexDirection="column">
                            <Text>The following {rejectedFiles.length} files were rejected:</Text>
                            {rejectedFiles.map((file: FileItem) => (
                                <Text key={file.id}>- {file.path}</Text>
                            ))}
                        </Box>
                        <Box flexDirection="column" marginTop={1}>
                            {instructOptions.map((opt, i) => (
                                <Text key={i} color={selectedBulkInstructOptionIndex === i ? 'cyan' : undefined}>
                                    {selectedBulkInstructOptionIndex === i ? '> ' : '  '}
                                    {opt}
                                </Text>
                            ))}
                        </Box>
                    </Box>
                );
            }

            return null;
        };

        const renderFooter = () => {
            // Contextual footer for body views
            if (bodyView === 'diff') {
                return <Text>(↑↓) Nav · (X)pand · (D/Esc) Back</Text>;
            }
            if (bodyView === 'reasoning') {
                return <Text>(↑↓) Scroll Text · (R)Collapse View · (C)opy Mode</Text>;
            }
            if (bodyView === 'script_output') {
                return (
                    <Text>(↑↓) Nav · (J↓/K↑) Next/Prev Error · (C)opy Output · (Ent/Esc) Back</Text>
                );
            }
            if (bodyView === 'bulk_repair') {
                return <Text>Choose an option [1-4, Esc]:</Text>;
            }
            if (bodyView === 'bulk_instruct') {
                return <Text>Choose an option [1-4, Esc]:</Text>;
            }
            if (bodyView === 'confirm_handoff') {
                return <Text>(Enter) Confirm Handoff      (Esc) Cancel</Text>;
            }

            // Main footer
            const actions = ['(↑↓) Nav'];

            const currentItem = navigableItems[selectedItemIndex];
            
            if (currentItem?.type === 'file') {
                const selectedFile = files.find(f => f.id === currentItem.id);
                const fileState = fileReviewStates.get(currentItem.id);
                if (fileState?.status !== 'FAILED') {
                    actions.push('(Spc) Toggle');
                }
                actions.push('(D)iff');
                
                // Add repair options for failed files
                if (selectedFile && fileState?.status === 'FAILED') {
                    actions.push('(T)ry Repair');
                }
                if (selectedFile && fileState?.status === 'REJECTED') {
                    actions.push('(I)nstruct');
                }
            } else if (currentItem?.type === 'script') {
                actions.push('(Ent) Expand Details');
            } else { // Prompt or Reasoning
                actions.push('(Ent) Expand');
            }

            if (currentItem?.type !== 'reasoning') {
                actions.push('(R)easoning');
            }

            // Add bulk repair if there are failed files
            const hasFailedFiles = Array.from(fileReviewStates.values()).some(s => s.status === 'FAILED');
            if (hasFailedFiles) {
                actions.push('(Shift+T) Bulk Repair');
            }
            // Add bulk instruct if there are rejected files
            if (hasRejectedFiles) {
                actions.push('(Shift+I) Bulk Instruct');
            }
            
            actions.push('(C)opy');

            if (approvedFilesCount > 0) {
                actions.push('(A)pprove');
            }

            if (Array.from(fileReviewStates.values()).some(s => s.status === 'APPROVED' || s.status === 'FAILED')) {
                actions.push('(Shift+R) Reject All');
            }
            actions.push('(Q)uit');

            return <Text>{actions.join(' · ')}</Text>;
        };

        return (
            <Box flexDirection="column">
                {/* Header */}
                <Text color="cyan">▲ relaycode review</Text>
                <Separator />
                
                {/* Navigator Section */}
                <Box flexDirection="column" marginY={1}>
                    <Box flexDirection="column">
                        <Text>{hash} · {message}</Text>
                        <Text>
                            (<Text color="green">+{totalLinesAdded}</Text>/<Text color="red">-{totalLinesRemoved}</Text>) · {numFiles} Files · {approvedFilesCount}/{numFiles} Approved
                            {patchStatus === 'PARTIAL_FAILURE' && scripts.length === 0 && <Text> · Scripts: SKIPPED</Text>}
                            {patchStatus === 'PARTIAL_FAILURE' && <Text color="red" bold> · MULTIPLE PATCHES FAILED</Text>}
                        </Text>
                    </Box>

                    <Box flexDirection="column" marginTop={1}>
                        <Text color={navigableItems[selectedItemIndex]?.type === 'prompt' ? 'cyan' : undefined}>
                            {navigableItems[selectedItemIndex]?.type === 'prompt' ? '> ' : '  '}
                            (P)rompt ▸ {(prompt || '').substring(0, 60)}...
                        </Text>
                        <Text color={navigableItems[selectedItemIndex]?.type === 'reasoning' ? 'cyan' : undefined}>
                            {navigableItems[selectedItemIndex]?.type === 'reasoning' ? '> ' : '  '}
                            (R)easoning ({(reasoning || '').split('\n\n').length} steps) {bodyView === 'reasoning' ? '▾' : '▸'}{' '}
                            {((reasoning || '').split('\n')[0] ?? '').substring(0, 50)}...
                        </Text>
                    </Box>
                </Box>

                <Separator />

                {/* Script Results (if any) */}
                {scripts.length > 0 && navigableItems.some(i => i.type === 'script') && (
                    <>
                        <Box flexDirection="column" marginY={1}>
                            {scripts.map((script: ScriptResult) => (
                                (() => {
                                    const navItemIndex = navigableItems.findIndex(i => {
                                        if (i.type === 'script') {
                                            return i.id === script.command;
                                        }
                                        return false;
                                    });
                                    const isSelected = selectedItemIndex === navItemIndex;
                                    return (
                                        <ScriptItemRow
                                            key={script.command}
                                            script={script}
                                            isSelected={isSelected}
                                            isExpanded={bodyView === 'script_output' && isSelected}
                                        />
                                    );
                                })()
                            ))}
                        </Box>
                        <Separator />
                    </>
                )}

                {/* Files Section */}
                <Box flexDirection="column" marginY={1}>
                    <Text bold>FILES</Text>
                    {files.map((file: FileItem) => {
                        const navItemIndex = navigableItems.findIndex(i => {
                            if (i.type === 'file') {
                                return i.id === file.id;
                            }
                            return false;
                        });
                        const isFocused = selectedItemIndex === navItemIndex;
                        const reviewState = fileReviewStates.get(file.id);
                        return (
                            <FileItemRow
                                key={file.id}
                                file={file}
                                isFocused={isFocused}
                                reviewStatus={reviewState?.status || 'AWAITING'}
                                reviewError={reviewState?.error}
                                reviewDetails={reviewState?.details}
                            />
                        );
                    })}
                </Box>
                
                <Separator />
                
                {/* Body Viewport */}
                {bodyView !== 'none' && (
                    <>
                        <Box marginY={1}>
                            {renderBody()}
                        </Box>
                        <Separator />
                    </>
                )}

                {/* Footer */}
                <Box>
                    {renderFooter()}
                </Box>
            </Box>
        );
    };


    export default ReviewScreen;
  src/components/DashboardScreen.tsx: "import React from 'react';\nimport { Box, Text } from 'ink';\nimport Spinner from 'ink-spinner';\nimport Separator from './Separator';\nimport type { Transaction, TransactionStatus, FileChangeType } from '../types/domain.types';\nimport { useDashboardScreen } from '../hooks/useDashboardScreen';\nimport { UI_CONFIG } from '../config/ui.config';\n\n// --- Sub-components & Helpers ---\n\nconst getStatusIcon = (status: TransactionStatus) => {\n    switch (status) {\n        case 'PENDING': return <Text color=\"yellow\">?</Text>;\n        case 'APPLIED': return <Text color=\"green\">✓</Text>;\n        case 'COMMITTED': return <Text color=\"blue\">→</Text>;\n        case 'HANDOFF': return <Text color=\"magenta\">→</Text>;\n        case 'FAILED': return <Text color=\"red\">✗</Text>;\n        case 'REVERTED': return <Text color=\"gray\">↩</Text>;\n        case 'IN-PROGRESS': return <Spinner type=\"dots\" />;\n        default: return <Text> </Text>;\n    }\n};\n\nconst getFileChangeTypeIcon = (type: FileChangeType) => {\n    switch (type) {\n        case 'MOD': return '[MOD]';\n        case 'ADD': return '[ADD]';\n        case 'DEL': return '[DEL]';\n        case 'REN': return '[REN]';\n    }\n};\n\nconst formatTimeAgo = (timestamp: number) => {\n    const seconds = Math.floor((Date.now() - timestamp) / 1000);\n    if (seconds < 60) return `${seconds}s`;\n    const minutes = Math.floor(seconds / 60);\n    return `${minutes}m`;\n};\n\nconst ExpandedEventInfo = ({ transaction }: { transaction: Transaction }) => {\n    const stats = transaction.stats;\n    const files = transaction.files || [];\n\n    return (\n        <Box flexDirection=\"column\" paddingLeft={4} marginBottom={1} borderStyle=\"round\" borderLeft={true} borderTop={false} borderRight={false} borderBottom={false} borderColor=\"gray\">\n            {stats && (\n                <Text color=\"gray\">\n                    Stats: {stats.files} files, +{stats.linesAdded}/-{stats.linesRemoved}\n                </Text>\n            )}\n             <Box flexDirection=\"column\" paddingLeft={1}>\n                {files.map(file => (\n                     <Text key={file.id}>\n                        <Text color=\"gray\">{getFileChangeTypeIcon(file.type)}</Text> {file.path}\n                    </Text>\n                ))}\n             </Box>\n        </Box>\n    );\n};\n\nconst EventStreamItem = ({ transaction, isSelected, isExpanded }: { transaction: Transaction, isSelected: boolean, isExpanded: boolean }) => {\n    const icon = getStatusIcon(transaction.status);\n    const time = formatTimeAgo(transaction.timestamp).padEnd(5, ' ');\n    const statusText = transaction.status.padEnd(11, ' ');\n    const expandIcon = isExpanded ? '▾' : '▸';\n    \n    const messageNode = transaction.status === 'IN-PROGRESS'\n        ? <Text color=\"cyan\">{transaction.message}</Text>\n        : transaction.message;\n    \n    const content = (\n        <Text>\n            {time} {expandIcon} {icon} {statusText} <Text color=\"gray\">{transaction.hash}</Text> · {messageNode}\n        </Text>\n    );\n\n    return isSelected ? <Text bold color=\"cyan\">{'> '}{content}</Text> : <Text>{'  '}{content}</Text>;\n};\n\nconst ConfirmationContent = ({\n    transactionsToConfirm,\n}: {\n    transactionsToConfirm: Transaction[];\n}) => {\n    const actionText = 'APPROVE';\n    \n    return (\n        <Box flexDirection=\"column\" marginY={1} paddingLeft={2}>\n            <Text bold color=\"yellow\">{actionText} ALL PENDING TRANSACTIONS?</Text>\n            <Text>\n                The following {transactionsToConfirm.length} transaction(s) will be approved:\n            </Text>\n            <Box flexDirection=\"column\" paddingLeft={1} marginTop={1}>\n                {transactionsToConfirm.map(tx => (\n                    <Text key={tx.id}>- {tx.hash}: {tx.message}</Text>\n                ))}\n            </Box>\n        </Box>\n    );\n};\n\n// --- Main Component ---\n\nconst DashboardScreen = () => {\n    const {\n        status,\n        transactions,\n        selectedTransactionIndex,\n        pendingApprovals,\n        pendingCommits,\n        isModal,\n        isProcessing,\n        viewOffset,\n        viewportHeight,\n        transactionsToConfirm,\n        expandedTransactionId,\n    } = useDashboardScreen({ reservedRows: UI_CONFIG.dashboard.reservedRows });\n\n    const renderStatusBar = () => {\n        let statusText: string;\n        let statusIcon: React.ReactNode;\n        switch (status) {\n            case 'LISTENING': statusText = 'LISTENING'; statusIcon = <Text color=\"green\">●</Text>; break;\n            case 'PAUSED': statusText = 'PAUSED'; statusIcon = <Text color=\"yellow\">||</Text>; break;\n            case 'APPROVING': statusText = 'APPROVING...'; statusIcon = <Text color=\"cyan\"><Spinner type=\"dots\"/></Text>; break;\n            default: statusText = 'LISTENING'; statusIcon = <Text color=\"green\">●</Text>;\n        }\n\n        let approvalStr: React.ReactNode = String(pendingApprovals).padStart(2, '0');\n        const commitStr: React.ReactNode = String(pendingCommits).padStart(2, '0');\n\n        if (status === 'APPROVING') approvalStr = <Text color=\"cyan\">(<Spinner type=\"dots\"/>)</Text>;\n        if (status === 'CONFIRM_APPROVE') {\n            approvalStr = <Text bold color=\"yellow\">┌ {approvalStr} ┐</Text>;\n        }\n        \n        return (\n            <Text>\n                STATUS: {statusIcon} {statusText} · APPROVALS: {approvalStr} · COMMITS: {commitStr}\n            </Text>\n        );\n    };\n\n    const renderFooter = () => {\n        if (isModal) return (\n            <Text>\n                (<Text color=\"cyan\" bold>Enter</Text>) Confirm      (<Text color=\"cyan\" bold>Esc</Text>) Cancel\n            </Text>\n        );\n        if (isProcessing) return <Text>Processing... This may take a moment.</Text>;\n\n        const pauseAction = status === 'PAUSED'\n\t\t\t? <Text>(<Text color=\"cyan\" bold>P</Text>)resume</Text>\n\t\t\t: <Text>(<Text color=\"cyan\" bold>P</Text>)ause</Text>;\n\t\treturn (\n            <Text color=\"gray\">\n                (<Text color=\"cyan\" bold>↑↓</Text>) Nav · (<Text color=\"cyan\" bold>→</Text>/Ent) View · (<Text color=\"cyan\" bold>←</Text>) Collapse · (<Text color=\"cyan\" bold>L</Text>)og · (<Text color=\"cyan\" bold>A</Text>)pprove All · (<Text color=\"cyan\" bold>C</Text>)ommit · {pauseAction} · (<Text color=\"cyan\" bold>Q</Text>)uit\n            </Text>\n        );\n    };\n    \n    return (\n        <Box flexDirection=\"column\" height=\"100%\">\n            <Text color=\"cyan\">▲ relaycode dashboard</Text>\n            <Separator />\n            <Box marginY={1}>\n                {renderStatusBar()}\n            </Box>\n            \n            {isModal && (\n                <>\n                    <ConfirmationContent transactionsToConfirm={transactionsToConfirm} />\n                    <Separator />\n                </>\n            )}\n            \n            <Text bold underline> EVENT STREAM (Last 15 minutes)</Text>\n            <Box flexDirection=\"column\" marginTop={1}>\n                {transactions.length === 0 && (\n                     <Box paddingLeft={2}><Text color=\"gray\">Listening for changes... no events yet.</Text></Box>\n                )}\n                {transactions.slice(viewOffset, viewOffset + viewportHeight).map((tx, index) => {\n                    const actualIndex = viewOffset + index;\n                    const isExpanded = expandedTransactionId === tx.id;\n                    return (\n                        <React.Fragment key={tx.id}>\n                            <EventStreamItem\n                                transaction={tx}\n                                isSelected={!isModal && actualIndex === selectedTransactionIndex}\n                                isExpanded={isExpanded}\n                            />\n                            {isExpanded && <ExpandedEventInfo transaction={tx} />}\n                        </React.Fragment>\n                    );\n                })}\n            </Box>\n\n            <Box marginTop={1}><Separator /></Box>\n            {renderFooter()}\n        </Box>\n    );\n};\n\nexport default DashboardScreen;"
  src/services/review.service.ts: >-
    import { useTransactionStore } from '../stores/transaction.store';

    import { useAppStore } from '../stores/app.store';

    import { sleep } from '../utils';

    import type { ApplyUpdate, PatchStatus } from '../stores/review.store';

    import type { Transaction, FileItem, FileReviewStatus } from
    '../types/domain.types';


    const generateBulkRepairPrompt = (failedFiles: FileItem[]): string => {
        return `The previous patch failed to apply to MULTIPLE files. Please generate a new, corrected patch that addresses all the files listed below.

    IMPORTANT: The response MUST contain a complete code block for EACH file
    that needs to be fixed.


    ${failedFiles.map(file => `--- FILE: ${file.path} ---

    Strategy: ${file.strategy}

    Error: Hunk #1 failed to apply // This is a mock error


    ORIGINAL CONTENT:

    ---

    // ... original content of ${file.path} ...

    ---


    FAILED PATCH:

    ---

    ${file.diff || '// ... failed diff ...'}

    ---

    `).join('\n')}


    Please analyze all failed files and provide a complete, corrected
    response.`;

    };


    const generateHandoffPrompt = (
        transaction: Transaction,
        fileReviewStates: Map<
            string, { status: FileReviewStatus; error?: string; details?: string }
        >,
    ): string => {
        const successfulFiles = (transaction.files || []).filter(f => fileReviewStates.get(f.id)?.status === 'APPROVED');
        const failedFiles = (transaction.files || []).filter(f => ['FAILED', 'REJECTED'].includes(fileReviewStates.get(f.id)?.status || ''));

        return `I am handing off a failed automated code transaction to you. Your task is to act as my programming assistant and complete the planned changes.

    The full plan for this transaction is detailed in the YAML file located at:
    .relay/transactions/${transaction.hash}.yml. Please use this file as your
    primary source of truth for the overall goal.


    Here is the current status of the transaction:


    --- TRANSACTION SUMMARY ---

    Goal: ${transaction.message}

    Reasoning:

    ${transaction.reasoning || ''}


    --- CURRENT FILE STATUS ---

    SUCCESSFUL CHANGES (already applied, no action needed):

    ${successfulFiles.map(f => `- MODIFIED: ${f.path}`).join('\n') || ' 
    (None)'}


    FAILED CHANGES (these are the files you need to fix):

    ${failedFiles.map(f => `- FAILED: ${f.path} (Error:
    ${fileReviewStates.get(f.id)?.error})`).join('\n')}


    Your job is to now work with me to fix the FAILED files and achieve the
    original goal of the transaction. Please start by asking me which file you
    should work on first.`;

    };


    const performHandoff = (hash: string) => {
        // This is a bit of a hack to find the right transaction to update in the demo
        const txToUpdate = useTransactionStore.getState().transactions.find(tx => tx.hash === hash);
        if (txToUpdate) {
            useTransactionStore.getState().actions.updateTransactionStatus(txToUpdate.id, 'HANDOFF');
        }

        useAppStore.getState().actions.showDashboardScreen();
    };


    async function* runApplySimulation(scenario: 'success' | 'failure'):
    AsyncGenerator<ApplyUpdate> {
        if (scenario === 'success') {
            yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'active' } }; await sleep(100);
            yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'done', duration: 0.1 } };

            yield { type: 'UPDATE_STEP', payload: { id: 'memory', status: 'active' } }; await sleep(100);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 's1', title: '[✓] write: src/core/clipboard.ts (strategy: replace)', status: 'done' } } };
            await sleep(100);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 's2', title: '[✓] write: src/utils/shell.ts (strategy: standard-diff)', status: 'done' } } };
            yield { type: 'UPDATE_STEP', payload: { id: 'memory', status: 'done', duration: 0.3 } };

            yield { type: 'UPDATE_STEP', payload: { id: 'post-command', status: 'active' } }; await sleep(1300);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'post-command', substep: { id: 's3', title: '`bun run test` ... Passed', status: 'done' } } };
            yield { type: 'UPDATE_STEP', payload: { id: 'post-command', status: 'done', duration: 2.3 } };

            yield { type: 'UPDATE_STEP', payload: { id: 'linter', status: 'active' } }; await sleep(1200);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'linter', substep: { id: 's4', title: '`bun run lint` ... 0 Errors', status: 'done' } } };
            yield { type: 'UPDATE_STEP', payload: { id: 'linter', status: 'done', duration: 1.2 } };

            await sleep(500);

        } else { // failure scenario
            yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'active' } }; await sleep(100);
            yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'done', duration: 0.1 } };

            yield { type: 'UPDATE_STEP', payload: { id: 'memory', status: 'active' } }; await sleep(100);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 'f1', title: '[✓] write: src/core/transaction.ts (strategy: replace)', status: 'done' } } };
            await sleep(100);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 'f2', title: '[!] failed: src/utils/logger.ts (Hunk #1 failed to apply)', status: 'failed' } } };
            await sleep(100);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 'f3', title: '[!] failed: src/commands/apply.ts (Context mismatch at line 92)', status: 'failed' } } };
            yield { type: 'UPDATE_STEP', payload: { id: 'memory', status: 'done', duration: 0.5 } };

            await sleep(100);
            yield { type: 'UPDATE_STEP', payload: { id: 'post-command', status: 'skipped', details: 'Skipped due to patch application failure' } };
            await sleep(100);
            yield { type: 'UPDATE_STEP', payload: { id: 'linter', status: 'skipped', details: 'Skipped due to patch application failure' } };

            await sleep(500);
        }
    }


    const prepareTransactionForReview = (
        transaction: Transaction,
    ): {
        patchStatus: PatchStatus;
        fileReviewStates: Map<string, { status: FileReviewStatus; error?: string }>;
    } => {
        // This simulates the backend determining which files failed or succeeded and sets it ONCE on load.
        // For this demo, tx '1' is the failure case, any other is success.
        const isFailureCase = transaction.id === '1';
        const fileReviewStates = new Map<string, { status: FileReviewStatus; error?: string }>();

        (transaction.files || []).forEach((file, index) => {
            if (isFailureCase) {
                const isFailedFile = index > 0;
                const status = isFailedFile ? 'FAILED' : 'APPROVED';
                const error = isFailedFile ? (index === 1 ? 'Hunk #1 failed to apply' : 'Context mismatch at line 92') : undefined;
                fileReviewStates.set(file.id, { status, error });
            } else {
                fileReviewStates.set(file.id, { status: 'APPROVED' });
            }
        });
        return { patchStatus: isFailureCase ? 'PARTIAL_FAILURE' : 'SUCCESS', fileReviewStates };
    };


    const generateSingleFileRepairPrompt = (file: FileItem, error?: string):
    string => {
        return `The patch failed to apply to ${file.path}. Please generate a corrected patch.

    Error: ${error || 'Unknown error'}

    Strategy: ${file.strategy}


    ORIGINAL CONTENT:

    ---

    // ... original file content would be here ...

    ---


    FAILED PATCH:

    ---

    ${file.diff || '// ... failed diff would be here ...'}

    ---


    Please provide a corrected patch that addresses the error.`;

    };


    const tryRepairFile = (file: FileItem, error?: string): FileItem => {
        generateSingleFileRepairPrompt(file, error);
        // In a real app: clipboardy.writeSync(repairPrompt)
        // eslint-disable-next-line no-console
        console.log(`[CLIPBOARD] Copied repair prompt for: ${file.path}`);

        return file;
    };


    const generateSingleFileInstructPrompt = (file: FileItem, transaction:
    Transaction): string => {
        return `The user REJECTED the last proposed change for the file \`${file.path}\`.

    The original high-level goal was:

    ---

    ${transaction.prompt || transaction.message}

    ---


    The rejected change was:

    ---

    ${file.diff || '// ... rejected diff would be here ...'}

    ---


    Please provide an alternative solution for \`${file.path}\` that still
    accomplishes the original goal.

    The response MUST be a complete, corrected patch for this file.`;

    };


    const tryInstructFile = (file: FileItem, transaction: Transaction): void =>
    {
        const instructPrompt = generateSingleFileInstructPrompt(file, transaction);
        // In a real app: clipboardy.writeSync(instructPrompt)
        // eslint-disable-next-line no-console
        console.log(`[CLIPBOARD] Copied instruction prompt for: ${file.path}`);
    };


    const generateBulkInstructPrompt = (rejectedFiles: FileItem[], transaction:
    Transaction): string => {
        // Mock implementation for demo. In a real scenario, this would generate a more complex prompt.
        const fileList = rejectedFiles.map(f => `- ${f.path}`).join('\n');
        // eslint-disable-next-line no-console
        console.log(`[CLIPBOARD] Copied bulk instruction prompt for ${rejectedFiles.length} files.`);
        return `The user has rejected changes in multiple files for the goal: "${transaction.message}".\n\nThe rejected files are:\n${fileList}\n\nPlease provide an alternative patch for all of them.`;
    };


    const runBulkReapply = async (
        failedFiles: FileItem[],
    ): Promise<{ id: string; status: FileReviewStatus; error?: string }[]> => {
        await sleep(1500); // Simulate re-apply

        // Mock a mixed result
        let first = true;
        return failedFiles.map(file => {
            if (first) {
                first = false;
                return { id: file.id, status: 'APPROVED' as const };
            } else {
                return {
                    id: file.id,
                    status: 'FAILED' as const,
                    error: "'replace' failed: markers not found",
                };
            }
        });
    };


    export const ReviewService = {
        prepareTransactionForReview,
        generateBulkRepairPrompt,
        generateBulkInstructPrompt,
        generateHandoffPrompt,
        performHandoff,
        runApplySimulation,
        generateSingleFileRepairPrompt,
        tryRepairFile,
        generateSingleFileInstructPrompt,
        tryInstructFile,
        runBulkReapply,
    };
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 131
