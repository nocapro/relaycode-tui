uuid: f191244c-9f69-4254-8c88-1c9f809d3b45
projectId: relaycode-tui
createdAt: '2025-09-22T06:58:34.076Z'
gitCommitMsg: >-
  refactor: extract app, init, and review types

  This commit continues the type refactoring by extracting types related to the
  application state machine, initialization process, and review screen into
  dedicated files within `src/types`.

  - Created `app.types.ts`, `init.types.ts`, and `review.types.ts`. - Updated
  the corresponding stores (`app.store.ts`, `init.store.ts`, `review.store.ts`)
  to import these centralized types. - Updated `review.service.ts` to import
  types directly, decoupling it further from the store's implementation details.
  - Renamed `BodyView` in the review store to `ReviewBodyView` for better
  clarity and to avoid potential naming collisions.
promptSummary: >-
  Continue refactoring by extracting types for the app state, initialization
  process, and review screen into their own dedicated files in `src/types` and
  updating all dependent files.
reasoning:
  - >-
    Excellent. Phase 1 established a solid foundation. For Phase 2 of our
    refactoring, I will continue extracting domain-specific types from the
    stores into our new `src/types` directory. This phase will focus on types
    related to the application's state machine, the initialization process, and
    the review screen.
  - '### Phase 2: Extracting App, Init, and Review Types'
  - '1.  **New Type Files Created**:'
  - >-
    *   `src/types/app.types.ts`: Contains the `AppScreen` type, which defines
    the possible screens in the application's navigation state.
  - >-
    *   `src/types/init.types.ts`: Centralizes all types related to the
    initialization sequence, such as `Task`, `TaskStatus`, and `InitPhase`.
  - >-
    *   `src/types/review.types.ts`: Groups together types used exclusively in
    the review process, including `ScriptResult`, `ApplyStep`, and the screen's
    view states. I have renamed the review screen's `BodyView` to
    `ReviewBodyView` to prevent potential naming conflicts.
  - '2.  **Stores Refactored**:'
  - >-
    *   `app.store.ts`, `init.store.ts`, and `review.store.ts` have been updated
    to remove their local type definitions and import them from the newly
    created files.
  - '3.  **Services Updated**:'
  - >-
    *   `review.service.ts`, which depends on the `ApplyStep` type, now imports
    it directly from `review.types.ts` instead of from the review store, further
    decoupling the service from the store's implementation.
  - 'Here are the changes for the second phase:'
  - First, I'll create the new type definition files.
  - Now, I'll update the existing files to use these new types.
operations:
  - type: write
    path: src/types/app.types.ts
    content: >-
      export type AppScreen = 'splash' | 'init' | 'dashboard' | 'review' |
      'review-processing' | 'git-commit' | 'transaction-detail' |
      'transaction-history';
    patchStrategy: replace
  - type: write
    path: src/types/init.types.ts
    content: >-
      export type TaskStatus = 'pending' | 'active' | 'done';

      export type InitPhase = 'ANALYZE' | 'CONFIGURE' | 'INTERACTIVE' |
      'FINALIZE';

      export type GitignoreChoice = 'ignore' | 'share';


      export interface Task {
          id: string;
          title: string;
          subtext?: string;
          status: TaskStatus;
      }
    patchStrategy: replace
  - type: write
    path: src/types/review.types.ts
    content: >-
      export interface ScriptResult {
          command: string;
          success: boolean;
          duration: number;
          summary: string;
          output: string;
      }


      export interface ApplyStep {
          id: string;
          title: string;
          status: 'pending' | 'active' | 'done' | 'failed' | 'skipped';
          details?: string;
          substeps?: ApplyStep[];
          duration?: number;
      }


      export type ReviewBodyView = 'diff' | 'reasoning' | 'script_output' |
      'copy_mode' | 'bulk_repair' | 'confirm_handoff' | 'none';

      export type PatchStatus = 'SUCCESS' | 'PARTIAL_FAILURE';
    patchStrategy: replace
  - type: write
    path: src/stores/app.store.ts
    content: >+
      --- src/stores/app.store.ts

      +++ src/stores/app.store.ts

      @@ -1,6 +1,5 @@
       import { create } from 'zustand';
      +import type { AppScreen } from '../types/app.types';
       
      -export type AppScreen = 'splash' | 'init' | 'dashboard' | 'review' |
      'review-processing' | 'git-commit' | 'transaction-detail' |
      'transaction-history';

      -
       interface AppState {
           isDebugMenuOpen: boolean;
           currentScreen: AppScreen;

    patchStrategy: standard-diff
  - type: write
    path: src/stores/init.store.ts
    content: >+
      --- src/stores/init.store.ts

      +++ src/stores/init.store.ts

      @@ -1,19 +1,5 @@
       import { create } from 'zustand';
      -

      -// Types

      -export type TaskStatus = 'pending' | 'active' | 'done';

      -export type InitPhase = 'ANALYZE' | 'CONFIGURE' | 'INTERACTIVE' |
      'FINALIZE';

      -export type GitignoreChoice = 'ignore' | 'share';

      -

      -export interface Task {

      -    id: string;

      -    title: string;

      -    subtext?: string;

      -    status: TaskStatus;

      -}

      +import type { Task, TaskStatus, InitPhase, GitignoreChoice } from
      '../types/init.types';
       
       // Initial State definitions from README
       export const initialAnalyzeTasks: Task[] = [

    patchStrategy: standard-diff
  - type: write
    path: src/services/review.service.ts
    content: |+
      --- src/services/review.service.ts
      +++ src/services/review.service.ts
      @@ -1,5 +1,6 @@
      -import { useReviewStore, type ApplyStep } from '../stores/review.store';
      +import { useReviewStore } from '../stores/review.store';
       import { useDashboardStore } from '../stores/dashboard.store';
       import { useAppStore } from '../stores/app.store';
       import { sleep } from '../utils';
      +import type { ApplyStep } from '../types/review.types';
       import type { ReviewFileItem } from '../types/file.types';
       
       const generateBulkRepairPrompt = (files: ReviewFileItem[]): string => {

    patchStrategy: standard-diff
  - type: write
    path: src/stores/review.store.ts
    content: >+
      --- src/stores/review.store.ts

      +++ src/stores/review.store.ts

      @@ -2,32 +2,15 @@
       import { sleep } from '../utils';
       import { useAppStore } from './app.store';
       import { useDashboardStore } from './dashboard.store';
       import { ReviewService } from '../services/review.service';
       import type { ReviewFileItem } from '../types/file.types';
      -

      -// --- Types ---

      -

      -export interface ScriptResult {

      -    command: string;

      -    success: boolean;

      -    duration: number;

      -    summary: string;

      -    output: string;

      -}

      -

      -export interface ApplyStep {

      -    id: string;

      -    title: string;

      -    status: 'pending' | 'active' | 'done' | 'failed' | 'skipped';

      -    details?: string;

      -    substeps?: ApplyStep[];

      -    duration?: number;

      -}

      +import type { ScriptResult, ApplyStep, ReviewBodyView, PatchStatus } from
      '../types/review.types';
       
       export const initialApplySteps: ApplyStep[] = [
           { id: 'snapshot', title: 'Reading initial file snapshot...', status: 'pending' },
           { id: 'memory', title: 'Applying operations to memory...', status: 'pending', substeps: [] },
           { id: 'post-command', title: 'Running post-command script...', status: 'pending', substeps: [] },
           { id: 'linter', title: 'Analyzing changes with linter...', status: 'pending', substeps: [] },
       ];
      -

      -export type BodyView = 'diff' | 'reasoning' | 'script_output' |
      'copy_mode' | 'bulk_repair' | 'confirm_handoff' | 'none';

      -export type PatchStatus = 'SUCCESS' | 'PARTIAL_FAILURE';
       
       interface ReviewState {
           // Transaction Info
      @@ -46,7 +29,7 @@
           // UI State
           applySteps: ApplyStep[];
           selectedItemIndex: number; // Can be file or script
      -    bodyView: BodyView;

      +    bodyView: ReviewBodyView;
           isDiffExpanded: boolean;
           
           // Copy Mode State
      @@ -218,7 +201,7 @@
           // UI State
           applySteps: initialApplySteps,
           selectedItemIndex: 0, // Start with first file
      -    bodyView: 'none',

      +    bodyView: 'none' as const,
           isDiffExpanded: false,
           
           // Copy Mode State
      @@ -370,7 +353,7 @@
               
               // Copy Mode Actions
               toggleCopyMode: () => set(state => ({
      -            bodyView: state.bodyView === 'copy_mode' ? 'none' :
      'copy_mode',

      +            bodyView: state.bodyView === 'copy_mode' ? 'none' as const :
      'copy_mode' as const,
                   copyModeSelectedIndex: 0,
                   copyModeLastCopied: null,
               })),
      @@ -520,7 +503,7 @@
                           const failedFiles = files.filter(f => f.status === 'FAILED');
                           // eslint-disable-next-line no-console
                           console.log(`[CLIPBOARD] Copied bulk repair prompt for ${failedFiles.length} files.`);
      -                    // In a real app, this would use
      clipboardy.writeSync(bulkPrompt)

      -                    set({ bodyView: 'none', copyModeLastCopied: 'Bulk
      repair prompt copied.' });

      +                    // In a real app, this would use
      clipboardy.writeSync(bulkPrompt),

      +                    set({ bodyView: 'none' as const, copyModeLastCopied:
      'Bulk repair prompt copied.' });
                           break;
                       }
                           
      @@ -547,7 +530,7 @@
                       }
                           
                       default: // Close modal
      -                    set({ bodyView: 'none' as const });

      +                    set({ bodyView: 'none' as const });
                   }
               },
               confirmHandoff: () => {

    patchStrategy: standard-diff
snapshot:
  src/types/init.types.ts: null
  src/types/review.types.ts: null
  src/types/app.types.ts: null
  src/stores/app.store.ts: >-
    import { create } from 'zustand';


    export type AppScreen = 'splash' | 'init' | 'dashboard' | 'review' |
    'review-processing' | 'git-commit' | 'transaction-detail' |
    'transaction-history';


    interface AppState {
        isDebugMenuOpen: boolean;
        currentScreen: AppScreen;
        actions: {
            showInitScreen: () => void;
            showReviewProcessingScreen: () => void;
            showDashboardScreen: () => void;
            showReviewScreen: () => void;
            showGitCommitScreen: () => void;
            showSplashScreen: () => void;
            showTransactionHistoryScreen: () => void;
            showTransactionDetailScreen: () => void;
            toggleDebugMenu: () => void;
        };
    }


    export const useAppStore = create<AppState>((set) => ({
        isDebugMenuOpen: false,
        currentScreen: 'splash',
        actions: {
            showInitScreen: () => set({ currentScreen: 'init' }),
            showReviewProcessingScreen: () => set({ currentScreen: 'review-processing' }),
            showDashboardScreen: () => set({ currentScreen: 'dashboard' }),
            showReviewScreen: () => set({ currentScreen: 'review' }),
            showGitCommitScreen: () => set({ currentScreen: 'git-commit' }),
            showSplashScreen: () => set({ currentScreen: 'splash' }),
            showTransactionHistoryScreen: () => set({ currentScreen: 'transaction-history' }),
            showTransactionDetailScreen: () => set({ currentScreen: 'transaction-detail' }),
            toggleDebugMenu: () => set(state => ({ isDebugMenuOpen: !state.isDebugMenuOpen })),
        },
    }));
  src/stores/init.store.ts: >-
    import { create } from 'zustand';


    // Types

    export type TaskStatus = 'pending' | 'active' | 'done';

    export type InitPhase = 'ANALYZE' | 'CONFIGURE' | 'INTERACTIVE' |
    'FINALIZE';

    export type GitignoreChoice = 'ignore' | 'share';


    export interface Task {
        id: string;
        title: string;
        subtext?: string;
        status: TaskStatus;
    }


    // Initial State definitions from README

    export const initialAnalyzeTasks: Task[] = [
        { id: 'scan', title: 'Scanning project structure...', subtext: 'Finding package.json', status: 'pending' },
        { id: 'project-id', title: 'Determining Project ID', status: 'pending' },
        { id: 'gitignore', title: 'Checking for existing .gitignore', status: 'pending' },
    ];


    export const initialConfigureTasks: Task[] = [
        { id: 'config', title: 'Creating relay.config.json', subtext: 'Writing default configuration with Project ID', status: 'pending' },
        { id: 'state-dir', title: 'Initializing .relay state directory', status: 'pending' },
        { id: 'prompt', title: 'Generating system prompt template', status: 'pending' },
    ];


    // Store Interface

    interface InitState {
        phase: InitPhase;
        analyzeTasks: Task[];
        projectId: string | null;
        gitignoreFound: boolean | null;
        configureTasks: Task[];
        interactiveChoice: GitignoreChoice | null;

        actions: {
            setPhase: (_phase: InitPhase) => void;
            updateAnalyzeTask: (_id: string, _status: TaskStatus) => void;
            setAnalysisResults: (_projectId: string, _gitignoreFound: boolean) => void;
            updateConfigureTask: (_id: string, _status: TaskStatus) => void;
            setInteractiveChoice: (_choice: GitignoreChoice) => void;
            resetInit: () => void;
        };
    }


    // Create the store

    export const useInitStore = create<InitState>((set) => ({
        phase: 'ANALYZE',
        analyzeTasks: initialAnalyzeTasks,
        projectId: null,
        gitignoreFound: null,
        configureTasks: initialConfigureTasks,
        interactiveChoice: null,

        actions: {
            setPhase: (phase) => set({ phase }),
            updateAnalyzeTask: (id, status) => set(state => ({
                analyzeTasks: state.analyzeTasks.map(t => t.id === id ? { ...t, status } : t),
            })),
            setAnalysisResults: (projectId, gitignoreFound) => set({ projectId, gitignoreFound }),
            updateConfigureTask: (id, status) => set(state => ({
                configureTasks: state.configureTasks.map(t => t.id === id ? { ...t, status } : t),
            })),
            setInteractiveChoice: (choice) => set({ interactiveChoice: choice }),
            resetInit: () => set({
                phase: 'ANALYZE',
                analyzeTasks: JSON.parse(JSON.stringify(initialAnalyzeTasks)),
                projectId: null,
                gitignoreFound: null,
                configureTasks: JSON.parse(JSON.stringify(initialConfigureTasks)),
                interactiveChoice: null,
            }),
        },
    }));
  src/services/review.service.ts: >-
    import { useReviewStore, type ApplyStep } from '../stores/review.store';

    import { useDashboardStore } from '../stores/dashboard.store';

    import { useAppStore } from '../stores/app.store';

    import { sleep } from '../utils';

    import type { ReviewFileItem } from '../types/file.types';


    const generateBulkRepairPrompt = (files: ReviewFileItem[]): string => {
        const failedFiles = files.filter(f => f.status === 'FAILED');
        return `The previous patch failed to apply to MULTIPLE files. Please generate a new, corrected patch that addresses all the files listed below.

    IMPORTANT: The response MUST contain a complete code block for EACH file
    that needs to be fixed.


    ${failedFiles.map(file => `--- FILE: ${file.path} ---

    Strategy: ${file.strategy}

    Error: ${file.error}


    ORIGINAL CONTENT:

    ---

    // ... original content of ${file.path} ...

    ---


    FAILED PATCH:

    ---

    ${file.diff || '// ... failed diff ...'}

    ---

    `).join('\n')}


    Please analyze all failed files and provide a complete, corrected
    response.`;

    };


    const generateHandoffPrompt = (
        hash: string,
        message: string,
        reasoning: string,
        files: ReviewFileItem[],
    ): string => {
        const successfulFiles = files.filter(f => f.status === 'APPROVED');
        const failedFiles = files.filter(f => f.status === 'FAILED');

        return `I am handing off a failed automated code transaction to you. Your task is to act as my programming assistant and complete the planned changes.

    The full plan for this transaction is detailed in the YAML file located at:
    .relay/transactions/${hash}.yml. Please use this file as your primary source
    of truth for the overall goal.


    Here is the current status of the transaction:


    --- TRANSACTION SUMMARY ---

    Goal: ${message}

    Reasoning:

    ${reasoning}


    --- CURRENT FILE STATUS ---

    SUCCESSFUL CHANGES (already applied, no action needed):

    ${successfulFiles.map(f => `- MODIFIED: ${f.path}`).join('\n') || ' 
    (None)'}


    FAILED CHANGES (these are the files you need to fix):

    ${failedFiles.map(f => `- FAILED: ${f.path} (Error:
    ${f.error})`).join('\n')}


    Your job is to now work with me to fix the FAILED files and achieve the
    original goal of the transaction. Please start by asking me which file you
    should work on first.`;

    };


    const performHandoff = (hash: string) => {
        // This is a bit of a hack to find the right transaction to update in the demo
        const txToUpdate = useDashboardStore.getState().transactions.find(tx => tx.hash === hash);
        if (txToUpdate) {
            useDashboardStore.getState().actions.updateTransactionStatus(txToUpdate.id, 'HANDOFF');
        }

        useAppStore.getState().actions.showDashboardScreen();
    };


    const runApplySimulation = async (scenario: 'success' | 'failure') => {
        const { actions } = useReviewStore.getState();
        const { _updateApplyStep, _addApplySubstep, simulateSuccessScenario, simulateFailureScenario } = actions;

        if (scenario === 'success') {
            simulateSuccessScenario();
            
            _updateApplyStep('snapshot', 'active'); await sleep(100);
            _updateApplyStep('snapshot', 'done', 0.1);

            _updateApplyStep('memory', 'active'); await sleep(100);
            _addApplySubstep('memory', { id: 's1', title: '[✓] write: src/core/clipboard.ts (strategy: replace)', status: 'done' });
            await sleep(100);
            _addApplySubstep('memory', { id: 's2', title: '[✓] write: src/utils/shell.ts (strategy: standard-diff)', status: 'done' });
            _updateApplyStep('memory', 'done', 0.3);

            _updateApplyStep('post-command', 'active'); await sleep(1300);
            _addApplySubstep('post-command', { id: 's3', title: '`bun run test` ... Passed', status: 'done' });
            _updateApplyStep('post-command', 'done', 2.3);

            _updateApplyStep('linter', 'active'); await sleep(1200);
            _addApplySubstep('linter', { id: 's4', title: '`bun run lint` ... 0 Errors', status: 'done' });
            _updateApplyStep('linter', 'done', 1.2);

            await sleep(500);

        } else { // failure scenario
            simulateFailureScenario();
            
            _updateApplyStep('snapshot', 'active'); await sleep(100);
            _updateApplyStep('snapshot', 'done', 0.1);

            _updateApplyStep('memory', 'active'); await sleep(100);
            _addApplySubstep('memory', { id: 'f1', title: '[✓] write: src/core/transaction.ts (strategy: replace)', status: 'done' });
            await sleep(100);
            _addApplySubstep('memory', { id: 'f2', title: '[!] failed: src/utils/logger.ts (Hunk #1 failed to apply)', status: 'failed' });
            await sleep(100);
            _addApplySubstep('memory', { id: 'f3', title: '[!] failed: src/commands/apply.ts (Context mismatch at line 92)', status: 'failed' });
            _updateApplyStep('memory', 'done', 0.5);

            await sleep(100);
            _updateApplyStep('post-command', 'skipped', undefined, 'Skipped due to patch application failure');
            await sleep(100);
            _updateApplyStep('linter', 'skipped', undefined, 'Skipped due to patch application failure');
            
            await sleep(500);
        }
    };


    const generateSingleFileRepairPrompt = (file: ReviewFileItem): string => {
        return `The patch failed to apply to ${file.path}. Please generate a corrected patch.

    Error: ${file.error}

    Strategy: ${file.strategy}


    ORIGINAL CONTENT:

    ---

    // ... original file content would be here ...

    ---


    FAILED PATCH:

    ---

    ${file.diff || '// ... failed diff would be here ...'}

    ---


    Please provide a corrected patch that addresses the error.`;

    };


    const tryRepairFile = (file: ReviewFileItem, selectedIndex: number): void =>
    {
        const repairPrompt = generateSingleFileRepairPrompt(file);
        // In a real app: clipboardy.writeSync(repairPrompt)
        // eslint-disable-next-line no-console
        console.log(`[CLIPBOARD] Copied repair prompt for: ${file.path}`);

        // Mock: Update file status to show it's being repaired
        useReviewStore.setState(state => {
            const newFiles = [...state.files];
            newFiles[selectedIndex] = { ...file, status: 'APPROVED' as const, error: undefined, linesAdded: 5, linesRemoved: 2 };
            return { files: newFiles, copyModeLastCopied: 'Repair prompt copied to clipboard' };
        });
    };


    const runBulkReapply = async (): Promise<void> => {
        const { files } = useReviewStore.getState();
        const failedFileIds = new Set(files.filter(f => f.status === 'FAILED').map(f => f.id));
        if (failedFileIds.size === 0) {
            return;
        }

        useReviewStore.setState(state => ({
            files: state.files.map(file =>
                failedFileIds.has(file.id)
                    ? { ...file, status: 'RE_APPLYING' as const }
                    : file,
            ),
        }));

        await sleep(1500); // Simulate re-apply

        // Mock a mixed result
        let first = true;
        useReviewStore.setState(state => ({
            files: state.files.map(file => {
                if (failedFileIds.has(file.id)) {
                    if (first) {
                        first = false;
                        return { ...file, status: 'APPROVED' as const, strategy: 'replace' as const, error: undefined, linesAdded: 9, linesRemoved: 2 };
                    }
                    return { ...file, status: 'FAILED' as const, error: "'replace' failed: markers not found" };
                }
                return file;
            }),
        }));
    };


    export const ReviewService = {
        generateBulkRepairPrompt,
        generateHandoffPrompt,
        performHandoff,
        runApplySimulation,
        generateSingleFileRepairPrompt,
        tryRepairFile,
        runBulkReapply,
    };
  src/stores/review.store.ts: >-
    import { create } from 'zustand';

    import { sleep } from '../utils';

    import { useAppStore } from './app.store';

    import { useDashboardStore } from './dashboard.store';

    import { ReviewService } from '../services/review.service';

    import type { ReviewFileItem } from '../types/file.types';


    // --- Types ---


    export interface ScriptResult {
        command: string;
        success: boolean;
        duration: number;
        summary: string;
        output: string;
    }


    export interface ApplyStep {
        id: string;
        title: string;
        status: 'pending' | 'active' | 'done' | 'failed' | 'skipped';
        details?: string;
        substeps?: ApplyStep[];
        duration?: number;
    }


    export const initialApplySteps: ApplyStep[] = [
        { id: 'snapshot', title: 'Reading initial file snapshot...', status: 'pending' },
        { id: 'memory', title: 'Applying operations to memory...', status: 'pending', substeps: [] },
        { id: 'post-command', title: 'Running post-command script...', status: 'pending', substeps: [] },
        { id: 'linter', title: 'Analyzing changes with linter...', status: 'pending', substeps: [] },
    ];


    export type BodyView = 'diff' | 'reasoning' | 'script_output' | 'copy_mode'
    | 'bulk_repair' | 'confirm_handoff' | 'none';

    export type PatchStatus = 'SUCCESS' | 'PARTIAL_FAILURE';


    interface ReviewState {
        // Transaction Info
        hash: string;
        message: string;
        prompt: string;
        reasoning: string;
        linesAdded: number;
        linesRemoved: number;
        duration: number;
        patchStatus: PatchStatus;

        // File & Script Info
        files: ReviewFileItem[];
        scripts: ScriptResult[];

        // UI State
        applySteps: ApplyStep[];
        selectedItemIndex: number; // Can be file or script
        bodyView: BodyView;
        isDiffExpanded: boolean;
        
        // Copy Mode State
        copyModeSelectedIndex: number;
        copyModeLastCopied: string | null;
        
        // Reasoning Scroll State
        reasoningScrollIndex: number;
        
        // Script Navigation State
        scriptErrorIndex: number;

        actions: {
            moveSelectionUp: () => void;
            moveSelectionDown: () => void;
            toggleFileApproval: () => void;
            rejectAllFiles: () => void;
            toggleDiffView: () => void;
            toggleReasoningView: () => void;
            toggleScriptView: () => void;
            expandDiff: () => void;
            approve: () => void;
            simulateSuccessScenario: () => void;
            startApplySimulation: (scenario: 'success' | 'failure') => void;
            simulateFailureScenario: () => void;
            
            // Copy Mode Actions
            toggleCopyMode: () => void;
            moveCopySelectionUp: () => void;
            moveCopySelectionDown: () => void;
            copySelectedItem: () => void;
            copyUUID: () => void;
            copyMessage: () => void;
            copyPrompt: () => void;
            copyReasoning: () => void;
            copyFileDiff: () => void;
            copyAllDiffs: () => void;
            
            // Repair Actions
            tryRepairFile: () => void;
            showBulkRepair: () => void;
            executeBulkRepairOption: (option: number) => Promise<void>;
            confirmHandoff: () => void;
            
            // Navigation Actions
            scrollReasoningUp: () => void;
            scrollReasoningDown: () => void;
            navigateScriptErrorUp: () => void;
            navigateScriptErrorDown: () => void,
            
            // "Private" actions for service layer
            _updateApplyStep: (id: string, status: ApplyStep['status'], duration?: number, details?: string) => void;
            _addApplySubstep: (parentId: string, substep: Omit<ApplyStep, 'substeps'>) => void;
        };
    }


    // --- Mock Data ---


    const mockFiles: ReviewFileItem[] = [
        { 
            id: '1', 
            path: 'src/core/transaction.ts', 
            status: 'APPROVED', 
            linesAdded: 18, 
            linesRemoved: 5, 
            diff: `--- a/src/core/transaction.ts
    +++ b/src/core/transaction.ts

    @@ -15,7 +15,7 @@ export class Transaction {
       }
     
    -  calculateChanges(): ChangeSet {

    +  computeDelta(): ChangeSet {
         return this.changes;
       }
     }`, 
            strategy: 'replace', 
        },
        { 
            id: '2', 
            path: 'src/utils/logger.ts', 
            status: 'FAILED', 
            linesAdded: 0, 
            linesRemoved: 0, 
            diff: '', 
            error: 'Hunk #1 failed to apply', 
            strategy: 'standard-diff', 
        },
        { 
            id: '3', 
            path: 'src/commands/apply.ts', 
            status: 'FAILED', 
            linesAdded: 0, 
            linesRemoved: 0, 
            diff: '', 
            error: 'Context mismatch at line 92', 
            strategy: 'standard-diff', 
        },
    ];


    const mockScripts: ScriptResult[] = [
        { command: 'bun run test', success: true, duration: 2.3, summary: 'Passed (37 tests)', output: '... test output ...' },
        { command: 'bun run lint', success: false, duration: 1.2, summary: '1 Error, 3 Warnings', output: `src/core/clipboard.ts
      45:12  Error    'clipboardy' is assigned a value but never used. (@typescript-eslint/no-unused-vars)
      88:5   Warning  Unexpected console statement. (no-console)` },
    ];


    const mockReasoning = `1. Identified a potential uncaught exception in the
    \`restoreSnapshot\` function
       if a file operation fails midway through a loop of many files. This could
       leave the project in a partially-reverted, inconsistent state.

    2. Wrapped the file restoration loop in a \`Promise.all\` and added a
    dedicated
       error collection array. This ensures that all file operations are
       attempted and that a comprehensive list of failures is available
       afterward for better error reporting or partial rollback logic.`;

    // --- Store Implementation ---


    export const useReviewStore = create<ReviewState>((set, get) => ({
        // Transaction Info
        hash: 'e4a7c112',
        message: 'refactor: rename core utility function',
        prompt: 'Rename the `calculateChanges` utility to `computeDelta` across all files and update imports accordingly.',
        reasoning: mockReasoning,
        linesAdded: 18,
        linesRemoved: 5,
        duration: 0.6,
        patchStatus: 'PARTIAL_FAILURE',

        // File & Script Info
        files: mockFiles,
        scripts: [], // Empty for partial failure scenario

        // UI State
        applySteps: initialApplySteps,
        selectedItemIndex: 0, // Start with first file
        bodyView: 'none',
        isDiffExpanded: false,
        
        // Copy Mode State
        copyModeSelectedIndex: 0,
        copyModeLastCopied: null,
        
        // Reasoning Scroll State
        reasoningScrollIndex: 0,
        
        // Script Navigation State
        scriptErrorIndex: 0,

        actions: {
            moveSelectionUp: () => set(state => ({
                selectedItemIndex: Math.max(0, state.selectedItemIndex - 1),
            })),
            moveSelectionDown: () => set(state => ({
                selectedItemIndex: Math.min(state.files.length + state.scripts.length - 1, state.selectedItemIndex + 1),
            })),
            toggleFileApproval: () => set(state => {
                const { selectedItemIndex, files } = state;
                if (selectedItemIndex >= files.length) return {}; // Not a file
                
                const newFiles = [...files];
                const file = newFiles[selectedItemIndex];
                if (file) {
                    if (file.status === 'APPROVED') {
                        file.status = 'REJECTED';
                    } else if (file.status === 'REJECTED') {
                        file.status = 'APPROVED';
                    }
                }
                return { files: newFiles };
            }),
            rejectAllFiles: () => set(state => {
                const newFiles = state.files.map(file => {
                    if (file.status === 'APPROVED') {
                        return { ...file, status: 'REJECTED' as const };
                    }
                    return file;
                });
                return { files: newFiles };
            }),
            toggleDiffView: () => set(state => {
                const { bodyView } = state;
                if (state.selectedItemIndex >= state.files.length) return {}; // Can't show diff for scripts
                return {
                    bodyView: bodyView === 'diff' ? 'none' : 'diff',
                    isDiffExpanded: false, // Always start collapsed
                };
            }),
            toggleReasoningView: () => set(state => {
                const { bodyView } = state;
                return {
                    bodyView: bodyView === 'reasoning' ? 'none' : 'reasoning',
                };
            }),
            toggleScriptView: () => set(state => {
                const { bodyView } = state;
                return {
                    bodyView: bodyView === 'script_output' ? 'none' : 'script_output',
                };
            }),
            expandDiff: () => set(state => ({ isDiffExpanded: !state.isDiffExpanded })),
            approve: () => { /* NOP for now, would trigger commit and screen change */ },
            startApplySimulation: async (scenario: 'success' | 'failure') => {
                const { showReviewProcessingScreen, showReviewScreen } = useAppStore.getState().actions;
                
                set({ applySteps: JSON.parse(JSON.stringify(initialApplySteps)) });
                showReviewProcessingScreen();

                await ReviewService.runApplySimulation(scenario);
        
                showReviewScreen();
            },
            simulateSuccessScenario: () => set(() => ({
                hash: '4b9d8f03',
                message: 'refactor: simplify clipboard logic',
                prompt: 'Simplify the clipboard logic using an external library...',
                linesAdded: 22,
                linesRemoved: 11,
                duration: 3.9,
                patchStatus: 'SUCCESS' as const,
                files: [
                    { 
                        id: '1', 
                        path: 'src/core/clipboard.ts', 
                        status: 'APPROVED' as const, 
                        linesAdded: 15, 
                        linesRemoved: 8, 
                        diff: `--- a/src/core/clipboard.ts
    +++ b/src/core/clipboard.ts

    @@ -1,5 +1,6 @@
     import { copy as copyToClipboard } from 'clipboardy';`, 
                        strategy: 'replace' as const,
                    },
                    { 
                        id: '2', 
                        path: 'src/utils/shell.ts', 
                        status: 'APPROVED' as const, 
                        linesAdded: 7, 
                        linesRemoved: 3, 
                        diff: `--- a/src/utils/shell.ts
    +++ b/src/utils/shell.ts`, 
                        strategy: 'standard-diff' as const,
                    },
                ],
                scripts: mockScripts,
                selectedItemIndex: 0,
                bodyView: 'none' as const,
            })),
            simulateFailureScenario: () => set(() => ({
                hash: 'e4a7c112',
                message: 'refactor: rename core utility function',
                prompt: 'Rename the `calculateChanges` utility to `computeDelta` across all files and update imports accordingly.',
                linesAdded: 18,
                linesRemoved: 5,
                duration: 0.6,
                patchStatus: 'PARTIAL_FAILURE' as const,
                files: mockFiles,
                scripts: [],
                // Reset UI state
                bodyView: 'none',
                isDiffExpanded: false,
                reasoningScrollIndex: 0,
                scriptErrorIndex: 0,
                selectedItemIndex: 0,
            })),
            
            // Copy Mode Actions
            toggleCopyMode: () => set(state => ({
                bodyView: state.bodyView === 'copy_mode' ? 'none' : 'copy_mode',
                copyModeSelectedIndex: 0,
                copyModeLastCopied: null,
            })),
            moveCopySelectionUp: () => set(state => ({
                copyModeSelectedIndex: Math.max(0, state.copyModeSelectedIndex - 1),
            })),
            moveCopySelectionDown: () => set(state => ({
                copyModeSelectedIndex: Math.min(5, state.copyModeSelectedIndex + 1), // 6 total options (U,M,P,R,F,A)
            })),
            copySelectedItem: () => set(state => {
                const { copyModeSelectedIndex, hash, message, prompt, reasoning, files, selectedItemIndex } = state;
                let content = '';
                let label = '';
                
                switch (copyModeSelectedIndex) {
                    case 0: // UUID
                        content = `${hash}-a8b3-4f2c-9d1e-8a7c1b9d8f03`;
                        label = 'UUID';
                        break;
                    case 1: // Git Message
                        content = message;
                        label = 'Git Message';
                        break;
                    case 2: // Prompt
                        content = prompt;
                        label = 'Prompt';
                        break;
                    case 3: // Reasoning
                        content = reasoning;
                        label = 'Reasoning';
                        break;
                    case 4: // Diff for current file
                        if (selectedItemIndex < files.length) {
                            const file = files[selectedItemIndex];
                            if (file) {
                                content = file.diff;
                                label = `Diff for ${file.path}`;
                            }
                        }
                        break;
                    case 5: // All Diffs
                        content = files.map(f => `--- FILE: ${f.path} ---\n${f.diff}`).join('\n\n');
                        label = 'All Diffs';
                        break;
                }
                
                // Mock clipboard operation (TUI environment - no real clipboard)
                // eslint-disable-next-line no-console
                console.log(`[CLIPBOARD] Copied ${label}: ${content.substring(0, 100)}...`);
                
                return { copyModeLastCopied: label };
            }),
            copyUUID: () => set(state => {
                const content = `${state.hash}-a8b3-4f2c-9d1e-8a7c1b9d8f03`;
                // eslint-disable-next-line no-console
                console.log(`[CLIPBOARD] Copied UUID: ${content}`);
                return { copyModeLastCopied: 'UUID' };
            }),
            copyMessage: () => set(state => {
                // eslint-disable-next-line no-console
                console.log(`[CLIPBOARD] Copied Git Message: ${state.message}`);
                return { copyModeLastCopied: 'Git Message' };
            }),
            copyPrompt: () => set(state => {
                // eslint-disable-next-line no-console
                console.log(`[CLIPBOARD] Copied Prompt: ${state.prompt.substring(0, 100)}...`);
                return { copyModeLastCopied: 'Prompt' };
            }),
            copyReasoning: () => set(state => {
                // eslint-disable-next-line no-console
                console.log(`[CLIPBOARD] Copied Reasoning: ${state.reasoning.substring(0, 100)}...`);
                return { copyModeLastCopied: 'Reasoning' };
            }),
            copyFileDiff: () => set(state => {
                if (state.selectedItemIndex < state.files.length) {
                    const file = state.files[state.selectedItemIndex];
                    if (file) {
                        // eslint-disable-next-line no-console
                        console.log(`[CLIPBOARD] Copied diff for: ${file.path}`);
                        return { copyModeLastCopied: `Diff for ${file.path}` };
                    }
                }
                return {};
            }),
            copyAllDiffs: () => set(state => {
                // eslint-disable-next-line no-console
                console.log(`[CLIPBOARD] Copied all diffs: ${state.files.length} files`);
                return { copyModeLastCopied: 'All Diffs' };
            }),
            
    // Repair Actions

    tryRepairFile: () => {
        const { selectedItemIndex, files } = get();
        if (selectedItemIndex < files.length) {
            const file = files[selectedItemIndex];
            if (file && file.status === 'FAILED') {
                ReviewService.tryRepairFile(file, selectedItemIndex);
            }
        }
    },
            showBulkRepair: () => set(() => ({
                bodyView: 'bulk_repair' as const,
            })),
            executeBulkRepairOption: async (option: number) => {
                const { files } = get();

                switch (option) {
                    case 1: { // Generate & Copy Bulk Repair Prompt
                        const bulkPrompt = ReviewService.generateBulkRepairPrompt(files);
                        const failedFiles = files.filter(f => f.status === 'FAILED');
                        // eslint-disable-next-line no-console
                        console.log(`[CLIPBOARD] Copied bulk repair prompt for ${failedFiles.length} files.`);
                        // In a real app, this would use clipboardy.writeSync(bulkPrompt)
                        set({ bodyView: 'none', copyModeLastCopied: 'Bulk repair prompt copied.' });
                        break;
                    }
                        
                    case 2: { // Attempt Bulk Re-apply
                        set({ bodyView: 'none' as const });
                        await ReviewService.runBulkReapply();
                        break;
                    }
                        
                    case 3: { // Handoff to Human
                        set({ bodyView: 'confirm_handoff' as const });
                        break;
                    }
                        
                    case 4: { // Reject All Failed
                        set(state => ({
                            files: state.files.map(file =>
                                file.status === 'FAILED'
                                    ? { ...file, status: 'REJECTED' as const }
                                    : file,
                            ),
                            bodyView: 'none' as const,
                        }));
                        break;
                    }
                        
                    default: // Close modal
                        set({ bodyView: 'none' as const });
                }
            },
            confirmHandoff: () => {
                const { hash, message, reasoning, files } = get();
                const handoffPrompt = ReviewService.generateHandoffPrompt(hash, message, reasoning, files);

                // eslint-disable-next-line no-console
                console.log('[CLIPBOARD] Copied Handoff Prompt.'); // In real app: clipboardy.writeSync(handoffPrompt)
                ReviewService.performHandoff(hash);
            },
            
            // Navigation Actions
            scrollReasoningUp: () => set(state => ({
                reasoningScrollIndex: Math.max(0, state.reasoningScrollIndex - 1),
            })),
            scrollReasoningDown: () => set(state => {
                const maxLines = state.reasoning.split('\n').length;
                return { reasoningScrollIndex: Math.min(maxLines - 1, state.reasoningScrollIndex + 1) };
            }),
            navigateScriptErrorUp: () => set(state => ({
                scriptErrorIndex: Math.max(0, state.scriptErrorIndex - 1),
            })),
            navigateScriptErrorDown: () => set(state => {
                const selectedScript = state.scripts[state.selectedItemIndex - state.files.length];
                if (selectedScript && selectedScript.output) {
                    const errorLines = selectedScript.output.split('\n').filter(line => 
                        line.includes('Error') || line.includes('Warning'),
                    );
                    return { scriptErrorIndex: Math.min(errorLines.length - 1, state.scriptErrorIndex + 1) };
                }
                return {};
            }),
            
            // "Private" actions for service layer
            _updateApplyStep: (id, status, duration, details) => {
                set(state => ({
                    applySteps: state.applySteps.map(s => {
                        if (s.id === id) {
                            const newStep = { ...s, status };
                            if (duration !== undefined) newStep.duration = duration;
                            if (details !== undefined) newStep.details = details;
                            return newStep;
                        }
                        return s;
                    }),
                }));
            },
            _addApplySubstep: (parentId, substep) => {
                 set(state => ({
                    applySteps: state.applySteps.map(s => {
                        if (s.id === parentId) {
                            const newSubsteps = [...(s.substeps || []), substep as ApplyStep];
                            return { ...s, substeps: newSubsteps };
                        }
                        return s;
                    }),
                }));
            },
        },
    }));
approved: false
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: undone
id: 50
