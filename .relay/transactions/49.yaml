uuid: c2d3b2c1-d40b-4171-aa3a-44e292a40673
projectId: relaycode-tui
createdAt: '2025-09-22T06:55:42.779Z'
gitCommitMsg: >-
  refactor: extract transaction and file types into dedicated files

  This commit introduces a `src/types` directory to centralize domain-specific
  type definitions, improving code organization and adherence to the DRY
  principle.

  - Created `src/types/transaction.types.ts` to house all transaction-related
  types (`Transaction`, `HistoryTransaction`, `TransactionStatus`). - Created
  `src/types/file.types.ts` for file-related types (`FileChange`,
  `ReviewFileItem`). - Refactored all Zustand stores and services to import
  these shared types from their new centralized location, removing redundant
  local type definitions. - Standardized transaction status strings in mock data
  to be uppercase for consistency with the unified types.
promptSummary: >-
  Extract all entity types to `types/[entity].type.ts` files and update imports
  to improve code organization and remove duplication, starting with transaction
  and file types.
reasoning:
  - >-
    As an expert AI programmer, I've analyzed your request to refactor the
    codebase by extracting types into dedicated files to improve organization
    and adhere to the DRY principle. This is the first phase of the refactoring,
    focusing on the core entities: `Transaction` and `File`.
  - '### Phase 1: Extracting Transaction and File Types'
  - >-
    1.  **Created `src/types` Directory**: I've created a new `src/types`
    directory to house all shared type definitions.
  - '2.  **New Type Files**:'
  - >-
    *   `src/types/file.types.ts`: This file now contains all type definitions
    related to file changes and their status within different contexts (e.g.,
    `FileChange`, `ReviewFileItem`).
  - >-
    *   `src/types/transaction.types.ts`: This file centralizes types for
    transactions, including the live `Transaction` on the dashboard and the more
    detailed `HistoryTransaction`. I've also unified the transaction status
    types into a single source of truth.
  - >-
    3.  **Refactored Stores**: All Zustand stores (`dashboard.store.ts`,
    `review.store.ts`, `transaction-history.store.ts`, etc.) have been updated
    to remove their local type definitions and instead import them from the new
    central type files.
  - >-
    4.  **Refactored Services**: The services that depended on types from the
    stores (`commit.service.ts`, `review.service.ts`, `transaction.service.ts`)
    are now updated to import directly from the new type files. This decouples
    them from the store's internal structure.
  - >-
    5.  **Standardized Data**: During the refactoring, I noticed the transaction
    statuses in the mock data used inconsistent casing. I have standardized them
    to be uppercase (`'COMMITTED'`, `'HANDOFF'`, `'REVERTED'`) to match the
    unified `TransactionStatus` type.
  - >-
    This first phase establishes a scalable pattern for managing types across
    the application.
  - 'Here are the code changes:'
  - >-
    I will start by creating the new directory `src/types` and the type
    definition files.
  - >-
    Next, I will update the existing stores and services to use these new
    centralized types.
operations:
  - type: write
    path: src/types/file.types.ts
    content: >-
      // From transaction-detail.store.ts and transaction-history.store.ts

      export type FileChangeType = 'MOD' | 'ADD' | 'DEL' | 'REN';

      export interface FileChange {
          id: string;
          path: string;
          type: FileChangeType;
          diff: string;
          linesAdded: number;
          linesRemoved: number;
      }


      // From review.store.ts

      export type FileReviewStatus = 'FAILED' | 'APPROVED' | 'REJECTED' |
      'AWAITING' | 'RE_APPLYING';

      export interface ReviewFileItem {
          id: string;
          path: string;
          status: FileReviewStatus;
          diff: string;
          linesAdded: number;
          linesRemoved: number;
          error?: string;
          strategy: 'replace' | 'standard-diff';
      }
    patchStrategy: replace
  - type: write
    path: src/types/transaction.types.ts
    content: >-
      import type { FileChange } from './file.types';


      export type TransactionStatus = 'PENDING' | 'APPLIED' | 'COMMITTED' |
      'FAILED' | 'REVERTED' | 'IN-PROGRESS' | 'HANDOFF';

      export type HistoryTransactionStatus = 'COMMITTED' | 'HANDOFF' |
      'REVERTED';


      export interface Transaction {
          id: string;
          timestamp: number;
          status: TransactionStatus;
          hash: string;
          message: string;
          error?: string;
      }


      // From transaction-history.store.ts

      export interface HistoryTransaction {
          id: string;
          hash: string;
          timestamp: number;
          status: HistoryTransactionStatus;
          message: string;
          files: FileChange[];
          stats: {
              files: number;
              linesAdded: number;
              linesRemoved: number;
          };
      }
    patchStrategy: replace
  - type: write
    path: src/services/commit.service.ts
    content: >+
      --- src/services/commit.service.ts

      +++ src/services/commit.service.ts

      @@ -1,4 +1,5 @@

      -import { useDashboardStore, type Transaction } from
      '../stores/dashboard.store';

      +import { useDashboardStore } from '../stores/dashboard.store';

      +import type { Transaction } from '../types/transaction.types';
       import { sleep } from '../utils';
       
       const generateCommitMessage = (transactions: Transaction[]): string => {

    patchStrategy: standard-diff
  - type: write
    path: src/services/review.service.ts
    content: >
      <<<<<<< SEARCH

      import { useReviewStore, type FileItem, type ApplyStep } from
      '../stores/review.store';

      =======

      import { useReviewStore, type ApplyStep } from '../stores/review.store';

      >>>>>>> REPLACE

      <<<<<<< SEARCH

      import { sleep } from '../utils';


      const generateBulkRepairPrompt = (files: FileItem[]): string => {

      =======

      import { sleep } from '../utils';

      import type { ReviewFileItem } from '../types/file.types';


      const generateBulkRepairPrompt = (files: ReviewFileItem[]): string => {

      >>>>>>> REPLACE

      <<<<<<< SEARCH

      const generateHandoffPrompt = (
          hash: string,
          message: string,
          reasoning: string,
          files: FileItem[],
      ): string => {

      =======

      const generateHandoffPrompt = (
          hash: string,
          message: string,
          reasoning: string,
          files: ReviewFileItem[],
      ): string => {

      >>>>>>> REPLACE

      <<<<<<< SEARCH

      const generateSingleFileRepairPrompt = (file: FileItem): string => {

      =======

      const generateSingleFileRepairPrompt = (file: ReviewFileItem): string => {

      >>>>>>> REPLACE

      <<<<<<< SEARCH

      const tryRepairFile = (file: FileItem, selectedIndex: number): void => {

      =======

      const tryRepairFile = (file: ReviewFileItem, selectedIndex: number): void
      => {

      >>>>>>> REPLACE
    patchStrategy: search-replace
  - type: write
    path: src/services/transaction.service.ts
    content: >+
      --- src/services/transaction.service.ts

      +++ src/services/transaction.service.ts

      @@ -1,5 +1,6 @@
       import { useDashboardStore } from '../stores/dashboard.store';
      -import { type HistoryTransaction, type FileChange, type TransactionStatus
      } from '../stores/transaction-history.store';

      +import type { HistoryTransaction, HistoryTransactionStatus } from
      '../types/transaction.types';

      +import type { FileChange } from '../types/file.types';
       
       const revertTransaction = (transactionId: string) => {
           const { updateTransactionStatus } = useDashboardStore.getState().actions;
      @@ -9,7 +10,7 @@
       const createMockTransactions = (): HistoryTransaction[] => {
           const now = Date.now();
           return Array.from({ length: 42 }, (_, i) => {
      -        const status: TransactionStatus = i % 5 === 2 ? 'Handoff' : i % 5
      === 3 ? 'Reverted' : 'Committed';

      +        const status: HistoryTransactionStatus = i % 5 === 2 ? 'HANDOFF'
      : i % 5 === 3 ? 'REVERTED' : 'COMMITTED';
               const files: FileChange[] = [
                   { id: `${i}-1`, path: 'src/core/transaction.ts', type: 'MOD', linesAdded: 25, linesRemoved: 8, diff: '--- a/src/core/transaction.ts\n+++ b/src/core/transaction.ts\n@@ -45,7 +45,9 @@\n-    for (const [filePath, content] of entries) {\n+    const restoreErrors: { path: string, error: unknown }[] = [];\n...\n...\n...\n...\n-    another line removed' },
                   { id: `${i}-2`, path: 'src/utils/logger.ts', type: 'MOD', linesAdded: 10, linesRemoved: 2, diff: 'diff for logger' },

    patchStrategy: standard-diff
  - type: write
    path: src/stores/commit.store.ts
    content: |+
      --- src/stores/commit.store.ts
      +++ src/stores/commit.store.ts
      @@ -1,5 +1,6 @@
       import { create } from 'zustand';
      -import { useDashboardStore, type Transaction } from './dashboard.store';
      +import { useDashboardStore } from './dashboard.store';
      +import type { Transaction } from '../types/transaction.types';
       import { CommitService } from '../services/commit.service';
       
       interface CommitState {

    patchStrategy: standard-diff
  - type: write
    path: src/stores/dashboard.store.ts
    content: >+
      --- src/stores/dashboard.store.ts

      +++ src/stores/dashboard.store.ts

      @@ -1,19 +1,9 @@
       import { create } from 'zustand';
       import { DashboardService } from '../services/dashboard.service';
      +import type { Transaction, TransactionStatus } from
      '../types/transaction.types';
       
       // --- Types ---
      -export type TransactionStatus = 'PENDING' | 'APPLIED' | 'COMMITTED' |
      'FAILED' | 'REVERTED' | 'IN-PROGRESS' | 'HANDOFF';

      -

      -export interface Transaction {

      -    id: string;

      -    timestamp: number;

      -    status: TransactionStatus;

      -    hash: string;

      -    message: string;

      -    error?: string;

      -}

      -
       export type DashboardStatus = 'LISTENING' | 'PAUSED' | 'CONFIRM_APPROVE' | 'APPROVING';
       
       // --- Initial State (for simulation) ---

    patchStrategy: standard-diff
  - type: write
    path: src/stores/review.store.ts
    content: >
      <<<<<<< SEARCH

      import { useDashboardStore } from './dashboard.store';

      import { ReviewService } from '../services/review.service';


      // --- Types ---


      export type FileStatus = 'FAILED' | 'APPROVED' | 'REJECTED' | 'AWAITING' |
      'RE_APPLYING';

      export interface FileItem {
          id: string;
          path: string;
          status: FileStatus;
          diff: string;
          linesAdded: number;
          linesRemoved: number;
          error?: string;
          strategy: 'replace' | 'standard-diff';
      }

      =======

      import { useDashboardStore } from './dashboard.store';

      import { ReviewService } from '../services/review.service';

      import type { ReviewFileItem } from '../types/file.types';


      // --- Types ---

      >>>>>>> REPLACE

      <<<<<<< SEARCH
          patchStatus: PatchStatus;

          // File & Script Info
          files: FileItem[];
          scripts: ScriptResult[];
      =======
          patchStatus: PatchStatus;

          // File & Script Info
          files: ReviewFileItem[];
          scripts: ScriptResult[];
      >>>>>>> REPLACE

      <<<<<<< SEARCH

      // --- Mock Data ---


      const mockFiles: FileItem[] = [

      =======

      // --- Mock Data ---


      const mockFiles: ReviewFileItem[] = [

      >>>>>>> REPLACE
    patchStrategy: search-replace
  - type: write
    path: src/stores/transaction-detail.store.ts
    content: |+
      --- src/stores/transaction-detail.store.ts
      +++ src/stores/transaction-detail.store.ts
      @@ -1,20 +1,11 @@
       import { create } from 'zustand';
      -import { useDashboardStore, type Transaction } from './dashboard.store';
      +import { useDashboardStore } from './dashboard.store';
       import { TransactionService } from '../services/transaction.service';
      +import type { Transaction } from '../types/transaction.types';
      +import type { FileChange as FileDetail } from '../types/file.types';
       
       // Types from README
      -export type FileChangeType = 'MOD' | 'ADD' | 'DEL' | 'REN';
      -export interface FileDetail {
      -    id: string;
      -    path: string;
      -    type: FileChangeType;
      -    diff: string;
      -    linesAdded: number;
      -    linesRemoved: number;
      -}
      -
       export type NavigatorSection = 'PROMPT' | 'REASONING' | 'FILES';
       export type BodyView = 'PROMPT' | 'REASONING' | 'FILES_LIST' | 'DIFF_VIEW' | 'COPY_MODE' | 'REVERT_CONFIRM' | 'NONE';
       

    patchStrategy: standard-diff
  - type: write
    path: src/stores/transaction-history.store.ts
    content: |+
      --- src/stores/transaction-history.store.ts
      +++ src/stores/transaction-history.store.ts
      @@ -1,36 +1,11 @@
       import { create } from 'zustand';
       import { TransactionService } from '../services/transaction.service';
      -
      -// --- Types ---
      -
      -export type FileChangeType = 'MOD' | 'ADD' | 'DEL' | 'REN';
      -export interface FileChange {
      -    id: string;
      -    path: string;
      -    type: FileChangeType;
      -    diff: string;
      -    linesAdded: number;
      -    linesRemoved: number;
      -}
      -
      -export type TransactionStatus = 'Committed' | 'Handoff' | 'Reverted';
      -export interface HistoryTransaction {
      -    id: string;
      -    hash: string;
      -    timestamp: number;
      -    status: TransactionStatus;
      -    message: string;
      -    files: FileChange[];
      -    stats: {
      -        files: number;
      -        linesAdded: number;
      -        linesRemoved: number;
      -    };
      -}
      +import type { HistoryTransaction } from '../types/transaction.types';
      +import type { FileChange } from '../types/file.types';
      +
       export type HistoryViewMode = 'LIST' | 'FILTER' | 'COPY' | 'BULK_ACTIONS';
       
       // Omit 'actions' from state type for partial updates
       type HistoryStateData = Omit<TransactionHistoryState, 'actions'>;
       
       interface TransactionHistoryState {

    patchStrategy: standard-diff
snapshot:
  src/types/file.types.ts: null
  src/types/transaction.types.ts: null
  src/services/commit.service.ts: >-
    import { useDashboardStore, type Transaction } from
    '../stores/dashboard.store';

    import { sleep } from '../utils';


    const generateCommitMessage = (transactions: Transaction[]): string => {
        if (transactions.length === 0) {
            return '';
        }
        // Using a more complex aggregation for better demo, based on the readme
        const title = 'feat: implement new dashboard and clipboard logic';
        const bodyPoints = [
            '- Adds error handling to the core transaction module to prevent uncaught exceptions during snapshot restoration.',
            '- Refactors the clipboard watcher for better performance and cross-platform compatibility, resolving issue #42.',
        ];

        if (transactions.length === 1 && transactions[0]) {
            return transactions[0].message;
        }

        return `${title}\n\n${bodyPoints.join('\n\n')}`;
    };


    const commit = async (transactionsToCommit: Transaction[]): Promise<void> =>
    {
        // In a real app, this would run git commands.
        // For simulation, we'll just update the dashboard store.
        const { updateTransactionStatus } = useDashboardStore.getState().actions;

        const txIds = transactionsToCommit.map(tx => tx.id);
        
        // A bit of simulation
        await sleep(500);

        txIds.forEach(id => {
            updateTransactionStatus(id, 'COMMITTED');
        });
    };


    export const CommitService = {
        generateCommitMessage,
        commit,
    };
  src/services/transaction.service.ts: >-
    import { useDashboardStore } from '../stores/dashboard.store';

    import { type HistoryTransaction, type FileChange, type TransactionStatus }
    from '../stores/transaction-history.store';


    const revertTransaction = (transactionId: string) => {
        const { updateTransactionStatus } = useDashboardStore.getState().actions;
        updateTransactionStatus(transactionId, 'REVERTED');
    };


    const createMockTransactions = (): HistoryTransaction[] => {
        const now = Date.now();
        return Array.from({ length: 42 }, (_, i) => {
            const status: TransactionStatus = i % 5 === 2 ? 'Handoff' : i % 5 === 3 ? 'Reverted' : 'Committed';
            const files: FileChange[] = [
                { id: `${i}-1`, path: 'src/core/transaction.ts', type: 'MOD', linesAdded: 25, linesRemoved: 8, diff: '--- a/src/core/transaction.ts\n+++ b/src/core/transaction.ts\n@@ -45,7 +45,9 @@\n-    for (const [filePath, content] of entries) {\n+    const restoreErrors: { path: string, error: unknown }[] = [];\n...\n...\n...\n...\n-    another line removed' },
                { id: `${i}-2`, path: 'src/utils/logger.ts', type: 'MOD', linesAdded: 10, linesRemoved: 2, diff: 'diff for logger' },
                { id: `${i}-3`, path: 'src/utils/old-helper.ts', type: 'DEL', linesAdded: 0, linesRemoved: 30, diff: 'diff for old-helper' },
            ];
            const linesAdded = files.reduce((sum, f) => sum + f.linesAdded, 0);
            const linesRemoved = files.reduce((sum, f) => sum + f.linesRemoved, 0);

            return {
                id: `tx-${i}`,
                hash: Math.random().toString(16).slice(2, 10),
                timestamp: now - i * 24 * 60 * 60 * 1000,
                status,
                message: `feat: commit message number ${42 - i}`,
                files,
                stats: { files: files.length, linesAdded, linesRemoved },
            };
        });
    };


    export const TransactionService = {
        revertTransaction,
        createMockTransactions,
    };
  src/services/review.service.ts: >-
    import { useReviewStore, type FileItem, type ApplyStep } from
    '../stores/review.store';

    import { useDashboardStore } from '../stores/dashboard.store';

    import { useAppStore } from '../stores/app.store';

    import { sleep } from '../utils';


    const generateBulkRepairPrompt = (files: FileItem[]): string => {
        const failedFiles = files.filter(f => f.status === 'FAILED');
        return `The previous patch failed to apply to MULTIPLE files. Please generate a new, corrected patch that addresses all the files listed below.

    IMPORTANT: The response MUST contain a complete code block for EACH file
    that needs to be fixed.


    ${failedFiles.map(file => `--- FILE: ${file.path} ---

    Strategy: ${file.strategy}

    Error: ${file.error}


    ORIGINAL CONTENT:

    ---

    // ... original content of ${file.path} ...

    ---


    FAILED PATCH:

    ---

    ${file.diff || '// ... failed diff ...'}

    ---

    `).join('\n')}


    Please analyze all failed files and provide a complete, corrected
    response.`;

    };


    const generateHandoffPrompt = (
        hash: string,
        message: string,
        reasoning: string,
        files: FileItem[],
    ): string => {
        const successfulFiles = files.filter(f => f.status === 'APPROVED');
        const failedFiles = files.filter(f => f.status === 'FAILED');

        return `I am handing off a failed automated code transaction to you. Your task is to act as my programming assistant and complete the planned changes.

    The full plan for this transaction is detailed in the YAML file located at:
    .relay/transactions/${hash}.yml. Please use this file as your primary source
    of truth for the overall goal.


    Here is the current status of the transaction:


    --- TRANSACTION SUMMARY ---

    Goal: ${message}

    Reasoning:

    ${reasoning}


    --- CURRENT FILE STATUS ---

    SUCCESSFUL CHANGES (already applied, no action needed):

    ${successfulFiles.map(f => `- MODIFIED: ${f.path}`).join('\n') || ' 
    (None)'}


    FAILED CHANGES (these are the files you need to fix):

    ${failedFiles.map(f => `- FAILED: ${f.path} (Error:
    ${f.error})`).join('\n')}


    Your job is to now work with me to fix the FAILED files and achieve the
    original goal of the transaction. Please start by asking me which file you
    should work on first.`;

    };


    const performHandoff = (hash: string) => {
        // This is a bit of a hack to find the right transaction to update in the demo
        const txToUpdate = useDashboardStore.getState().transactions.find(tx => tx.hash === hash);
        if (txToUpdate) {
            useDashboardStore.getState().actions.updateTransactionStatus(txToUpdate.id, 'HANDOFF');
        }

        useAppStore.getState().actions.showDashboardScreen();
    };


    const runApplySimulation = async (scenario: 'success' | 'failure') => {
        const { actions } = useReviewStore.getState();
        const { _updateApplyStep, _addApplySubstep, simulateSuccessScenario, simulateFailureScenario } = actions;

        if (scenario === 'success') {
            simulateSuccessScenario();
            
            _updateApplyStep('snapshot', 'active'); await sleep(100);
            _updateApplyStep('snapshot', 'done', 0.1);

            _updateApplyStep('memory', 'active'); await sleep(100);
            _addApplySubstep('memory', { id: 's1', title: '[✓] write: src/core/clipboard.ts (strategy: replace)', status: 'done' });
            await sleep(100);
            _addApplySubstep('memory', { id: 's2', title: '[✓] write: src/utils/shell.ts (strategy: standard-diff)', status: 'done' });
            _updateApplyStep('memory', 'done', 0.3);

            _updateApplyStep('post-command', 'active'); await sleep(1300);
            _addApplySubstep('post-command', { id: 's3', title: '`bun run test` ... Passed', status: 'done' });
            _updateApplyStep('post-command', 'done', 2.3);

            _updateApplyStep('linter', 'active'); await sleep(1200);
            _addApplySubstep('linter', { id: 's4', title: '`bun run lint` ... 0 Errors', status: 'done' });
            _updateApplyStep('linter', 'done', 1.2);

            await sleep(500);

        } else { // failure scenario
            simulateFailureScenario();
            
            _updateApplyStep('snapshot', 'active'); await sleep(100);
            _updateApplyStep('snapshot', 'done', 0.1);

            _updateApplyStep('memory', 'active'); await sleep(100);
            _addApplySubstep('memory', { id: 'f1', title: '[✓] write: src/core/transaction.ts (strategy: replace)', status: 'done' });
            await sleep(100);
            _addApplySubstep('memory', { id: 'f2', title: '[!] failed: src/utils/logger.ts (Hunk #1 failed to apply)', status: 'failed' });
            await sleep(100);
            _addApplySubstep('memory', { id: 'f3', title: '[!] failed: src/commands/apply.ts (Context mismatch at line 92)', status: 'failed' });
            _updateApplyStep('memory', 'done', 0.5);

            await sleep(100);
            _updateApplyStep('post-command', 'skipped', undefined, 'Skipped due to patch application failure');
            await sleep(100);
            _updateApplyStep('linter', 'skipped', undefined, 'Skipped due to patch application failure');
            
            await sleep(500);
        }
    };


    const generateSingleFileRepairPrompt = (file: FileItem): string => {
        return `The patch failed to apply to ${file.path}. Please generate a corrected patch.

    Error: ${file.error}

    Strategy: ${file.strategy}


    ORIGINAL CONTENT:

    ---

    // ... original file content would be here ...

    ---


    FAILED PATCH:

    ---

    ${file.diff || '// ... failed diff would be here ...'}

    ---


    Please provide a corrected patch that addresses the error.`;

    };


    const tryRepairFile = (file: FileItem, selectedIndex: number): void => {
        const repairPrompt = generateSingleFileRepairPrompt(file);
        // In a real app: clipboardy.writeSync(repairPrompt)
        // eslint-disable-next-line no-console
        console.log(`[CLIPBOARD] Copied repair prompt for: ${file.path}`);

        // Mock: Update file status to show it's being repaired
        useReviewStore.setState(state => {
            const newFiles = [...state.files];
            newFiles[selectedIndex] = { ...file, status: 'APPROVED' as const, error: undefined, linesAdded: 5, linesRemoved: 2 };
            return { files: newFiles, copyModeLastCopied: 'Repair prompt copied to clipboard' };
        });
    };


    const runBulkReapply = async (): Promise<void> => {
        const { files } = useReviewStore.getState();
        const failedFileIds = new Set(files.filter(f => f.status === 'FAILED').map(f => f.id));
        if (failedFileIds.size === 0) {
            return;
        }

        useReviewStore.setState(state => ({
            files: state.files.map(file =>
                failedFileIds.has(file.id)
                    ? { ...file, status: 'RE_APPLYING' as const }
                    : file,
            ),
        }));

        await sleep(1500); // Simulate re-apply

        // Mock a mixed result
        let first = true;
        useReviewStore.setState(state => ({
            files: state.files.map(file => {
                if (failedFileIds.has(file.id)) {
                    if (first) {
                        first = false;
                        return { ...file, status: 'APPROVED' as const, strategy: 'replace' as const, error: undefined, linesAdded: 9, linesRemoved: 2 };
                    }
                    return { ...file, status: 'FAILED' as const, error: "'replace' failed: markers not found" };
                }
                return file;
            }),
        }));
    };


    export const ReviewService = {
        generateBulkRepairPrompt,
        generateHandoffPrompt,
        performHandoff,
        runApplySimulation,
        generateSingleFileRepairPrompt,
        tryRepairFile,
        runBulkReapply,
    };
  src/stores/commit.store.ts: |-
    import { create } from 'zustand';
    import { useDashboardStore, type Transaction } from './dashboard.store';
    import { CommitService } from '../services/commit.service';

    interface CommitState {
        transactionsToCommit: Transaction[];
        finalCommitMessage: string;
        isCommitting: boolean;
        actions: {
            prepareCommitScreen: () => void;
            commit: () => Promise<void>;
        }
    }

    export const useCommitStore = create<CommitState>((set, get) => ({
        transactionsToCommit: [],
        finalCommitMessage: '',
        isCommitting: false,
        actions: {
            prepareCommitScreen: () => {
                const { transactions } = useDashboardStore.getState();
                const appliedTransactions = transactions.filter(tx => tx.status === 'APPLIED');
                
                const finalCommitMessage = CommitService.generateCommitMessage(appliedTransactions);

                set({
                    transactionsToCommit: appliedTransactions,
                    finalCommitMessage,
                });
            },
            commit: async () => {
                set({ isCommitting: true });
                const { transactionsToCommit } = get();
                await CommitService.commit(transactionsToCommit);
                set({ isCommitting: false });
            },
        },
    }));
  src/stores/dashboard.store.ts: >-
    import { create } from 'zustand';

    import { DashboardService } from '../services/dashboard.service';


    // --- Types ---

    export type TransactionStatus = 'PENDING' | 'APPLIED' | 'COMMITTED' |
    'FAILED' | 'REVERTED' | 'IN-PROGRESS' | 'HANDOFF';


    export interface Transaction {
        id: string;
        timestamp: number;
        status: TransactionStatus;
        hash: string;
        message: string;
        error?: string;
    }


    export type DashboardStatus = 'LISTENING' | 'PAUSED' | 'CONFIRM_APPROVE' |
    'APPROVING';


    // --- Initial State (for simulation) ---

    const createInitialTransactions = (): Transaction[] => [
        { id: '1', timestamp: Date.now() - 15 * 1000, status: 'PENDING', hash: 'e4a7c112', message: 'fix: add missing error handling' },
        { id: '2', timestamp: Date.now() - 2 * 60 * 1000, status: 'APPLIED', hash: '4b9d8f03', message: 'refactor: simplify clipboard logic' },
        { id: '3', timestamp: Date.now() - 5 * 60 * 1000, status: 'COMMITTED', hash: '8a3f21b8', message: 'feat: implement new dashboard UI' },
        { id: '4', timestamp: Date.now() - 8 * 60 * 1000, status: 'REVERTED', hash: 'b2c9e04d', message: 'Reverting transaction 9c2e1a05' },
        { id: '5', timestamp: Date.now() - 9 * 60 * 1000, status: 'FAILED', hash: '9c2e1a05', message: 'style: update button component (Linter errors: 5)' },
        { id: '6', timestamp: Date.now() - 12 * 60 * 1000, status: 'COMMITTED', hash: 'c7d6b5e0', message: 'docs: update readme with TUI spec' },
    ];


    // --- Store Interface ---

    interface DashboardState {
        status: DashboardStatus;
        previousStatus: DashboardStatus; // To handle cancel from confirmation
        transactions: Transaction[];
        selectedTransactionIndex: number;
        showHelp: boolean;
        actions: {
            togglePause: () => void;
            moveSelectionUp: () => void;
            moveSelectionDown: () => void;
            startApproveAll: () => void;
            confirmAction: () => Promise<void>;
            cancelAction: () => void;
            toggleHelp: () => void;
            setStatus: (status: DashboardStatus) => void; // For debug menu
            updateTransactionStatus: (id: string, status: TransactionStatus) => void;
        };
    }


    // --- Store Implementation ---

    export const useDashboardStore = create<DashboardState>((set, get) => ({
        status: 'LISTENING',
        previousStatus: 'LISTENING',
        transactions: createInitialTransactions(),
        selectedTransactionIndex: 0,
        showHelp: false,
        actions: {
            togglePause: () => set(state => ({
                status: state.status === 'LISTENING' ? 'PAUSED' : 'LISTENING',
            })),
            moveSelectionUp: () => set(state => ({
                selectedTransactionIndex: Math.max(0, state.selectedTransactionIndex - 1),
            })),
            moveSelectionDown: () => set(state => ({
                selectedTransactionIndex: Math.min(state.transactions.length - 1, state.selectedTransactionIndex + 1),
            })),
            startApproveAll: () => set(state => ({
                status: 'CONFIRM_APPROVE',
                previousStatus: state.status,
            })),
            cancelAction: () => set(state => ({ status: state.previousStatus })),
            toggleHelp: () => set(state => ({ showHelp: !state.showHelp })),
            setStatus: (status) => set({ status }),
            updateTransactionStatus: (id, status) => {
                set(state => ({
                    transactions: state.transactions.map(tx =>
                        tx.id === id ? { ...tx, status, timestamp: Date.now() } : tx,
                    ),
                }));
                // After updating, move selection to the updated transaction
                const index = get().transactions.findIndex(tx => tx.id === id);
                if (index !== -1) set({ selectedTransactionIndex: index });
            },

            confirmAction: async () => {
                const { status, previousStatus } = get();
                if (status === 'CONFIRM_APPROVE') {
                    set({ status: 'APPROVING' });

                    await DashboardService.approveAll();

                    set({ status: previousStatus });
                }
            },
        },
    }));
  src/stores/review.store.ts: >-
    import { create } from 'zustand';

    import { sleep } from '../utils';

    import { useAppStore } from './app.store';

    import { useDashboardStore } from './dashboard.store';

    import { ReviewService } from '../services/review.service';


    // --- Types ---


    export type FileStatus = 'FAILED' | 'APPROVED' | 'REJECTED' | 'AWAITING' |
    'RE_APPLYING';

    export interface FileItem {
        id: string;
        path: string;
        status: FileStatus;
        diff: string;
        linesAdded: number;
        linesRemoved: number;
        error?: string;
        strategy: 'replace' | 'standard-diff';
    }


    export interface ScriptResult {
        command: string;
        success: boolean;
        duration: number;
        summary: string;
        output: string;
    }


    export interface ApplyStep {
        id: string;
        title: string;
        status: 'pending' | 'active' | 'done' | 'failed' | 'skipped';
        details?: string;
        substeps?: ApplyStep[];
        duration?: number;
    }


    export const initialApplySteps: ApplyStep[] = [
        { id: 'snapshot', title: 'Reading initial file snapshot...', status: 'pending' },
        { id: 'memory', title: 'Applying operations to memory...', status: 'pending', substeps: [] },
        { id: 'post-command', title: 'Running post-command script...', status: 'pending', substeps: [] },
        { id: 'linter', title: 'Analyzing changes with linter...', status: 'pending', substeps: [] },
    ];


    export type BodyView = 'diff' | 'reasoning' | 'script_output' | 'copy_mode'
    | 'bulk_repair' | 'confirm_handoff' | 'none';

    export type PatchStatus = 'SUCCESS' | 'PARTIAL_FAILURE';


    interface ReviewState {
        // Transaction Info
        hash: string;
        message: string;
        prompt: string;
        reasoning: string;
        linesAdded: number;
        linesRemoved: number;
        duration: number;
        patchStatus: PatchStatus;

        // File & Script Info
        files: FileItem[];
        scripts: ScriptResult[];

        // UI State
        applySteps: ApplyStep[];
        selectedItemIndex: number; // Can be file or script
        bodyView: BodyView;
        isDiffExpanded: boolean;
        
        // Copy Mode State
        copyModeSelectedIndex: number;
        copyModeLastCopied: string | null;
        
        // Reasoning Scroll State
        reasoningScrollIndex: number;
        
        // Script Navigation State
        scriptErrorIndex: number;

        actions: {
            moveSelectionUp: () => void;
            moveSelectionDown: () => void;
            toggleFileApproval: () => void;
            rejectAllFiles: () => void;
            toggleDiffView: () => void;
            toggleReasoningView: () => void;
            toggleScriptView: () => void;
            expandDiff: () => void;
            approve: () => void;
            simulateSuccessScenario: () => void;
            startApplySimulation: (scenario: 'success' | 'failure') => void;
            simulateFailureScenario: () => void;
            
            // Copy Mode Actions
            toggleCopyMode: () => void;
            moveCopySelectionUp: () => void;
            moveCopySelectionDown: () => void;
            copySelectedItem: () => void;
            copyUUID: () => void;
            copyMessage: () => void;
            copyPrompt: () => void;
            copyReasoning: () => void;
            copyFileDiff: () => void;
            copyAllDiffs: () => void;
            
            // Repair Actions
            tryRepairFile: () => void;
            showBulkRepair: () => void;
            executeBulkRepairOption: (option: number) => Promise<void>;
            confirmHandoff: () => void;
            
            // Navigation Actions
            scrollReasoningUp: () => void;
            scrollReasoningDown: () => void;
            navigateScriptErrorUp: () => void;
            navigateScriptErrorDown: () => void,
            
            // "Private" actions for service layer
            _updateApplyStep: (id: string, status: ApplyStep['status'], duration?: number, details?: string) => void;
            _addApplySubstep: (parentId: string, substep: Omit<ApplyStep, 'substeps'>) => void;
        };
    }


    // --- Mock Data ---


    const mockFiles: FileItem[] = [
        { 
            id: '1', 
            path: 'src/core/transaction.ts', 
            status: 'APPROVED', 
            linesAdded: 18, 
            linesRemoved: 5, 
            diff: `--- a/src/core/transaction.ts
    +++ b/src/core/transaction.ts

    @@ -15,7 +15,7 @@ export class Transaction {
       }
     
    -  calculateChanges(): ChangeSet {

    +  computeDelta(): ChangeSet {
         return this.changes;
       }
     }`, 
            strategy: 'replace', 
        },
        { 
            id: '2', 
            path: 'src/utils/logger.ts', 
            status: 'FAILED', 
            linesAdded: 0, 
            linesRemoved: 0, 
            diff: '', 
            error: 'Hunk #1 failed to apply', 
            strategy: 'standard-diff', 
        },
        { 
            id: '3', 
            path: 'src/commands/apply.ts', 
            status: 'FAILED', 
            linesAdded: 0, 
            linesRemoved: 0, 
            diff: '', 
            error: 'Context mismatch at line 92', 
            strategy: 'standard-diff', 
        },
    ];


    const mockScripts: ScriptResult[] = [
        { command: 'bun run test', success: true, duration: 2.3, summary: 'Passed (37 tests)', output: '... test output ...' },
        { command: 'bun run lint', success: false, duration: 1.2, summary: '1 Error, 3 Warnings', output: `src/core/clipboard.ts
      45:12  Error    'clipboardy' is assigned a value but never used. (@typescript-eslint/no-unused-vars)
      88:5   Warning  Unexpected console statement. (no-console)` },
    ];


    const mockReasoning = `1. Identified a potential uncaught exception in the
    \`restoreSnapshot\` function
       if a file operation fails midway through a loop of many files. This could
       leave the project in a partially-reverted, inconsistent state.

    2. Wrapped the file restoration loop in a \`Promise.all\` and added a
    dedicated
       error collection array. This ensures that all file operations are
       attempted and that a comprehensive list of failures is available
       afterward for better error reporting or partial rollback logic.`;

    // --- Store Implementation ---


    export const useReviewStore = create<ReviewState>((set, get) => ({
        // Transaction Info
        hash: 'e4a7c112',
        message: 'refactor: rename core utility function',
        prompt: 'Rename the `calculateChanges` utility to `computeDelta` across all files and update imports accordingly.',
        reasoning: mockReasoning,
        linesAdded: 18,
        linesRemoved: 5,
        duration: 0.6,
        patchStatus: 'PARTIAL_FAILURE',

        // File & Script Info
        files: mockFiles,
        scripts: [], // Empty for partial failure scenario

        // UI State
        applySteps: initialApplySteps,
        selectedItemIndex: 0, // Start with first file
        bodyView: 'none',
        isDiffExpanded: false,
        
        // Copy Mode State
        copyModeSelectedIndex: 0,
        copyModeLastCopied: null,
        
        // Reasoning Scroll State
        reasoningScrollIndex: 0,
        
        // Script Navigation State
        scriptErrorIndex: 0,

        actions: {
            moveSelectionUp: () => set(state => ({
                selectedItemIndex: Math.max(0, state.selectedItemIndex - 1),
            })),
            moveSelectionDown: () => set(state => ({
                selectedItemIndex: Math.min(state.files.length + state.scripts.length - 1, state.selectedItemIndex + 1),
            })),
            toggleFileApproval: () => set(state => {
                const { selectedItemIndex, files } = state;
                if (selectedItemIndex >= files.length) return {}; // Not a file
                
                const newFiles = [...files];
                const file = newFiles[selectedItemIndex];
                if (file) {
                    if (file.status === 'APPROVED') {
                        file.status = 'REJECTED';
                    } else if (file.status === 'REJECTED') {
                        file.status = 'APPROVED';
                    }
                }
                return { files: newFiles };
            }),
            rejectAllFiles: () => set(state => {
                const newFiles = state.files.map(file => {
                    if (file.status === 'APPROVED') {
                        return { ...file, status: 'REJECTED' as const };
                    }
                    return file;
                });
                return { files: newFiles };
            }),
            toggleDiffView: () => set(state => {
                const { bodyView } = state;
                if (state.selectedItemIndex >= state.files.length) return {}; // Can't show diff for scripts
                return {
                    bodyView: bodyView === 'diff' ? 'none' : 'diff',
                    isDiffExpanded: false, // Always start collapsed
                };
            }),
            toggleReasoningView: () => set(state => {
                const { bodyView } = state;
                return {
                    bodyView: bodyView === 'reasoning' ? 'none' : 'reasoning',
                };
            }),
            toggleScriptView: () => set(state => {
                const { bodyView } = state;
                return {
                    bodyView: bodyView === 'script_output' ? 'none' : 'script_output',
                };
            }),
            expandDiff: () => set(state => ({ isDiffExpanded: !state.isDiffExpanded })),
            approve: () => { /* NOP for now, would trigger commit and screen change */ },
            startApplySimulation: async (scenario: 'success' | 'failure') => {
                const { showReviewProcessingScreen, showReviewScreen } = useAppStore.getState().actions;
                
                set({ applySteps: JSON.parse(JSON.stringify(initialApplySteps)) });
                showReviewProcessingScreen();

                await ReviewService.runApplySimulation(scenario);
        
                showReviewScreen();
            },
            simulateSuccessScenario: () => set(() => ({
                hash: '4b9d8f03',
                message: 'refactor: simplify clipboard logic',
                prompt: 'Simplify the clipboard logic using an external library...',
                linesAdded: 22,
                linesRemoved: 11,
                duration: 3.9,
                patchStatus: 'SUCCESS' as const,
                files: [
                    { 
                        id: '1', 
                        path: 'src/core/clipboard.ts', 
                        status: 'APPROVED' as const, 
                        linesAdded: 15, 
                        linesRemoved: 8, 
                        diff: `--- a/src/core/clipboard.ts
    +++ b/src/core/clipboard.ts

    @@ -1,5 +1,6 @@
     import { copy as copyToClipboard } from 'clipboardy';`, 
                        strategy: 'replace' as const,
                    },
                    { 
                        id: '2', 
                        path: 'src/utils/shell.ts', 
                        status: 'APPROVED' as const, 
                        linesAdded: 7, 
                        linesRemoved: 3, 
                        diff: `--- a/src/utils/shell.ts
    +++ b/src/utils/shell.ts`, 
                        strategy: 'standard-diff' as const,
                    },
                ],
                scripts: mockScripts,
                selectedItemIndex: 0,
                bodyView: 'none' as const,
            })),
            simulateFailureScenario: () => set(() => ({
                hash: 'e4a7c112',
                message: 'refactor: rename core utility function',
                prompt: 'Rename the `calculateChanges` utility to `computeDelta` across all files and update imports accordingly.',
                linesAdded: 18,
                linesRemoved: 5,
                duration: 0.6,
                patchStatus: 'PARTIAL_FAILURE' as const,
                files: mockFiles,
                scripts: [],
                // Reset UI state
                bodyView: 'none',
                isDiffExpanded: false,
                reasoningScrollIndex: 0,
                scriptErrorIndex: 0,
                selectedItemIndex: 0,
            })),
            
            // Copy Mode Actions
            toggleCopyMode: () => set(state => ({
                bodyView: state.bodyView === 'copy_mode' ? 'none' : 'copy_mode',
                copyModeSelectedIndex: 0,
                copyModeLastCopied: null,
            })),
            moveCopySelectionUp: () => set(state => ({
                copyModeSelectedIndex: Math.max(0, state.copyModeSelectedIndex - 1),
            })),
            moveCopySelectionDown: () => set(state => ({
                copyModeSelectedIndex: Math.min(5, state.copyModeSelectedIndex + 1), // 6 total options (U,M,P,R,F,A)
            })),
            copySelectedItem: () => set(state => {
                const { copyModeSelectedIndex, hash, message, prompt, reasoning, files, selectedItemIndex } = state;
                let content = '';
                let label = '';
                
                switch (copyModeSelectedIndex) {
                    case 0: // UUID
                        content = `${hash}-a8b3-4f2c-9d1e-8a7c1b9d8f03`;
                        label = 'UUID';
                        break;
                    case 1: // Git Message
                        content = message;
                        label = 'Git Message';
                        break;
                    case 2: // Prompt
                        content = prompt;
                        label = 'Prompt';
                        break;
                    case 3: // Reasoning
                        content = reasoning;
                        label = 'Reasoning';
                        break;
                    case 4: // Diff for current file
                        if (selectedItemIndex < files.length) {
                            const file = files[selectedItemIndex];
                            if (file) {
                                content = file.diff;
                                label = `Diff for ${file.path}`;
                            }
                        }
                        break;
                    case 5: // All Diffs
                        content = files.map(f => `--- FILE: ${f.path} ---\n${f.diff}`).join('\n\n');
                        label = 'All Diffs';
                        break;
                }
                
                // Mock clipboard operation (TUI environment - no real clipboard)
                // eslint-disable-next-line no-console
                console.log(`[CLIPBOARD] Copied ${label}: ${content.substring(0, 100)}...`);
                
                return { copyModeLastCopied: label };
            }),
            copyUUID: () => set(state => {
                const content = `${state.hash}-a8b3-4f2c-9d1e-8a7c1b9d8f03`;
                // eslint-disable-next-line no-console
                console.log(`[CLIPBOARD] Copied UUID: ${content}`);
                return { copyModeLastCopied: 'UUID' };
            }),
            copyMessage: () => set(state => {
                // eslint-disable-next-line no-console
                console.log(`[CLIPBOARD] Copied Git Message: ${state.message}`);
                return { copyModeLastCopied: 'Git Message' };
            }),
            copyPrompt: () => set(state => {
                // eslint-disable-next-line no-console
                console.log(`[CLIPBOARD] Copied Prompt: ${state.prompt.substring(0, 100)}...`);
                return { copyModeLastCopied: 'Prompt' };
            }),
            copyReasoning: () => set(state => {
                // eslint-disable-next-line no-console
                console.log(`[CLIPBOARD] Copied Reasoning: ${state.reasoning.substring(0, 100)}...`);
                return { copyModeLastCopied: 'Reasoning' };
            }),
            copyFileDiff: () => set(state => {
                if (state.selectedItemIndex < state.files.length) {
                    const file = state.files[state.selectedItemIndex];
                    if (file) {
                        // eslint-disable-next-line no-console
                        console.log(`[CLIPBOARD] Copied diff for: ${file.path}`);
                        return { copyModeLastCopied: `Diff for ${file.path}` };
                    }
                }
                return {};
            }),
            copyAllDiffs: () => set(state => {
                // eslint-disable-next-line no-console
                console.log(`[CLIPBOARD] Copied all diffs: ${state.files.length} files`);
                return { copyModeLastCopied: 'All Diffs' };
            }),
            
    // Repair Actions

    tryRepairFile: () => {
        const { selectedItemIndex, files } = get();
        if (selectedItemIndex < files.length) {
            const file = files[selectedItemIndex];
            if (file && file.status === 'FAILED') {
                ReviewService.tryRepairFile(file, selectedItemIndex);
            }
        }
    },
            showBulkRepair: () => set(() => ({
                bodyView: 'bulk_repair' as const,
            })),
            executeBulkRepairOption: async (option: number) => {
                const { files } = get();

                switch (option) {
                    case 1: { // Generate & Copy Bulk Repair Prompt
                        const bulkPrompt = ReviewService.generateBulkRepairPrompt(files);
                        const failedFiles = files.filter(f => f.status === 'FAILED');
                        // eslint-disable-next-line no-console
                        console.log(`[CLIPBOARD] Copied bulk repair prompt for ${failedFiles.length} files.`);
                        // In a real app, this would use clipboardy.writeSync(bulkPrompt)
                        set({ bodyView: 'none', copyModeLastCopied: 'Bulk repair prompt copied.' });
                        break;
                    }
                        
                    case 2: { // Attempt Bulk Re-apply
                        set({ bodyView: 'none' as const });
                        await ReviewService.runBulkReapply();
                        break;
                    }
                        
                    case 3: { // Handoff to Human
                        set({ bodyView: 'confirm_handoff' as const });
                        break;
                    }
                        
                    case 4: { // Reject All Failed
                        set(state => ({
                            files: state.files.map(file =>
                                file.status === 'FAILED'
                                    ? { ...file, status: 'REJECTED' as const }
                                    : file,
                            ),
                            bodyView: 'none' as const,
                        }));
                        break;
                    }
                        
                    default: // Close modal
                        set({ bodyView: 'none' as const });
                }
            },
            confirmHandoff: () => {
                const { hash, message, reasoning, files } = get();
                const handoffPrompt = ReviewService.generateHandoffPrompt(hash, message, reasoning, files);

                // eslint-disable-next-line no-console
                console.log('[CLIPBOARD] Copied Handoff Prompt.'); // In real app: clipboardy.writeSync(handoffPrompt)
                ReviewService.performHandoff(hash);
            },
            
            // Navigation Actions
            scrollReasoningUp: () => set(state => ({
                reasoningScrollIndex: Math.max(0, state.reasoningScrollIndex - 1),
            })),
            scrollReasoningDown: () => set(state => {
                const maxLines = state.reasoning.split('\n').length;
                return { reasoningScrollIndex: Math.min(maxLines - 1, state.reasoningScrollIndex + 1) };
            }),
            navigateScriptErrorUp: () => set(state => ({
                scriptErrorIndex: Math.max(0, state.scriptErrorIndex - 1),
            })),
            navigateScriptErrorDown: () => set(state => {
                const selectedScript = state.scripts[state.selectedItemIndex - state.files.length];
                if (selectedScript && selectedScript.output) {
                    const errorLines = selectedScript.output.split('\n').filter(line => 
                        line.includes('Error') || line.includes('Warning'),
                    );
                    return { scriptErrorIndex: Math.min(errorLines.length - 1, state.scriptErrorIndex + 1) };
                }
                return {};
            }),
            
            // "Private" actions for service layer
            _updateApplyStep: (id, status, duration, details) => {
                set(state => ({
                    applySteps: state.applySteps.map(s => {
                        if (s.id === id) {
                            const newStep = { ...s, status };
                            if (duration !== undefined) newStep.duration = duration;
                            if (details !== undefined) newStep.details = details;
                            return newStep;
                        }
                        return s;
                    }),
                }));
            },
            _addApplySubstep: (parentId, substep) => {
                 set(state => ({
                    applySteps: state.applySteps.map(s => {
                        if (s.id === parentId) {
                            const newSubsteps = [...(s.substeps || []), substep as ApplyStep];
                            return { ...s, substeps: newSubsteps };
                        }
                        return s;
                    }),
                }));
            },
        },
    }));
  src/stores/transaction-detail.store.ts: >-
    import { create } from 'zustand';

    import { useDashboardStore, type Transaction } from './dashboard.store';

    import { TransactionService } from '../services/transaction.service';


    // Types from README

    export type FileChangeType = 'MOD' | 'ADD' | 'DEL' | 'REN';

    export interface FileDetail {
        id: string;
        path: string;
        type: FileChangeType;
        diff: string;
        linesAdded: number;
        linesRemoved: number;
    }


    export type NavigatorSection = 'PROMPT' | 'REASONING' | 'FILES';

    export type BodyView = 'PROMPT' | 'REASONING' | 'FILES_LIST' | 'DIFF_VIEW' |
    'COPY_MODE' | 'REVERT_CONFIRM' | 'NONE';


    interface TransactionDetailState {
        // Data
        transaction: Transaction | null;
        prompt: string;
        reasoning: string;
        files: FileDetail[];
        
        // UI State
        navigatorFocus: NavigatorSection | 'FILES_LIST';
        expandedSection: NavigatorSection | null;
        selectedFileIndex: number;
        bodyView: BodyView;
        copyModeSelectionIndex: number;
        copyModeSelections: Record<string, boolean>;
        copyModeLastCopied: string | null;

        // Actions
        actions: {
            loadTransaction: (transactionId: string) => void;
            navigateUp: () => void;
            navigateDown: () => void;
            handleEnterOrRight: () => void;
            handleEscapeOrLeft: () => void;
            toggleCopyMode: () => void;
            toggleRevertConfirm: () => void;
            copyModeNavigateUp: () => void;
            copyModeNavigateDown: () => void;
            copyModeToggleSelection: () => void;
            copyModeExecuteCopy: () => void;
            confirmRevert: () => void;
        }
    }


    // Mock data based on README

    const mockTransactionData = {
        prompt: 'The user requested to add more robust error handling to the `restoreSnapshot` function. Specifically, it should not halt on the first error but instead attempt all file restorations and then report a summary of any failures.',
        reasoning: `1. The primary goal was to make the rollback functionality in \`restoreSnapshot\` more robust. The previous implementation used a simple for-loop which would halt on the first error, leaving the project in a partially restored state.

    2. I opted for a \`Promise.all\` approach to run file restorations in
    parallel. This improves performance slightly but, more importantly, ensures
    all restoration attempts are completed, even if some fail.


    3. An \`restoreErrors\` array was introduced to collect any exceptions that
    occur during the process. If this array is not empty after the
    \`Promise.all\` completes, a comprehensive error is thrown, informing the
    user exactly which files failed to restore. This provides much better
    diagnostics.`,
        files: [
            { id: '1', path: 'src/core/transaction.ts', type: 'MOD' as const, linesAdded: 18, linesRemoved: 5, diff: `   export const restoreSnapshot = async (snapshot: FileSnapshot, ...): ... => {
         ...
    -    for (const [filePath, content] of entries) {

    -        if (content === null) {

    -            await deleteFile(filePath, cwd);

    -        }

    -    }

    +    const restoreErrors: { path: string, error: unknown }[] = [];

    +

    +    await Promise.all(entries.map(async ([filePath, content]) => {

    +        try {

    +          if (content === null) { ... }

    +        } catch (error) {

    +          restoreErrors.push({ path: filePath, error });

    +        }

    +    }));

    +

    +    if (restoreErrors.length > 0) { ... }
       }` },
            { id: '2', path: 'src/utils/logger.ts', type: 'MOD' as const, linesAdded: 7, linesRemoved: 3, diff: '... diff content for logger.ts ...' },
            { id: '3', path: 'src/utils/old-helper.ts', type: 'DEL' as const, linesAdded: 0, linesRemoved: 0, diff: '... diff content for old-helper.ts ...' },
        ],
    };


    const navigatorOrder: NavigatorSection[] = ['PROMPT', 'REASONING', 'FILES'];

    const copyOptionsList = [
        'Git Message', 'Prompt', 'Reasoning', `All Diffs (${mockTransactionData.files.length} files)`, `Diff for: ${mockTransactionData.files[0]?.path}`, 'UUID', 'Full YAML representation',
    ];


    export const useTransactionDetailStore =
    create<TransactionDetailState>((set, get) => ({
        transaction: null,
        prompt: '',
        reasoning: '',
        files: [],
        
        navigatorFocus: 'PROMPT',
        expandedSection: null,
        selectedFileIndex: 0,
        bodyView: 'NONE',
        copyModeSelectionIndex: 0,
        copyModeSelections: { 'Git Message': true, 'Reasoning': true }, // Default selections from readme
        copyModeLastCopied: null,

        actions: {
            loadTransaction: (transactionId) => {
                const { transactions } = useDashboardStore.getState();
                const transaction = transactions.find(tx => tx.id === transactionId);
                if (transaction) {
                    set({
                        transaction,
                        ...mockTransactionData,
                        // Reset UI state
                        navigatorFocus: 'PROMPT',
                        expandedSection: null,
                        selectedFileIndex: 0,
                        bodyView: 'NONE',
                    });
                }
            },
            navigateUp: () => {
                const { navigatorFocus, selectedFileIndex } = get();
                if (navigatorFocus === 'FILES_LIST') {
                    set({ selectedFileIndex: Math.max(0, selectedFileIndex - 1) });
                } else {
                    const currentIndex = navigatorOrder.indexOf(navigatorFocus as NavigatorSection);
                    if (currentIndex > 0) {
                        set({ navigatorFocus: navigatorOrder[currentIndex - 1] });
                    }
                }
            },
            navigateDown: () => {
                const { navigatorFocus, selectedFileIndex, files } = get();
                if (navigatorFocus === 'FILES_LIST') {
                    set({ selectedFileIndex: Math.min(files.length - 1, selectedFileIndex + 1) });
                } else {
                    const currentIndex = navigatorOrder.indexOf(navigatorFocus as NavigatorSection);
                    if (currentIndex < navigatorOrder.length - 1) {
                        set({ navigatorFocus: navigatorOrder[currentIndex + 1] });
                    }
                }
            },
            handleEnterOrRight: () => {
                const { navigatorFocus, expandedSection } = get();

                if (navigatorFocus === 'FILES_LIST') {
                    // Already in file list, now show diff
                    set({ bodyView: 'DIFF_VIEW' });
                    return;
                }

                if (expandedSection === navigatorFocus) {
                    // Section is already expanded, handle nested navigation
                    if (navigatorFocus === 'FILES') {
                        set({ navigatorFocus: 'FILES_LIST', bodyView: 'FILES_LIST' });
                    }
                    return;
                }

                // Expand the focused section
                set({ expandedSection: navigatorFocus });

                switch(navigatorFocus) {
                    case 'PROMPT':
                        set({ bodyView: 'PROMPT' });
                        break;
                    case 'REASONING':
                        set({ bodyView: 'REASONING' });
                        break;
                    case 'FILES':
                        set({ bodyView: 'FILES_LIST' });
                        break;
                }
            },
            handleEscapeOrLeft: () => {
                const { navigatorFocus, expandedSection, bodyView } = get();

                if (bodyView === 'DIFF_VIEW') {
                    set({ bodyView: 'FILES_LIST' }); // Go back from diff to file list
                    return;
                }

                if (navigatorFocus === 'FILES_LIST') {
                    set({ navigatorFocus: 'FILES', bodyView: 'NONE' }); // Go back from file list to files section
                    return;
                }

                // If a section is expanded, collapse it
                if (expandedSection) {
                    set({ expandedSection: null, bodyView: 'NONE' });
                    return;
                }
            },
            toggleCopyMode: () => set(state => {
                if (state.bodyView === 'COPY_MODE') {
                    return { bodyView: 'NONE' };
                }
                return {
                    bodyView: 'COPY_MODE',
                    copyModeSelectionIndex: 0,
                    copyModeLastCopied: null,
                };
            }),
            toggleRevertConfirm: () => set(state => ({
                bodyView: state.bodyView === 'REVERT_CONFIRM' ? 'NONE' : 'REVERT_CONFIRM',
            })),
            copyModeNavigateUp: () => set(state => ({
                copyModeSelectionIndex: Math.max(0, state.copyModeSelectionIndex - 1),
            })),
            copyModeNavigateDown: () => set(state => ({
                copyModeSelectionIndex: Math.min(copyOptionsList.length - 1, state.copyModeSelectionIndex + 1),
            })),
            copyModeToggleSelection: () => set(state => {
                const currentOption = copyOptionsList[state.copyModeSelectionIndex];
                if (!currentOption) return {};

                const newSelections = { ...state.copyModeSelections };
                newSelections[currentOption] = !newSelections[currentOption];
                return { copyModeSelections: newSelections };
            }),
            copyModeExecuteCopy: () => {
                // Mock copy to clipboard
                const { copyModeSelections } = get();
                const selectedItems = Object.keys(copyModeSelections).filter(key => copyModeSelections[key]);
                const message = `Copied ${selectedItems.length} items to clipboard.`;
                // In real app: clipboardy.writeSync(...)
                // eslint-disable-next-line no-console
                console.log(`[CLIPBOARD] Mock copy: ${selectedItems.join(', ')}`);
                set({ copyModeLastCopied: message });
            },
            confirmRevert: () => {
                const { transaction } = get();
                if (!transaction) return;
                TransactionService.revertTransaction(transaction.id);
                set({ bodyView: 'NONE' });
            },
        },
    }));
  src/stores/transaction-history.store.ts: >-
    import { create } from 'zustand';

    import { TransactionService } from '../services/transaction.service';


    // --- Types ---


    export type FileChangeType = 'MOD' | 'ADD' | 'DEL' | 'REN';

    export interface FileChange {
        id: string;
        path: string;
        type: FileChangeType;
        diff: string;
        linesAdded: number;
        linesRemoved: number;
    }


    export type TransactionStatus = 'Committed' | 'Handoff' | 'Reverted';

    export interface HistoryTransaction {
        id: string;
        hash: string;
        timestamp: number;
        status: TransactionStatus;
        message: string;
        files: FileChange[];
        stats: {
            files: number;
            linesAdded: number;
            linesRemoved: number;
        };
    }

    export type HistoryViewMode = 'LIST' | 'FILTER' | 'COPY' | 'BULK_ACTIONS';


    // Omit 'actions' from state type for partial updates

    type HistoryStateData = Omit<TransactionHistoryState, 'actions'>;


    interface TransactionHistoryState {
        transactions: HistoryTransaction[];
        mode: HistoryViewMode;
        selectedItemPath: string; // e.g. "tx-1" or "tx-1/file-2"
        expandedIds: Set<string>; // holds ids of expanded items
        filterQuery: string;
        selectedForAction: Set<string>; // set of transaction IDs
        copyModeSelections: Set<string>;
        lastCopiedMessage: string | null;

        actions: {
            load: (initialState?: Partial<HistoryStateData>) => void;
            navigateDown: () => void;
            navigateUp: () => void;
            expandOrDrillDown: () => void;
            collapseOrBubbleUp: () => void;
            toggleSelection: () => void;
            setMode: (mode: HistoryViewMode) => void;
            setFilterQuery: (query: string) => void;
            applyFilter: () => void;
            toggleCopySelection: (field: string) => void;
            executeCopy: () => void;
            prepareDebugState: (stateName: 'l1-drill' | 'l2-drill' | 'filter' | 'copy' | 'bulk') => void;
        }
    }


    export const getVisibleItemPaths = (transactions: HistoryTransaction[],
    expandedIds: Set<string>): string[] => {
        const paths: string[] = [];
        for (const tx of transactions) {
            paths.push(tx.id);
            if (expandedIds.has(tx.id)) {
                for (const file of tx.files) {
                    paths.push(`${tx.id}/${file.id}`);
                }
            }
        }
        return paths;
    };


    // --- Store ---

    export const useTransactionHistoryStore =
    create<TransactionHistoryState>((set, get) => ({
        transactions: [],
        mode: 'LIST',
        selectedItemPath: 'tx-0',
        expandedIds: new Set(),
        filterQuery: '',
        selectedForAction: new Set(),
        copyModeSelections: new Set(['Git Messages', 'Reasonings']),
        lastCopiedMessage: null,

        actions: {
            load: (initialState) => {
                const transactions = TransactionService.createMockTransactions();
                set({
                    transactions,
                    selectedItemPath: transactions[0]?.id || '',
                    mode: 'LIST',
                    expandedIds: new Set(),
                    selectedForAction: new Set(),
                    filterQuery: '',
                    copyModeSelections: new Set(['Git Messages', 'Reasonings']),
                    lastCopiedMessage: null,
                    ...initialState,
                });
            },
            navigateUp: () => {
                const { transactions, expandedIds, selectedItemPath } = get();
                const visibleItems = getVisibleItemPaths(transactions, expandedIds);
                const currentIndex = visibleItems.indexOf(selectedItemPath);
                if (currentIndex > 0) {
                    set({ selectedItemPath: visibleItems[currentIndex - 1] });
                }
            },
            navigateDown: () => {
                const { transactions, expandedIds, selectedItemPath } = get();
                const visibleItems = getVisibleItemPaths(transactions, expandedIds);
                const currentIndex = visibleItems.indexOf(selectedItemPath);
                if (currentIndex < visibleItems.length - 1) {
                    set({ selectedItemPath: visibleItems[currentIndex + 1] });
                }
            },
            expandOrDrillDown: () => set(state => {
                const { selectedItemPath, expandedIds } = state;
                const newExpandedIds = new Set(expandedIds);
                if (!newExpandedIds.has(selectedItemPath)) {
                    newExpandedIds.add(selectedItemPath);
                }
                return { expandedIds: newExpandedIds };
            }),
            collapseOrBubbleUp: () => set(state => {
                const { selectedItemPath, expandedIds } = state;
                const newExpandedIds = new Set(expandedIds);
                if (newExpandedIds.has(selectedItemPath)) {
                    // If it's expanded, collapse it
                    newExpandedIds.delete(selectedItemPath);
                    
                    // Also collapse children
                    for (const id of newExpandedIds) {
                        if (id.startsWith(`${selectedItemPath}/`)) {
                            newExpandedIds.delete(id);
                        }
                    }

                    return { expandedIds: newExpandedIds };
                } else if (selectedItemPath.includes('/')) {
                    // If it's a file, move selection to parent transaction
                    const parentId = selectedItemPath.split('/')[0];
                    return { selectedItemPath: parentId || '' };
                }
                return {};
            }),
            toggleSelection: () => set(state => {
                const { selectedItemPath, selectedForAction } = state;
                const txId = selectedItemPath.split('/')[0];
                if (!txId) return {};

                const newSelection = new Set(selectedForAction);
                if (newSelection.has(txId)) {
                    newSelection.delete(txId);
                } else {
                    newSelection.add(txId);
                }
                return { selectedForAction: newSelection };
            }),
            setMode: (mode) => set({ mode, lastCopiedMessage: null }),
            setFilterQuery: (query) => set({ filterQuery: query }),
            applyFilter: () => {
                // In a real app, this would filter `transactions`.
                // For the demo, we just go back to LIST mode.
                set({ mode: 'LIST' });
            },
            toggleCopySelection: (field) => set(state => {
                const newSelections = new Set(state.copyModeSelections);
                if (newSelections.has(field)) {
                    newSelections.delete(field);
                } else {
                    newSelections.add(field);
                }
                return { copyModeSelections: newSelections };
            }),
            executeCopy: () => {
                 // Mock copy
                const { selectedForAction, copyModeSelections } = get();
                const message = `Copied ${Array.from(copyModeSelections).join(' & ')} from ${selectedForAction.size} transactions to clipboard.`;
                // In real app: clipboardy.writeSync(...)
                // eslint-disable-next-line no-console
                console.log(`[CLIPBOARD MOCK] ${message}`);
                set({ lastCopiedMessage: message });
            },
            prepareDebugState: (stateName) => {
                switch (stateName) {
                    case 'l1-drill':
                        get().actions.load({ expandedIds: new Set(['tx-0']), selectedItemPath: 'tx-0' });
                        break;
                    case 'l2-drill':
                        get().actions.load({ expandedIds: new Set(['tx-0', 'tx-0/0-1']), selectedItemPath: 'tx-0/0-1' });
                        break;
                    case 'filter':
                        get().actions.load({ mode: 'FILTER', filterQuery: 'logger.ts status:committed' });
                        break;
                    case 'copy':
                        get().actions.load({
                            mode: 'COPY',
                            selectedForAction: new Set(['tx-0', 'tx-2']),
                            copyModeSelections: new Set(['Git Messages', 'Diffs', 'UUIDs']),
                        });
                        break;
                    case 'bulk':
                        get().actions.load({ mode: 'BULK_ACTIONS', selectedForAction: new Set(['tx-0', 'tx-2']) });
                        break;
                }
            },
        },
    }));
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: '2025-09-22T07:10:10.664Z'
status: committed
id: 49
