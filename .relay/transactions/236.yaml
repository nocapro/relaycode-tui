uuid: 440938f3-ef5a-4933-bd54-5f11079d8544
projectId: relaycode-tui
createdAt: '2025-09-27T11:13:06.057Z'
gitCommitMsg: >-
  feat(ai): Overhaul AI processing screen for parallel simulation

  - Renamed AI processing steps to be more descriptive (prepare, request, parse,
  apply). - Reworked `runAutoFix` service to simulate parallel AI requests and
  patch applications, providing a more dynamic and realistic UI. - Aligned
  `AiProcessingScreen`'s `ProcessingStepRow` with `ReviewProcessingScreen` to
  remove duration timers from substeps for visual consistency. - Hooked up
  "Auto-repair with AI" option in the bulk repair menu.
promptSummary: >-
  I need to fix the AiProcessingScreen. The steps should be revised to reflect
  parallel requests and file applications. The animations should be similar to
  ReviewProcessingScreen.
reasoning:
  - >-
    Based on your request, I will revise the AI Processing screen to better
    simulate parallel processing for auto-repair, update the step names for
    clarity, and align its animations to be more consistent with the Review
    Processing screen.
  - 'Here are the step-by-step changes:'
  - >-
    1.  **Revise AI Processing Steps**: I'll update the step definitions in
    `src/constants/review.constants.ts` to be more descriptive of a multi-stage
    AI repair process: "Preparing prompts", "Requesting fixes", "Parsing
    responses", and "Applying patches".
  - >-
    2.  **Simulate Parallel Execution**: I will modify the `runAutoFix`
    simulation in `src/services/ai.service.ts`. The new simulation will:
  - '*   Show all file repair requests starting in parallel (multiple spinners).'
  - >-
    *   Simulate requests completing at different times, with some occasionally
    failing.
  - '*   Add a new parallel step for applying the generated patches to memory.'
  - >-
    3.  **Align Visuals with Review Screen**: To make the animation more similar
    to the `ReviewProcessingScreen`, I will update the `ProcessingStepRow`
    component in `src/components/AiProcessingScreen.tsx` to no longer display
    running timers on individual sub-steps, matching the behavior of its
    counterpart.
  - >-
    These changes will result in a more dynamic and informative UI that better
    reflects a parallel AI auto-repair workflow.
operations:
  - type: write
    path: src/components/AiProcessingScreen.tsx
    content: >+
      --- src/components/AiProcessingScreen.tsx

      +++ src/components/AiProcessingScreen.tsx

      @@ -12,29 +12,25 @@
           isSubstep?: boolean;
           now: number;
       }) => {
      -    let durationText = '';

      -    if (step.status === 'active' && step.startTime) {

      -        durationText = ` (${((now - step.startTime) /
      1000).toFixed(1)}s)`;

      -    } else if (step.duration) {

      -        durationText = ` (${step.duration.toFixed(1)}s)`;

      -    }

      -
           if (isSubstep) {
               let color: string | undefined;
               let symbol: React.ReactNode;
       
               switch (step.status) {
                   case 'pending': symbol = '○'; color = 'gray'; break;
                   case 'active': symbol = <Text color="cyan"><Spinner type="dots" /></Text>; break;
                   case 'done': symbol = '✓'; color = 'green'; break;
      -            case 'failed': symbol = '✗'; color = 'red'; break; // '✗' for
      substep failure

      +            case 'failed': symbol = '✗'; color = 'red'; break;
                   default: symbol = ' ';
               }
       
               return (
                   <Text>
      -                {'     └─ '}<Text color={color}>{symbol}</Text>{'
      '}{step.title}{durationText}

      +                {'     └─ '}<Text color={color}>{symbol}</Text>{'
      '}{step.title}
                   </Text>
               );
           }
       
      +    let durationText = '';

      +    // This logic is kept similar to ReviewProcessingScreen for
      consistency

      +    if (!isSubstep) {

      +        if (step.status === 'active' && step.startTime) {

      +            durationText = ` (${((now - step.startTime) /
      1000).toFixed(1)}s)`;

      +        } else if (step.duration) {

      +            durationText = ` (${step.duration.toFixed(1)}s)`;

      +        }

      +    }

      +
           let symbol;
           let color;
           switch (step.status) {

    patchStrategy: standard-diff
  - type: write
    path: src/constants/review.constants.ts
    content: >+
      --- src/constants/review.constants.ts

      +++ src/constants/review.constants.ts

      @@ -10,9 +10,10 @@
       ];
       
       export const INITIAL_AI_PROCESSING_STEPS: ApplyStep[] = [
      -    { id: 'prompt', title: 'Generating AI prompts...', status: 'pending'
      },

      -    { id: 'request', title: 'Sending requests to AI...', status:
      'pending', substeps: [] },

      -    { id: 'patch', title: 'Validating and formatting new patch...',
      status: 'pending' },

      +    { id: 'prompt', title: 'Preparing auto-repair prompts...', status:
      'pending' },

      +    { id: 'request', title: 'Requesting fixes from AI...', status:
      'pending', substeps: [] },

      +    { id: 'parse', title: 'Parsing AI responses...', status: 'pending' },

      +    { id: 'apply', title: 'Applying new patches...', status: 'pending',
      substeps: [] },
       ];
       
       export const REVIEW_BODY_VIEWS = {

    patchStrategy: standard-diff
  - type: write
    path: src/services/ai.service.ts
    content: >+
      --- src/services/ai.service.ts

      +++ src/services/ai.service.ts

      @@ -34,32 +34,48 @@
       
           yield { type: 'UPDATE_STEP', payload: { id: 'prompt', status: 'active' } };
           await sleep(200);
      -    // In a real app, you would generate a detailed prompt here.
           yield { type: 'UPDATE_STEP', payload: { id: 'prompt', status: 'done', details: `Generated prompts for ${failedFiles.length} files.` } };
       
           yield { type: 'UPDATE_STEP', payload: { id: 'request', status: 'active' } };
       
      -    // Use a larger list of files for a better demo
           const filesToFix: Pick<FileItem, 'id' | 'path'>[] = [
               ...failedFiles,
               ...mockAiFixFiles.slice(0, 20).map(path => ({ id: path, path })),
           ];
       
      -    for (const file of filesToFix) {

      +    // Start all fixes in parallel

      +    for (const file of filesToFix) {
               yield { type: 'ADD_SUBSTEP', payload: { parentId: 'request', substep: { id: file.id, title: `Fixing: ${file.path}`, status: 'active' }}};
      -        await sleep(Math.random() * 500 + 200); // Simulate network
      latency

      -        yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'request',
      substepId: file.id, status: 'done' }};
           }
      -    yield { type: 'UPDATE_STEP', payload: { id: 'request', status:
      'done', details: `Received responses from '${model}'` } };

      -    

      -    yield { type: 'UPDATE_STEP', payload: { id: 'patch', status: 'active'
      } };

      -    await sleep(500);

      -    // In a real app, this would be the actual patch from the AI.

      +

      +    // Simulate them finishing at different times

      +    const shuffledFiles = [...filesToFix].sort(() => Math.random() -
      0.5);

      +    for (const file of shuffledFiles) {

      +        await sleep(Math.random() * 200 + 50); // Simulate network
      latency + processing time

      +        const success = Math.random() > 0.1; // 90% success rate

      +        yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'request',
      substepId: file.id, status: success ? 'done' : 'failed' }};

      +    }

      +

      +    yield { type: 'UPDATE_STEP', payload: { id: 'request', status:
      'done', details: `Received responses for ${filesToFix.length} files from
      '${model}'` } };

      +

      +    yield { type: 'UPDATE_STEP', payload: { id: 'parse', status: 'active'
      } };

      +    await sleep(300);

      +    yield { type: 'UPDATE_STEP', payload: { id: 'parse', status: 'done',
      details: 'Validated and formatted AI responses.' } };

      +

      +    yield { type: 'UPDATE_STEP', payload: { id: 'apply', status: 'active'
      } };

      +    // In a real app, we'd only apply successful responses

      +    for (const file of filesToFix) {

      +        yield { type: 'ADD_SUBSTEP', payload: { parentId: 'apply',
      substep: { id: file.id, title: `Applying: ${file.path}`, status: 'active'
      }}};

      +    }

      +

      +    const shuffledApply = [...filesToFix].sort(() => Math.random() -
      0.5);

      +    for (const file of shuffledApply) {

      +        await sleep(Math.random() * 100 + 25);

      +        const success = Math.random() > 0.05; // 95% success rate

      +        yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'apply',
      substepId: file.id, status: success ? 'done' : 'failed' }};

      +    }

      +

      +    yield { type: 'UPDATE_STEP', payload: { id: 'apply', status: 'done',
      details: 'Applied patches to memory.' } };

      +

      +    // The structure of what's returned might change if we are applying
      multiple patches

      +    // but for now, we'll keep the existing signature.
           const newPatch = `--- a/src/services/payment.gateway.ts
       +++ b/src/services/payment.gateway.ts
       @@ -10,7 +10,7 @@
      @@ -68,11 +84,8 @@
       -    private static instance: PaymentGateway;
       +    private static instance: PaymentGateway | null = null;
            private apiKey: string;
       
            private constructor(apiKey: string) {
       `;
      -    yield { type: 'UPDATE_STEP', payload: { id: 'patch', status: 'done',
      details: 'Validated and formatted new patch.' } };

      -

      -    await sleep(500);
       
           return { newPatch };
       }

    patchStrategy: standard-diff
  - type: write
    path: src/stores/review.store.ts
    content: |
      <<<<<<< SEARCH
              executeBulkRepairOption: async (option) => {
                  const selectedTransactionId = useViewStore.getState().selectedTransactionId;
                  const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                  if (!tx?.files) return;

                  const failedFiles = tx.files.filter(
                      f => get().fileReviewStates.get(f.id)?.status === 'FAILED',
                  );
                  if (failedFiles.length === 0) {
                      set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                      return;
                  }

                  switch (option) {
                      case 1:
                          ReviewService.generateBulkRepairPrompt(failedFiles);
                          set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                          break;
                      case 2: {
                          set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                          failedFiles.forEach(f => get().actions.updateFileReviewStatus(f.id, 'RE_APPLYING'));
                          const results = await ReviewService.runBulkReapply(failedFiles);
                          results.forEach(result => {
                              get().actions.updateFileReviewStatus(
                                  result.id, result.status, result.error,
                              );
                          });
                          break;
                      }
                      case 3:
                          get().actions.setBodyView('confirm_handoff');
                          break;
                      case 4:
                          failedFiles.forEach(file => {
                              get().actions.updateFileReviewStatus(file.id, 'REJECTED');
                          });
                          set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                          break;
                      default:
                          set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                  }
              },
      =======
              executeBulkRepairOption: async (option) => {
                  const selectedTransactionId = useViewStore.getState().selectedTransactionId;
                  const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                  if (!tx?.files) return;

                  const failedFiles = tx.files.filter(
                      f => get().fileReviewStates.get(f.id)?.status === 'FAILED',
                  );
                  if (failedFiles.length === 0) {
                      set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                      return;
                  }

                  switch (option) {
                      case 1:
                          ReviewService.generateBulkRepairPrompt(failedFiles);
                          set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                          break;
                      case 2: {
                          set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                          failedFiles.forEach(f => get().actions.updateFileReviewStatus(f.id, 'RE_APPLYING'));
                          const results = await ReviewService.runBulkReapply(failedFiles);
                          results.forEach(result => {
                              get().actions.updateFileReviewStatus(
                                  result.id, result.status, result.error,
                              );
                          });
                          break;
                      }
                      case 3:
                          get().actions.setBodyView('confirm_handoff');
                          break;
                      case 4:
                          failedFiles.forEach(file => {
                              get().actions.updateFileReviewStatus(file.id, 'REJECTED');
                          });
                          set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                          break;
                      case 5: // AI Auto-repair
                          get().actions.startAiAutoFix();
                          break;
                      default:
                          set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                  }
              },
      >>>>>>> REPLACE
    patchStrategy: search-replace
snapshot:
  src/components/AiProcessingScreen.tsx: >-
    import { Box, Text } from 'ink';

    import Spinner from 'ink-spinner';

    import { type ApplyStep } from '../stores/review.store'; // ApplyStep can be
    reused

    import ActionFooter from './ActionFooter';

    import { useAiProcessingScreen } from '../hooks/useAiProcessingScreen';

    import Separator from './Separator';

    import ScreenLayout from './layout/ScreenLayout';


    // This component is based on ReviewProcessingScreen's ApplyStepRow,

    // but adapted to show durations for substeps as well.

    const ProcessingStepRow = ({ step, isSubstep = false, now }: {
        step: ApplyStep;
        isSubstep?: boolean;
        now: number;
    }) => {
        let durationText = '';
        if (step.status === 'active' && step.startTime) {
            durationText = ` (${((now - step.startTime) / 1000).toFixed(1)}s)`;
        } else if (step.duration) {
            durationText = ` (${step.duration.toFixed(1)}s)`;
        }

        if (isSubstep) {
            let color: string | undefined;
            let symbol: React.ReactNode;

            switch (step.status) {
                case 'pending': symbol = '○'; color = 'gray'; break;
                case 'active': symbol = <Text color="cyan"><Spinner type="dots" /></Text>; break;
                case 'done': symbol = '✓'; color = 'green'; break;
                case 'failed': symbol = '✗'; color = 'red'; break; // '✗' for substep failure
                default: symbol = ' ';
            }

            return (
                <Text>
                    {'     └─ '}<Text color={color}>{symbol}</Text>{' '}{step.title}{durationText}
                </Text>
            );
        }

        let symbol;
        let color;
        switch (step.status) {
            case 'pending': symbol = '( )'; break;
            case 'active': symbol = '(●)'; color = 'cyan'; break;
            case 'done': symbol = '[✓]'; color = 'green'; break;
            case 'failed': symbol = '[!]'; color = 'red'; break;
            case 'skipped': symbol = '(-)'; color = 'gray'; break;
        }

        return (
            <Box flexDirection="column">
                <Text>
                    <Text color={color}>{symbol}</Text> {step.title}{durationText}
                </Text>
                {step.details && (
                    <Text color="gray">
                        {'     └─ '}{step.details}
                    </Text>
                )}
                {step.substeps?.map((sub: ApplyStep, i: number) => (
                    <ProcessingStepRow key={i} step={sub} isSubstep={true} now={now} />
                ))}
            </Box>
        );
    };


    const AiProcessingScreen = () => {
        const {
            transaction,
            aiProcessingSteps,
            isProcessing,
            elapsedTime,
            now,
        } = useAiProcessingScreen();

        const renderFooter = () => {
            if (isProcessing) {
                return (
                    <Box flexDirection="column" gap={1}>
                        <Text>Elapsed: {elapsedTime.toFixed(1)}s · Processing... Please wait.</Text>
                        <Separator />
                        <ActionFooter actions={[{ key: 'Ctrl+C', label: 'Cancel Process' }]} />
                    </Box>
                );
            }
            return <Text>Elapsed: {elapsedTime.toFixed(1)}s · Repair complete. Transitioning...</Text>;
        };

        if (!transaction) {
            return <Text>Loading...</Text>;
        }

        const failedFilesCount = aiProcessingSteps.find(s => s.id === 'request')?.substeps?.length || 0;

        return (
            <ScreenLayout
                title="AI AUTO-REPAIR"
                footer={renderFooter()}
            >
                <Box flexDirection="column">
                    <Text>Attempting to auto-repair {failedFilesCount > 0 ? `${failedFilesCount} ` : ''}files... ({transaction.message})</Text>
                    <Box flexDirection="column" marginTop={1} gap={1}>
                        {aiProcessingSteps.map((step: ApplyStep) => <ProcessingStepRow key={step.id} step={step} now={now} />)}
                    </Box>
                </Box>
            </ScreenLayout>
        );
    };


    export default AiProcessingScreen;
  src/constants/review.constants.ts: |-
    import type { ApplyStep } from '../stores/review.store';
    import type { ActionItem } from '../types/actions.types';

    /**
     * Constants for the Review screen and process.
     */
    export const INITIAL_APPLY_STEPS: ApplyStep[] = [
        { id: 'snapshot', title: 'Reading initial file snapshot...', status: 'pending' },
        { id: 'memory', title: 'Applying operations to memory...', status: 'pending', substeps: [] },
        { id: 'post-command', title: 'Running post-command script...', status: 'pending', substeps: [] },
        { id: 'linter', title: 'Analyzing changes with linter...', status: 'pending', substeps: [] },
    ];

    export const INITIAL_AI_PROCESSING_STEPS: ApplyStep[] = [
        { id: 'prompt', title: 'Generating AI prompts...', status: 'pending' },
        { id: 'request', title: 'Sending requests to AI...', status: 'pending', substeps: [] },
        { id: 'patch', title: 'Validating and formatting new patch...', status: 'pending' },
    ];

    export const REVIEW_BODY_VIEWS = {
        COMMIT_MESSAGE: 'commit_message',
        DIFF: 'diff',
        PROMPT: 'prompt',
        REASONING: 'reasoning',
        SCRIPT_OUTPUT: 'script_output',
        BULK_REPAIR: 'bulk_repair',
        CONFIRM_HANDOFF: 'confirm_handoff',
        BULK_INSTRUCT: 'bulk_instruct',
        NONE: 'none',
    } as const;

    export const PATCH_STATUS = {
        SUCCESS: 'SUCCESS',
        PARTIAL_FAILURE: 'PARTIAL_FAILURE',
    } as const;

    export const BULK_REPAIR_OPTIONS = [
        '(1) Copy Bulk Re-apply Prompt (for single-shot AI)',
        '(2) Bulk Change Strategy & Re-apply',
        '(3) Handoff to External Agent',
        '(4) Bulk Abandon All Failed Files',
        '(5) Auto-repair with AI',
        '(Esc) Cancel',
    ] as const;

    export const BULK_INSTRUCT_OPTIONS = [
        '(1) Copy Bulk Re-instruct Prompt (for single-shot AI)',
        '(2) Handoff to External Agent',
        '(3) Bulk Un-reject All Files (revert to original)',
        '(4) Cancel',
    ] as const;

    interface ReviewFooterConfig {
        isFileSelected: boolean;
        fileStatus?: 'FAILED' | 'REJECTED' | 'OTHER';
        currentItemType?: 'file' | 'script' | 'reasoning' | 'prompt' | 'commit_message';
        hasFailedFiles: boolean;
        hasRejectedFiles: boolean;
        hasApprovedFiles: boolean;
    }

    export const REVIEW_FOOTER_ACTIONS = {
        DIFF_VIEW: [
            { key: '↑↓', label: 'Next/Prev File' },
            { key: 'PgUp/PgDn', label: 'Scroll' },
            { key: '←/D/Esc', label: 'Back' },
        ] as const,
        PROMPT_VIEW: [
            { key: '↑↓', label: 'Next/Prev Item' },
            { key: 'PgUp/PgDn', label: 'Scroll' },
            { key: '←/P/Ent', label: 'Collapse' },
            { key: 'C', label: 'Copy Mode' },
        ] as const,
        REASONING_VIEW: [
            { key: '↑↓', label: 'Next/Prev Item' },
            { key: 'PgUp/PgDn', label: 'Scroll' },
            { key: '←/R/Ent', label: 'Collapse' },
            { key: 'C', label: 'Copy Mode' },
        ] as const,
        COMMIT_MESSAGE_VIEW: [
            { key: '↑↓', label: 'Next/Prev Item' },
            { key: 'PgUp/PgDn', label: 'Scroll' },
            { key: '←/M/Ent', label: 'Collapse' },
            { key: 'C', label: 'Copy Mode' },
        ] as const,
        SCRIPT_OUTPUT_VIEW: [
            { key: '↑↓', label: 'Next/Prev Item' },
            { key: 'PgUp/PgDn', label: 'Scroll' },
            { key: 'J↓/K↑', label: 'Next/Prev Error' },
            { key: 'C', label: 'Copy Output' },
            { key: '←/Ent/Esc', label: 'Back' },
        ] as const,
        BULK_REPAIR_VIEW: { text: 'Use (↑↓) Nav · (Enter) Select · (1-4) Jump · (Esc) Cancel' } as const,
        BULK_INSTRUCT_VIEW: { text: 'Use (↑↓) Nav · (Enter) Select · (1-4) Jump · (Esc) Cancel' } as const,
        HANDOFF_CONFIRM_VIEW: [
            { key: 'Enter', label: 'Confirm Handoff' },
            { key: 'Esc', label: 'Cancel' },
        ] as const,
        MAIN_VIEW: (config: ReviewFooterConfig): ActionItem[] => {
            const actions: ActionItem[] = [{ key: '↑↓', label: 'Nav' }];

            if (config.isFileSelected) {
                if (config.fileStatus !== 'FAILED') actions.push({ key: 'Spc', label: 'Toggle' });
                actions.push({ key: 'D/Ent', label: 'Diff' });
                if (config.fileStatus === 'FAILED') actions.push({ key: 'T', label: 'Try Repair' });
                if (config.fileStatus === 'REJECTED') actions.push({ key: 'I', label: 'Instruct' });
            } else if (config.currentItemType === 'script') {
                actions.push({ key: 'Ent', label: 'Expand Details' });
            } else {
                actions.push({ key: 'Ent', label: 'Expand' });
            }

            actions.push({ key: 'M', label: 'Message' });
            actions.push({ key: 'P', label: 'Prompt' });
            actions.push({ key: 'R', label: 'Reasoning' });
            if (config.hasFailedFiles) actions.push({ key: 'Shift+T', label: 'Bulk Repair' });
            if (config.hasRejectedFiles) actions.push({ key: 'Shift+I', label: 'Bulk Instruct' });

            actions.push({ key: 'C', label: 'Copy' });

            if (config.hasApprovedFiles) actions.push({ key: 'A', label: 'Approve' });
            actions.push({ key: 'X', label: 'Reject Tx' });
            actions.push({ key: '←/Q/Esc', label: 'Back' });
            return actions;
        },
    };

    export const getReviewProcessingFooterActions = (
        isSkippable: boolean,
    ): readonly ActionItem[] => {
        const actions: ActionItem[] = [{ key: 'Ctrl+C', label: 'Cancel Process' }];
        if (isSkippable) {
            actions.push({ key: 'S', label: 'Skip Script' });
        }
        return actions;
    };
  src/services/ai.service.ts: |-
    import { useSettingsStore } from '../stores/settings.store';
    import { sleep } from '../utils';
    import type { Transaction, FileItem } from '../types/domain.types';

    // From review.service.ts to make the simulation more interesting
    const mockAiFixFiles = [
        'src/components/Button.tsx',
        'src/components/data-table/DataTable.tsx',
        'src/components/forms/Input.tsx',
        'src/hooks/useForm.ts',
        'src/hooks/useDebounce.ts',
        'src/styles/theme.css',
        'src/utils/string-formatters.ts',
        'src/pages/HomePage.tsx',
        'src/pages/AboutPage.tsx',
        'src/services/api-client.ts',
        'src/stores/user.store.ts',
        'src/constants/routes.ts',
        'src/features/auth/LoginScreen.tsx',
        'src/features/auth/SignupForm.tsx',
        'src/features/dashboard/components/OverviewChart.tsx',
        'src/features/settings/ProfileEditor.tsx',
        'src/core/App.tsx',
        'src/services/payment.gateway.ts',
        'src/services/notification.service.ts',
        'src/components/UserProfile.tsx',
    ];

    // Mock function to simulate running an auto-fix with an AI
    export async function* runAutoFix(
        failedFiles: FileItem[],
        _transaction: Transaction,
    ): AsyncGenerator<any, { newPatch: string }, unknown> {
        const { model } = useSettingsStore.getState();

        yield { type: 'UPDATE_STEP', payload: { id: 'prompt', status: 'active' } };
        await sleep(200);
        // In a real app, you would generate a detailed prompt here.
        yield { type: 'UPDATE_STEP', payload: { id: 'prompt', status: 'done', details: `Generated prompts for ${failedFiles.length} files.` } };

        yield { type: 'UPDATE_STEP', payload: { id: 'request', status: 'active' } };

        // Use a larger list of files for a better demo
        const filesToFix: Pick<FileItem, 'id' | 'path'>[] = [
            ...failedFiles,
            ...mockAiFixFiles.slice(0, 20).map(path => ({ id: path, path })),
        ];

        for (const file of filesToFix) {
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'request', substep: { id: file.id, title: `Fixing: ${file.path}`, status: 'active' }}};
            await sleep(Math.random() * 500 + 200); // Simulate network latency
            yield { type: 'UPDATE_SUBSTEP', payload: { parentId: 'request', substepId: file.id, status: 'done' }};
        }
        yield { type: 'UPDATE_STEP', payload: { id: 'request', status: 'done', details: `Received responses from '${model}'` } };
        
        yield { type: 'UPDATE_STEP', payload: { id: 'patch', status: 'active' } };
        await sleep(500);
        // In a real app, this would be the actual patch from the AI.
        const newPatch = `--- a/src/services/payment.gateway.ts
    +++ b/src/services/payment.gateway.ts
    @@ -10,7 +10,7 @@
      */
     export class PaymentGateway {
     -    private static instance: PaymentGateway;
    +    private static instance: PaymentGateway | null = null;
         private apiKey: string;
     
         private constructor(apiKey: string) {
    `;
        yield { type: 'UPDATE_STEP', payload: { id: 'patch', status: 'done', details: 'Validated and formatted new patch.' } };

        await sleep(500);

        return { newPatch };
    }

    export const AiService = {
        runAutoFix,
    };
  src/stores/review.store.ts: >-
    import { create } from 'zustand';

    import { useAppStore } from './app.store';

    import { useTransactionStore } from './transaction.store';

    import { useViewStore } from './view.store';

    import { AiService } from '../services/ai.service';

    import { ReviewService, type SimulationResult } from
    '../services/review.service';

    import { INITIAL_APPLY_STEPS, PATCH_STATUS, REVIEW_BODY_VIEWS,
    BULK_INSTRUCT_OPTIONS, BULK_REPAIR_OPTIONS, INITIAL_AI_PROCESSING_STEPS }
    from '../constants/review.constants';

    import { sleep } from '../utils';

    import type { FileReviewStatus } from '../types/domain.types';


    export interface ApplyStep {
        id: string;
        title: string;
        status: 'pending' | 'active' | 'done' | 'failed' | 'skipped';
        details?: string;
        substeps?: ApplyStep[];
        startTime?: number;
        duration?: number;
    }


    export type ReviewBodyView = (typeof REVIEW_BODY_VIEWS)[keyof typeof
    REVIEW_BODY_VIEWS];

    export type PatchStatus = (typeof PATCH_STATUS)[keyof typeof PATCH_STATUS];

    export type ApplyUpdate =
        | { type: 'UPDATE_STEP'; payload: { id: string; status: ApplyStep['status']; duration?: number; details?: string } }
        | { type: 'ADD_SUBSTEP'; payload: { parentId: string; substep: Omit<ApplyStep, 'substeps'> } }
        | { type: 'UPDATE_SUBSTEP'; payload: { parentId: string; substepId: string; status: ApplyStep['status']; title?: string } };

    interface ReviewState {
        patchStatus: PatchStatus;
        applySteps: ApplyStep[];
        selectedItemIndex: number;
        bodyView: ReviewBodyView;
        scriptErrorIndex: number;
        processingStartTime: number | null;
        fileReviewStates: Map<string, { status: FileReviewStatus; error?: string; details?: string }>;

        selectedBulkRepairOptionIndex: number;
        selectedBulkInstructOptionIndex: number;
        isCancelling: boolean;
        isSkipping: boolean;

        // AI auto-repair state
        aiProcessingSteps: ApplyStep[];
        aiProcessingStartTime: number | null;

        actions: {
            load: (transactionId: string, initialState?: Partial<Pick<ReviewState, 'bodyView' | 'selectedBulkRepairOptionIndex'>>) => void;
            setSelectedItemIndex: (index: number) => void;
            toggleBodyView: (view: Extract<
                ReviewBodyView, 'prompt' | 'bulk_instruct' | 'commit_message' |
                'diff' | 'reasoning' | 'script_output' | 'bulk_repair' | 'confirm_handoff'
            >) => void;
            setBodyView: (view: ReviewBodyView) => void;
            approve: () => void;
            rejectTransaction: () => void;
            startApplySimulation: (transactionId: string, scenario: 'success' | 'failure') => void;
            tryRepairFile: (fileId: string) => void;
            showBulkRepair: () => void;
            executeBulkRepairOption: (option: number) => Promise<void>;
            skipCurrentStep: () => void;
            resetSkip: () => void;
            tryInstruct: (fileId: string) => void;
            cancelProcessing: () => void;
            startAiAutoFix: () => void;
            showBulkInstruct: () => void;
            executeBulkInstructOption: (option: number) => Promise<void>;
            confirmHandoff: () => void;
            navigateScriptErrorUp: () => void;
            navigateScriptErrorDown: () => void;
            updateApplyStep: (id: string, status: ApplyStep['status'], details?: string) => void;
            addApplySubstep: (parentId: string, substep: Omit<ApplyStep, 'substeps'>) => void;
            updateApplySubstep: (parentId: string, substepId: string, status: ApplyStep['status'], title?: string) => void;
            updateAiProcessingStep: (id: string, status: ApplyStep['status'], details?: string) => void;
            addAiProcessingSubstep: (parentId: string, substep: Omit<ApplyStep, 'substeps'>) => void;
            updateAiProcessingSubstep: (parentId: string, substepId: string, status: ApplyStep['status'], title?: string) => void;
            updateFileReviewStatus: (fileId: string, status: FileReviewStatus, error?: string, details?: string) => void;
            toggleFileApproval: (fileId: string) => void;
            rejectAllFiles: () => void;
            navigateBulkRepairUp: () => void;
            navigateBulkRepairDown: () => void;
            navigateBulkInstructUp: () => void;
            navigateBulkInstructDown: () => void;
        };
    }


    export const useReviewStore = create<ReviewState>((set, get) => ({
        patchStatus: PATCH_STATUS.SUCCESS,
        applySteps: INITIAL_APPLY_STEPS,
        selectedItemIndex: 0,
        bodyView: REVIEW_BODY_VIEWS.NONE,
        scriptErrorIndex: 0,
        processingStartTime: null,
        fileReviewStates: new Map(),
        selectedBulkRepairOptionIndex: 0,
        selectedBulkInstructOptionIndex: 0,
        isCancelling: false,
        isSkipping: false,
        aiProcessingSteps: [],
        aiProcessingStartTime: null,

        actions: {
            load: (transactionId, initialState) => {
                const transaction = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!transaction) return;

                // This logic is preserved from the deleted `prepareTransactionForReview`
                // to allow debug screens to jump directly to a pre-populated review state
                // without running the full simulation.
                const isFailureCase = transaction.id === '1';
                const fileReviewStates = new Map<string, { status: FileReviewStatus; error?: string }>();
                (transaction.files || []).forEach((file, index) => {
                    if (isFailureCase) {
                        const isFailedFile = index > 0;
                        const status = isFailedFile ? 'FAILED' : 'APPROVED';
                        const error = isFailedFile ? (index === 1 ? 'Hunk #1 failed to apply' : 'Context mismatch at line 92') : undefined;
                        fileReviewStates.set(file.id, { status, error });
                    } else {
                        fileReviewStates.set(file.id, { status: 'APPROVED' });
                    }
                });
                const patchStatus = isFailureCase ? 'PARTIAL_FAILURE' : 'SUCCESS';
                useViewStore.getState().actions.setSelectedTransactionId(transaction.id);
                set({
                    patchStatus,
                    fileReviewStates,
                    processingStartTime: null,
                    selectedItemIndex: 0,
                    bodyView: initialState?.bodyView ?? REVIEW_BODY_VIEWS.NONE,
                    scriptErrorIndex: 0,
                    applySteps: JSON.parse(JSON.stringify(INITIAL_APPLY_STEPS)),
                    selectedBulkRepairOptionIndex: 0,
                    selectedBulkInstructOptionIndex: 0,
                    ...initialState,
                });
            },
            setSelectedItemIndex: (index) => set({ selectedItemIndex: index }),
            toggleBodyView: (view) => set(state => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                const files = tx?.files || [];
                if (view === 'diff' && state.selectedItemIndex >= files.length) return {};
                return {
                    bodyView: state.bodyView === view ? REVIEW_BODY_VIEWS.NONE : view,
                };
            }),
            setBodyView: (view) => set({ bodyView: view }),
            approve: () => {
                const { selectedTransactionId } = useViewStore.getState();
                if (selectedTransactionId) {
                    useTransactionStore.getState().actions.updateTransactionStatus(selectedTransactionId, 'APPLIED');
                    useAppStore.getState().actions.showDashboardScreen();
                }
            },
            rejectTransaction: () => {
                const { selectedTransactionId } = useViewStore.getState();
                if (selectedTransactionId) {
                    useTransactionStore.getState().actions.updateTransactionStatus(selectedTransactionId, 'REJECTED');
                    useAppStore.getState().actions.showDashboardScreen();
                }
            },
            startApplySimulation: async (transactionId, scenario) => {
                const transaction = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!transaction?.files) return;

                const { showReviewProcessingScreen, showReviewScreen } = useAppStore.getState().actions;
                const { updateApplyStep, addApplySubstep, updateApplySubstep } = get().actions;

                useViewStore.getState().actions.setSelectedTransactionId(transaction.id);
                set({
                    applySteps: JSON.parse(JSON.stringify(INITIAL_APPLY_STEPS)),
                    processingStartTime: Date.now(),
                    isCancelling: false,
                    isSkipping: false,
                    fileReviewStates: new Map(), // Clear previous states
                });

                showReviewProcessingScreen();
                const simulationGenerator = ReviewService.runApplySimulation(transaction.files, scenario);
                let simulationResult: SimulationResult;

                // Manually iterate to get the return value from the async generator
                const iterator = simulationGenerator[Symbol.asyncIterator]();
                while (true) {
                    const { value, done } = await iterator.next();
                    if (done) {
                        simulationResult = value as SimulationResult;
                        break;
                    }
                    const update = value;
                    if (update.type === 'UPDATE_STEP') {
                        updateApplyStep(update.payload.id, update.payload.status, update.payload.details);
                    } else if (update.type === 'ADD_SUBSTEP') {
                        addApplySubstep(update.payload.parentId, update.payload.substep);
                    } else if (update.type === 'UPDATE_SUBSTEP') {
                        updateApplySubstep(update.payload.parentId, update.payload.substepId, update.payload.status, update.payload.title);
                    }
                }

                await sleep(1000);
                set({
                    processingStartTime: null,
                    fileReviewStates: simulationResult.fileReviewStates,
                    patchStatus: simulationResult.patchStatus,
                });
                showReviewScreen();
            },
            tryRepairFile: (fileId) => {
                const selectedTransactionId = useViewStore.getState().selectedTransactionId;
                const { fileReviewStates } = get();
                if (!selectedTransactionId) return;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                const file = tx?.files?.find(f => f.id === fileId);
                if (!file) return;

                const { status, error } = fileReviewStates.get(file.id) || {};
                if (status !== 'FAILED') return;
                
                ReviewService.tryRepairFile(file, error);
                get().actions.updateFileReviewStatus(file.id, 'AWAITING');
            },
            tryInstruct: (fileId) => {
                const selectedTransactionId = useViewStore.getState().selectedTransactionId;
                const { fileReviewStates } = get();
                if (!selectedTransactionId) return;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                const file = tx?.files?.find(f => f.id === fileId);
                if (!tx || !file) return;

                const { status } = fileReviewStates.get(file.id) || {};
                if (status !== 'REJECTED') return;
                
                ReviewService.tryInstructFile(file, tx);
                get().actions.updateFileReviewStatus(file.id, 'AWAITING', undefined, 'Instruction prompt copied!');
            },
            showBulkInstruct: () => get().actions.setBodyView('bulk_instruct'),
            cancelProcessing: () => set({ isCancelling: true }),
            startAiAutoFix: async () => {
                const { selectedTransactionId } = useViewStore.getState();
                const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                if (!tx || !tx.files) return;

                const failedFiles = tx.files.filter(f => get().fileReviewStates.get(f.id)?.status === 'FAILED');
                if (failedFiles.length === 0) return;

                const { showAiProcessingScreen, showReviewScreen } = useAppStore.getState().actions;
                const { updateAiProcessingStep, addAiProcessingSubstep, updateAiProcessingSubstep } = get().actions;

                set({
                    bodyView: REVIEW_BODY_VIEWS.NONE,
                    aiProcessingSteps: JSON.parse(JSON.stringify(INITIAL_AI_PROCESSING_STEPS)),
                    aiProcessingStartTime: Date.now(),
                });

                showAiProcessingScreen();

                const autoFixGenerator = AiService.runAutoFix(failedFiles, tx);

                const iterator = autoFixGenerator[Symbol.asyncIterator]();
                while (true) {
                    const { value, done } = await iterator.next();
                    if (done) {
                        break;
                    }
                    const update = value;
                    if (update.type === 'UPDATE_STEP') {
                        updateAiProcessingStep(update.payload.id, update.payload.status, update.payload.details);
                    } else if (update.type === 'ADD_SUBSTEP') {
                        addAiProcessingSubstep(update.payload.parentId, update.payload.substep);
                    } else if (update.type === 'UPDATE_SUBSTEP') {
                        updateAiProcessingSubstep(update.payload.parentId, update.payload.substepId, update.payload.status, update.payload.title);
                    }
                }

                await sleep(1500); // Give user time to see final state
                set({ aiProcessingStartTime: null });
                showReviewScreen();
            },
            skipCurrentStep: () => set({ isSkipping: true }),
            resetSkip: () => set({ isSkipping: false }),
            executeBulkInstructOption: async (option) => {
                const selectedTransactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                if (!tx?.files) return;

                const rejectedFiles = tx.files.filter(
                    f => get().fileReviewStates.get(f.id)?.status === 'REJECTED',
                );
                if (rejectedFiles.length === 0) {
                    set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                    return;
                }

                switch (option) {
                    case 1:
                        ReviewService.generateBulkInstructPrompt(rejectedFiles, tx);
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                        break;
                    case 2:
                        get().actions.setBodyView('confirm_handoff');
                        break;
                    case 3:
                        rejectedFiles.forEach(file => {
                            get().actions.updateFileReviewStatus(file.id, 'APPROVED');
                        });
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                        break;
                    case 5:
                        get().actions.startAiAutoFix();
                        break;
                    default:
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                }
            },

            showBulkRepair: () => get().actions.toggleBodyView('bulk_repair'),
            executeBulkRepairOption: async (option) => {
                const selectedTransactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                if (!tx?.files) return;

                const failedFiles = tx.files.filter(
                    f => get().fileReviewStates.get(f.id)?.status === 'FAILED',
                );
                if (failedFiles.length === 0) {
                    set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                    return;
                }

                switch (option) {
                    case 1:
                        ReviewService.generateBulkRepairPrompt(failedFiles);
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                        break;
                    case 2: {
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                        failedFiles.forEach(f => get().actions.updateFileReviewStatus(f.id, 'RE_APPLYING'));
                        const results = await ReviewService.runBulkReapply(failedFiles);
                        results.forEach(result => {
                            get().actions.updateFileReviewStatus(
                                result.id, result.status, result.error,
                            );
                        });
                        break;
                    }
                    case 3:
                        get().actions.setBodyView('confirm_handoff');
                        break;
                    case 4:
                        failedFiles.forEach(file => {
                            get().actions.updateFileReviewStatus(file.id, 'REJECTED');
                        });
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                        break;
                    default:
                        set({ bodyView: REVIEW_BODY_VIEWS.NONE });
                }
            },
            confirmHandoff: () => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!tx?.files) return;
                const { fileReviewStates } = get();
                ReviewService.generateHandoffPrompt(tx, fileReviewStates);
                ReviewService.performHandoff(tx.hash);
            },
            navigateScriptErrorUp: () => set(state => ({ scriptErrorIndex: Math.max(0, state.scriptErrorIndex - 1) })),
            navigateScriptErrorDown: () => set(state => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!tx?.scripts || !tx?.files) return {};
                const selectedScript = tx.scripts[state.selectedItemIndex - tx.files.length];
                if (selectedScript?.output) {
                    const errorLines = selectedScript.output
                        .split('\n')
                        .filter(line => line.includes('Error') || line.includes('Warning'));
                    return { scriptErrorIndex: Math.min(errorLines.length - 1, state.scriptErrorIndex + 1) };
                }
                return {};
            }),
            updateApplyStep: (id, status, details) => {
                set(state => {
                    const newSteps = state.applySteps.map(s => {
                        if (s.id === id) {
                            const newStep: ApplyStep = { ...s, status };
                            if (status === 'active') {
                                newStep.startTime = Date.now();
                            } else if ((status === 'done' || status === 'failed' || status === 'skipped') && s.startTime) {
                                newStep.duration = (Date.now() - s.startTime) / 1000;
                            }
                            if (details !== undefined) newStep.details = details;
                            return newStep;
                        }
                        return s;
                    });
                    return { applySteps: newSteps };
                });
            },
            updateApplySubstep: (parentId, substepId, status, title) => {
                set(state => ({
                    applySteps: state.applySteps.map(s => {
                        if (s.id === parentId && s.substeps) {
                            const newSubsteps = s.substeps.map(sub => {
                                if (sub.id === substepId) {
                                    const newSub: ApplyStep = { ...sub, status };
                                    if (status === 'active') {
                                        newSub.startTime = Date.now();
                                    } else if ((status === 'done' || status === 'failed') && sub.startTime) {
                                        newSub.duration = (Date.now() - sub.startTime) / 1000;
                                    }
                                    if (title) newSub.title = title;
                                    return newSub;
                                }
                                return sub;
                            });
                            return { ...s, substeps: newSubsteps };
                        }
                        return s;
                    }),
                }));
            },
            addApplySubstep: (parentId, substep) => {
                set(state => ({
                    applySteps: state.applySteps.map(s => {
                        if (s.id === parentId) {
                            const newSubsteps = [...(s.substeps || []), substep as ApplyStep];
                            return { ...s, substeps: newSubsteps };
                        }
                        return s;
                    }),
                }));
            },
            updateAiProcessingStep: (id, status, details) => {
                set(state => {
                    const newSteps = state.aiProcessingSteps.map(s => {
                        if (s.id === id) {
                            const newStep: ApplyStep = { ...s, status };
                            if (status === 'active') {
                                newStep.startTime = Date.now();
                            } else if ((status === 'done' || status === 'failed' || status === 'skipped') && s.startTime) {
                                newStep.duration = (Date.now() - s.startTime) / 1000;
                            }
                            if (details !== undefined) newStep.details = details;
                            return newStep;
                        }
                        return s;
                    });
                    return { aiProcessingSteps: newSteps };
                });
            },
            updateAiProcessingSubstep: (parentId, substepId, status, title) => {
                set(state => ({
                    aiProcessingSteps: state.aiProcessingSteps.map(s => {
                        if (s.id === parentId && s.substeps) {
                            const newSubsteps = s.substeps.map(sub => {
                                if (sub.id === substepId) {
                                    const newSub: ApplyStep = { ...sub, status };
                                    if (status === 'active') {
                                        newSub.startTime = Date.now();
                                    } else if ((status === 'done' || status === 'failed') && sub.startTime) {
                                        newSub.duration = (Date.now() - sub.startTime) / 1000;
                                    }
                                    if (title) newSub.title = title;
                                    return newSub;
                                }
                                return sub;
                            });
                            return { ...s, substeps: newSubsteps };
                        }
                        return s;
                    }),
                }));
            },
            addAiProcessingSubstep: (parentId, substep) => {
                set(state => ({
                    aiProcessingSteps: state.aiProcessingSteps.map(s => {
                        if (s.id === parentId) {
                            const newSubsteps = [...(s.substeps || []), substep as ApplyStep];
                            return { ...s, substeps: newSubsteps };
                        }
                        return s;
                    }),
                }));
            },
            updateFileReviewStatus: (fileId, status, error, details) => {
                set(state => {
                    const newStates = new Map(state.fileReviewStates);
                    newStates.set(fileId, { status, error, details });
                    return { fileReviewStates: newStates };
                });
            },
            toggleFileApproval: (fileId) => {
                set(state => {
                    const newStates = new Map(state.fileReviewStates);
                    const current = newStates.get(fileId);
                    if (current) {
                        const newStatus: FileReviewStatus = current.status === 'APPROVED' ? 'REJECTED' : 'APPROVED';
                        newStates.set(fileId, { status: newStatus, error: undefined, details: undefined });
                    }
                    return { fileReviewStates: newStates };
                });
            },
            rejectAllFiles: () => {
                set(state => {
                    const newStates = new Map(state.fileReviewStates);
                    for (const [fileId, reviewState] of newStates.entries()) {
                        if (reviewState.status === 'APPROVED') {
                            newStates.set(fileId, { status: 'REJECTED', error: undefined, details: undefined });
                        }
                    }
                    return { fileReviewStates: newStates };
                });
            },
            navigateBulkRepairUp: () => set(state => ({
                selectedBulkRepairOptionIndex: (state.selectedBulkRepairOptionIndex - 1 + BULK_REPAIR_OPTIONS.length) % BULK_REPAIR_OPTIONS.length,
            })),
            navigateBulkRepairDown: () => set(state => ({
                selectedBulkRepairOptionIndex: (state.selectedBulkRepairOptionIndex + 1) % BULK_REPAIR_OPTIONS.length,
            })),
            navigateBulkInstructUp: () => set(state => ({
                selectedBulkInstructOptionIndex: (state.selectedBulkInstructOptionIndex - 1 + BULK_INSTRUCT_OPTIONS.length) % BULK_INSTRUCT_OPTIONS.length,
            })),
            navigateBulkInstructDown: () => set(state => ({
                selectedBulkInstructOptionIndex: (state.selectedBulkInstructOptionIndex + 1) % BULK_INSTRUCT_OPTIONS.length,
            })),
        },
    }));
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 236
