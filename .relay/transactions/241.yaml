uuid: c25cfb34-8c08-4e89-9a74-d45a90d96d93
projectId: relaycode-tui
createdAt: '2025-09-27T23:41:26.492Z'
gitCommitMsg: >-
  feat(clipboard): implement global pause/resume hotkey

  Introduces a global 'p' hotkey to pause and resume clipboard watching from any
  screen.

  - The dashboard status (LISTENING/PAUSED) is now managed centrally in
    `useDashboardStore` and triggered via `useGlobalHotkeys`.
  - Pressing 'p' copies a system prompt to the clipboard. - The `ScreenLayout`
  header now displays a persistent status icon (●/||)
    and a transient text notification upon state change.
  - The local 'p' hotkey has been removed from the dashboard screen.
promptSummary: >-
  Implement a global pause/resume hotkey for the clipboard watcher with header
  feedback.
reasoning:
  - >-
    Here are the changes to implement the global clipboard pause/resume hotkey.
    I've centralized the state management, made the hotkey global, and updated
    the main screen layout to provide both persistent and transient feedback in
    the header as you requested.
  - >-
    First, I'll update the view store to handle the transient header messages
    that will appear when the clipboard listening state changes.
  - >-
    Next, I'll add the required functionality to the `ClipboardService`,
    including a function to copy the system prompt to the clipboard when the
    listening state is toggled.
  - >-
    Now, I'll modify the `dashboard.store.ts` to orchestrate the state change,
    UI feedback, and clipboard copy action.
  - >-
    With the core logic in place, I'll move the `'p'` hotkey from being
    dashboard-specific to global by adding it to `useGlobalHotkeys`.
  - >-
    Consequently, I'll remove the now-redundant local hotkey from the dashboard
    screen hook.
  - >-
    Finally, I will update the `ScreenLayout` component to display both the
    persistent status icon and the transient status message in the header.
  - >-
    These changes fully implement the global clipboard pause/resume feature as
    specified.
operations:
  - type: write
    path: src/stores/view.store.ts
    content: >+
      --- src/stores/view.store.ts

      +++ src/stores/view.store.ts

      @@ -5,9 +5,11 @@
       interface ViewState {
           selectedTransactionId: string | null;
           activeOverlay: Overlay;
      +    headerStatus: { message: string; timestamp: number } | null;
           actions: {
               setSelectedTransactionId: (id: string | null) => void;
               setActiveOverlay: (overlay: ViewState['activeOverlay']) => void;
      +        setHeaderStatus: (message: string) => void;
           };
       }
       
       export const useViewStore = create<ViewState>((set) => ({
           selectedTransactionId: null,
           activeOverlay: OVERLAYS.NONE,
      +    headerStatus: null,
           actions: {
               setSelectedTransactionId: (id) => set({ selectedTransactionId: id }),
               setActiveOverlay: (overlay) => set({ activeOverlay: overlay }),
      +        setHeaderStatus: (message) => set({ headerStatus: { message,
      timestamp: Date.now() } }),
           },
       }));

    patchStrategy: standard-diff
  - type: write
    path: src/services/clipboard.service.ts
    content: >+
      --- src/services/clipboard.service.ts

      +++ src/services/clipboard.service.ts

      @@ -1,6 +1,7 @@
       import { useTransactionStore, type Transaction } from '../stores/transaction.store';
       import { useNotificationStore } from '../stores/notification.store';
       import { useReviewStore } from '../stores/review.store';
       import { LoggerService } from './logger.service';
      +import clipboardy from 'clipboardy';
       
       const MOCK_VALID_PATCH = `diff --git a/src/components/Button.tsx b/src/components/Button.tsx
       index 12345..67890 100644
      @@ -14,6 +15,16 @@
       
       const MOCK_INVALID_TEXT = 'This is just some regular text, not a patch.';
       
      +const MOCK_SYSTEM_PROMPT = `You are an expert AI programmer. To modify a
      file, you MUST use a code block with a specified patch strategy.

      +

      +**Syntax:**

      +\`\`\`typescript // filePath {patchStrategy}

      +... content ...

      +\`\`\`

      +- \`filePath\`: The path to the file. **If the path contains spaces, it
      MUST be enclosed in double quotes.**

      +- \`patchStrategy\`: (Optional) One of \`standard-diff\`,
      \`search-replace\`. If omitted, the entire file is replaced (this is the
      \`replace\` strategy).

      +`;

      +
       const createTransactionFromPatch = (patchContent: string): Transaction => {
           // In a real app, we would parse this. For demo, we'll create a mock.
           const lines = patchContent.split('\n');
      @@ -54,6 +65,29 @@
           };
       };
       
      +const copySystemPrompt = async () => {

      +    try {

      +        await clipboardy.write(MOCK_SYSTEM_PROMPT);

      +        LoggerService.info('System prompt copied to clipboard.');

      +        useNotificationStore.getState().actions.show({

      +            type: 'success',

      +            title: 'Clipboard Updated',

      +            message: 'System prompt has been copied to your clipboard.',

      +            duration: 2,

      +        });

      +    } catch (error) {

      +        LoggerService.error(`Failed to copy system prompt to clipboard:
      ${error}`);

      +        useNotificationStore.getState().actions.show({

      +            type: 'error',

      +            title: 'Clipboard Error',

      +            message: 'Could not copy system prompt to clipboard.',

      +            duration: 3,

      +        });

      +    }

      +};

      +
       /**
        * Simulates processing the clipboard content.
        * @param forceValidPatch For debug purposes, force the outcome. If undefined, it will be random.
      @@ -99,4 +133,5 @@
       
       export const ClipboardService = {
           processClipboardContent,
      +    copySystemPrompt,
       };

    patchStrategy: standard-diff
  - type: write
    path: src/stores/dashboard.store.ts
    content: >+
      --- src/stores/dashboard.store.ts

      +++ src/stores/dashboard.store.ts

      @@ -1,7 +1,9 @@
       import { create } from 'zustand';
       import { useTransactionStore } from './transaction.store';
       import { DashboardService } from '../services/dashboard.service';
       import { DASHBOARD_STATUS } from '../constants/dashboard.constants';
      +import { useViewStore } from './view.store';

      +import { ClipboardService } from '../services/clipboard.service';
       
       export type DashboardStatus = (typeof DASHBOARD_STATUS)[keyof typeof DASHBOARD_STATUS];
        
      @@ -25,10 +27,21 @@
           selectedTransactionIndex: 0,
           expandedTransactionId: null,
           actions: {
      -        togglePause: () => set(state => ({

      -            status: state.status === DASHBOARD_STATUS.LISTENING ?
      DASHBOARD_STATUS.PAUSED : DASHBOARD_STATUS.LISTENING,

      -        })),

      +        togglePause: () => {

      +            const newStatus = get().status === DASHBOARD_STATUS.LISTENING

      +                ? DASHBOARD_STATUS.PAUSED

      +                : DASHBOARD_STATUS.LISTENING;

      +

      +            set({ status: newStatus });

      +

      +            const message = newStatus === DASHBOARD_STATUS.PAUSED

      +                ? 'CLIPBOARD PAUSED'

      +                : 'CLIPBOARD LISTENING';

      +            useViewStore.getState().actions.setHeaderStatus(message);

      +            ClipboardService.copySystemPrompt();

      +        },
               startApproveAll: () => set(state => ({
                   status: DASHBOARD_STATUS.CONFIRM_APPROVE,
                   previousStatus: state.status,

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useGlobalHotkeys.tsx
    content: |+
      --- src/hooks/useGlobalHotkeys.tsx
      +++ src/hooks/useGlobalHotkeys.tsx
      @@ -2,6 +2,7 @@
       import { useAppStore } from '../stores/app.store';
       import { useViewStore } from '../stores/view.store';
       import { OVERLAYS } from '../constants/view.constants';
       import { ClipboardService } from '../services/clipboard.service';
      +import { useDashboardStore } from '../stores/dashboard.store';
       
       export const useGlobalHotkeys = ({ isActive }: { isActive: boolean }) => {
           const { exit } = useApp();
      @@ -28,6 +29,11 @@
                   return;
               }
       
      +        if (input.toLowerCase() === 'p') {
      +            useDashboardStore.getState().actions.togglePause();
      +            return;
      +        }
      +
               // If an overlay with its own input is open, stop here.
               if (activeOverlay === OVERLAYS.DEBUG || activeOverlay === OVERLAYS.LOG) {
                   return;

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useDashboardScreen.tsx
    content: |+
      --- src/hooks/useDashboardScreen.tsx
      +++ src/hooks/useDashboardScreen.tsx
      @@ -48,7 +48,6 @@
           }, [transactions]);
       
           const {
      -        togglePause,
               startApproveAll,
               confirmAction,
               cancelAction,
      @@ -95,7 +94,6 @@
                       return;
                   }
                   if (key.return) viewDetails();
      -            if (input.toLowerCase() === 'p') togglePause();
                   if (input.toLowerCase() === 'a' && pendingApprovals > 0) startApproveAll();
                   if (input.toLowerCase() === 'c' && pendingCommits > 0) {
                       commitActions.prepareCommitScreen();

    patchStrategy: standard-diff
  - type: write
    path: src/components/layout/ScreenLayout.tsx
    content: >+
      --- src/components/layout/ScreenLayout.tsx

      +++ src/components/layout/ScreenLayout.tsx

      @@ -1,5 +1,8 @@

      +import { useState, useEffect } from 'react';
       import { Box, Text } from 'ink';
       import Separator from '../Separator';
      +import { useViewStore } from '../../stores/view.store';

      +import { useDashboardStore } from '../../stores/dashboard.store';

      +import { DASHBOARD_STATUS } from '../../constants/dashboard.constants';
       
       interface ScreenLayoutProps {
           title: string;
      @@ -9,12 +12,32 @@
       }
       
       const ScreenLayout = ({ title, footer, children, contextInfo }: ScreenLayoutProps) => {
      +    const headerStatus = useViewStore(s => s.headerStatus);

      +    const dashboardStatus = useDashboardStore(s => s.status);

      +    const [visibleStatus, setVisibleStatus] = useState<string |
      null>(null);

      +

      +    useEffect(() => {

      +        if (!headerStatus) return;

      +

      +        setVisibleStatus(headerStatus.message);

      +

      +        const timer = setTimeout(() => {

      +            setVisibleStatus(null);

      +        }, 2000);

      +

      +        return () => clearTimeout(timer);

      +    }, [headerStatus]);

      +

      +    const isListening = dashboardStatus === DASHBOARD_STATUS.LISTENING;

      +
           return (
               <Box flexDirection="column" flexGrow={1}>
                   <Box flexDirection="row">
                       <Text bold color="black" backgroundColor="yellow"> ▲ relaycode · {title} </Text>
                       <Box flexGrow={1} />
      -                {contextInfo && <Text color="gray">{contextInfo}</Text>}

      +                {contextInfo && <Text color="gray">{contextInfo} </Text>}

      +                <Text color={isListening ? 'green' : 'yellow'}>
      {isListening ? '●' : '||'} </Text>

      +                {visibleStatus && <Text color="yellow" bold> ·
      {visibleStatus}</Text>}
                   </Box>
                   <Separator />
                   <Box flexDirection="column" flexGrow={1} marginY={1}>

    patchStrategy: standard-diff
snapshot:
  src/stores/view.store.ts: |-
    import { create } from 'zustand';
    import { OVERLAYS } from '../constants/view.constants';

    export type Overlay = (typeof OVERLAYS)[keyof typeof OVERLAYS];

    interface ViewState {
        selectedTransactionId: string | null;
        activeOverlay: Overlay;
        actions: {
            setSelectedTransactionId: (id: string | null) => void;
            setActiveOverlay: (overlay: ViewState['activeOverlay']) => void;
        };
    }

    export const useViewStore = create<ViewState>((set) => ({
        selectedTransactionId: null,
        activeOverlay: OVERLAYS.NONE,
        actions: {
            setSelectedTransactionId: (id) => set({ selectedTransactionId: id }),
            setActiveOverlay: (overlay) => set({ activeOverlay: overlay }),
        },
    }));
  src/services/clipboard.service.ts: >-
    import { useTransactionStore, type Transaction } from
    '../stores/transaction.store';

    import { useNotificationStore } from '../stores/notification.store';

    import { useReviewStore } from '../stores/review.store';

    import { LoggerService } from './logger.service';


    const MOCK_VALID_PATCH = `diff --git a/src/components/Button.tsx
    b/src/components/Button.tsx

    index 12345..67890 100644

    --- a/src/components/Button.tsx

    +++ b/src/components/Button.tsx

    @@ -1,5 +1,6 @@

    -import React from 'react';

    +import React, { useState } from 'react';

     const Button = () => <button>Click Me</button>;

     export default Button;
    `;


    const MOCK_INVALID_TEXT = 'This is just some regular text, not a patch.';


    const createTransactionFromPatch = (patchContent: string): Transaction => {
        // In a real app, we would parse this. For demo, we'll create a mock.
        const lines = patchContent.split('\n');
        const linesAdded = lines.filter(l => l.startsWith('+')).length;
        const linesRemoved = lines.filter(l => l.startsWith('-')).length;
        const filePath = lines.find(l => l.startsWith('--- a/'))?.split(' a/')[1] || 'unknown/file.ts';

        return {
            id: (Math.random() * 1000).toFixed(0),
            timestamp: Date.now(),
            status: 'PENDING',
            hash: Math.random().toString(16).substring(2, 10),
            message: 'feat: apply patch from clipboard',
            prompt: 'A patch was manually pasted into the application.',
            reasoning: 'The user pasted clipboard content which was identified as a valid patch and processed into a new transaction.',
            files: [
                {
                    id: `${(Math.random() * 1000).toFixed(0)}-1`,
                    type: 'MOD',
                    path: filePath,
                    linesAdded,
                    linesRemoved,
                    diff: patchContent,
                    strategy: 'standard-diff',
                },
            ],
            stats: {
                files: 1,
                linesAdded,
                linesRemoved,
            },
        };
    };


    /**
     * Simulates processing the clipboard content.
     * @param forceValidPatch For debug purposes, force the outcome. If undefined, it will be random.
     */
    const processClipboardContent = async (forceValidPatch?: boolean) => {
        LoggerService.info('Manual paste detected. Processing clipboard content...');
        
        // Simulate reading from clipboardy
        const isActuallyValid = forceValidPatch === true || (forceValidPatch === undefined && Math.random() > 0.5);
        const clipboardContent = isActuallyValid ? MOCK_VALID_PATCH : MOCK_INVALID_TEXT;

        // Simulate checking if it's a valid patch
        if (clipboardContent.includes('diff --git')) {
            LoggerService.debug('Valid patch detected in clipboard. Creating transaction.');
            const newTransaction = createTransactionFromPatch(clipboardContent);

            // Add to store so it exists for the review process
            useTransactionStore.getState().actions.addTransaction(newTransaction);

            // Immediately start the review simulation
            LoggerService.debug(`Starting apply simulation for new transaction ${newTransaction.id}`);
            // Forcing 'success' scenario for pasted patches. The simulation itself can
            // result in a failure state which is then handled by the review screen.
            useReviewStore.getState().actions.startApplySimulation(newTransaction.id, 'success');

            useNotificationStore.getState().actions.show({
                type: 'info',
                title: 'Processing Pasted Patch',
                message: `Applying new transaction "${newTransaction.hash}"...`,
                duration: 2,
            });
        } else {
            LoggerService.debug('No valid patch detected in clipboard content.');
            useNotificationStore.getState().actions.show({
                type: 'info',
                title: 'Clipboard Ignored',
                message: 'Pasted content was not a valid patch.',
                duration: 3,
            });
        }
    };


    export const ClipboardService = {
        processClipboardContent,
    };
  src/stores/dashboard.store.ts: >-
    import { create } from 'zustand';

    import { useTransactionStore } from './transaction.store';

    import { DashboardService } from '../services/dashboard.service';

    import { DASHBOARD_STATUS } from '../constants/dashboard.constants';


    export type DashboardStatus = (typeof DASHBOARD_STATUS)[keyof typeof
    DASHBOARD_STATUS];
     
    interface DashboardState {
        status: DashboardStatus;
        previousStatus: DashboardStatus;
        selectedTransactionIndex: number;
        expandedTransactionId: string | null;
        actions: {
            togglePause: () => void;
            startApproveAll: () => void;
            confirmAction: () => Promise<void>;
            cancelAction: () => void;
            setStatus: (status: DashboardStatus) => void;
            toggleExpand: () => void;
            setExpandedTransactionId: (id: string | null) => void;
            setSelectedIndex: (index: number) => void;
        };
    }


    export const useDashboardStore = create<DashboardState>((set, get) => ({
        status: DASHBOARD_STATUS.LISTENING,
        previousStatus: DASHBOARD_STATUS.LISTENING,
        selectedTransactionIndex: 0,
        expandedTransactionId: null,
        actions: {
            togglePause: () => set(state => ({
                status: state.status === DASHBOARD_STATUS.LISTENING ? DASHBOARD_STATUS.PAUSED : DASHBOARD_STATUS.LISTENING,
            })),
            startApproveAll: () => set(state => ({
                status: DASHBOARD_STATUS.CONFIRM_APPROVE,
                previousStatus: state.status,
            })),
            cancelAction: () => set(state => ({ status: state.previousStatus })),
            setStatus: (status) => set({ status }),
            confirmAction: async () => { // The `if` is redundant as this is only called from that state.
                const previousStatus = get().previousStatus;
                set({ status: DASHBOARD_STATUS.APPROVING });
                await DashboardService.approveAll();
                set({ status: previousStatus });
            },
            toggleExpand: () => {
                const { selectedTransactionIndex, expandedTransactionId } = get();
                const { transactions } = useTransactionStore.getState();
                const selectedTx = transactions[selectedTransactionIndex];
                if (!selectedTx) return;

                if (expandedTransactionId === selectedTx.id) {
                    set({ expandedTransactionId: null });
                } else {
                    set({ expandedTransactionId: selectedTx.id });
                }
            },
            setExpandedTransactionId: (id) => set({ expandedTransactionId: id }),
            setSelectedIndex: (index) => set({ selectedTransactionIndex: index }),
        },
    }));
  src/hooks/useGlobalHotkeys.tsx: |-
    import { useApp, useInput } from 'ink';
    import { useAppStore } from '../stores/app.store';
    import { useViewStore } from '../stores/view.store';
    import { OVERLAYS } from '../constants/view.constants';
    import { ClipboardService } from '../services/clipboard.service';

    export const useGlobalHotkeys = ({ isActive }: { isActive: boolean }) => {
        const { exit } = useApp();
        const { navigateBack } = useAppStore(s => s.actions);
        const { activeOverlay, setActiveOverlay } = useViewStore(s => ({
            activeOverlay: s.activeOverlay,
            setActiveOverlay: s.actions.setActiveOverlay,
        }));

        useInput((input, key) => {
            // Debug Menu toggle is the highest priority global key
            if (key.ctrl && input === 'b') {
                setActiveOverlay(activeOverlay === OVERLAYS.DEBUG ? OVERLAYS.NONE : OVERLAYS.DEBUG);
                return;
            }
            if (key.ctrl && input === 'l') {
                setActiveOverlay(activeOverlay === OVERLAYS.LOG ? OVERLAYS.NONE : OVERLAYS.LOG);
                return;
            }
            if (key.ctrl && input === 's') {
                // This is a temporary location. In a real app, this might live elsewhere
                // or be disabled on certain screens.
                useAppStore.getState().actions.showSettingsScreen();
            }

            if (key.ctrl && input === 'v') {
                ClipboardService.processClipboardContent();
                return;
            }

            // If an overlay with its own input is open, stop here.
            if (activeOverlay === OVERLAYS.DEBUG || activeOverlay === OVERLAYS.LOG) {
                return;
            }

            // Help screen takes precedence over other keys
            if (activeOverlay === OVERLAYS.HELP) {
                if (key.escape || input === '?') {
                    setActiveOverlay(OVERLAYS.NONE);
                }
                return;
            }

            // --- Global hotkeys when no modal/overlay is open ---
            
            // Open Help
            if (input === '?') {
                setActiveOverlay(OVERLAYS.HELP);
                return;
            }
            
            // Quit from main screens
            if (input.toLowerCase() === 'q' || key.escape) {
                const screenBefore = useAppStore.getState().currentScreen;
                navigateBack();
                const screenAfter = useAppStore.getState().currentScreen;

                // If navigateBack did not change the screen, it means we are on a root screen.
                if (screenBefore === screenAfter) {
                    exit();
                }
            }
        }, { isActive });
    };
  src/hooks/useDashboardScreen.tsx: >-
    import { useState, useEffect, useRef, useMemo } from 'react';

    import { useInput } from 'ink';

    import { useDashboardStore } from '../stores/dashboard.store';

    import { useAppStore } from '../stores/app.store';

    import { useCommitStore } from '../stores/commit.store';

    import { useTransactionStore, selectTransactionsByStatus } from
    '../stores/transaction.store';

    import { useReviewStore } from '../stores/review.store';

    import { useDetailStore } from '../stores/detail.store';

    import { useHistoryStore } from '../stores/history.store';

    import type { LayoutConfig } from './useLayout';

    import { DASHBOARD_STATUS } from '../constants/dashboard.constants';

    import { useViewport } from './useViewport';

    import { useListNavigator } from './useListNavigator';

    import path from 'node:path';

    import { execSync } from 'node:child_process';


    export const useDashboardScreen = ({ layoutConfig }: { layoutConfig:
    LayoutConfig }) => {
        const {
            status,
            selectedTransactionIndex,
            expandedTransactionId,
        } = useDashboardStore();
        const transactions = useTransactionStore(s => s.transactions);
        const [newTransactionIds, setNewTransactionIds] = useState(new Set<string>());
        const prevTransactionIds = useRef(new Set(transactions.map(t => t.id)));

        const pendingTransactions = useTransactionStore(selectTransactionsByStatus('PENDING'));
        const appliedTransactions = useTransactionStore(selectTransactionsByStatus('APPLIED'));

        const { viewOffset, viewportHeight } = useViewport({
            selectedIndex: selectedTransactionIndex,
            itemCount: transactions.length,
            layoutConfig,
        });

        useEffect(() => {
            const currentIds = new Set(transactions.map(t => t.id));
            const newIds = new Set<string>();

            for (const id of currentIds) {
                if (!prevTransactionIds.current.has(id)) {
                    newIds.add(id);
                }
            }

            if (newIds.size > 0) {
                setNewTransactionIds(current => new Set([...current, ...newIds]));
                newIds.forEach(id => {
                    setTimeout(() => {
                        setNewTransactionIds(current => {
                            const next = new Set(current);
                            next.delete(id);
                            return next;
                        });
                    }, 1000);
                });
            }

            prevTransactionIds.current = currentIds;
        }, [transactions]);

        const {
            togglePause,
            startApproveAll,
            confirmAction,
            cancelAction,
            toggleExpand,
        } = useDashboardStore(s => s.actions);
        const appActions = useAppStore(s => s.actions);
        const commitActions = useCommitStore(s => s.actions);

        const pendingApprovals = pendingTransactions.length;
        const pendingCommits = appliedTransactions.length;

        const isModal = status === DASHBOARD_STATUS.CONFIRM_APPROVE;
        const isProcessing = status === DASHBOARD_STATUS.APPROVING;

        const viewDetails = () => {
            const selectedTx = transactions[selectedTransactionIndex];
            if (!selectedTx) return;

            if (selectedTx.status === 'PENDING') {
                useReviewStore.getState().actions.load(selectedTx.id);
                appActions.showReviewScreen();
            } else {
                useDetailStore.getState().actions.load(selectedTx.id);
                appActions.showTransactionDetailScreen();
            }
        };

        useInput((_input, key) => {
            if (key.return) confirmAction();
            if (key.escape) cancelAction();
        }, { isActive: isModal });

        useListNavigator({
            itemCount: transactions.length,
            viewportHeight,
            selectedIndex: selectedTransactionIndex,
            onIndexChange: (index) => {
                useDashboardStore.getState().actions.setSelectedIndex(index);
                useDashboardStore.getState().actions.setExpandedTransactionId(null);
            },
            isActive: !isModal && !isProcessing,
            onKey: (input, key) => {
                if (key.leftArrow) {
                    if (expandedTransactionId) toggleExpand();
                    return;
                }
                if (key.rightArrow) {
                    if (transactions[selectedTransactionIndex]) {
                        if (!expandedTransactionId) toggleExpand();
                        else viewDetails();
                    }
                    return;
                }
                if (key.return) viewDetails();
                if (input.toLowerCase() === 'p') togglePause();
                if (input.toLowerCase() === 'a' && pendingApprovals > 0) startApproveAll();
                if (input.toLowerCase() === 'c' && pendingCommits > 0) {
                    commitActions.prepareCommitScreen();
                    appActions.showGitCommitScreen();
                }
                if (input.toLowerCase() === 'l') {
                    useHistoryStore.getState().actions.load();
                    appActions.showTransactionHistoryScreen();
                }
            },
        });

        const transactionsToConfirm = status === DASHBOARD_STATUS.CONFIRM_APPROVE ? pendingTransactions : [];

        const contextInfo = useMemo(() => {
            try {
                const cwd = process.cwd();
                const parentDir = path.basename(path.dirname(cwd));
                const currentDir = path.basename(cwd);
                const shortCwd = `.../${parentDir}/${currentDir}`;
                const gitBranch = execSync('git rev-parse --abbrev-ref HEAD').toString().trim();
                return `[${shortCwd} @ ${gitBranch}]`;
            } catch (error) {
                return '[Context unavailable]'; // Handle cases where not in a git repo, etc.
            }
        }, []);

        return {
            status,
            transactions,
            selectedTransactionIndex,
            expandedTransactionId,
            pendingApprovals,
            pendingCommits,
            isModal,
            isProcessing,
            newTransactionIds,
            viewOffset,
            viewportHeight,
            transactionsToConfirm,
            contextInfo,
        };
    };
  src/components/layout/ScreenLayout.tsx: >-
    import { Box, Text } from 'ink';

    import Separator from '../Separator';


    interface ScreenLayoutProps {
        title: string;
        footer: React.ReactNode;
        children: React.ReactNode;
        contextInfo?: string;
    }


    const ScreenLayout = ({ title, footer, children, contextInfo }:
    ScreenLayoutProps) => {
        return (
            <Box flexDirection="column" flexGrow={1}>
                <Box flexDirection="row">
                    <Text bold color="black" backgroundColor="yellow"> ▲ relaycode · {title} </Text>
                    <Box flexGrow={1} />
                    {contextInfo && <Text color="gray">{contextInfo}</Text>}
                </Box>
                <Separator />
                <Box flexDirection="column" flexGrow={1} marginY={1}>
                    {children}
                </Box>
                <Separator />
                <Box>
                    {footer}
                </Box>
            </Box>
        );
    };


    export default ScreenLayout;
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: '2025-09-27T23:57:49.748Z'
status: committed
id: 241
