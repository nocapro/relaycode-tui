uuid: c328ddac-5969-4e00-a549-33158c9735a2
projectId: relaycode-tui
createdAt: '2025-09-25T05:56:47.155Z'
gitCommitMsg: >-
  feat(review): implement "instruct" workflow for rejected files

  Introduces a new user workflow on the Review Screen for files that have been
  manually rejected. This "instruct" flow is parallel to the existing "repair"
  flow for failed patches.

  Key features: - Users can now press `(I)` on a rejected file to copy a
  contextual prompt to their clipboard, asking an LLM for an alternative
  solution. - A bulk instruction mode, triggered by `(Shift+I)`, allows
  generating a single prompt for all rejected files. - The UI now displays a
  "Bulk Instruction" modal for managing this workflow. - File items in an
  `AWAITING` state now display contextual details (e.g., "Instruction prompt
  copied!"). - State management in `review.store` has been updated to support
  the new views, actions, and state tracking. - The `review.service` can now
  generate specialized prompts for both single-file and bulk instructions. - A
  new debug menu option has been added for direct access to the "Bulk Instruct"
  modal for testing.
promptSummary: >-
  Implement a new "instruct" workflow for rejected files in the review screen,
  allowing users to generate prompts for an LLM to get alternative solutions.
  This includes state management, UI modals, keyboard interactions, and a debug
  menu shortcut.
reasoning:
  - >-
    Executing parts 1, 2, and 3 of the master plan to implement the "Instruction
    Workflow" for rejected files.
  - '### Part 1: State Management & Service Layer Refactoring'
  - >-
    I will first update the core state management in `review.store.ts` to
    recognize the new workflow states and actions. Then, I'll enhance
    `review.service.ts` with logic to generate the context-rich prompts required
    by the Language Model.
  - '### Part 2: UI and Interaction Logic Implementation'
  - >-
    I will now connect the new state and services to the user interface, adding
    new visual elements to `ReviewScreen.tsx` and the keyboard interaction logic
    in `useReviewScreen.tsx`.
  - '### Part 3: Debuggability and Testing'
  - >-
    To ensure this new workflow is easily testable, I will add a direct entry
    point into the "Bulk Instruct" modal via the debug menu.
  - >-
    This completes the implementation of parts 1, 2, and 3. The application now
    supports a new "instruct" workflow for rejected files, complete with state
    management, UI modals, keyboard interactions, and a debug menu shortcut for
    rapid testing.
operations:
  - type: write
    path: src/stores/review.store.ts
    content: >+
      --- src/stores/review.store.ts

      +++ src/stores/review.store.ts

      @@ -10,7 +10,7 @@
           substeps?: ApplyStep[];
           duration?: number;
       }
      -export type ReviewBodyView = 'diff' | 'reasoning' | 'script_output' |
      'bulk_repair' | 'confirm_handoff' | 'none';

      +export type ReviewBodyView = 'diff' | 'reasoning' | 'script_output' |
      'bulk_repair' | 'confirm_handoff' | 'bulk_instruct' | 'none';
       export type PatchStatus = 'SUCCESS' | 'PARTIAL_FAILURE';
       export type ApplyUpdate =
           | { type: 'UPDATE_STEP'; payload: { id: string; status: ApplyStep['status']; duration?: number; details?: string } }
      @@ -23,8 +23,9 @@
           isDiffExpanded: boolean;
           reasoningScrollIndex: number;
           scriptErrorIndex: number;
      -    fileReviewStates: Map<string, { status: FileReviewStatus; error?:
      string }>;

      +    fileReviewStates: Map<string, { status: FileReviewStatus; error?:
      string; details?: string }>;
       
           selectedBulkRepairOptionIndex: number;
      +    selectedBulkInstructOptionIndex: number;
       
           actions: {
               load: (transactionId: string, initialState?: Partial<Pick<ReviewState, 'bodyView' | 'selectedBulkRepairOptionIndex'>>) => void;
      @@ -32,7 +33,7 @@
               moveSelectionDown: (listSize: number) => void;
               expandDiff: () => void;
               toggleBodyView: (view: Extract<
      -            ReviewBodyView,

      +            ReviewBodyView, 'bulk_instruct' |
                   'diff' | 'reasoning' | 'script_output' | 'bulk_repair' | 'confirm_handoff'
               >) => void;
               setBodyView: (view: ReviewBodyView) => void;
      @@ -41,16 +42,21 @@
               tryRepairFile: (fileId: string) => void;
               showBulkRepair: () => void;
               executeBulkRepairOption: (option: number) => Promise<void>;
      +        tryInstruct: (fileId: string) => void;

      +        showBulkInstruct: () => void;

      +        executeBulkInstructOption: (option: number) => Promise<void>;
               confirmHandoff: () => void;
               scrollReasoningUp: () => void;
               scrollReasoningDown: () => void;
               navigateScriptErrorUp: () => void;
               navigateScriptErrorDown: () => void;
               updateApplyStep: (id: string, status: ApplyStep['status'], duration?: number, details?: string) => void;
               addApplySubstep: (parentId: string, substep: Omit<ApplyStep, 'substeps'>) => void;
      -        updateFileReviewStatus: (fileId: string, status:
      FileReviewStatus, error?: string) => void;

      +        updateFileReviewStatus: (fileId: string, status:
      FileReviewStatus, error?: string, details?: string) => void;
               toggleFileApproval: (fileId: string) => void;
               rejectAllFiles: () => void;
               navigateBulkRepairUp: () => void;
               navigateBulkRepairDown: () => void;
      +        navigateBulkInstructUp: () => void;

      +        navigateBulkInstructDown: () => void;
           };
       }
       
      @@ -64,6 +70,7 @@
           scriptErrorIndex: 0,
           fileReviewStates: new Map(),
           selectedBulkRepairOptionIndex: 0,
      +    selectedBulkInstructOptionIndex: 0,
       
           actions: {
               load: (transactionId, initialState) => {
      @@ -82,6 +89,7 @@
                       scriptErrorIndex: 0,
                       applySteps: JSON.parse(JSON.stringify(INITIAL_APPLY_STEPS)),
                       selectedBulkRepairOptionIndex: 0,
      +                selectedBulkInstructOptionIndex: 0,
                       ...initialState,
                   });
               },
      @@ -141,6 +149,52 @@
                   ReviewService.tryRepairFile(file, error);
                   get().actions.updateFileReviewStatus(file.id, 'AWAITING');
               },
      +        tryInstruct: (fileId) => {

      +            const selectedTransactionId =
      useViewStore.getState().selectedTransactionId;

      +            const { fileReviewStates } = get();

      +            if (!selectedTransactionId) return;

      +            const tx = useTransactionStore.getState().transactions.find(t
      => t.id === selectedTransactionId);

      +            const file = tx?.files?.find(f => f.id === fileId);

      +            if (!tx || !file) return;

      +

      +            const { status } = fileReviewStates.get(file.id) || {};

      +            if (status !== 'REJECTED') return;

      +            

      +            ReviewService.tryInstructFile(file, tx);

      +            get().actions.updateFileReviewStatus(file.id, 'AWAITING',
      undefined, 'Instruction prompt copied!');

      +        },

      +        showBulkInstruct: () =>
      get().actions.setBodyView('bulk_instruct'),

      +        executeBulkInstructOption: async (option) => {

      +            const selectedTransactionId =
      useViewStore.getState().selectedTransactionId;

      +            const tx = useTransactionStore.getState().transactions.find(t
      => t.id === selectedTransactionId);

      +            if (!tx?.files) return;

      +

      +            const rejectedFiles = tx.files.filter(f =>
      get().fileReviewStates.get(f.id)?.status === 'REJECTED');

      +            if (rejectedFiles.length === 0) {

      +                set({ bodyView: 'none' });

      +                return;

      +            }

      +

      +            switch (option) {

      +                case 1:

      +                   
      ReviewService.generateBulkInstructPrompt(rejectedFiles, tx);

      +                    set({ bodyView: 'none' });

      +                    break;

      +                case 2:

      +                    get().actions.setBodyView('confirm_handoff');

      +                    break;

      +                case 3:

      +                    rejectedFiles.forEach(file => {

      +                        get().actions.updateFileReviewStatus(file.id,
      'APPROVED');

      +                    });

      +                    set({ bodyView: 'none' });

      +                    break;

      +                default:

      +                    set({ bodyView: 'none' });

      +            }

      +        },

      +
               showBulkRepair: () => get().actions.toggleBodyView('bulk_repair'),
               executeBulkRepairOption: async (option) => {
                   const selectedTransactionId = useViewStore.getState().selectedTransactionId;
      @@ -231,10 +285,10 @@
                       }),
                   }));
               },
      -        updateFileReviewStatus: (fileId, status, error) => {

      -            set(state => {

      -                const newStates = new Map(state.fileReviewStates);

      -                newStates.set(fileId, { status, error });

      +        updateFileReviewStatus: (fileId, status, error, details) => {

      +            set(state => {

      +                const newStates = new Map(state.fileReviewStates);

      +                newStates.set(fileId, { status, error, details });
                       return { fileReviewStates: newStates };
                   });
               },
      @@ -244,7 +298,7 @@
                       const current = newStates.get(fileId);
                       if (current) {
                           const newStatus: FileReviewStatus = current.status === 'APPROVED' ? 'REJECTED' : 'APPROVED';
      -                    newStates.set(fileId, { status: newStatus, error:
      undefined });

      +                    newStates.set(fileId, { status: newStatus, error:
      undefined, details: undefined });
                       }
                       return { fileReviewStates: newStates };
                   });
      @@ -254,7 +308,7 @@
                       const newStates = new Map(state.fileReviewStates);
                       for (const [fileId, reviewState] of newStates.entries()) {
                           if (reviewState.status === 'APPROVED') {
      -                        newStates.set(fileId, { status: 'REJECTED',
      error: undefined });

      +                        newStates.set(fileId, { status: 'REJECTED',
      error: undefined, details: undefined });
                           }
                       }
                       return { fileReviewStates: newStates };
      @@ -265,5 +319,11 @@
               navigateBulkRepairDown: () => set(state => ({
                   selectedBulkRepairOptionIndex: moveIndex(state.selectedBulkRepairOptionIndex, 'down', 4),
               })),
      +        navigateBulkInstructUp: () => set(state => ({

      +            selectedBulkInstructOptionIndex:
      moveIndex(state.selectedBulkInstructOptionIndex, 'up', 4),

      +        })),

      +        navigateBulkInstructDown: () => set(state => ({

      +            selectedBulkInstructOptionIndex:
      moveIndex(state.selectedBulkInstructOptionIndex, 'down', 4),

      +        })),
           },
       }));

    patchStrategy: standard-diff
  - type: write
    path: src/services/review.service.ts
    content: >+
      --- src/services/review.service.ts

      +++ src/services/review.service.ts

      @@ -21,11 +21,11 @@
       const generateHandoffPrompt = (
           transaction: Transaction,
           fileReviewStates: Map<
      -        string, { status: FileReviewStatus; error?: string }

      +        string, { status: FileReviewStatus; error?: string; details?:
      string }
           >,
       ): string => {
           const successfulFiles = (transaction.files || []).filter(f => fileReviewStates.get(f.id)?.status === 'APPROVED');
      -    const failedFiles = (transaction.files || []).filter(f =>
      fileReviewStates.get(f.id)?.status === 'FAILED');

      +    const failedFiles = (transaction.files || []).filter(f => ['FAILED',
      'REJECTED'].includes(fileReviewStates.get(f.id)?.status || ''));
       
           return `I am handing off a failed automated code transaction to you. Your task is to act as my programming assistant and complete the planned changes.
       
      @@ -124,6 +124,37 @@
           return file;
       };
       
      +const generateSingleFileInstructPrompt = (file: FileItem, transaction:
      Transaction): string => {

      +    return `The user REJECTED the last proposed change for the file
      \`${file.path}\`.

      +

      +The original high-level goal was:

      +---

      +${transaction.prompt || transaction.message}

      +---

      +

      +The rejected change was:

      +---

      +${file.diff || '// ... rejected diff would be here ...'}

      +---

      +

      +Please provide an alternative solution for \`${file.path}\` that still
      accomplishes the original goal.

      +The response MUST be a complete, corrected patch for this file.`;

      +};

      +

      +const tryInstructFile = (file: FileItem, transaction: Transaction): void
      => {

      +    const instructPrompt = generateSingleFileInstructPrompt(file,
      transaction);

      +    // In a real app: clipboardy.writeSync(instructPrompt)

      +    // eslint-disable-next-line no-console

      +    console.log(`[CLIPBOARD] Copied instruction prompt for:
      ${file.path}`);

      +};

      +

      +const generateBulkInstructPrompt = (rejectedFiles: FileItem[],
      transaction: Transaction): string => {

      +    // Mock implementation for demo. In a real scenario, this would
      generate a more complex prompt.

      +    const fileList = rejectedFiles.map(f => `- ${f.path}`).join('\n');

      +    // eslint-disable-next-line no-console

      +    console.log(`[CLIPBOARD] Copied bulk instruction prompt for
      ${rejectedFiles.length} files.`);

      +    return `The user has rejected changes in multiple files for the goal:
      "${transaction.message}".\n\nThe rejected files
      are:\n${fileList}\n\nPlease provide an alternative patch for all of
      them.`;

      +};

      +
       const runBulkReapply = async (
           failedFiles: FileItem[],
       ): Promise<{ id: string; status: FileReviewStatus; error?: string }[]> => {
      @@ -148,10 +179,14 @@
       export const ReviewService = {
           prepareTransactionForReview,
           generateBulkRepairPrompt,
      +    generateBulkInstructPrompt,
           generateHandoffPrompt,
           performHandoff,
           runApplySimulation,
           generateSingleFileRepairPrompt,
           tryRepairFile,
      +    generateSingleFileInstructPrompt,

      +    tryInstructFile,
           runBulkReapply,
       };

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useReviewScreen.tsx
    content: >+
      --- src/hooks/useReviewScreen.tsx

      +++ src/hooks/useReviewScreen.tsx

      @@ -23,6 +23,7 @@
               bodyView,
               patchStatus,
               selectedBulkRepairOptionIndex,
      +        selectedBulkInstructOptionIndex,
           } = store;
       
           const transaction = useTransactionStore(selectSelectedTransaction);
      @@ -48,6 +49,11 @@
               };
           }, [files, fileReviewStates]);
       
      +    const hasRejectedFiles = useMemo(() => {

      +        if (!fileReviewStates) return false;

      +        return Array.from(fileReviewStates.values()).some(s => s.status
      === 'REJECTED');

      +    }, [fileReviewStates]);

      +
           const { approvedFilesCount } = reviewStats;
       
           const isFileSelected = navigableItems[selectedItemIndex]?.type === 'file';
      @@ -62,7 +68,11 @@
               startApplySimulation,
               approve,
               tryRepairFile,
      +        tryInstruct,
               showBulkRepair,
      +        showBulkInstruct,
               executeBulkRepairOption,
      +        executeBulkInstructOption,
               confirmHandoff,
               scrollReasoningUp,
               scrollReasoningDown,
      @@ -72,6 +82,8 @@
               rejectAllFiles,
               navigateBulkRepairUp,
               navigateBulkRepairDown,
      +        navigateBulkInstructUp,

      +        navigateBulkInstructDown,
           } = store.actions;
       
           const openCopyMode = () => {
      @@ -89,7 +101,7 @@
               // The 'q' (quit/back) is now handled by the global hotkey hook.
       
               if (key.escape) {
      -            if (bodyView === 'bulk_repair' || bodyView ===
      'confirm_handoff') {

      +            if (['bulk_repair', 'confirm_handoff',
      'bulk_instruct'].includes(bodyView)) {
                       toggleBodyView(bodyView);
                   } else if (bodyView !== 'none') {
                       setBodyView('none');
      @@ -111,6 +123,19 @@
       
               if (input >= '1' && input <= '4') {
                   executeBulkRepairOption(parseInt(input));
      +        }

      +    };

      +    

      +    const handleBulkInstructInput = (input: string, key: Key): void => {

      +        if (key.upArrow) navigateBulkInstructUp();

      +        if (key.downArrow) navigateBulkInstructDown();

      +        if (key.return) {

      +            executeBulkInstructOption(selectedBulkInstructOptionIndex +
      1); // Options are 1-based

      +            return;

      +        }

      +

      +        if (input >= '1' && input <= '3') {

      +            executeBulkInstructOption(parseInt(input));
               }
           };
       
      @@ -176,14 +201,23 @@
               }
       
               if (input.toLowerCase() === 't') {
      -            if (key.shift) { // Bulk repair

      +            if (key.shift) {
                       const hasFailedFiles = Array.from(fileReviewStates.values()).some(s => s.status === 'FAILED');
                       if (hasFailedFiles) showBulkRepair();
      -            } else {

      -                if (currentItem?.type === 'file') {

      -                    const fileState =
      fileReviewStates.get(currentItem.id);

      -                    if (fileState?.status === 'FAILED')
      tryRepairFile(currentItem.id);

      -                }

      +            } else if (currentItem?.type === 'file') {

      +                const fileState = fileReviewStates.get(currentItem.id);

      +                if (fileState?.status === 'FAILED')
      tryRepairFile(currentItem.id);

      +            }

      +        }

      +

      +        if (input.toLowerCase() === 'i') {

      +            if (key.shift) {

      +                if (hasRejectedFiles) showBulkInstruct();

      +            } else if (currentItem?.type === 'file') {

      +                const fileState = fileReviewStates.get(currentItem.id);

      +                if (fileState?.status === 'REJECTED') {

      +                    tryInstruct(currentItem.id);

      +                }
                   }
               }
           };
      @@ -196,6 +230,7 @@
               switch (bodyView) {
                   case 'confirm_handoff': return handleHandoffConfirmInput(input, key);
                   case 'bulk_repair': return handleBulkRepairInput(input, key);
      +            case 'bulk_instruct': return handleBulkInstructInput(input,
      key);
                   case 'reasoning': return handleReasoningInput(input, key);
                   case 'script_output': return handleScriptOutputInput(input, key);
                   case 'diff': return handleDiffInput(input);
      @@ -213,7 +248,9 @@
               navigableItems,
               isFileSelected,
               selectedBulkRepairOptionIndex,
      +        selectedBulkInstructOptionIndex,
               ...reviewStats,
      +        hasRejectedFiles,
           };
       };

    patchStrategy: standard-diff
  - type: write
    path: src/components/ReviewScreen.tsx
    content: >+
      --- src/components/ReviewScreen.tsx

      +++ src/components/ReviewScreen.tsx

      @@ -7,9 +7,10 @@
       // --- Sub-components ---
       
       const FileItemRow = ({ file, reviewStatus, reviewError, isFocused }: {
      -    file: FileItem;

      +const FileItemRow = ({ file, reviewStatus, reviewError, reviewDetails,
      isFocused }: {

      +    file: FileItem;
           reviewStatus: string;
           reviewError?: string;
      +    reviewDetails?: string;
           isFocused: boolean;
       }) => {
           let icon;
      @@ -53,7 +54,7 @@
                   <Box>
                       <Text {...colorProps}>
                           {prefix}<Text color={iconColor}>{icon} AWAITING {file.path}</Text>
      -                    <Text color="yellow">    (Bulk re-apply prompt
      copied!)</Text>

      +                    <Text color="yellow">    ({reviewDetails})</Text>
                       </Text>
                   </Box>
               );
      @@ -124,7 +125,9 @@
               totalLinesAdded,
               totalLinesRemoved,
               selectedBulkRepairOptionIndex,
      +        selectedBulkInstructOptionIndex,
               navigableItems,
      +        hasRejectedFiles,
           } = useReviewScreen();
       
           if (!transaction) {
      @@ -239,6 +242,35 @@
                   );
               }
       
      +        if (bodyView === 'bulk_instruct') {

      +            const rejectedFiles = files.filter((f: FileItem) =>
      fileReviewStates.get(f.id)?.status === 'REJECTED');

      +            const instructOptions = [

      +                '(1) Copy Bulk Re-instruct Prompt (for single-shot AI)',

      +                '(2) Handoff to External Agent',

      +                '(3) Bulk Un-reject All Files (revert to original)',

      +                '(4) Cancel',

      +            ];

      +

      +            return (

      +                <Box flexDirection="column" gap={1}>

      +                    <Text bold>BULK INSTRUCTION ACTION</Text>

      +

      +                    <Box flexDirection="column">

      +                        <Text>The following {rejectedFiles.length} files
      were rejected:</Text>

      +                        {rejectedFiles.map((file: FileItem) => (

      +                            <Text key={file.id}>- {file.path}</Text>

      +                        ))}

      +                    </Box>

      +                    <Box flexDirection="column" marginTop={1}>

      +                        {instructOptions.map((opt, i) => (

      +                            <Text key={i}
      color={selectedBulkInstructOptionIndex === i ? 'cyan' : undefined}>

      +                                {selectedBulkInstructOptionIndex === i ?
      '> ' : '  '}

      +                                {opt}

      +                            </Text>

      +                        ))}

      +                    </Box>

      +                </Box>

      +            );

      +        }

      +
               return null;
           };
       
      @@ -256,6 +288,9 @@
               if (bodyView === 'bulk_repair') {
                   return <Text>Choose an option [1-4, Esc]:</Text>;
               }
      +        if (bodyView === 'bulk_instruct') {

      +            return <Text>Choose an option [1-4, Esc]:</Text>;

      +        }
               if (bodyView === 'confirm_handoff') {
                   return <Text>(Enter) Confirm Handoff      (Esc) Cancel</Text>;
               }
      @@ -264,7 +299,6 @@
               const actions = ['(↑↓) Nav'];
       
               const currentItem = navigableItems[selectedItemIndex];
      -        const hasFailedFiles =
      Array.from(fileReviewStates.values()).some(s => s.status === 'FAILED');
               
               if (currentItem?.type === 'file') {
                   const selectedFile = files.find(f => f.id === currentItem.id);
      @@ -277,6 +311,9 @@
                   // Add repair options for failed files
                   if (selectedFile && fileState?.status === 'FAILED') {
                       actions.push('(T)ry Repair');
      +            }

      +            if (selectedFile && fileState?.status === 'REJECTED') {

      +                actions.push('(I)nstruct');
                   }
               } else if (currentItem?.type === 'script') {
                   actions.push('(Ent) Expand Details');
      @@ -288,8 +325,13 @@
               }
       
               // Add bulk repair if there are failed files
      +        const hasFailedFiles =
      Array.from(fileReviewStates.values()).some(s => s.status === 'FAILED');
               if (hasFailedFiles) {
                   actions.push('(Shift+T) Bulk Repair');
      +        }

      +        // Add bulk instruct if there are rejected files

      +        if (hasRejectedFiles) {

      +            actions.push('(Shift+I) Bulk Instruct');
               }
               
               actions.push('(C)opy');
      @@ -375,6 +417,7 @@
                                   isFocused={isFocused}
                                   reviewStatus={reviewState?.status || 'AWAITING'}
                                   reviewError={reviewState?.error}
      +                            reviewDetails={reviewState?.details}
                               />
                           );
                       })}

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useDebugMenu.tsx
    content: |+
      --- src/hooks/useDebugMenu.tsx
      +++ src/hooks/useDebugMenu.tsx
      @@ -165,6 +165,18 @@
                       appActions.showReviewScreen();
                   },
               },
      +        {
      +            title: 'Review: Bulk Instruct',
      +            action: () => {
      +                reviewActions.load('2'); // Load success case
      +                // Reject some files to enable the workflow
      +                reviewActions.toggleFileApproval('2-1');
      +                reviewActions.toggleFileApproval('2-2');
      +                reviewActions.showBulkInstruct();
      +                appActions.showReviewScreen();
      +            },
      +        },
               {
                   title: 'Review: Handoff Confirm',
                   action: () => {

    patchStrategy: standard-diff
snapshot:
  src/stores/review.store.ts: >-
    import { create } from 'zustand';

    import { useAppStore } from './app.store';

    import { useTransactionStore } from './transaction.store';

    import { useViewStore } from './view.store';

    import { ReviewService } from '../services/review.service';

    import { moveIndex } from './navigation.utils';

    import { INITIAL_APPLY_STEPS } from '../constants/review.constants';

    import type { FileReviewStatus } from '../types/domain.types';


    export interface ApplyStep {
        id: string;
        title: string;
        status: 'pending' | 'active' | 'done' | 'failed' | 'skipped';
        details?: string;
        substeps?: ApplyStep[];
        duration?: number;
    }

    export type ReviewBodyView = 'diff' | 'reasoning' | 'script_output' |
    'bulk_repair' | 'confirm_handoff' | 'none';

    export type PatchStatus = 'SUCCESS' | 'PARTIAL_FAILURE';

    export type ApplyUpdate =
        | { type: 'UPDATE_STEP'; payload: { id: string; status: ApplyStep['status']; duration?: number; details?: string } }
        | { type: 'ADD_SUBSTEP'; payload: { parentId: string; substep: Omit<ApplyStep, 'substeps'> } };

    interface ReviewState {
        patchStatus: PatchStatus;
        applySteps: ApplyStep[];
        selectedItemIndex: number;
        bodyView: ReviewBodyView;
        isDiffExpanded: boolean;
        reasoningScrollIndex: number;
        scriptErrorIndex: number;
        fileReviewStates: Map<string, { status: FileReviewStatus; error?: string }>;

        selectedBulkRepairOptionIndex: number;

        actions: {
            load: (transactionId: string, initialState?: Partial<Pick<ReviewState, 'bodyView' | 'selectedBulkRepairOptionIndex'>>) => void;
            moveSelectionUp: (listSize: number) => void;
            moveSelectionDown: (listSize: number) => void;
            expandDiff: () => void;
            toggleBodyView: (view: Extract<
                ReviewBodyView,
                'diff' | 'reasoning' | 'script_output' | 'bulk_repair' | 'confirm_handoff'
            >) => void;
            setBodyView: (view: ReviewBodyView) => void;
            approve: () => void;
            startApplySimulation: (scenario: 'success' | 'failure') => void;
            tryRepairFile: (fileId: string) => void;
            showBulkRepair: () => void;
            executeBulkRepairOption: (option: number) => Promise<void>;
            confirmHandoff: () => void;
            scrollReasoningUp: () => void;
            scrollReasoningDown: () => void;
            navigateScriptErrorUp: () => void;
            navigateScriptErrorDown: () => void;
            updateApplyStep: (id: string, status: ApplyStep['status'], duration?: number, details?: string) => void;
            addApplySubstep: (parentId: string, substep: Omit<ApplyStep, 'substeps'>) => void;
            updateFileReviewStatus: (fileId: string, status: FileReviewStatus, error?: string) => void;
            toggleFileApproval: (fileId: string) => void;
            rejectAllFiles: () => void;
            navigateBulkRepairUp: () => void;
            navigateBulkRepairDown: () => void;
        };
    }


    export const useReviewStore = create<ReviewState>((set, get) => ({
        patchStatus: 'SUCCESS',
        applySteps: INITIAL_APPLY_STEPS,
        selectedItemIndex: 0,
        bodyView: 'none',
        isDiffExpanded: false,
        reasoningScrollIndex: 0,
        scriptErrorIndex: 0,
        fileReviewStates: new Map(),
        selectedBulkRepairOptionIndex: 0,

        actions: {
            load: (transactionId, initialState) => {
                const transaction = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!transaction) return;
                
                const { patchStatus, fileReviewStates } = ReviewService.prepareTransactionForReview(transaction);

                useViewStore.getState().actions.setSelectedTransactionId(transaction.id);
                set({
                    patchStatus,
                    fileReviewStates,
                    selectedItemIndex: 0,
                    bodyView: initialState?.bodyView ?? 'none',
                    isDiffExpanded: false,
                    reasoningScrollIndex: 0,
                    scriptErrorIndex: 0,
                    applySteps: JSON.parse(JSON.stringify(INITIAL_APPLY_STEPS)),
                    selectedBulkRepairOptionIndex: 0,
                    ...initialState,
                });
            },
            moveSelectionUp: (listSize) => set(state => {
                return { selectedItemIndex: moveIndex(state.selectedItemIndex, 'up', listSize) };
            }),
            moveSelectionDown: (listSize) => set(state => {
                return { selectedItemIndex: moveIndex(state.selectedItemIndex, 'down', listSize) };
            }),
            toggleBodyView: (view) => set(state => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                const files = tx?.files || [];
                if (view === 'diff' && state.selectedItemIndex >= files.length) return {};
                return {
                    bodyView: state.bodyView === view ? 'none' : view,
                    isDiffExpanded: false,
                };
            }),
            setBodyView: (view) => set({ bodyView: view }),
            expandDiff: () => set(state => ({ isDiffExpanded: !state.isDiffExpanded })),
            approve: () => {
                const { selectedTransactionId } = useViewStore.getState();
                if (selectedTransactionId) {
                    useTransactionStore.getState().actions.updateTransactionStatus(selectedTransactionId, 'APPLIED');
                    useAppStore.getState().actions.showDashboardScreen();
                }
            },
            startApplySimulation: async (scenario) => {
                const { showReviewProcessingScreen } = useAppStore.getState().actions;
                const { updateApplyStep, addApplySubstep } = get().actions;
                set({ applySteps: JSON.parse(JSON.stringify(INITIAL_APPLY_STEPS)) });
                showReviewProcessingScreen();
                const simulationGenerator = ReviewService.runApplySimulation(scenario);
                for await (const update of simulationGenerator) {
                    if (update.type === 'UPDATE_STEP') {
                        updateApplyStep(
                            update.payload.id,
                            update.payload.status,
                            update.payload.duration,
                            update.payload.details,
                        );
                    } else if (update.type === 'ADD_SUBSTEP') {
                        addApplySubstep(update.payload.parentId, update.payload.substep);
                    }
                }
                // Transition back to review screen is handled by the processing screen component or a separate flow
                // For this simulation, we'll assume it transitions back, but the action itself doesn't need to do it.
                // This avoids a direct dependency from the store to app-level navigation.
            },
            tryRepairFile: (fileId) => {
                const selectedTransactionId = useViewStore.getState().selectedTransactionId;
                const { fileReviewStates } = get();
                if (!selectedTransactionId) return;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                const file = tx?.files?.find(f => f.id === fileId);
                if (!file) return;

                const { status, error } = fileReviewStates.get(file.id) || {};
                if (status !== 'FAILED') return;
                
                ReviewService.tryRepairFile(file, error);
                get().actions.updateFileReviewStatus(file.id, 'AWAITING');
            },
            showBulkRepair: () => get().actions.toggleBodyView('bulk_repair'),
            executeBulkRepairOption: async (option) => {
                const selectedTransactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === selectedTransactionId);
                if (!tx?.files) return;

                const failedFiles = tx.files.filter(f => get().fileReviewStates.get(f.id)?.status === 'FAILED');
                if (failedFiles.length === 0) {
                    set({ bodyView: 'none' });
                    return;
                }

                switch (option) {
                    case 1:
                        ReviewService.generateBulkRepairPrompt(failedFiles);
                        set({ bodyView: 'none' });
                        break;
                    case 2: {
                        set({ bodyView: 'none' });
                        failedFiles.forEach(f => get().actions.updateFileReviewStatus(f.id, 'RE_APPLYING'));
                        const results = await ReviewService.runBulkReapply(failedFiles);
                        results.forEach(result =>
                            get().actions.updateFileReviewStatus(
                                result.id, result.status, result.error,
                            ),
                        );
                        break;
                    }
                    case 3:
                        get().actions.setBodyView('confirm_handoff');
                        break;
                    case 4:
                        failedFiles.forEach(file => {
                            get().actions.updateFileReviewStatus(file.id, 'REJECTED');
                        });
                        set({ bodyView: 'none' });
                        break;
                    default:
                        set({ bodyView: 'none' });
                }
            },
            confirmHandoff: () => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!tx?.files) return;
                const { fileReviewStates } = get();
                ReviewService.generateHandoffPrompt(tx, fileReviewStates);
                ReviewService.performHandoff(tx.hash);
            },
            scrollReasoningUp: () => set(state => ({ reasoningScrollIndex: Math.max(0, state.reasoningScrollIndex - 1) })),
            scrollReasoningDown: () => set(state => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!tx?.reasoning) return {};
                const maxLines = tx.reasoning.split('\n').length;
                return { reasoningScrollIndex: Math.min(maxLines - 1, state.reasoningScrollIndex + 1) };
            }),
            navigateScriptErrorUp: () => set(state => ({ scriptErrorIndex: Math.max(0, state.scriptErrorIndex - 1) })),
            navigateScriptErrorDown: () => set(state => {
                const transactionId = useViewStore.getState().selectedTransactionId;
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!tx?.scripts || !tx?.files) return {};
                const selectedScript = tx.scripts[state.selectedItemIndex - tx.files.length];
                if (selectedScript?.output) {
                    const errorLines = selectedScript.output
                        .split('\n')
                        .filter(line => line.includes('Error') || line.includes('Warning'));
                    return { scriptErrorIndex: Math.min(errorLines.length - 1, state.scriptErrorIndex + 1) };
                }
                return {};
            }),
            updateApplyStep: (id, status, duration, details) => {
                set(state => ({
                    applySteps: state.applySteps.map(s => {
                        if (s.id === id) {
                            const newStep = { ...s, status };
                            if (duration !== undefined) newStep.duration = duration;
                            if (details !== undefined) newStep.details = details;
                            return newStep;
                        }
                        return s;
                    }),
                }));
            },
            addApplySubstep: (parentId, substep) => {
                set(state => ({
                    applySteps: state.applySteps.map(s => {
                        if (s.id === parentId) {
                            const newSubsteps = [...(s.substeps || []), substep as ApplyStep];
                            return { ...s, substeps: newSubsteps };
                        }
                        return s;
                    }),
                }));
            },
            updateFileReviewStatus: (fileId, status, error) => {
                set(state => {
                    const newStates = new Map(state.fileReviewStates);
                    newStates.set(fileId, { status, error });
                    return { fileReviewStates: newStates };
                });
            },
            toggleFileApproval: (fileId) => {
                set(state => {
                    const newStates = new Map(state.fileReviewStates);
                    const current = newStates.get(fileId);
                    if (current) {
                        const newStatus: FileReviewStatus = current.status === 'APPROVED' ? 'REJECTED' : 'APPROVED';
                        newStates.set(fileId, { status: newStatus, error: undefined });
                    }
                    return { fileReviewStates: newStates };
                });
            },
            rejectAllFiles: () => {
                set(state => {
                    const newStates = new Map(state.fileReviewStates);
                    for (const [fileId, reviewState] of newStates.entries()) {
                        if (reviewState.status === 'APPROVED') {
                            newStates.set(fileId, { status: 'REJECTED', error: undefined });
                        }
                    }
                    return { fileReviewStates: newStates };
                });
            },
            navigateBulkRepairUp: () => set(state => ({
                selectedBulkRepairOptionIndex: moveIndex(state.selectedBulkRepairOptionIndex, 'up', 4),
            })),
            navigateBulkRepairDown: () => set(state => ({
                selectedBulkRepairOptionIndex: moveIndex(state.selectedBulkRepairOptionIndex, 'down', 4),
            })),
        },
    }));
  src/services/review.service.ts: >-
    import { useTransactionStore } from '../stores/transaction.store';

    import { useAppStore } from '../stores/app.store';

    import { sleep } from '../utils';

    import type { ApplyUpdate, PatchStatus } from '../stores/review.store';

    import type { Transaction, FileItem, FileReviewStatus } from
    '../types/domain.types';


    const generateBulkRepairPrompt = (failedFiles: FileItem[]): string => {
        return `The previous patch failed to apply to MULTIPLE files. Please generate a new, corrected patch that addresses all the files listed below.

    IMPORTANT: The response MUST contain a complete code block for EACH file
    that needs to be fixed.


    ${failedFiles.map(file => `--- FILE: ${file.path} ---

    Strategy: ${file.strategy}

    Error: Hunk #1 failed to apply // This is a mock error


    ORIGINAL CONTENT:

    ---

    // ... original content of ${file.path} ...

    ---


    FAILED PATCH:

    ---

    ${file.diff || '// ... failed diff ...'}

    ---

    `).join('\n')}


    Please analyze all failed files and provide a complete, corrected
    response.`;

    };


    const generateHandoffPrompt = (
        transaction: Transaction,
        fileReviewStates: Map<
            string, { status: FileReviewStatus; error?: string }
        >,
    ): string => {
        const successfulFiles = (transaction.files || []).filter(f => fileReviewStates.get(f.id)?.status === 'APPROVED');
        const failedFiles = (transaction.files || []).filter(f => fileReviewStates.get(f.id)?.status === 'FAILED');

        return `I am handing off a failed automated code transaction to you. Your task is to act as my programming assistant and complete the planned changes.

    The full plan for this transaction is detailed in the YAML file located at:
    .relay/transactions/${transaction.hash}.yml. Please use this file as your
    primary source of truth for the overall goal.


    Here is the current status of the transaction:


    --- TRANSACTION SUMMARY ---

    Goal: ${transaction.message}

    Reasoning:

    ${transaction.reasoning || ''}


    --- CURRENT FILE STATUS ---

    SUCCESSFUL CHANGES (already applied, no action needed):

    ${successfulFiles.map(f => `- MODIFIED: ${f.path}`).join('\n') || ' 
    (None)'}


    FAILED CHANGES (these are the files you need to fix):

    ${failedFiles.map(f => `- FAILED: ${f.path} (Error:
    ${fileReviewStates.get(f.id)?.error})`).join('\n')}


    Your job is to now work with me to fix the FAILED files and achieve the
    original goal of the transaction. Please start by asking me which file you
    should work on first.`;

    };


    const performHandoff = (hash: string) => {
        // This is a bit of a hack to find the right transaction to update in the demo
        const txToUpdate = useTransactionStore.getState().transactions.find(tx => tx.hash === hash);
        if (txToUpdate) {
            useTransactionStore.getState().actions.updateTransactionStatus(txToUpdate.id, 'HANDOFF');
        }

        useAppStore.getState().actions.showDashboardScreen();
    };


    async function* runApplySimulation(scenario: 'success' | 'failure'):
    AsyncGenerator<ApplyUpdate> {
        if (scenario === 'success') {
            yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'active' } }; await sleep(100);
            yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'done', duration: 0.1 } };

            yield { type: 'UPDATE_STEP', payload: { id: 'memory', status: 'active' } }; await sleep(100);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 's1', title: '[✓] write: src/core/clipboard.ts (strategy: replace)', status: 'done' } } };
            await sleep(100);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 's2', title: '[✓] write: src/utils/shell.ts (strategy: standard-diff)', status: 'done' } } };
            yield { type: 'UPDATE_STEP', payload: { id: 'memory', status: 'done', duration: 0.3 } };

            yield { type: 'UPDATE_STEP', payload: { id: 'post-command', status: 'active' } }; await sleep(1300);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'post-command', substep: { id: 's3', title: '`bun run test` ... Passed', status: 'done' } } };
            yield { type: 'UPDATE_STEP', payload: { id: 'post-command', status: 'done', duration: 2.3 } };

            yield { type: 'UPDATE_STEP', payload: { id: 'linter', status: 'active' } }; await sleep(1200);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'linter', substep: { id: 's4', title: '`bun run lint` ... 0 Errors', status: 'done' } } };
            yield { type: 'UPDATE_STEP', payload: { id: 'linter', status: 'done', duration: 1.2 } };

            await sleep(500);

        } else { // failure scenario
            yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'active' } }; await sleep(100);
            yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'done', duration: 0.1 } };

            yield { type: 'UPDATE_STEP', payload: { id: 'memory', status: 'active' } }; await sleep(100);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 'f1', title: '[✓] write: src/core/transaction.ts (strategy: replace)', status: 'done' } } };
            await sleep(100);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 'f2', title: '[!] failed: src/utils/logger.ts (Hunk #1 failed to apply)', status: 'failed' } } };
            await sleep(100);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 'f3', title: '[!] failed: src/commands/apply.ts (Context mismatch at line 92)', status: 'failed' } } };
            yield { type: 'UPDATE_STEP', payload: { id: 'memory', status: 'done', duration: 0.5 } };

            await sleep(100);
            yield { type: 'UPDATE_STEP', payload: { id: 'post-command', status: 'skipped', details: 'Skipped due to patch application failure' } };
            await sleep(100);
            yield { type: 'UPDATE_STEP', payload: { id: 'linter', status: 'skipped', details: 'Skipped due to patch application failure' } };

            await sleep(500);
        }
    }


    const prepareTransactionForReview = (
        transaction: Transaction,
    ): {
        patchStatus: PatchStatus;
        fileReviewStates: Map<string, { status: FileReviewStatus; error?: string }>;
    } => {
        // This simulates the backend determining which files failed or succeeded and sets it ONCE on load.
        // For this demo, tx '1' is the failure case, any other is success.
        const isFailureCase = transaction.id === '1';
        const fileReviewStates = new Map<string, { status: FileReviewStatus; error?: string }>();

        (transaction.files || []).forEach((file, index) => {
            if (isFailureCase) {
                const isFailedFile = index > 0;
                const status = isFailedFile ? 'FAILED' : 'APPROVED';
                const error = isFailedFile ? (index === 1 ? 'Hunk #1 failed to apply' : 'Context mismatch at line 92') : undefined;
                fileReviewStates.set(file.id, { status, error });
            } else {
                fileReviewStates.set(file.id, { status: 'APPROVED' });
            }
        });
        return { patchStatus: isFailureCase ? 'PARTIAL_FAILURE' : 'SUCCESS', fileReviewStates };
    };


    const generateSingleFileRepairPrompt = (file: FileItem, error?: string):
    string => {
        return `The patch failed to apply to ${file.path}. Please generate a corrected patch.

    Error: ${error || 'Unknown error'}

    Strategy: ${file.strategy}


    ORIGINAL CONTENT:

    ---

    // ... original file content would be here ...

    ---


    FAILED PATCH:

    ---

    ${file.diff || '// ... failed diff would be here ...'}

    ---


    Please provide a corrected patch that addresses the error.`;

    };


    const tryRepairFile = (file: FileItem, error?: string): FileItem => {
        generateSingleFileRepairPrompt(file, error);
        // In a real app: clipboardy.writeSync(repairPrompt)
        // eslint-disable-next-line no-console
        console.log(`[CLIPBOARD] Copied repair prompt for: ${file.path}`);

        return file;
    };


    const runBulkReapply = async (
        failedFiles: FileItem[],
    ): Promise<{ id: string; status: FileReviewStatus; error?: string }[]> => {
        await sleep(1500); // Simulate re-apply

        // Mock a mixed result
        let first = true;
        return failedFiles.map(file => {
            if (first) {
                first = false;
                return { id: file.id, status: 'APPROVED' as const };
            } else {
                return {
                    id: file.id,
                    status: 'FAILED' as const,
                    error: "'replace' failed: markers not found",
                };
            }
        });
    };


    export const ReviewService = {
        prepareTransactionForReview,
        generateBulkRepairPrompt,
        generateHandoffPrompt,
        performHandoff,
        runApplySimulation,
        generateSingleFileRepairPrompt,
        tryRepairFile,
        runBulkReapply,
    };
  src/hooks/useReviewScreen.tsx: >-
    import { useMemo } from 'react';

    import { useInput, type Key } from 'ink';

    import { useReviewStore } from '../stores/review.store';

    import { useAppStore } from '../stores/app.store';

    import { useCopyStore } from '../stores/copy.store';

    import { useTransactionStore, selectSelectedTransaction } from
    '../stores/transaction.store';

    import type { FileItem } from '../types/domain.types';


    type NavigableItem =
        | { type: 'prompt' }
        | { type: 'reasoning' }
        | { type: 'script'; id: string }
        | { type: 'file'; id: string };

    export const useReviewScreen = () => {
        const store = useReviewStore();
        const {
            selectedItemIndex,
            bodyView,
            patchStatus,
            selectedBulkRepairOptionIndex,
        } = store;

        const transaction = useTransactionStore(selectSelectedTransaction);
        const { showDashboardScreen } = useAppStore(s => s.actions);

        const navigableItems = useMemo((): NavigableItem[] => {
            if (!transaction) return [];
            const scriptItems: NavigableItem[] = (transaction.scripts || []).map(s => ({ type: 'script', id: s.command }));
            const fileItems: NavigableItem[] = (transaction.files || []).map(f => ({ type: 'file', id: f.id }));
            return [{ type: 'prompt' }, { type: 'reasoning' }, ...scriptItems, ...fileItems];
        }, [transaction]);

        // Memoize files to prevent re-renders, fixing the exhaustive-deps lint warning.
        const files: FileItem[] = useMemo(() => transaction?.files || [], [transaction]);
        const fileReviewStates = useReviewStore(s => s.fileReviewStates);

        const reviewStats = useMemo(() => {
            const approvedFiles = files.filter(f => fileReviewStates.get(f.id)?.status === 'APPROVED');
            return {
                totalFiles: files.length,
                totalLinesAdded: files.reduce((sum, f) => sum + f.linesAdded, 0),
                totalLinesRemoved: files.reduce((sum, f) => sum + f.linesRemoved, 0),
                numFiles: files.length,
                approvedFilesCount: approvedFiles.length,
            };
        }, [files, fileReviewStates]);

        const { approvedFilesCount } = reviewStats;

        const isFileSelected = navigableItems[selectedItemIndex]?.type === 'file';

        const scripts = transaction?.scripts || [];

        const {
            moveSelectionUp,
            moveSelectionDown,
            expandDiff,
            toggleBodyView,
            setBodyView,
            startApplySimulation,
            approve,
            tryRepairFile,
            showBulkRepair,
            executeBulkRepairOption,
            confirmHandoff,
            scrollReasoningUp,
            scrollReasoningDown,
            navigateScriptErrorUp,
            navigateScriptErrorDown,
            toggleFileApproval,
            rejectAllFiles,
            navigateBulkRepairUp,
            navigateBulkRepairDown,
        } = store.actions;

        const openCopyMode = () => {
            if (!transaction) return;
            const currentItem = navigableItems[selectedItemIndex];
            const selectedFile = currentItem?.type === 'file' ? files.find(f => f.id === currentItem.id) : undefined;
            useCopyStore.getState().actions.openForReview(transaction, transaction.files || [], selectedFile);
        };

        // --- Input Handlers ---

        const handleGlobalInput = (input: string, key: Key): boolean => {
            if (input === '1') { // For demo purposes
                startApplySimulation('success'); return true;
            }
            if (input === '2') { // For demo purposes
                startApplySimulation('failure'); return true;
            }
            // The 'q' (quit/back) is now handled by the global hotkey hook.

            if (key.escape) {
                if (bodyView === 'bulk_repair' || bodyView === 'confirm_handoff') {
                    toggleBodyView(bodyView);
                } else if (bodyView !== 'none') {
                    setBodyView('none');
                }
                return true;
            }
            return false;
        };

        const handleHandoffConfirmInput = (_input: string, key: Key): void => {
            if (key.return) confirmHandoff();
        };

        const handleBulkRepairInput = (input: string, key: Key): void => {
            if (key.upArrow) navigateBulkRepairUp();
            if (key.downArrow) navigateBulkRepairDown();
            if (key.return) {
                executeBulkRepairOption(selectedBulkRepairOptionIndex + 1); // Options are 1-based
                return;
            }

            if (input >= '1' && input <= '4') {
                executeBulkRepairOption(parseInt(input));
            }
        };

        const handleReasoningInput = (input: string, key: Key): void => {
            if (key.upArrow) scrollReasoningUp();
            if (key.downArrow) scrollReasoningDown();
            if (input.toLowerCase() === 'r') toggleBodyView('reasoning');
        };

        const handleScriptOutputInput = (input: string, key: Key): void => {
            if (input.toLowerCase() === 'j') navigateScriptErrorDown();
            if (input.toLowerCase() === 'k') navigateScriptErrorUp();
            if (key.return) toggleBodyView('script_output');
            if (input.toLowerCase() === 'c') { // TODO: this copy logic is not great.
                const currentItem = navigableItems[selectedItemIndex];
                const selectedScript = currentItem?.type === 'script' ? scripts.find(s => s.command === currentItem.id) : undefined;
                if (selectedScript) {
                    // eslint-disable-next-line no-console
                    console.log(`[CLIPBOARD] Copied script output: ${selectedScript.command}`);
                }
            }
        };

        const handleDiffInput = (input: string) => {
            if (input.toLowerCase() === 'x') expandDiff();
            if (input.toLowerCase() === 'd') toggleBodyView('diff');
        };

        const handleMainNavigationInput = (input: string, key: Key): void => {
            // Handle Shift+R for reject all
            if (key.shift && input.toLowerCase() === 'r') {
                if (approvedFilesCount > 0 && transaction) {
                    rejectAllFiles();
                }
                return;
            }

            // Main View Navigation
            if (key.upArrow) moveSelectionUp(navigableItems.length);
            if (key.downArrow) moveSelectionDown(navigableItems.length);

            const currentItem = navigableItems[selectedItemIndex];

            if (input === ' ') {
                if (currentItem?.type === 'file') {
                    const fileState = fileReviewStates.get(currentItem.id);
                    if (fileState && fileState.status !== 'FAILED') {
                        toggleFileApproval(currentItem.id);
                    }
                }
            }

            if (input.toLowerCase() === 'd' && currentItem?.type === 'file') {
                toggleBodyView('diff');
            }

            if (input.toLowerCase() === 'r') {
                toggleBodyView('reasoning');
            }

            if (key.return) { // Enter key
                if (currentItem?.type === 'file') {
                    toggleBodyView('diff');
                } else if (currentItem?.type === 'reasoning') {
                    toggleBodyView('reasoning');
                } else if (currentItem?.type === 'script') {
                    toggleBodyView('script_output');
                }
            }

            if (input.toLowerCase() === 'a') {
                if (approvedFilesCount > 0) {
                    approve();
                    showDashboardScreen();
                }
            }

            if (input.toLowerCase() === 'c') {
                openCopyMode();
            }

            if (input.toLowerCase() === 't') {
                if (key.shift) { // Bulk repair
                    const hasFailedFiles = Array.from(fileReviewStates.values()).some(s => s.status === 'FAILED');
                    if (hasFailedFiles) showBulkRepair();
                } else {
                    if (currentItem?.type === 'file') {
                        const fileState = fileReviewStates.get(currentItem.id);
                        if (fileState?.status === 'FAILED') tryRepairFile(currentItem.id);
                    }
                }
            }
        };

        useInput((input: string, key: Key) => {
            if (handleGlobalInput(input, key)) {
                return;
            }

            switch (bodyView) {
                case 'confirm_handoff': return handleHandoffConfirmInput(input, key);
                case 'bulk_repair': return handleBulkRepairInput(input, key);
                case 'reasoning': return handleReasoningInput(input, key);
                case 'script_output': return handleScriptOutputInput(input, key);
                case 'diff': return handleDiffInput(input);
                default: return handleMainNavigationInput(input, key);
            }
        });

        return {
            ...store,
            fileReviewStates,
            selectedItemIndex,
            transaction,
            files,
            scripts,
            patchStatus,
            navigableItems,
            isFileSelected,
            selectedBulkRepairOptionIndex,
            ...reviewStats,
        };
    };
  src/components/ReviewScreen.tsx: >-
    import { Box, Text } from 'ink';

    import Separator from './Separator';

    import DiffScreen from './DiffScreen';

    import ReasonScreen from './ReasonScreen';

    import type { ScriptResult, FileItem, FileChangeType } from
    '../types/domain.types';

    import { useReviewScreen } from '../hooks/useReviewScreen';


    // --- Sub-components ---


    const FileItemRow = ({ file, reviewStatus, reviewError, isFocused }: {
        file: FileItem;
        reviewStatus: string;
        reviewError?: string;
        isFocused: boolean;
    }) => {
        let icon;
        let iconColor;
        switch (reviewStatus) {
            case 'APPROVED': icon = '[✓]'; iconColor = 'green'; break;
            case 'REJECTED': icon = '[✗]'; iconColor = 'red'; break;
            case 'FAILED': icon = '[!]'; iconColor = 'red'; break;
            case 'AWAITING': icon = '[●]'; iconColor = 'yellow'; break;
            case 'RE_APPLYING': icon = '[●]'; iconColor = 'cyan'; break;
        }

        const typeColor = (type: FileChangeType) => {
            switch (type) {
                case 'ADD': return 'green';
                case 'DEL': return 'red';
                case 'REN': return 'yellow';
                default: return 'white';
            }
        };

        const diffStats = <Text>(+<Text color="green">{file.linesAdded}</Text>/-<Text color="red">{file.linesRemoved}</Text>)</Text>;
        const strategy = file.strategy === 'standard-diff' ? 'diff' : file.strategy;
        const prefix = isFocused ? '> ' : '  ';
        const colorProps = isFocused ? { bold: true, color: 'cyan' } : {};

        if (reviewStatus === 'FAILED') {
            return (
                <Box>
                    <Text {...colorProps}>
                        {prefix}<Text color={iconColor}>{icon} FAILED {file.path}</Text>
                        <Text color="red">    ({reviewError})</Text>
                    </Text>
                </Box>
            );
        }

        if (reviewStatus === 'AWAITING') {
            return (
                <Box>
                    <Text {...colorProps}>
                        {prefix}<Text color={iconColor}>{icon} AWAITING {file.path}</Text>
                        <Text color="yellow">    (Bulk re-apply prompt copied!)</Text>
                    </Text>
                </Box>
            );
        }

        if (reviewStatus === 'RE_APPLYING') {
            return (
                 <Box>
                    <Text {...colorProps}>
                        {prefix}<Text color={iconColor}>{icon} RE-APPLYING... {file.path}</Text>
                        <Text color="cyan"> (using &apos;replace&apos; strategy)</Text>
                    </Text>
                </Box>
            );
        }

        return (
            <Box>
                <Text {...colorProps}>
                    {prefix}<Text color={iconColor}>{icon}</Text> {file.type}{' '}
                    <Text color={typeColor(file.type)}>{file.path}</Text>{' '}
                    {diffStats} [{strategy}]
                </Text>
            </Box>
        );
    };


    const ScriptItemRow = ({
        script,
        isSelected,
        isExpanded,
    }: {
        script: ScriptResult;
        isSelected: boolean;
        isExpanded: boolean;
    }) => {
        const icon = script.success ? '✓' : '✗';
        const iconColor = script.success ? 'green' : 'red';
        const arrow = isExpanded ? '▾' : '▸';
        const prefix = isSelected ? '> ' : '  ';
        
        // Extract script type from command (e.g., "bun run test" -> "Post-Command", "bun run lint" -> "Linter")
        const scriptType = script.command.includes('test') ? 'Post-Command' : 
                          script.command.includes('lint') ? 'Linter' : 
                          'Script';

        return (
            <Box>
                <Text bold={isSelected} color={isSelected ? 'cyan' : undefined}>
                    {prefix}<Text color={iconColor}>{icon}</Text> {scriptType}: `{script.command}` ({script.duration}s) {arrow}{' '}
                    {script.summary}
                </Text>
            </Box>
        );
    };


    // --- Main Component ---


    const ReviewScreen = () => {
        const {
            transaction,
            files,
            scripts = [],
            patchStatus,
            selectedItemIndex,
            bodyView,
            isDiffExpanded,
            reasoningScrollIndex,
            scriptErrorIndex,
            fileReviewStates,
            numFiles,
            approvedFilesCount,
            totalLinesAdded,
            totalLinesRemoved,
            selectedBulkRepairOptionIndex,
            navigableItems,
        } = useReviewScreen();

        if (!transaction) {
            return <Text>Loading review...</Text>;
        }
        const { hash, message, prompt = '', reasoning = '' } = transaction;

        const renderBody = () => {
            if (bodyView === 'none') return null;

            if (bodyView === 'reasoning') {
                const reasoningText = reasoning || '';
                const reasoningLinesCount = reasoningText.split('\n').length;
                const visibleLinesCount = 10;
                return (
                    <Box flexDirection="column">
                        <ReasonScreen
                            reasoning={reasoningText}
                            scrollIndex={reasoningScrollIndex}
                            visibleLinesCount={visibleLinesCount}
                        />
                        {reasoningLinesCount > visibleLinesCount && (
                            <Text color="gray">
                                Showing lines {reasoningScrollIndex + 1}-{Math.min(reasoningScrollIndex + visibleLinesCount, reasoningLinesCount)}{' '}
                                of {reasoningLinesCount}
                            </Text>
                        )}
                    </Box>
                );
            }
            
            if (bodyView === 'diff') {
                const currentItem = navigableItems[selectedItemIndex];
                const selectedFile = currentItem?.type === 'file' ? files.find(f => f.id === currentItem.id) : undefined;
                if (!selectedFile) return null;
                return (
                    <DiffScreen
                        filePath={selectedFile.path}
                        diffContent={selectedFile.diff}
                        isExpanded={isDiffExpanded}
                    />
                );
            }

            if (bodyView === 'script_output') {
                 const currentItem = navigableItems[selectedItemIndex];
                 const scriptItems = navigableItems.filter((i): i is { type: 'script'; id: string } => i.type === 'script');
                 const scriptIndex = currentItem?.type === 'script'
                    ? scriptItems.findIndex(i => i.id === currentItem.id)
                    : -1;
                 const selectedScript = scripts[scriptIndex] || null;
                 if (!selectedScript) return null;
                 
                 const outputLines = selectedScript.output.split('\n');
                 const errorLines = outputLines.filter((line: string) =>
                    line.includes('Error') || line.includes('Warning'),
                 );
                 
                 return (
                    <Box flexDirection="column">
                        <Text>{selectedScript.command.includes('lint') ? 'LINTER' : 'SCRIPT'} OUTPUT: `{selectedScript.command}`</Text>
                        <Box marginTop={1} flexDirection="column">
                            {outputLines.map((line: string, index: number) => {
                                const isError = line.includes('Error');
                                const isWarning = line.includes('Warning');
                                const isHighlighted = errorLines[scriptErrorIndex] === line;
                                
                                return (
                                    <Text 
                                        key={index} 
                                        color={isError ? 'red' : isWarning ? 'yellow' : undefined}
                                        bold={isHighlighted}
                                        backgroundColor={isHighlighted ? 'blue' : undefined}
                                    >
                                        {line}
                                    </Text>
                                );
                            })}
                        </Box>
                        {errorLines.length > 0 && (
                            <Text color="gray">
                                Error {scriptErrorIndex + 1} of {errorLines.length} highlighted
                            </Text>
                        )}
                    </Box>
                 );
            }

            if (bodyView === 'confirm_handoff') {
                return (
                    <Box flexDirection="column" gap={1}>
                        <Text bold>HANDOFF TO EXTERNAL AGENT</Text>
                        <Box flexDirection="column">
                            <Text>This action will:</Text>
                            <Text>1. Copy a detailed prompt to your clipboard for an agentic AI.</Text>
                            <Text>2. Mark the current transaction as &apos;Handoff&apos; and close this review.</Text>
                            <Text>3. Assume that you and the external agent will complete the work.</Text>
                        </Box>
                        <Text>Relaycode will NOT wait for a new patch. This is a final action.</Text>
                        <Text bold color="yellow">Are you sure you want to proceed?</Text>
                    </Box>
                );
            }

            if (bodyView === 'bulk_repair') {
                const failedFiles = files.filter((f: FileItem) => fileReviewStates.get(f.id)?.status === 'FAILED');
                const repairOptions = [
                    '(1) Copy Bulk Re-apply Prompt (for single-shot AI)',
                    '(2) Bulk Change Strategy & Re-apply',
                    '(3) Handoff to External Agent',
                    '(4) Bulk Abandon All Failed Files',
                    '(Esc) Cancel',
                ];

                return (
                    <Box flexDirection="column" gap={1}>
                        <Text bold>BULK REPAIR ACTION</Text>

                        <Box flexDirection="column">
                            <Text>The following {failedFiles.length} files failed to apply:</Text>
                            {failedFiles.map((file: FileItem) => (
                                <Text key={file.id}>- {file.path}</Text>
                            ))}
                        </Box>

                        <Text>How would you like to proceed?</Text>

                        <Box flexDirection="column">
                            {repairOptions.map((opt, i) => (
                                <Text key={i} color={selectedBulkRepairOptionIndex === i ? 'cyan' : undefined}>
                                    {selectedBulkRepairOptionIndex === i ? '> ' : '  '}
                                    {opt}
                                </Text>
                            ))}
                        </Box>
                    </Box>
                );
            }

            return null;
        };

        const renderFooter = () => {
            // Contextual footer for body views
            if (bodyView === 'diff') {
                return <Text>(↑↓) Nav · (X)pand · (D/Esc) Back</Text>;
            }
            if (bodyView === 'reasoning') {
                return <Text>(↑↓) Scroll Text · (R)Collapse View · (C)opy Mode</Text>;
            }
            if (bodyView === 'script_output') {
                return (
                    <Text>(↑↓) Nav · (J↓/K↑) Next/Prev Error · (C)opy Output · (Ent/Esc) Back</Text>
                );
            }
            if (bodyView === 'bulk_repair') {
                return <Text>Choose an option [1-4, Esc]:</Text>;
            }
            if (bodyView === 'confirm_handoff') {
                return <Text>(Enter) Confirm Handoff      (Esc) Cancel</Text>;
            }

            // Main footer
            const actions = ['(↑↓) Nav'];

            const currentItem = navigableItems[selectedItemIndex];
            const hasFailedFiles = Array.from(fileReviewStates.values()).some(s => s.status === 'FAILED');
            
            if (currentItem?.type === 'file') {
                const selectedFile = files.find(f => f.id === currentItem.id);
                const fileState = fileReviewStates.get(currentItem.id);
                if (fileState?.status !== 'FAILED') {
                    actions.push('(Spc) Toggle');
                }
                actions.push('(D)iff');
                
                // Add repair options for failed files
                if (selectedFile && fileState?.status === 'FAILED') {
                    actions.push('(T)ry Repair');
                }
            } else if (currentItem?.type === 'script') {
                actions.push('(Ent) Expand Details');
            } else { // Prompt or Reasoning
                actions.push('(Ent) Expand');
            }

            if (currentItem?.type !== 'reasoning') {
                actions.push('(R)easoning');
            }

            // Add bulk repair if there are failed files
            if (hasFailedFiles) {
                actions.push('(Shift+T) Bulk Repair');
            }
            
            actions.push('(C)opy');

            if (approvedFilesCount > 0) {
                actions.push('(A)pprove');
            }

            if (Array.from(fileReviewStates.values()).some(s => s.status === 'APPROVED' || s.status === 'FAILED')) {
                actions.push('(Shift+R) Reject All');
            }
            actions.push('(Q)uit');

            return <Text>{actions.join(' · ')}</Text>;
        };

        return (
            <Box flexDirection="column">
                {/* Header */}
                <Text color="cyan">▲ relaycode review</Text>
                <Separator />
                
                {/* Navigator Section */}
                <Box flexDirection="column" marginY={1}>
                    <Box flexDirection="column">
                        <Text>{hash} · {message}</Text>
                        <Text>
                            (<Text color="green">+{totalLinesAdded}</Text>/<Text color="red">-{totalLinesRemoved}</Text>) · {numFiles} Files · {approvedFilesCount}/{numFiles} Approved
                            {patchStatus === 'PARTIAL_FAILURE' && scripts.length === 0 && <Text> · Scripts: SKIPPED</Text>}
                            {patchStatus === 'PARTIAL_FAILURE' && <Text color="red" bold> · MULTIPLE PATCHES FAILED</Text>}
                        </Text>
                    </Box>

                    <Box flexDirection="column" marginTop={1}>
                        <Text color={navigableItems[selectedItemIndex]?.type === 'prompt' ? 'cyan' : undefined}>
                            {navigableItems[selectedItemIndex]?.type === 'prompt' ? '> ' : '  '}
                            (P)rompt ▸ {(prompt || '').substring(0, 60)}...
                        </Text>
                        <Text color={navigableItems[selectedItemIndex]?.type === 'reasoning' ? 'cyan' : undefined}>
                            {navigableItems[selectedItemIndex]?.type === 'reasoning' ? '> ' : '  '}
                            (R)easoning ({(reasoning || '').split('\n\n').length} steps) {bodyView === 'reasoning' ? '▾' : '▸'}{' '}
                            {((reasoning || '').split('\n')[0] ?? '').substring(0, 50)}...
                        </Text>
                    </Box>
                </Box>

                <Separator />

                {/* Script Results (if any) */}
                {scripts.length > 0 && navigableItems.some(i => i.type === 'script') && (
                    <>
                        <Box flexDirection="column" marginY={1}>
                            {scripts.map((script: ScriptResult) => (
                                (() => {
                                    const navItemIndex = navigableItems.findIndex(i => {
                                        if (i.type === 'script') {
                                            return i.id === script.command;
                                        }
                                        return false;
                                    });
                                    const isSelected = selectedItemIndex === navItemIndex;
                                    return (
                                        <ScriptItemRow
                                            key={script.command}
                                            script={script}
                                            isSelected={isSelected}
                                            isExpanded={bodyView === 'script_output' && isSelected}
                                        />
                                    );
                                })()
                            ))}
                        </Box>
                        <Separator />
                    </>
                )}

                {/* Files Section */}
                <Box flexDirection="column" marginY={1}>
                    <Text bold>FILES</Text>
                    {files.map((file: FileItem) => {
                        const navItemIndex = navigableItems.findIndex(i => {
                            if (i.type === 'file') {
                                return i.id === file.id;
                            }
                            return false;
                        });
                        const isFocused = selectedItemIndex === navItemIndex;
                        const reviewState = fileReviewStates.get(file.id);
                        return (
                            <FileItemRow
                                key={file.id}
                                file={file}
                                isFocused={isFocused}
                                reviewStatus={reviewState?.status || 'AWAITING'}
                                reviewError={reviewState?.error}
                            />
                        );
                    })}
                </Box>
                
                <Separator />
                
                {/* Body Viewport */}
                {bodyView !== 'none' && (
                    <>
                        <Box marginY={1}>
                            {renderBody()}
                        </Box>
                        <Separator />
                    </>
                )}

                {/* Footer */}
                <Box>
                    {renderFooter()}
                </Box>
            </Box>
        );
    };


    export default ReviewScreen;
  src/hooks/useDebugMenu.tsx: |-
    import { useState } from 'react';
    import { useInput } from 'ink';
    import { useAppStore } from '../stores/app.store';
    import { useViewStore } from '../stores/view.store';
    import { useDashboardStore } from '../stores/dashboard.store';
    import { useReviewStore } from '../stores/review.store';
    import { useDetailStore } from '../stores/detail.store';
    import { useHistoryStore } from '../stores/history.store';
    import { useInitStore } from '../stores/init.store';
    import { useCommitStore } from '../stores/commit.store';
    import { useCopyStore } from '../stores/copy.store';
    import type { MenuItem } from '../types/debug.types';
    import { useTransactionStore } from '../stores/transaction.store';
    import { moveIndex } from '../stores/navigation.utils';
    export type { MenuItem } from '../types/debug.types';

    const useDebugMenuActions = () => {
        const { actions: appActions } = useAppStore();
        const { actions: initActions } = useInitStore();
        const { actions: commitActions } = useCommitStore();
        const { actions: dashboardActions } = useDashboardStore();
        const { actions: reviewActions } = useReviewStore();
        const { actions: detailActions } = useDetailStore();
        const { actions: historyActions } = useHistoryStore();

        const menuItems: MenuItem[] = [
            {
                title: 'Splash Screen',
                action: () => appActions.showSplashScreen(),
            },
            {
                title: 'Init: Analyze Phase',
                action: () => {
                    initActions.setPhase('ANALYZE');
                    appActions.showInitScreen();
                },
            },
            {
                title: 'Init: Interactive Phase',
                action: () => {
                    initActions.setPhase('INTERACTIVE');
                    appActions.showInitScreen();
                },
            },
            {
                title: 'Init: Finalize Phase',
                action: () => {
                    initActions.setPhase('FINALIZE');
                    appActions.showInitScreen();
                },
            },
            {
                title: 'Dashboard: Listening',
                action: () => {
                    dashboardActions.setStatus('LISTENING');
                    appActions.showDashboardScreen();
                },
            },
            {
                title: 'Dashboard: Confirm Approve',
                action: () => {
                    dashboardActions.startApproveAll();
                    appActions.showDashboardScreen();
                },
            },
            {
                title: 'Dashboard: Approving',
                action: () => {
                    dashboardActions.setStatus('APPROVING');
                    appActions.showDashboardScreen();
                },
            },
            {
                title: 'Review: Partial Failure (Default)',
                action: () => {
                    reviewActions.load('1');
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Success',
                action: () => {
                    reviewActions.load('2');
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Diff View',
                action: () => {
                    reviewActions.load('1');
                    reviewActions.setBodyView('diff');
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Reasoning View',
                action: () => {
                    reviewActions.load('1', { bodyView: 'reasoning' });
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Copy Mode',
                action: () => {
                    reviewActions.load('1');
                    appActions.showReviewScreen();
                    const tx = useTransactionStore.getState().transactions.find(t => t.id === '1');
                    if (!tx) return;
                    // On load, selected index is 0, so we can assume the first file.
                    const selectedFile = tx.files && tx.files.length > 0
                        ? tx.files[0]
                        : undefined;
                    useCopyStore.getState().actions.openForReview(tx, tx.files || [], selectedFile);
                },
            },
            {
                title: 'Review: Script Output',
                action: () => {
                    reviewActions.load('2');
                    appActions.showReviewScreen();
                    reviewActions.setBodyView('script_output');
                },
            },
            {
                title: 'Review: Bulk Repair',
                action: () => {
                    reviewActions.load('1', { bodyView: 'bulk_repair' });
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Bulk Repair (Navigable)',
                action: () => {
                    reviewActions.load('1', { bodyView: 'bulk_repair', selectedBulkRepairOptionIndex: 1 });
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review: Handoff Confirm',
                action: () => {
                    reviewActions.load('1', { bodyView: 'confirm_handoff' });
                    appActions.showReviewScreen();
                },
            },
            {
                title: 'Review Processing',
                action: () => {
                    reviewActions.load('2'); // Use tx '2' which has scripts
                    appActions.showReviewProcessingScreen();
                },
            },
            {
                title: 'Git Commit Screen',
                action: () => {
                    commitActions.prepareCommitScreen();
                    appActions.showGitCommitScreen();
                },
            },
            {
                title: 'Transaction Detail Screen',
                action: () => {
                    // The dashboard store has transactions, we'll just pick one.
                    detailActions.load('3'); // 'feat: implement new dashboard UI'
                    appActions.showTransactionDetailScreen();
                },
            },
            {
                title: 'Transaction History Screen',
                action: () => {
                    historyActions.load();
                    appActions.showTransactionHistoryScreen();
                },
            },
            {
                title: 'History: L1 Drilldown (Content)',
                action: () => {
                    historyActions.prepareDebugState('l1-drill-content');
                    appActions.showTransactionHistoryScreen();
                },
            },
            {
                title: 'History: L2 Drilldown (Reasoning)',
                action: () => {
                    historyActions.prepareDebugState('l2-drill-reasoning');
                    appActions.showTransactionHistoryScreen();
                },
            },
            {
                title: 'History: L2 Drilldown (File Diff)',
                action: () => {
                    historyActions.prepareDebugState('l2-drill-diff');
                    appActions.showTransactionHistoryScreen();
                },
            },
            {
                title: 'History: Filter Mode',
                action: () => {
                    historyActions.prepareDebugState('filter');
                    appActions.showTransactionHistoryScreen();
                },
            },
            {
                title: 'History: Copy Mode',
                action: () => {
                    historyActions.prepareDebugState('copy');
                    appActions.showTransactionHistoryScreen();
                    const { transactions } = useTransactionStore.getState();
                    const { selectedForAction } = useHistoryStore.getState();
                    const txsToCopy = transactions.filter(tx => selectedForAction.has(tx.id));
                    useCopyStore.getState().actions.openForHistory(txsToCopy);
                },
            },
            {
                title: 'History: Bulk Actions Mode',
                action: () => {
                    historyActions.prepareDebugState('bulk');
                    appActions.showTransactionHistoryScreen();
                },
            },
        ];
        return { menuItems };
    };

    export const useDebugMenu = () => {
        const [selectedIndex, setSelectedIndex] = useState(0);
        const { menuItems } = useDebugMenuActions();
        
        useInput((input, key) => {
            if (key.upArrow) {
                setSelectedIndex(i => moveIndex(i, 'up', menuItems.length));
                return;
            }
            if (key.downArrow) {
                setSelectedIndex(i => moveIndex(i, 'down', menuItems.length));
                return;
            }
            if (key.return) {
                const item = menuItems[selectedIndex];
                if (item) {
                    item.action();
                    useViewStore.getState().actions.setActiveOverlay('none');
                }
                return;
            }
            if (key.escape) {
                useViewStore.getState().actions.setActiveOverlay('none');
                return;
            }

            // No ctrl/meta keys for selection shortcuts, and only single characters
            if (key.ctrl || key.meta || input.length !== 1) return;

            if (input >= '1' && input <= '9') {
                const targetIndex = parseInt(input, 10) - 1;
                if (targetIndex < menuItems.length) {
                    setSelectedIndex(targetIndex);
                }
            } else if (input.toLowerCase() >= 'a' && input.toLowerCase() <= 'z') {
                const targetIndex = 9 + (input.toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0));
                if (targetIndex < menuItems.length) {
                    setSelectedIndex(targetIndex);
                }
            }
        });

        return {
            selectedIndex,
            menuItems,
        };
    };
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 130
