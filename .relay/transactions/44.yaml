uuid: c296f8a8-b570-4f9e-a89a-0e7845f3bb1e
projectId: relaycode-tui
createdAt: '2025-09-22T05:49:12.153Z'
gitCommitMsg: >-
  refactor: introduce service layer for business logic

  This commit introduces a new `src/services` directory to encapsulate business
  logic and simulated backend operations, separating them from UI state
  management in stores and hooks.

  - Created `CommitService` to handle commit message generation and the commit
  process. - Created `DashboardService` for the multi-step transaction approval
  flow. - Created `InitService` to manage the entire simulated initialization
  sequence. - Created `ReviewService` for complex logic like generating repair
  prompts and handling handoffs. - Created `TransactionService` for
  cross-cutting concerns like reverting transactions and loading mock data. -
  Refactored `useInitializationScreen` hook and various Zustand stores
  (`commit`, `dashboard`, `review`, `transaction-detail`, `transaction-history`)
  to delegate business logic to the new services.
promptSummary: >-
  I was asked to refactor the application to separate business logic from
  UI-related code. This is the first of four phases. I've created a new
  `services` layer and moved simulated backend logic from hooks and stores into
  new service files ([entity].service.ts).
reasoning:
  - >-
    As an expert AI programmer, I will refactor the application to separate
    business logic from UI-related hooks and stores. This first phase focuses on
    creating a new `services` layer to house simulated backend logic, making the
    stores and hooks leaner and more focused on state management and user input.
  - '### Step 1: Create Commit Service'
  - >-
    I'll start by creating a service to handle the logic related to Git commits,
    such as generating the commit message and simulating the commit process.
  - '### Step 2: Create Dashboard Service'
  - >-
    Next, I'll create a service for dashboard-specific logic, like the
    multi-step process of approving pending transactions.
  - '### Step 3: Create Initialization Service'
  - >-
    I'll extract the simulated initialization process from the
    `useInitializationScreen` hook into a dedicated service. This makes the
    entire initialization flow a single, testable business process.
  - '### Step 4: Create Review Service'
  - >-
    For the complex review screen, I'll create a service to handle logic like
    generating prompts for bulk repair and handoff, and performing the handoff
    state transition which affects multiple stores.
  - '### Step 5: Create Transaction Service'
  - >-
    A general transaction service will handle logic that spans different
    transaction-related screens, such as reverting a transaction (an action on
    the detail screen that affects the dashboard) and generating mock data for
    the history screen.
  - '### Step 6: Refactor Stores and Hooks to Use Services'
  - >-
    Now that the services are in place, I will update the corresponding stores
    and hooks to delegate business logic to them.
  - First, I'll update the initialization screen hook to use the `InitService`.
  - Next, I'll refactor the commit store.
  - I'll update the dashboard store to simplify its `confirmAction`.
  - Then, the review store.
  - I'll update the transaction detail store.
  - >-
    Finally, I'll update the transaction history store to remove the mock data
    generation logic.
  - >-
    This completes the first phase of refactoring. I have successfully
    established a service layer and moved significant business logic into it,
    cleaning up the stores and hooks.
operations:
  - type: write
    path: src/services/commit.service.ts
    content: >-
      import { useDashboardStore, type Transaction } from
      '../stores/dashboard.store';

      import { sleep } from '../utils';


      const generateCommitMessage = (transactions: Transaction[]): string => {
          if (transactions.length === 0) {
              return '';
          }
          // Using a more complex aggregation for better demo, based on the readme
          const title = 'feat: implement new dashboard and clipboard logic';
          const bodyPoints = [
              '- Adds error handling to the core transaction module to prevent uncaught exceptions during snapshot restoration.',
              '- Refactors the clipboard watcher for better performance and cross-platform compatibility, resolving issue #42.',
          ];

          if (transactions.length === 1 && transactions[0]) {
              return transactions[0].message;
          }

          return `${title}\n\n${bodyPoints.join('\n\n')}`;
      };


      const commit = async (transactionsToCommit: Transaction[]): Promise<void>
      => {
          // In a real app, this would run git commands.
          // For simulation, we'll just update the dashboard store.
          const { updateTransactionStatus } = useDashboardStore.getState().actions;

          const txIds = transactionsToCommit.map(tx => tx.id);
          
          // A bit of simulation
          await sleep(500);

          txIds.forEach(id => {
              updateTransactionStatus(id, 'COMMITTED');
          });
      };


      export const CommitService = {
          generateCommitMessage,
          commit,
      };
    patchStrategy: replace
  - type: write
    path: src/services/dashboard.service.ts
    content: |-
      import { useDashboardStore } from '../stores/dashboard.store';
      import { sleep } from '../utils';

      const approveAll = async () => {
          // Find pending transactions and mark them as in-progress
          const pendingTxIds: string[] = [];
          useDashboardStore.setState(state => {
              const newTxs = state.transactions.map(tx => {
                  if (tx.status === 'PENDING') {
                      pendingTxIds.push(tx.id);
                      return { ...tx, status: 'IN-PROGRESS' as const };
                  }
                  return tx;
              });
              return { transactions: newTxs };
          });

          await sleep(2000); // Simulate approval process

          // Mark them as applied
          useDashboardStore.setState(state => {
              const newTxs = state.transactions.map(tx => {
                  if (pendingTxIds.includes(tx.id)) {
                      return { ...tx, status: 'APPLIED' as const };
                  }
                  return tx;
              });
              return { transactions: newTxs };
          });
      };

      export const DashboardService = {
          approveAll,
      };
    patchStrategy: replace
  - type: write
    path: src/services/init.service.ts
    content: >-
      import { useInitStore, initialAnalyzeTasks, initialConfigureTasks } from
      '../stores/init.store';

      import { sleep } from '../utils';


      const runInitializationProcess = async () => {
          const { actions } = useInitStore.getState();
          actions.resetInit();

          actions.setPhase('ANALYZE');
          for (const task of initialAnalyzeTasks) {
              actions.updateAnalyzeTask(task.id, 'active');
              await sleep(800);
              actions.updateAnalyzeTask(task.id, 'done');
          }
          actions.setAnalysisResults('relaycode (from package.json)', true);
          await sleep(500);

          actions.setPhase('CONFIGURE');
          const configTasksUntilInteractive = initialConfigureTasks.slice(0, 2);
          for (const task of configTasksUntilInteractive) {
              actions.updateConfigureTask(task.id, 'active');
              await sleep(800);
              actions.updateConfigureTask(task.id, 'done');
          }
          await sleep(500);

          actions.setPhase('INTERACTIVE');
      };


      const resumeInitializationProcess = async () => {
          const { actions } = useInitStore.getState();
          
          actions.setPhase('CONFIGURE');
          const lastTask = initialConfigureTasks[2];
          if (lastTask) {
              actions.updateConfigureTask(lastTask.id, 'active');
              await sleep(800);
              actions.updateConfigureTask(lastTask.id, 'done');
              await sleep(500);

              actions.setPhase('FINALIZE');
          }
      };



      export const InitService = {
          runInitializationProcess,
          resumeInitializationProcess,
      };
    patchStrategy: replace
  - type: write
    path: src/services/review.service.ts
    content: >-
      import { FileItem } from '../stores/review.store';

      import { useDashboardStore } from '../stores/dashboard.store';

      import { useAppStore } from '../stores/app.store';


      const generateBulkRepairPrompt = (files: FileItem[]): string => {
          const failedFiles = files.filter(f => f.status === 'FAILED');
          return `The previous patch failed to apply to MULTIPLE files. Please generate a new, corrected patch that addresses all the files listed below.

      IMPORTANT: The response MUST contain a complete code block for EACH file
      that needs to be fixed.


      ${failedFiles.map(file => `--- FILE: ${file.path} ---

      Strategy: ${file.strategy}

      Error: ${file.error}


      ORIGINAL CONTENT:

      ---

      // ... original content of ${file.path} ...

      ---


      FAILED PATCH:

      ---

      ${file.diff || '// ... failed diff ...'}

      ---

      `).join('\n')}


      Please analyze all failed files and provide a complete, corrected
      response.`;

      };


      const generateHandoffPrompt = (
          hash: string,
          message: string,
          reasoning: string,
          files: FileItem[],
      ): string => {
          const successfulFiles = files.filter(f => f.status === 'APPROVED');
          const failedFiles = files.filter(f => f.status === 'FAILED');

          return `I am handing off a failed automated code transaction to you. Your task is to act as my programming assistant and complete the planned changes.

      The full plan for this transaction is detailed in the YAML file located
      at: .relay/transactions/${hash}.yml. Please use this file as your primary
      source of truth for the overall goal.


      Here is the current status of the transaction:


      --- TRANSACTION SUMMARY ---

      Goal: ${message}

      Reasoning:

      ${reasoning}


      --- CURRENT FILE STATUS ---

      SUCCESSFUL CHANGES (already applied, no action needed):

      ${successfulFiles.map(f => `- MODIFIED: ${f.path}`).join('\n') || ' 
      (None)'}


      FAILED CHANGES (these are the files you need to fix):

      ${failedFiles.map(f => `- FAILED: ${f.path} (Error:
      ${f.error})`).join('\n')}


      Your job is to now work with me to fix the FAILED files and achieve the
      original goal of the transaction. Please start by asking me which file you
      should work on first.`;

      };


      const performHandoff = (hash: string) => {
          // This is a bit of a hack to find the right transaction to update in the demo
          const txToUpdate = useDashboardStore.getState().transactions.find(tx => tx.hash === hash);
          if (txToUpdate) {
              useDashboardStore.getState().actions.updateTransactionStatus(txToUpdate.id, 'HANDOFF');
          }

          useAppStore.getState().actions.showDashboardScreen();
      };


      export const ReviewService = {
          generateBulkRepairPrompt,
          generateHandoffPrompt,
          performHandoff,
      };
    patchStrategy: replace
  - type: write
    path: src/services/transaction.service.ts
    content: >-
      import { useDashboardStore } from '../stores/dashboard.store';

      import { type HistoryTransaction, type FileChange, type TransactionStatus
      } from '../stores/transaction-history.store';


      const revertTransaction = (transactionId: string) => {
          const { updateTransactionStatus } = useDashboardStore.getState().actions;
          updateTransactionStatus(transactionId, 'REVERTED');
      };


      const createMockTransactions = (): HistoryTransaction[] => {
          const now = Date.now();
          return Array.from({ length: 42 }, (_, i) => {
              const status: TransactionStatus = i % 5 === 2 ? 'Handoff' : i % 5 === 3 ? 'Reverted' : 'Committed';
              const files: FileChange[] = [
                  { id: `${i}-1`, path: 'src/core/transaction.ts', type: 'MOD', linesAdded: 25, linesRemoved: 8, diff: '--- a/src/core/transaction.ts\n+++ b/src/core/transaction.ts\n@@ -45,7 +45,9 @@\n-    for (const [filePath, content] of entries) {\n+    const restoreErrors: { path: string, error: unknown }[] = [];\n...\n...\n...\n...\n-    another line removed' },
                  { id: `${i}-2`, path: 'src/utils/logger.ts', type: 'MOD', linesAdded: 10, linesRemoved: 2, diff: 'diff for logger' },
                  { id: `${i}-3`, path: 'src/utils/old-helper.ts', type: 'DEL', linesAdded: 0, linesRemoved: 30, diff: 'diff for old-helper' },
              ];
              const linesAdded = files.reduce((sum, f) => sum + f.linesAdded, 0);
              const linesRemoved = files.reduce((sum, f) => sum + f.linesRemoved, 0);

              return {
                  id: `tx-${i}`,
                  hash: Math.random().toString(16).slice(2, 10),
                  timestamp: now - i * 24 * 60 * 60 * 1000,
                  status,
                  message: `feat: commit message number ${42 - i}`,
                  files,
                  stats: { files: files.length, linesAdded, linesRemoved },
              };
          });
      };


      export const TransactionService = {
          revertTransaction,
          createMockTransactions,
      };
    patchStrategy: replace
  - type: write
    path: src/hooks/useInitializationScreen.tsx
    content: >+
      --- src/hooks/useInitializationScreen.tsx

      +++ src/hooks/useInitializationScreen.tsx

      @@ -2,7 +2,7 @@
       import { Text, useApp, useInput } from 'ink';
       import { useInitStore, initialAnalyzeTasks, initialConfigureTasks } from '../stores/init.store';
       import { useAppStore } from '../stores/app.store';
      -import { sleep } from '../utils';

      +import { InitService } from '../services/init.service';
       
       export const useInitializationScreen = () => {
           const phase = useInitStore(s => s.phase);
      @@ -27,45 +27,15 @@
           });
       
           useEffect(() => {
      -        actions.resetInit();

      -        const runSimulation = async () => {

      -            actions.setPhase('ANALYZE');

      -            for (const task of initialAnalyzeTasks) {

      -                actions.updateAnalyzeTask(task.id, 'active');

      -                await sleep(800);

      -                actions.updateAnalyzeTask(task.id, 'done');

      -            }

      -            actions.setAnalysisResults('relaycode (from package.json)',
      true);

      -            await sleep(500);

      -

      -            actions.setPhase('CONFIGURE');

      -            const configTasksUntilInteractive =
      initialConfigureTasks.slice(0, 2);

      -            for (const task of configTasksUntilInteractive) {

      -                actions.updateConfigureTask(task.id, 'active');

      -                await sleep(800);

      -                actions.updateConfigureTask(task.id, 'done');

      -            }

      -            await sleep(500);

      -

      -            actions.setPhase('INTERACTIVE');

      -        };

      -

      -        runSimulation();

      -    }, [actions]);

      +        InitService.runInitializationProcess();

      +    }, []);
       
           useEffect(() => {
               if (phase === 'INTERACTIVE' && interactiveChoice !== null) {
      -            const resumeSimulation = async () => {

      -                actions.setPhase('CONFIGURE');

      -                const lastTask = initialConfigureTasks[2];

      -                if (lastTask) {

      -                    actions.updateConfigureTask(lastTask.id, 'active');

      -                    await sleep(800);

      -                    actions.updateConfigureTask(lastTask.id, 'done');

      -                    await sleep(500);

      -

      -                    actions.setPhase('FINALIZE');

      -                }

      -            };

      -            resumeSimulation();

      +            InitService.resumeInitializationProcess();
               }
      -    }, [interactiveChoice, phase, actions]);

      +    }, [interactiveChoice, phase]);
       
           const {
               analyzeTasks,

    patchStrategy: standard-diff
  - type: write
    path: src/stores/commit.store.ts
    content: >+
      --- src/stores/commit.store.ts

      +++ src/stores/commit.store.ts

      @@ -1,6 +1,6 @@
       import { create } from 'zustand';
       import { useDashboardStore, type Transaction } from './dashboard.store';
      -import { sleep } from '../utils';

      +import { CommitService } from '../services/commit.service';
       
       interface CommitState {
           transactionsToCommit: Transaction[];
      @@ -12,23 +12,6 @@
           }
       }
       
      -const generateCommitMessage = (transactions: Transaction[]): string => {

      -    if (transactions.length === 0) {

      -        return '';

      -    }

      -    // Using a more complex aggregation for better demo, based on the
      readme

      -    const title = 'feat: implement new dashboard and clipboard logic';

      -    const bodyPoints = [

      -        '- Adds error handling to the core transaction module to prevent
      uncaught exceptions during snapshot restoration.',

      -        '- Refactors the clipboard watcher for better performance and
      cross-platform compatibility, resolving issue #42.',

      -    ];

      -

      -    if (transactions.length === 1 && transactions[0]) {

      -        return transactions[0].message;

      -    }

      -

      -    return `${title}\n\n${bodyPoints.join('\n\n')}`;

      -};

      -
       export const useCommitStore = create<CommitState>((set, get) => ({
           transactionsToCommit: [],
           finalCommitMessage: '',
      @@ -38,7 +21,7 @@
                   const { transactions } = useDashboardStore.getState();
                   const appliedTransactions = transactions.filter(tx => tx.status === 'APPLIED');
                   
      -            const finalCommitMessage =
      generateCommitMessage(appliedTransactions);

      +            const finalCommitMessage =
      CommitService.generateCommitMessage(appliedTransactions);
       
                   set({
                       transactionsToCommit: appliedTransactions,
      @@ -47,21 +30,8 @@
               },
               commit: async () => {
                   set({ isCommitting: true });
      -            

      -            // In a real app, this would run git commands.

      -            // For simulation, we'll just update the dashboard store.

      -            const { updateTransactionStatus } =
      useDashboardStore.getState().actions;
                   const { transactionsToCommit } = get();
      -

      -            const txIds = transactionsToCommit.map(tx => tx.id);

      -            

      -            // A bit of simulation

      -            await sleep(500);

      -

      -            txIds.forEach(id => {

      -                updateTransactionStatus(id, 'COMMITTED');

      -            });

      -

      +            await CommitService.commit(transactionsToCommit);
                   set({ isCommitting: false });
               },
           },

    patchStrategy: standard-diff
  - type: write
    path: src/stores/dashboard.store.ts
    content: >+
      --- src/stores/dashboard.store.ts

      +++ src/stores/dashboard.store.ts

      @@ -1,5 +1,5 @@
       import { create } from 'zustand';
      -import { sleep } from '../utils';

      +import { DashboardService } from '../services/dashboard.service';
       
       // --- Types ---
       export type TransactionStatus = 'PENDING' | 'APPLIED' | 'COMMITTED' | 'FAILED' | 'REVERTED' | 'IN-PROGRESS' | 'HANDOFF';
      @@ -87,35 +87,14 @@
               },
       
               confirmAction: async () => {
                   const { status, previousStatus } = get();
                   if (status === 'CONFIRM_APPROVE') {
                       set({ status: 'APPROVING' });
       
      -                // Find pending transactions and mark them as in-progress

      -                const pendingTxIds: string[] = [];

      -                set(state => {

      -                    const newTxs = state.transactions.map(tx => {

      -                        if (tx.status === 'PENDING') {

      -                            pendingTxIds.push(tx.id);

      -                            return { ...tx, status: 'IN-PROGRESS' as
      const };

      -                        }

      -                        return tx;

      -                    });

      -                    return { transactions: newTxs };

      -                });

      +                await DashboardService.approveAll();
       
      -                await sleep(2000); // Simulate approval process

      -

      -                // Mark them as applied

      -                set(state => {

      -                    const newTxs = state.transactions.map(tx => {

      -                        if (pendingTxIds.includes(tx.id)) {

      -                            return { ...tx, status: 'APPLIED' as const };

      -                        }

      -                        return tx;

      -                    });

      -                    return { transactions: newTxs, status: previousStatus
      };

      -                });

      +                set({ status: previousStatus });
                   }
               },
           },

    patchStrategy: standard-diff
  - type: write
    path: src/stores/review.store.ts
    content: >+
      --- src/stores/review.store.ts

      +++ src/stores/review.store.ts

      @@ -2,6 +2,7 @@
       import { sleep } from '../utils';
       import { useAppStore } from './app.store';
       import { useDashboardStore } from './dashboard.store';
      +import { ReviewService } from '../services/review.service';
       
       // --- Types ---
       
      @@ -528,29 +529,9 @@
                       case 1: {
                           set(state => {
                               // Copy Bulk Re-apply Prompt
      -                        const failedFiles = state.files.filter(f =>
      f.status === 'FAILED');

      -                        const bulkPrompt = `The previous patch failed to
      apply to MULTIPLE files. Please generate a new, corrected patch that
      addresses all the files listed below.

      -

      -IMPORTANT: The response MUST contain a complete code block for EACH file
      that needs to be fixed.

      -

      -${failedFiles.map(file => `--- FILE: ${file.path} ---

      -Strategy: ${file.strategy}

      -Error: ${file.error}

      -

      -ORIGINAL CONTENT:

      ---

      -// ... original content of ${file.path} ...

      ----

      -

      -FAILED PATCH:

      ----

      -${file.diff || '// ... failed diff ...'}

      ----

      -`).join('\n')}

      -

      -Please analyze all failed files and provide a complete, corrected
      response.`;

      -

      +                        const bulkPrompt =
      ReviewService.generateBulkRepairPrompt(state.files);

      +                        const failedFiles = state.files.filter(f =>
      f.status === 'FAILED');

      +                        
                               // eslint-disable-next-line no-console
                               console.log(`[CLIPBOARD] Copied bulk repair prompt for ${failedFiles.length} files`);
       
      @@ -622,34 +603,9 @@
               },
               confirmHandoff: () => {
                   const { hash, message, reasoning, files } = useReviewStore.getState();
      -            const { updateTransactionStatus } =
      useDashboardStore.getState().actions;

      -            const { showDashboardScreen } =
      useAppStore.getState().actions;

      -

      -            const successfulFiles = files.filter(f => f.status ===
      'APPROVED');

      -            const failedFiles = files.filter(f => f.status === 'FAILED');

      -

      -            const handoffPrompt = `I am handing off a failed automated
      code transaction to you. Your task is to act as my programming assistant
      and complete the planned changes.

      -

      -The full plan for this transaction is detailed in the YAML file located
      at: .relay/transactions/${hash}.yml. Please use this file as your primary
      source of truth for the overall goal.

      -

      -Here is the current status of the transaction:

      -

      ---- TRANSACTION SUMMARY ---

      -Goal: ${message}

      -Reasoning:

      -${reasoning}

      -

      ---- CURRENT FILE STATUS ---

      -SUCCESSFUL CHANGES (already applied, no action needed):

      -${successfulFiles.map(f => `- MODIFIED: ${f.path}`).join('\n') || ' 
      (None)'}

      -

      -FAILED CHANGES (these are the files you need to fix):

      -${failedFiles.map(f => `- FAILED: ${f.path} (Error:
      ${f.error})`).join('\n')}

      -

      -Your job is to now work with me to fix the FAILED files and achieve the
      original goal of the transaction. Please start by asking me which file you
      should work on first.`;

      +            const handoffPrompt =
      ReviewService.generateHandoffPrompt(hash, message, reasoning, files);
       
                   // eslint-disable-next-line no-console
                   console.log('[CLIPBOARD] Copied Handoff Prompt.');
      -

      -            // This is a bit of a hack to find the right transaction to
      update in the demo

      -            const txToUpdate =
      useDashboardStore.getState().transactions.find(tx => tx.hash === hash);

      -            if (txToUpdate) {

      -                updateTransactionStatus(txToUpdate.id, 'HANDOFF');

      -            }

      -

      -            showDashboardScreen();

      +            ReviewService.performHandoff(hash);
               },
               
               // Navigation Actions

    patchStrategy: standard-diff
  - type: write
    path: src/stores/transaction-detail.store.ts
    content: >+
      --- src/stores/transaction-detail.store.ts

      +++ src/stores/transaction-detail.store.ts

      @@ -1,5 +1,6 @@
       import { create } from 'zustand';
       import { useDashboardStore, type Transaction } from './dashboard.store';
      +import { TransactionService } from '../services/transaction.service';
       
       // Types from README
       export type FileChangeType = 'MOD' | 'ADD' | 'DEL' | 'REN';
      @@ -211,9 +212,7 @@
               confirmRevert: () => {
                   const { transaction } = get();
                   if (!transaction) return;
      -            // In a real app, this would create a new transaction. Here
      we'll just update status.

      -            const { updateTransactionStatus } =
      useDashboardStore.getState().actions;

      -            updateTransactionStatus(transaction.id, 'REVERTED');

      +            TransactionService.revertTransaction(transaction.id);
                   set({ bodyView: 'NONE' });
               },
           },

    patchStrategy: standard-diff
  - type: write
    path: src/stores/transaction-history.store.ts
    content: >+
      --- src/stores/transaction-history.store.ts

      +++ src/stores/transaction-history.store.ts

      @@ -1,4 +1,5 @@
       import { create } from 'zustand';
      +import { TransactionService } from '../services/transaction.service';
       
       // --- Types ---
       
      @@ -37,36 +38,6 @@
               prepareDebugState: (stateName: 'l1-drill' | 'l2-drill' | 'filter' | 'copy' | 'bulk') => void;
           }
       }
      -

      -// --- Mock Data ---

      -const createMockTransactions = (): HistoryTransaction[] => {

      -    const now = Date.now();

      -    return Array.from({ length: 42 }, (_, i) => {

      -        const status: TransactionStatus = i % 5 === 2 ? 'Handoff' : i % 5
      === 3 ? 'Reverted' : 'Committed';

      -        const files: FileChange[] = [

      -            { id: `${i}-1`, path: 'src/core/transaction.ts', type: 'MOD',
      linesAdded: 25, linesRemoved: 8, diff: '--- a/src/core/transaction.ts\n+++
      b/src/core/transaction.ts\n@@ -45,7 +45,9 @@\n-    for (const [filePath,
      content] of entries) {\n+    const restoreErrors: { path: string, error:
      unknown }[] = [];\n...\n...\n...\n...\n-    another line removed' },

      -            { id: `${i}-2`, path: 'src/utils/logger.ts', type: 'MOD',
      linesAdded: 10, linesRemoved: 2, diff: 'diff for logger' },

      -            { id: `${i}-3`, path: 'src/utils/old-helper.ts', type: 'DEL',
      linesAdded: 0, linesRemoved: 30, diff: 'diff for old-helper' },

      -        ];

      -        const linesAdded = files.reduce((sum, f) => sum + f.linesAdded,
      0);

      -        const linesRemoved = files.reduce((sum, f) => sum +
      f.linesRemoved, 0);

      -

      -        return {

      -            id: `tx-${i}`,

      -            hash: Math.random().toString(16).slice(2, 10),

      -            timestamp: now - i * 24 * 60 * 60 * 1000,

      -            status,

      -            message: `feat: commit message number ${42 - i}`,

      -            files,

      -            stats: { files: files.length, linesAdded, linesRemoved },

      -        };

      -    });

      -};
       
       export const getVisibleItemPaths = (transactions: HistoryTransaction[], expandedIds: Set<string>): string[] => {
           const paths: string[] = [];
      @@ -93,7 +64,7 @@
       
           actions: {
               load: (initialState) => {
      -            const transactions = createMockTransactions();

      +            const transactions =
      TransactionService.createMockTransactions();
                   set({
                       transactions,
                       selectedItemPath: transactions[0]?.id || '',

    patchStrategy: standard-diff
snapshot:
  src/services/commit.service.ts: null
  src/services/dashboard.service.ts: null
  src/services/init.service.ts: null
  src/services/review.service.ts: null
  src/services/transaction.service.ts: null
  src/hooks/useInitializationScreen.tsx: >-
    import React, { useEffect } from 'react';

    import { Text, useApp, useInput } from 'ink';

    import { useInitStore, initialAnalyzeTasks, initialConfigureTasks } from
    '../stores/init.store';

    import { useAppStore } from '../stores/app.store';

    import { sleep } from '../utils';


    export const useInitializationScreen = () => {
        const phase = useInitStore(s => s.phase);
        const interactiveChoice = useInitStore(s => s.interactiveChoice);
        const actions = useInitStore(s => s.actions);
        const showDashboardScreen = useAppStore(s => s.actions.showDashboardScreen);
        const { exit } = useApp();

        useInput((input, key) => {
            if (phase === 'INTERACTIVE') {
                if (key.return) {
                    actions.setInteractiveChoice('ignore');
                } else if (input.toLowerCase() === 's') {
                    actions.setInteractiveChoice('share');
                }
            }
            if (phase === 'FINALIZE') {
                if (input.toLowerCase() === 'q') {
                    exit();
                } else if (input.toLowerCase() === 'w') {
                    showDashboardScreen();
                }
            }
        });

        useEffect(() => {
            actions.resetInit();
            const runSimulation = async () => {
                actions.setPhase('ANALYZE');
                for (const task of initialAnalyzeTasks) {
                    actions.updateAnalyzeTask(task.id, 'active');
                    await sleep(800);
                    actions.updateAnalyzeTask(task.id, 'done');
                }
                actions.setAnalysisResults('relaycode (from package.json)', true);
                await sleep(500);

                actions.setPhase('CONFIGURE');
                const configTasksUntilInteractive = initialConfigureTasks.slice(0, 2);
                for (const task of configTasksUntilInteractive) {
                    actions.updateConfigureTask(task.id, 'active');
                    await sleep(800);
                    actions.updateConfigureTask(task.id, 'done');
                }
                await sleep(500);

                actions.setPhase('INTERACTIVE');
            };

            runSimulation();
        }, [actions]);

        useEffect(() => {
            if (phase === 'INTERACTIVE' && interactiveChoice !== null) {
                const resumeSimulation = async () => {
                    actions.setPhase('CONFIGURE');
                    const lastTask = initialConfigureTasks[2];
                    if (lastTask) {
                        actions.updateConfigureTask(lastTask.id, 'active');
                        await sleep(800);
                        actions.updateConfigureTask(lastTask.id, 'done');
                        await sleep(500);

                        actions.setPhase('FINALIZE');
                    }
                };
                resumeSimulation();
            }
        }, [interactiveChoice, phase, actions]);

        const {
            analyzeTasks,
            configureTasks,
            projectId,
        } = useInitStore();

        let footerText;
        switch (phase) {
            case 'ANALYZE': footerText = 'This utility will configure relaycode for your project.'; break;
            case 'CONFIGURE': footerText = 'Applying configuration based on project analysis...'; break;
            case 'INTERACTIVE': footerText = <Text>(<Text color="cyan" bold>Enter</Text>) No, ignore it (default)      (<Text color="cyan" bold>S</Text>) Yes, share it</Text>; break;
            case 'FINALIZE': footerText = <Text>(<Text color="cyan" bold>W</Text>)atch for Patches · (<Text color="cyan" bold>L</Text>)View Logs · (<Text color="cyan" bold>Q</Text>)uit</Text>; break;
        }

        return {
            phase,
            analyzeTasks,
            configureTasks,
            interactiveChoice,
            projectId,
            footerText,
        };
    };
  src/stores/commit.store.ts: |-
    import { create } from 'zustand';
    import { useDashboardStore, type Transaction } from './dashboard.store';
    import { sleep } from '../utils';

    interface CommitState {
        transactionsToCommit: Transaction[];
        finalCommitMessage: string;
        isCommitting: boolean;
        actions: {
            prepareCommitScreen: () => void;
            commit: () => Promise<void>;
        }
    }

    const generateCommitMessage = (transactions: Transaction[]): string => {
        if (transactions.length === 0) {
            return '';
        }
        // Using a more complex aggregation for better demo, based on the readme
        const title = 'feat: implement new dashboard and clipboard logic';
        const bodyPoints = [
            '- Adds error handling to the core transaction module to prevent uncaught exceptions during snapshot restoration.',
            '- Refactors the clipboard watcher for better performance and cross-platform compatibility, resolving issue #42.',
        ];

        if (transactions.length === 1 && transactions[0]) {
            return transactions[0].message;
        }

        return `${title}\n\n${bodyPoints.join('\n\n')}`;
    };

    export const useCommitStore = create<CommitState>((set, get) => ({
        transactionsToCommit: [],
        finalCommitMessage: '',
        isCommitting: false,
        actions: {
            prepareCommitScreen: () => {
                const { transactions } = useDashboardStore.getState();
                const appliedTransactions = transactions.filter(tx => tx.status === 'APPLIED');
                
                const finalCommitMessage = generateCommitMessage(appliedTransactions);

                set({
                    transactionsToCommit: appliedTransactions,
                    finalCommitMessage,
                });
            },
            commit: async () => {
                set({ isCommitting: true });
                
                // In a real app, this would run git commands.
                // For simulation, we'll just update the dashboard store.
                const { updateTransactionStatus } = useDashboardStore.getState().actions;
                const { transactionsToCommit } = get();

                const txIds = transactionsToCommit.map(tx => tx.id);
                
                // A bit of simulation
                await sleep(500);

                txIds.forEach(id => {
                    updateTransactionStatus(id, 'COMMITTED');
                });

                set({ isCommitting: false });
            },
        },
    }));
  src/stores/dashboard.store.ts: >-
    import { create } from 'zustand';

    import { sleep } from '../utils';


    // --- Types ---

    export type TransactionStatus = 'PENDING' | 'APPLIED' | 'COMMITTED' |
    'FAILED' | 'REVERTED' | 'IN-PROGRESS' | 'HANDOFF';


    export interface Transaction {
        id: string;
        timestamp: number;
        status: TransactionStatus;
        hash: string;
        message: string;
        error?: string;
    }


    export type DashboardStatus = 'LISTENING' | 'PAUSED' | 'CONFIRM_APPROVE' |
    'APPROVING';


    // --- Initial State (for simulation) ---

    const createInitialTransactions = (): Transaction[] => [
        { id: '1', timestamp: Date.now() - 15 * 1000, status: 'PENDING', hash: 'e4a7c112', message: 'fix: add missing error handling' },
        { id: '2', timestamp: Date.now() - 2 * 60 * 1000, status: 'APPLIED', hash: '4b9d8f03', message: 'refactor: simplify clipboard logic' },
        { id: '3', timestamp: Date.now() - 5 * 60 * 1000, status: 'COMMITTED', hash: '8a3f21b8', message: 'feat: implement new dashboard UI' },
        { id: '4', timestamp: Date.now() - 8 * 60 * 1000, status: 'REVERTED', hash: 'b2c9e04d', message: 'Reverting transaction 9c2e1a05' },
        { id: '5', timestamp: Date.now() - 9 * 60 * 1000, status: 'FAILED', hash: '9c2e1a05', message: 'style: update button component (Linter errors: 5)' },
        { id: '6', timestamp: Date.now() - 12 * 60 * 1000, status: 'COMMITTED', hash: 'c7d6b5e0', message: 'docs: update readme with TUI spec' },
    ];


    // --- Store Interface ---

    interface DashboardState {
        status: DashboardStatus;
        previousStatus: DashboardStatus; // To handle cancel from confirmation
        transactions: Transaction[];
        selectedTransactionIndex: number;
        showHelp: boolean;
        actions: {
            togglePause: () => void;
            moveSelectionUp: () => void;
            moveSelectionDown: () => void;
            startApproveAll: () => void;
            confirmAction: () => Promise<void>;
            cancelAction: () => void;
            toggleHelp: () => void;
            setStatus: (status: DashboardStatus) => void; // For debug menu
            updateTransactionStatus: (id: string, status: TransactionStatus) => void;
        };
    }


    // --- Store Implementation ---

    export const useDashboardStore = create<DashboardState>((set, get) => ({
        status: 'LISTENING',
        previousStatus: 'LISTENING',
        transactions: createInitialTransactions(),
        selectedTransactionIndex: 0,
        showHelp: false,
        actions: {
            togglePause: () => set(state => ({
                status: state.status === 'LISTENING' ? 'PAUSED' : 'LISTENING',
            })),
            moveSelectionUp: () => set(state => ({
                selectedTransactionIndex: Math.max(0, state.selectedTransactionIndex - 1),
            })),
            moveSelectionDown: () => set(state => ({
                selectedTransactionIndex: Math.min(state.transactions.length - 1, state.selectedTransactionIndex + 1),
            })),
            startApproveAll: () => set(state => ({
                status: 'CONFIRM_APPROVE',
                previousStatus: state.status,
            })),
            cancelAction: () => set(state => ({ status: state.previousStatus })),
            toggleHelp: () => set(state => ({ showHelp: !state.showHelp })),
            setStatus: (status) => set({ status }),
            updateTransactionStatus: (id, status) => {
                set(state => ({
                    transactions: state.transactions.map(tx =>
                        tx.id === id ? { ...tx, status, timestamp: Date.now() } : tx,
                    ),
                }));
                // After updating, move selection to the updated transaction
                const index = get().transactions.findIndex(tx => tx.id === id);
                if (index !== -1) set({ selectedTransactionIndex: index });
            },

            confirmAction: async () => {
                const { status, previousStatus } = get();
                if (status === 'CONFIRM_APPROVE') {
                    set({ status: 'APPROVING' });

                    // Find pending transactions and mark them as in-progress
                    const pendingTxIds: string[] = [];
                    set(state => {
                        const newTxs = state.transactions.map(tx => {
                            if (tx.status === 'PENDING') {
                                pendingTxIds.push(tx.id);
                                return { ...tx, status: 'IN-PROGRESS' as const };
                            }
                            return tx;
                        });
                        return { transactions: newTxs };
                    });

                    await sleep(2000); // Simulate approval process

                    // Mark them as applied
                    set(state => {
                        const newTxs = state.transactions.map(tx => {
                            if (pendingTxIds.includes(tx.id)) {
                                return { ...tx, status: 'APPLIED' as const };
                            }
                            return tx;
                        });
                        return { transactions: newTxs, status: previousStatus };
                    });
                }
            },
        },
    }));
  src/stores/review.store.ts: >-
    import { create } from 'zustand';

    import { sleep } from '../utils';

    import { useAppStore } from './app.store';

    import { useDashboardStore } from './dashboard.store';


    // --- Types ---


    export type FileStatus = 'FAILED' | 'APPROVED' | 'REJECTED' | 'AWAITING' |
    'RE_APPLYING';

    export interface FileItem {
        id: string;
        path: string;
        status: FileStatus;
        diff: string;
        linesAdded: number;
        linesRemoved: number;
        error?: string;
        strategy: 'replace' | 'standard-diff';
    }


    export interface ScriptResult {
        command: string;
        success: boolean;
        duration: number;
        summary: string;
        output: string;
    }


    export interface ApplyStep {
        id: string;
        title: string;
        status: 'pending' | 'active' | 'done' | 'failed' | 'skipped';
        details?: string;
        substeps?: ApplyStep[];
        duration?: number;
    }


    const initialApplySteps: ApplyStep[] = [
        { id: 'snapshot', title: 'Reading initial file snapshot...', status: 'pending' },
        { id: 'memory', title: 'Applying operations to memory...', status: 'pending', substeps: [] },
        { id: 'post-command', title: 'Running post-command script...', status: 'pending', substeps: [] },
        { id: 'linter', title: 'Analyzing changes with linter...', status: 'pending', substeps: [] },
    ];


    export type BodyView = 'diff' | 'reasoning' | 'script_output' | 'copy_mode'
    | 'bulk_repair' | 'confirm_handoff' | 'none';

    export type PatchStatus = 'SUCCESS' | 'PARTIAL_FAILURE';


    interface ReviewState {
        // Transaction Info
        hash: string;
        message: string;
        prompt: string;
        reasoning: string;
        linesAdded: number;
        linesRemoved: number;
        duration: number;
        patchStatus: PatchStatus;

        // File & Script Info
        files: FileItem[];
        scripts: ScriptResult[];

        // UI State
        applySteps: ApplyStep[];
        selectedItemIndex: number; // Can be file or script
        bodyView: BodyView;
        isDiffExpanded: boolean;
        
        // Copy Mode State
        copyModeSelectedIndex: number;
        copyModeLastCopied: string | null;
        
        // Reasoning Scroll State
        reasoningScrollIndex: number;
        
        // Script Navigation State
        scriptErrorIndex: number;

        actions: {
            moveSelectionUp: () => void;
            moveSelectionDown: () => void;
            toggleFileApproval: () => void;
            rejectAllFiles: () => void;
            toggleDiffView: () => void;
            toggleReasoningView: () => void;
            toggleScriptView: () => void;
            expandDiff: () => void;
            approve: () => void;
            simulateSuccessScenario: () => void;
            startApplySimulation: (scenario: 'success' | 'failure') => void;
            simulateFailureScenario: () => void;
            
            // Copy Mode Actions
            toggleCopyMode: () => void;
            moveCopySelectionUp: () => void;
            moveCopySelectionDown: () => void;
            copySelectedItem: () => void;
            copyUUID: () => void;
            copyMessage: () => void;
            copyPrompt: () => void;
            copyReasoning: () => void;
            copyFileDiff: () => void;
            copyAllDiffs: () => void;
            
            // Repair Actions
            tryRepairFile: () => void;
            showBulkRepair: () => void;
            executeBulkRepairOption: (option: number) => Promise<void>;
            confirmHandoff: () => void;
            
            // Navigation Actions
            scrollReasoningUp: () => void;
            scrollReasoningDown: () => void;
            navigateScriptErrorUp: () => void;
            navigateScriptErrorDown: () => void,
        };
    }


    // --- Mock Data ---


    const mockFiles: FileItem[] = [
        { 
            id: '1', 
            path: 'src/core/transaction.ts', 
            status: 'APPROVED', 
            linesAdded: 18, 
            linesRemoved: 5, 
            diff: `--- a/src/core/transaction.ts
    +++ b/src/core/transaction.ts

    @@ -15,7 +15,7 @@ export class Transaction {
       }
     
    -  calculateChanges(): ChangeSet {

    +  computeDelta(): ChangeSet {
         return this.changes;
       }
     }`, 
            strategy: 'replace', 
        },
        { 
            id: '2', 
            path: 'src/utils/logger.ts', 
            status: 'FAILED', 
            linesAdded: 0, 
            linesRemoved: 0, 
            diff: '', 
            error: 'Hunk #1 failed to apply', 
            strategy: 'standard-diff', 
        },
        { 
            id: '3', 
            path: 'src/commands/apply.ts', 
            status: 'FAILED', 
            linesAdded: 0, 
            linesRemoved: 0, 
            diff: '', 
            error: 'Context mismatch at line 92', 
            strategy: 'standard-diff', 
        },
    ];


    const mockScripts: ScriptResult[] = [
        { command: 'bun run test', success: true, duration: 2.3, summary: 'Passed (37 tests)', output: '... test output ...' },
        { command: 'bun run lint', success: false, duration: 1.2, summary: '1 Error, 3 Warnings', output: `src/core/clipboard.ts
      45:12  Error    'clipboardy' is assigned a value but never used. (@typescript-eslint/no-unused-vars)
      88:5   Warning  Unexpected console statement. (no-console)` },
    ];


    const mockReasoning = `1. Identified a potential uncaught exception in the
    \`restoreSnapshot\` function
       if a file operation fails midway through a loop of many files. This could
       leave the project in a partially-reverted, inconsistent state.

    2. Wrapped the file restoration loop in a \`Promise.all\` and added a
    dedicated
       error collection array. This ensures that all file operations are
       attempted and that a comprehensive list of failures is available
       afterward for better error reporting or partial rollback logic.`;

    // --- Store Implementation ---


    export const useReviewStore = create<ReviewState>((set) => ({
        // Transaction Info
        hash: 'e4a7c112',
        message: 'refactor: rename core utility function',
        prompt: 'Rename the `calculateChanges` utility to `computeDelta` across all files and update imports accordingly.',
        reasoning: mockReasoning,
        linesAdded: 18,
        linesRemoved: 5,
        duration: 0.6,
        patchStatus: 'PARTIAL_FAILURE',

        // File & Script Info
        files: mockFiles,
        scripts: [], // Empty for partial failure scenario

        // UI State
        applySteps: initialApplySteps,
        selectedItemIndex: 0, // Start with first file
        bodyView: 'none',
        isDiffExpanded: false,
        
        // Copy Mode State
        copyModeSelectedIndex: 0,
        copyModeLastCopied: null,
        
        // Reasoning Scroll State
        reasoningScrollIndex: 0,
        
        // Script Navigation State
        scriptErrorIndex: 0,

        actions: {
            moveSelectionUp: () => set(state => ({
                selectedItemIndex: Math.max(0, state.selectedItemIndex - 1),
            })),
            moveSelectionDown: () => set(state => ({
                selectedItemIndex: Math.min(state.files.length + state.scripts.length - 1, state.selectedItemIndex + 1),
            })),
            toggleFileApproval: () => set(state => {
                const { selectedItemIndex, files } = state;
                if (selectedItemIndex >= files.length) return {}; // Not a file
                
                const newFiles = [...files];
                const file = newFiles[selectedItemIndex];
                if (file) {
                    if (file.status === 'APPROVED') {
                        file.status = 'REJECTED';
                    } else if (file.status === 'REJECTED') {
                        file.status = 'APPROVED';
                    }
                }
                return { files: newFiles };
            }),
            rejectAllFiles: () => set(state => {
                const newFiles = state.files.map(file => {
                    if (file.status === 'APPROVED') {
                        return { ...file, status: 'REJECTED' as const };
                    }
                    return file;
                });
                return { files: newFiles };
            }),
            toggleDiffView: () => set(state => {
                const { bodyView } = state;
                if (state.selectedItemIndex >= state.files.length) return {}; // Can't show diff for scripts
                return {
                    bodyView: bodyView === 'diff' ? 'none' : 'diff',
                    isDiffExpanded: false, // Always start collapsed
                };
            }),
            toggleReasoningView: () => set(state => {
                const { bodyView } = state;
                return {
                    bodyView: bodyView === 'reasoning' ? 'none' : 'reasoning',
                };
            }),
            toggleScriptView: () => set(state => {
                const { bodyView } = state;
                return {
                    bodyView: bodyView === 'script_output' ? 'none' : 'script_output',
                };
            }),
            expandDiff: () => set(state => ({ isDiffExpanded: !state.isDiffExpanded })),
            approve: () => { /* NOP for now, would trigger commit and screen change */ },
            startApplySimulation: async (scenario: 'success' | 'failure') => {
                const { showReviewProcessingScreen, showReviewScreen } = useAppStore.getState().actions;
                
                set({ applySteps: JSON.parse(JSON.stringify(initialApplySteps)) });
                showReviewProcessingScreen();
                
                const updateStep = (id: string, status: ApplyStep['status'], duration?: number, details?: string) => {
                    set(state => ({
                        applySteps: state.applySteps.map(s => {
                            if (s.id === id) {
                                const newStep = { ...s, status };
                                if (duration !== undefined) newStep.duration = duration;
                                if (details !== undefined) newStep.details = details;
                                return newStep;
                            }
                            return s;
                        }),
                    }));
                };
        
                const addSubstep = (parentId: string, substep: Omit<ApplyStep, 'substeps'>) => {
                     set(state => ({
                        applySteps: state.applySteps.map(s => {
                            if (s.id === parentId) {
                                const newSubsteps = [...(s.substeps || []), substep as ApplyStep];
                                return { ...s, substeps: newSubsteps };
                            }
                            return s;
                        }),
                    }));
                };
        
                if (scenario === 'success') {
                    useReviewStore.getState().actions.simulateSuccessScenario();
                    
                    updateStep('snapshot', 'active'); await sleep(100);
                    updateStep('snapshot', 'done', 0.1);
        
                    updateStep('memory', 'active'); await sleep(100);
                    addSubstep('memory', { id: 's1', title: '[✓] write: src/core/clipboard.ts (strategy: replace)', status: 'done' });
                    await sleep(100);
                    addSubstep('memory', { id: 's2', title: '[✓] write: src/utils/shell.ts (strategy: standard-diff)', status: 'done' });
                    updateStep('memory', 'done', 0.3);
        
                    updateStep('post-command', 'active'); await sleep(1300);
                    addSubstep('post-command', { id: 's3', title: '`bun run test` ... Passed', status: 'done' });
                    updateStep('post-command', 'done', 2.3);
        
                    updateStep('linter', 'active'); await sleep(1200);
                    addSubstep('linter', { id: 's4', title: '`bun run lint` ... 0 Errors', status: 'done' });
                    updateStep('linter', 'done', 1.2);
        
                    await sleep(500);
        
                } else { // failure scenario
                    useReviewStore.getState().actions.simulateFailureScenario();
                    
                    updateStep('snapshot', 'active'); await sleep(100);
                    updateStep('snapshot', 'done', 0.1);
        
                    updateStep('memory', 'active'); await sleep(100);
                    addSubstep('memory', { id: 'f1', title: '[✓] write: src/core/transaction.ts (strategy: replace)', status: 'done' });
                    await sleep(100);
                    addSubstep('memory', { id: 'f2', title: '[!] failed: src/utils/logger.ts (Hunk #1 failed to apply)', status: 'failed' });
                    await sleep(100);
                    addSubstep('memory', { id: 'f3', title: '[!] failed: src/commands/apply.ts (Context mismatch at line 92)', status: 'failed' });
                    updateStep('memory', 'done', 0.5);
        
                    await sleep(100);
                    updateStep('post-command', 'skipped', undefined, 'Skipped due to patch application failure');
                    await sleep(100);
                    updateStep('linter', 'skipped', undefined, 'Skipped due to patch application failure');
                    
                    await sleep(500);
                }
        
                showReviewScreen();
            },
            simulateSuccessScenario: () => set(() => ({
                hash: '4b9d8f03',
                message: 'refactor: simplify clipboard logic',
                prompt: 'Simplify the clipboard logic using an external library...',
                linesAdded: 22,
                linesRemoved: 11,
                duration: 3.9,
                patchStatus: 'SUCCESS' as const,
                files: [
                    { 
                        id: '1', 
                        path: 'src/core/clipboard.ts', 
                        status: 'APPROVED' as const, 
                        linesAdded: 15, 
                        linesRemoved: 8, 
                        diff: `--- a/src/core/clipboard.ts
    +++ b/src/core/clipboard.ts

    @@ -1,5 +1,6 @@
     import { copy as copyToClipboard } from 'clipboardy';`, 
                        strategy: 'replace' as const,
                    },
                    { 
                        id: '2', 
                        path: 'src/utils/shell.ts', 
                        status: 'APPROVED' as const, 
                        linesAdded: 7, 
                        linesRemoved: 3, 
                        diff: `--- a/src/utils/shell.ts
    +++ b/src/utils/shell.ts`, 
                        strategy: 'standard-diff' as const,
                    },
                ],
                scripts: mockScripts,
                selectedItemIndex: 0,
                bodyView: 'none' as const,
            })),
            simulateFailureScenario: () => set(() => ({
                hash: 'e4a7c112',
                message: 'refactor: rename core utility function',
                prompt: 'Rename the `calculateChanges` utility to `computeDelta` across all files and update imports accordingly.',
                linesAdded: 18,
                linesRemoved: 5,
                duration: 0.6,
                patchStatus: 'PARTIAL_FAILURE' as const,
                files: mockFiles,
                scripts: [],
                // Reset UI state
                bodyView: 'none',
                isDiffExpanded: false,
                reasoningScrollIndex: 0,
                scriptErrorIndex: 0,
                selectedItemIndex: 0,
            })),
            
            // Copy Mode Actions
            toggleCopyMode: () => set(state => ({
                bodyView: state.bodyView === 'copy_mode' ? 'none' : 'copy_mode',
                copyModeSelectedIndex: 0,
                copyModeLastCopied: null,
            })),
            moveCopySelectionUp: () => set(state => ({
                copyModeSelectedIndex: Math.max(0, state.copyModeSelectedIndex - 1),
            })),
            moveCopySelectionDown: () => set(state => ({
                copyModeSelectedIndex: Math.min(5, state.copyModeSelectedIndex + 1), // 6 total options (U,M,P,R,F,A)
            })),
            copySelectedItem: () => set(state => {
                const { copyModeSelectedIndex, hash, message, prompt, reasoning, files, selectedItemIndex } = state;
                let content = '';
                let label = '';
                
                switch (copyModeSelectedIndex) {
                    case 0: // UUID
                        content = `${hash}-a8b3-4f2c-9d1e-8a7c1b9d8f03`;
                        label = 'UUID';
                        break;
                    case 1: // Git Message
                        content = message;
                        label = 'Git Message';
                        break;
                    case 2: // Prompt
                        content = prompt;
                        label = 'Prompt';
                        break;
                    case 3: // Reasoning
                        content = reasoning;
                        label = 'Reasoning';
                        break;
                    case 4: // Diff for current file
                        if (selectedItemIndex < files.length) {
                            const file = files[selectedItemIndex];
                            if (file) {
                                content = file.diff;
                                label = `Diff for ${file.path}`;
                            }
                        }
                        break;
                    case 5: // All Diffs
                        content = files.map(f => `--- FILE: ${f.path} ---\n${f.diff}`).join('\n\n');
                        label = 'All Diffs';
                        break;
                }
                
                // Mock clipboard operation (TUI environment - no real clipboard)
                // eslint-disable-next-line no-console
                console.log(`[CLIPBOARD] Copied ${label}: ${content.substring(0, 100)}...`);
                
                return { copyModeLastCopied: label };
            }),
            copyUUID: () => set(state => {
                const content = `${state.hash}-a8b3-4f2c-9d1e-8a7c1b9d8f03`;
                // eslint-disable-next-line no-console
                console.log(`[CLIPBOARD] Copied UUID: ${content}`);
                return { copyModeLastCopied: 'UUID' };
            }),
            copyMessage: () => set(state => {
                // eslint-disable-next-line no-console
                console.log(`[CLIPBOARD] Copied Git Message: ${state.message}`);
                return { copyModeLastCopied: 'Git Message' };
            }),
            copyPrompt: () => set(state => {
                // eslint-disable-next-line no-console
                console.log(`[CLIPBOARD] Copied Prompt: ${state.prompt.substring(0, 100)}...`);
                return { copyModeLastCopied: 'Prompt' };
            }),
            copyReasoning: () => set(state => {
                // eslint-disable-next-line no-console
                console.log(`[CLIPBOARD] Copied Reasoning: ${state.reasoning.substring(0, 100)}...`);
                return { copyModeLastCopied: 'Reasoning' };
            }),
            copyFileDiff: () => set(state => {
                if (state.selectedItemIndex < state.files.length) {
                    const file = state.files[state.selectedItemIndex];
                    if (file) {
                        // eslint-disable-next-line no-console
                        console.log(`[CLIPBOARD] Copied diff for: ${file.path}`);
                        return { copyModeLastCopied: `Diff for ${file.path}` };
                    }
                }
                return {};
            }),
            copyAllDiffs: () => set(state => {
                const content = state.files.map(f => `--- FILE: ${f.path} ---\n${f.diff}`).join('\n\n');
                // eslint-disable-next-line no-console
                console.log(`[CLIPBOARD] Copied all diffs: ${state.files.length} files`);
                return { copyModeLastCopied: 'All Diffs' };
            }),
            
            // Repair Actions
            tryRepairFile: () => set(state => {
                const { selectedItemIndex, files } = state;
                if (selectedItemIndex < files.length) {
                    const file = files[selectedItemIndex];
                    if (file && file.status === 'FAILED') {
                        // Generate repair prompt and copy to clipboard
                        const repairPrompt = `The patch failed to apply to ${file.path}. Please generate a corrected patch.

    Error: ${file.error}

    Strategy: ${file.strategy}


    ORIGINAL CONTENT:

    ---

    // ... original file content would be here ...

    ---


    FAILED PATCH:

    ---

    ${file.diff || '// ... failed diff would be here ...'}

    ---


    Please provide a corrected patch that addresses the error.`;

                        // eslint-disable-next-line no-console
                        console.log(`[CLIPBOARD] Copied repair prompt for: ${file.path}`);

                        // Mock: Update file status to show it's being repaired
                        const newFiles = [...files];
                        newFiles[selectedItemIndex] = { ...file, status: 'APPROVED' as const, error: undefined, linesAdded: 5, linesRemoved: 2 };

                        return { files: newFiles, copyModeLastCopied: 'Repair prompt copied to clipboard' };
                    }
                }
                return {};
            }),
            showBulkRepair: () => set(() => ({
                bodyView: 'bulk_repair' as const,
            })),
            executeBulkRepairOption: async (option: number) => {
                switch (option) {
                    case 1: {
                        set(state => {
                            // Copy Bulk Re-apply Prompt
                            const failedFiles = state.files.filter(f => f.status === 'FAILED');
                            const bulkPrompt = `The previous patch failed to apply to MULTIPLE files. Please generate a new, corrected patch that addresses all the files listed below.

    IMPORTANT: The response MUST contain a complete code block for EACH file
    that needs to be fixed.


    ${failedFiles.map(file => `--- FILE: ${file.path} ---

    Strategy: ${file.strategy}

    Error: ${file.error}


    ORIGINAL CONTENT:

    ---

    // ... original content of ${file.path} ...

    ---


    FAILED PATCH:

    ---

    ${file.diff || '// ... failed diff ...'}

    ---

    `).join('\n')}


    Please analyze all failed files and provide a complete, corrected
    response.`;

                            // eslint-disable-next-line no-console
                            console.log(`[CLIPBOARD] Copied bulk repair prompt for ${failedFiles.length} files`);

                            const newFiles = state.files.map(file =>
                                file.status === 'FAILED'
                                    ? { ...file, status: 'AWAITING' as const }
                                    : file,
                            );

                            return { files: newFiles, bodyView: 'none' as const, copyModeLastCopied: 'Bulk repair prompt copied' };
                        });
                        break;
                    }
                        
                    case 2: {
                        const failedFileIds = new Set(useReviewStore.getState().files.filter(f => f.status === 'FAILED').map(f => f.id));

                        set(state => ({
                            files: state.files.map(file =>
                                failedFileIds.has(file.id)
                                    ? { ...file, status: 'RE_APPLYING' as const }
                                    : file,
                            ),
                            bodyView: 'none' as const,
                        }));

                        await sleep(1500); // Simulate re-apply

                        // Mock a mixed result
                        let first = true;
                        set(state => ({
                            files: state.files.map(file => {
                                if (failedFileIds.has(file.id)) {
                                    if (first) {
                                        first = false;
                                        return { ...file, status: 'APPROVED' as const, strategy: 'replace' as const, error: undefined, linesAdded: 9, linesRemoved: 2 };
                                    }
                                    return { ...file, status: 'FAILED' as const, error: "'replace' failed: markers not found" };
                                }
                                return file;
                            }),
                        }));
                        break;
                    }
                        
                    case 3: {
                        set({ bodyView: 'confirm_handoff' as const });
                        break;
                    }
                        
                    case 4: {
                        set(state => ({
                            files: state.files.map(file =>
                                file.status === 'FAILED'
                                    ? { ...file, status: 'REJECTED' as const }
                                    : file,
                            ),
                            bodyView: 'none' as const,
                        }));
                        break;
                    }
                        
                    default:
                        set({ bodyView: 'none' as const });
                }
            },
            confirmHandoff: () => {
                const { hash, message, reasoning, files } = useReviewStore.getState();
                const { updateTransactionStatus } = useDashboardStore.getState().actions;
                const { showDashboardScreen } = useAppStore.getState().actions;

                const successfulFiles = files.filter(f => f.status === 'APPROVED');
                const failedFiles = files.filter(f => f.status === 'FAILED');

                const handoffPrompt = `I am handing off a failed automated code transaction to you. Your task is to act as my programming assistant and complete the planned changes.

    The full plan for this transaction is detailed in the YAML file located at:
    .relay/transactions/${hash}.yml. Please use this file as your primary source
    of truth for the overall goal.


    Here is the current status of the transaction:


    --- TRANSACTION SUMMARY ---

    Goal: ${message}

    Reasoning:

    ${reasoning}


    --- CURRENT FILE STATUS ---

    SUCCESSFUL CHANGES (already applied, no action needed):

    ${successfulFiles.map(f => `- MODIFIED: ${f.path}`).join('\n') || ' 
    (None)'}


    FAILED CHANGES (these are the files you need to fix):

    ${failedFiles.map(f => `- FAILED: ${f.path} (Error:
    ${f.error})`).join('\n')}


    Your job is to now work with me to fix the FAILED files and achieve the
    original goal of the transaction. Please start by asking me which file you
    should work on first.`;

                // eslint-disable-next-line no-console
                console.log('[CLIPBOARD] Copied Handoff Prompt.');

                // This is a bit of a hack to find the right transaction to update in the demo
                const txToUpdate = useDashboardStore.getState().transactions.find(tx => tx.hash === hash);
                if (txToUpdate) {
                    updateTransactionStatus(txToUpdate.id, 'HANDOFF');
                }

                showDashboardScreen();
            },
            
            // Navigation Actions
            scrollReasoningUp: () => set(state => ({
                reasoningScrollIndex: Math.max(0, state.reasoningScrollIndex - 1),
            })),
            scrollReasoningDown: () => set(state => {
                const maxLines = state.reasoning.split('\n').length;
                return { reasoningScrollIndex: Math.min(maxLines - 1, state.reasoningScrollIndex + 1) };
            }),
            navigateScriptErrorUp: () => set(state => ({
                scriptErrorIndex: Math.max(0, state.scriptErrorIndex - 1),
            })),
            navigateScriptErrorDown: () => set(state => {
                const selectedScript = state.scripts[state.selectedItemIndex - state.files.length];
                if (selectedScript && selectedScript.output) {
                    const errorLines = selectedScript.output.split('\n').filter(line => 
                        line.includes('Error') || line.includes('Warning'),
                    );
                    return { scriptErrorIndex: Math.min(errorLines.length - 1, state.scriptErrorIndex + 1) };
                }
                return {};
            }),
        },
    }));
  src/stores/transaction-detail.store.ts: >-
    import { create } from 'zustand';

    import { useDashboardStore, type Transaction } from './dashboard.store';


    // Types from README

    export type FileChangeType = 'MOD' | 'ADD' | 'DEL' | 'REN';

    export interface FileDetail {
        id: string;
        path: string;
        type: FileChangeType;
        diff: string;
        linesAdded: number;
        linesRemoved: number;
    }


    export type NavigatorSection = 'PROMPT' | 'REASONING' | 'FILES';

    export type BodyView = 'PROMPT' | 'REASONING' | 'FILES_LIST' | 'DIFF_VIEW' |
    'COPY_MODE' | 'REVERT_CONFIRM' | 'NONE';


    interface TransactionDetailState {
        // Data
        transaction: Transaction | null;
        prompt: string;
        reasoning: string;
        files: FileDetail[];
        
        // UI State
        navigatorFocus: NavigatorSection | 'FILES_LIST';
        expandedSection: NavigatorSection | null;
        selectedFileIndex: number;
        bodyView: BodyView;
        copyModeSelectionIndex: number;
        copyModeSelections: Record<string, boolean>;
        copyModeLastCopied: string | null;

        // Actions
        actions: {
            loadTransaction: (transactionId: string) => void;
            navigateUp: () => void;
            navigateDown: () => void;
            handleEnterOrRight: () => void;
            handleEscapeOrLeft: () => void;
            toggleCopyMode: () => void;
            toggleRevertConfirm: () => void;
            copyModeNavigateUp: () => void;
            copyModeNavigateDown: () => void;
            copyModeToggleSelection: () => void;
            copyModeExecuteCopy: () => void;
            confirmRevert: () => void;
        }
    }


    // Mock data based on README

    const mockTransactionData = {
        prompt: 'The user requested to add more robust error handling to the `restoreSnapshot` function. Specifically, it should not halt on the first error but instead attempt all file restorations and then report a summary of any failures.',
        reasoning: `1. The primary goal was to make the rollback functionality in \`restoreSnapshot\` more robust. The previous implementation used a simple for-loop which would halt on the first error, leaving the project in a partially restored state.

    2. I opted for a \`Promise.all\` approach to run file restorations in
    parallel. This improves performance slightly but, more importantly, ensures
    all restoration attempts are completed, even if some fail.


    3. An \`restoreErrors\` array was introduced to collect any exceptions that
    occur during the process. If this array is not empty after the
    \`Promise.all\` completes, a comprehensive error is thrown, informing the
    user exactly which files failed to restore. This provides much better
    diagnostics.`,
        files: [
            { id: '1', path: 'src/core/transaction.ts', type: 'MOD' as const, linesAdded: 18, linesRemoved: 5, diff: `   export const restoreSnapshot = async (snapshot: FileSnapshot, ...): ... => {
         ...
    -    for (const [filePath, content] of entries) {

    -        if (content === null) {

    -            await deleteFile(filePath, cwd);

    -        }

    -    }

    +    const restoreErrors: { path: string, error: unknown }[] = [];

    +

    +    await Promise.all(entries.map(async ([filePath, content]) => {

    +        try {

    +          if (content === null) { ... }

    +        } catch (error) {

    +          restoreErrors.push({ path: filePath, error });

    +        }

    +    }));

    +

    +    if (restoreErrors.length > 0) { ... }
       }` },
            { id: '2', path: 'src/utils/logger.ts', type: 'MOD' as const, linesAdded: 7, linesRemoved: 3, diff: '... diff content for logger.ts ...' },
            { id: '3', path: 'src/utils/old-helper.ts', type: 'DEL' as const, linesAdded: 0, linesRemoved: 0, diff: '... diff content for old-helper.ts ...' },
        ],
    };


    const navigatorOrder: NavigatorSection[] = ['PROMPT', 'REASONING', 'FILES'];

    const copyOptionsList = [
        'Git Message', 'Prompt', 'Reasoning', `All Diffs (${mockTransactionData.files.length} files)`, `Diff for: ${mockTransactionData.files[0]?.path}`, 'UUID', 'Full YAML representation',
    ];


    export const useTransactionDetailStore =
    create<TransactionDetailState>((set, get) => ({
        transaction: null,
        prompt: '',
        reasoning: '',
        files: [],
        
        navigatorFocus: 'PROMPT',
        expandedSection: null,
        selectedFileIndex: 0,
        bodyView: 'NONE',
        copyModeSelectionIndex: 0,
        copyModeSelections: { 'Git Message': true, 'Reasoning': true }, // Default selections from readme
        copyModeLastCopied: null,

        actions: {
            loadTransaction: (transactionId) => {
                const { transactions } = useDashboardStore.getState();
                const transaction = transactions.find(tx => tx.id === transactionId);
                if (transaction) {
                    set({
                        transaction,
                        ...mockTransactionData,
                        // Reset UI state
                        navigatorFocus: 'PROMPT',
                        expandedSection: null,
                        selectedFileIndex: 0,
                        bodyView: 'NONE',
                    });
                }
            },
            navigateUp: () => {
                const { navigatorFocus, selectedFileIndex } = get();
                if (navigatorFocus === 'FILES_LIST') {
                    set({ selectedFileIndex: Math.max(0, selectedFileIndex - 1) });
                } else {
                    const currentIndex = navigatorOrder.indexOf(navigatorFocus as NavigatorSection);
                    if (currentIndex > 0) {
                        set({ navigatorFocus: navigatorOrder[currentIndex - 1] });
                    }
                }
            },
            navigateDown: () => {
                const { navigatorFocus, selectedFileIndex, files } = get();
                if (navigatorFocus === 'FILES_LIST') {
                    set({ selectedFileIndex: Math.min(files.length - 1, selectedFileIndex + 1) });
                } else {
                    const currentIndex = navigatorOrder.indexOf(navigatorFocus as NavigatorSection);
                    if (currentIndex < navigatorOrder.length - 1) {
                        set({ navigatorFocus: navigatorOrder[currentIndex + 1] });
                    }
                }
            },
            handleEnterOrRight: () => {
                const { navigatorFocus, expandedSection } = get();

                if (navigatorFocus === 'FILES_LIST') {
                    // Already in file list, now show diff
                    set({ bodyView: 'DIFF_VIEW' });
                    return;
                }

                if (expandedSection === navigatorFocus) {
                    // Section is already expanded, handle nested navigation
                    if (navigatorFocus === 'FILES') {
                        set({ navigatorFocus: 'FILES_LIST', bodyView: 'FILES_LIST' });
                    }
                    return;
                }

                // Expand the focused section
                set({ expandedSection: navigatorFocus });

                switch(navigatorFocus) {
                    case 'PROMPT':
                        set({ bodyView: 'PROMPT' });
                        break;
                    case 'REASONING':
                        set({ bodyView: 'REASONING' });
                        break;
                    case 'FILES':
                        set({ bodyView: 'FILES_LIST' });
                        break;
                }
            },
            handleEscapeOrLeft: () => {
                const { navigatorFocus, expandedSection, bodyView } = get();

                if (bodyView === 'DIFF_VIEW') {
                    set({ bodyView: 'FILES_LIST' }); // Go back from diff to file list
                    return;
                }

                if (navigatorFocus === 'FILES_LIST') {
                    set({ navigatorFocus: 'FILES', bodyView: 'NONE' }); // Go back from file list to files section
                    return;
                }

                // If a section is expanded, collapse it
                if (expandedSection) {
                    set({ expandedSection: null, bodyView: 'NONE' });
                    return;
                }
            },
            toggleCopyMode: () => set(state => {
                if (state.bodyView === 'COPY_MODE') {
                    return { bodyView: 'NONE' };
                }
                return {
                    bodyView: 'COPY_MODE',
                    copyModeSelectionIndex: 0,
                    copyModeLastCopied: null,
                };
            }),
            toggleRevertConfirm: () => set(state => ({
                bodyView: state.bodyView === 'REVERT_CONFIRM' ? 'NONE' : 'REVERT_CONFIRM',
            })),
            copyModeNavigateUp: () => set(state => ({
                copyModeSelectionIndex: Math.max(0, state.copyModeSelectionIndex - 1),
            })),
            copyModeNavigateDown: () => set(state => ({
                copyModeSelectionIndex: Math.min(copyOptionsList.length - 1, state.copyModeSelectionIndex + 1),
            })),
            copyModeToggleSelection: () => set(state => {
                const currentOption = copyOptionsList[state.copyModeSelectionIndex];
                if (!currentOption) return {};

                const newSelections = { ...state.copyModeSelections };
                newSelections[currentOption] = !newSelections[currentOption];
                return { copyModeSelections: newSelections };
            }),
            copyModeExecuteCopy: () => {
                // Mock copy to clipboard
                const { copyModeSelections } = get();
                const selectedItems = Object.keys(copyModeSelections).filter(key => copyModeSelections[key]);
                const message = `Copied ${selectedItems.length} items to clipboard.`;
                // In real app: clipboardy.writeSync(...)
                // eslint-disable-next-line no-console
                console.log(`[CLIPBOARD] Mock copy: ${selectedItems.join(', ')}`);
                set({ copyModeLastCopied: message });
            },
            confirmRevert: () => {
                const { transaction } = get();
                if (!transaction) return;
                // In a real app, this would create a new transaction. Here we'll just update status.
                const { updateTransactionStatus } = useDashboardStore.getState().actions;
                updateTransactionStatus(transaction.id, 'REVERTED');
                set({ bodyView: 'NONE' });
            },
        },
    }));
  src/stores/transaction-history.store.ts: >-
    import { create } from 'zustand';


    // --- Types ---


    export type FileChangeType = 'MOD' | 'ADD' | 'DEL' | 'REN';

    export interface FileChange {
        id: string;
        path: string;
        type: FileChangeType;
        diff: string;
        linesAdded: number;
        linesRemoved: number;
    }


    export type TransactionStatus = 'Committed' | 'Handoff' | 'Reverted';

    export interface HistoryTransaction {
        id: string;
        hash: string;
        timestamp: number;
        status: TransactionStatus;
        message: string;
        files: FileChange[];
        stats: {
            files: number;
            linesAdded: number;
            linesRemoved: number;
        };
    }

    export type HistoryViewMode = 'LIST' | 'FILTER' | 'COPY' | 'BULK_ACTIONS';


    // Omit 'actions' from state type for partial updates

    type HistoryStateData = Omit<TransactionHistoryState, 'actions'>;


    interface TransactionHistoryState {
        transactions: HistoryTransaction[];
        mode: HistoryViewMode;
        selectedItemPath: string; // e.g. "tx-1" or "tx-1/file-2"
        expandedIds: Set<string>; // holds ids of expanded items
        filterQuery: string;
        selectedForAction: Set<string>; // set of transaction IDs
        lastCopiedMessage: string | null;

        actions: {
            load: (initialState?: Partial<HistoryStateData>) => void;
            navigateDown: () => void;
            navigateUp: () => void;
            expandOrDrillDown: () => void;
            collapseOrBubbleUp: () => void;
            toggleSelection: () => void;
            setMode: (mode: HistoryViewMode) => void;
            setFilterQuery: (query: string) => void;
            applyFilter: () => void;
            executeCopy: (selections: string[]) => void;
            prepareDebugState: (stateName: 'l1-drill' | 'l2-drill' | 'filter' | 'copy' | 'bulk') => void;
        }
    }


    // --- Mock Data ---

    const createMockTransactions = (): HistoryTransaction[] => {
        const now = Date.now();
        return Array.from({ length: 42 }, (_, i) => {
            const status: TransactionStatus = i % 5 === 2 ? 'Handoff' : i % 5 === 3 ? 'Reverted' : 'Committed';
            const files: FileChange[] = [
                { id: `${i}-1`, path: 'src/core/transaction.ts', type: 'MOD', linesAdded: 25, linesRemoved: 8, diff: '--- a/src/core/transaction.ts\n+++ b/src/core/transaction.ts\n@@ -45,7 +45,9 @@\n-    for (const [filePath, content] of entries) {\n+    const restoreErrors: { path: string, error: unknown }[] = [];\n...\n...\n...\n...\n-    another line removed' },
                { id: `${i}-2`, path: 'src/utils/logger.ts', type: 'MOD', linesAdded: 10, linesRemoved: 2, diff: 'diff for logger' },
                { id: `${i}-3`, path: 'src/utils/old-helper.ts', type: 'DEL', linesAdded: 0, linesRemoved: 30, diff: 'diff for old-helper' },
            ];
            const linesAdded = files.reduce((sum, f) => sum + f.linesAdded, 0);
            const linesRemoved = files.reduce((sum, f) => sum + f.linesRemoved, 0);

            return {
                id: `tx-${i}`,
                hash: Math.random().toString(16).slice(2, 10),
                timestamp: now - i * 24 * 60 * 60 * 1000,
                status,
                message: `feat: commit message number ${42 - i}`,
                files,
                stats: { files: files.length, linesAdded, linesRemoved },
            };
        });
    };


    export const getVisibleItemPaths = (transactions: HistoryTransaction[],
    expandedIds: Set<string>): string[] => {
        const paths: string[] = [];
        for (const tx of transactions) {
            paths.push(tx.id);
            if (expandedIds.has(tx.id)) {
                for (const file of tx.files) {
                    paths.push(`${tx.id}/${file.id}`);
                }
            }
        }
        return paths;
    };


    // --- Store ---

    export const useTransactionHistoryStore =
    create<TransactionHistoryState>((set, get) => ({
        transactions: [],
        mode: 'LIST',
        selectedItemPath: 'tx-0',
        expandedIds: new Set(),
        filterQuery: '',
        selectedForAction: new Set(),
        lastCopiedMessage: null,

        actions: {
            load: (initialState) => {
                const transactions = createMockTransactions();
                set({
                    transactions,
                    selectedItemPath: transactions[0]?.id || '',
                    mode: 'LIST',
                    expandedIds: new Set(),
                    selectedForAction: new Set(),
                    filterQuery: '',
                    lastCopiedMessage: null,
                    ...initialState,
                });
            },
            navigateUp: () => {
                const { transactions, expandedIds, selectedItemPath } = get();
                const visibleItems = getVisibleItemPaths(transactions, expandedIds);
                const currentIndex = visibleItems.indexOf(selectedItemPath);
                if (currentIndex > 0) {
                    set({ selectedItemPath: visibleItems[currentIndex - 1] });
                }
            },
            navigateDown: () => {
                const { transactions, expandedIds, selectedItemPath } = get();
                const visibleItems = getVisibleItemPaths(transactions, expandedIds);
                const currentIndex = visibleItems.indexOf(selectedItemPath);
                if (currentIndex < visibleItems.length - 1) {
                    set({ selectedItemPath: visibleItems[currentIndex + 1] });
                }
            },
            expandOrDrillDown: () => set(state => {
                const { selectedItemPath, expandedIds } = state;
                const newExpandedIds = new Set(expandedIds);
                if (!newExpandedIds.has(selectedItemPath)) {
                    newExpandedIds.add(selectedItemPath);
                }
                return { expandedIds: newExpandedIds };
            }),
            collapseOrBubbleUp: () => set(state => {
                const { selectedItemPath, expandedIds } = state;
                const newExpandedIds = new Set(expandedIds);
                if (newExpandedIds.has(selectedItemPath)) {
                    // If it's expanded, collapse it
                    newExpandedIds.delete(selectedItemPath);
                    
                    // Also collapse children
                    for (const id of newExpandedIds) {
                        if (id.startsWith(`${selectedItemPath}/`)) {
                            newExpandedIds.delete(id);
                        }
                    }

                    return { expandedIds: newExpandedIds };
                } else if (selectedItemPath.includes('/')) {
                    // If it's a file, move selection to parent transaction
                    const parentId = selectedItemPath.split('/')[0];
                    return { selectedItemPath: parentId || '' };
                }
                return {};
            }),
            toggleSelection: () => set(state => {
                const { selectedItemPath, selectedForAction } = state;
                const txId = selectedItemPath.split('/')[0];
                if (!txId) return {};

                const newSelection = new Set(selectedForAction);
                if (newSelection.has(txId)) {
                    newSelection.delete(txId);
                } else {
                    newSelection.add(txId);
                }
                return { selectedForAction: newSelection };
            }),
            setMode: (mode) => set({ mode, lastCopiedMessage: null }),
            setFilterQuery: (query) => set({ filterQuery: query }),
            applyFilter: () => {
                // In a real app, this would filter `transactions`.
                // For the demo, we just go back to LIST mode.
                set({ mode: 'LIST' });
            },
            executeCopy: (selections) => {
                 // Mock copy
                const { selectedForAction } = get();
                const message = `Copied ${selections.join(' & ')} from ${selectedForAction.size} transactions to clipboard.`;
                // In real app: clipboardy.writeSync(...)
                // eslint-disable-next-line no-console
                console.log(`[CLIPBOARD MOCK] ${message}`);
                set({ lastCopiedMessage: message });
            },
            prepareDebugState: (stateName) => {
                switch (stateName) {
                    case 'l1-drill':
                        get().actions.load({ expandedIds: new Set(['tx-0']), selectedItemPath: 'tx-0' });
                        break;
                    case 'l2-drill':
                        get().actions.load({ expandedIds: new Set(['tx-0', 'tx-0/0-1']), selectedItemPath: 'tx-0/0-1' });
                        break;
                    case 'filter':
                        get().actions.load({ mode: 'FILTER', filterQuery: 'logger.ts status:committed' });
                        break;
                    case 'copy':
                        get().actions.load({ mode: 'COPY', selectedForAction: new Set(['tx-0', 'tx-2']) });
                        break;
                    case 'bulk':
                        get().actions.load({ mode: 'BULK_ACTIONS', selectedForAction: new Set(['tx-0', 'tx-2']) });
                        break;
                }
            },
        },
    }));
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: '2025-09-22T06:42:27.279Z'
status: committed
id: 44
