uuid: c32c86e0-0a56-42bb-a951-2f7b80860268
projectId: relaycode-tui
createdAt: '2025-09-23T13:17:55.304Z'
gitCommitMsg: >-
  refactor(state): Unify transaction state management

  Centralizes all transaction data within `transaction.store.ts` to establish it
  as the single source of truth. This eliminates data duplication and potential
  synchronization issues across the application.

  - Removed redundant transaction data from `review.store.ts` and
  `commit.store.ts`. - Updated all dependent hooks (`useReviewScreen`,
  `useGitCommitScreen`) and components (`ReviewScreen`,
  `ReviewProcessingScreen`) to fetch transaction data from the unified
  `transaction.store`. - Moved the responsibility of preparing review-specific
  file state from `review.service.ts` into the `review.store.ts` `load` action,
  improving separation of concerns. - Changed data initialization to be explicit
  within `index.tsx` rather than an automatic side-effect of importing the
  store.
promptSummary: >-
  The user wants to execute part 1 of a multi-part refactor to unify transaction
  state management.
reasoning:
  - >-
    This is Part 1 of a multi-part refactor to improve the codebase's
    architecture by unifying state management and establishing a single source
    of truth for transaction data.
  - >-
    In this part, `transaction.store.ts` becomes the sole owner of transaction
    data. I have removed redundant transaction information from
    `review.store.ts` and `commit.store.ts`, and updated all dependent
    components and hooks to fetch data from the centralized store. This
    eliminates data silos, prevents synchronization issues, and simplifies the
    data flow throughout the application.
  - '### 1. Centralize Transaction Data in `transaction.store`'
  - >-
    I'll start by modifying `transaction.store.ts` to remove the automatic data
    loading call. The application will now initialize its state explicitly.
  - '### 2. Explicitly Initialize Data'
  - >-
    Next, I'll update the application's entry point, `index.tsx`, to explicitly
    load the transaction data when the application starts.
  - '### 3. Refactor `commit.store`'
  - >-
    Now, I'll refactor `commit.store.ts` to remove its local copy of
    transactions. It will now fetch "APPLIED" transactions directly from
    `transaction.store` when needed.
  - >-
    The corresponding hook `useGitCommitScreen.tsx` is updated to reflect this
    change.
  - '### 4. Refactor `review.store` and `review.service`'
  - >-
    This is the most significant part of the change. I'm removing all duplicated
    transaction data from `review.store.ts` and moving the logic for preparing
    the review state from `review.service.ts` into the store's `load` action.
  - The service call becomes much simpler.
  - '### 5. Update UI Layer'
  - >-
    Finally, I'll update the hooks and components for the review screens to
    fetch data from the unified `transaction.store`.
  - I had to add an import to `ReviewProcessingScreen`.
operations:
  - type: write
    path: src/stores/transaction.store.ts
    content: |+
      --- src/stores/transaction.store.ts
      +++ src/stores/transaction.store.ts
      @@ -25,6 +25,3 @@
           },
       }));
       
      -// Initialize the store with data on load.
      -useTransactionStore.getState().actions.loadTransactions();

    patchStrategy: standard-diff
  - type: write
    path: index.tsx
    content: |+
      --- index.tsx
      +++ index.tsx
      @@ -2,12 +2,15 @@
       import { render } from 'ink';
       import App from './src/App';
       import { useAppStore } from './src/stores/app.store';
      +import { useTransactionStore } from './src/stores/transaction.store';
       import { useCommitStore } from './src/stores/commit.store';
       import { useReviewStore } from './src/stores/review.store';
       import { ReviewService } from './src/services/review.service';
       import { useTransactionDetailStore } from './src/stores/transaction-detail.store';
       import { useTransactionHistoryStore } from './src/stores/transaction-history.store';
       
       const main = () => {
      +    // Initialize stores
      +    useTransactionStore.getState().actions.loadTransactions();
           const args = process.argv.slice(2);
       
           if (args[0] === 'debug-screen' && args[1]) {

    patchStrategy: standard-diff
  - type: write
    path: src/stores/commit.store.ts
    content: >+
      --- src/stores/commit.store.ts

      +++ src/stores/commit.store.ts

      @@ -4,7 +4,6 @@
       import { useTransactionStore } from './transaction.store';
       
       interface CommitState {
      -    transactionsToCommit: Transaction[];
           finalCommitMessage: string;
           isCommitting: boolean;
           actions: {
      @@ -14,24 +13,20 @@
       }
       
       export const useCommitStore = create<CommitState>((set, get) => ({
      -    transactionsToCommit: [],
           finalCommitMessage: '',
           isCommitting: false,
           actions: {
               prepareCommitScreen: () => {
                   const { transactions } = useTransactionStore.getState();
                   const appliedTransactions = transactions.filter(tx => tx.status === 'APPLIED');
      -
                   const finalCommitMessage = CommitService.generateCommitMessage(appliedTransactions);
      -

      -            set({

      -                transactionsToCommit: appliedTransactions,

      -                finalCommitMessage,

      -            });

      +            set({ finalCommitMessage });
               },
               commit: async () => {
                   set({ isCommitting: true });
      -            const { transactionsToCommit } = get();

      -            await CommitService.commit(transactionsToCommit);

      +            const { transactions } = useTransactionStore.getState();

      +            const appliedTransactions = transactions.filter(tx =>
      tx.status === 'APPLIED');

      +            await CommitService.commit(appliedTransactions);
                   set({ isCommitting: false });
               },
           },

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useGitCommitScreen.tsx
    content: >+
      --- src/hooks/useGitCommitScreen.tsx

      +++ src/hooks/useGitCommitScreen.tsx

      @@ -1,9 +1,11 @@
       import { useInput } from 'ink';
       import { useCommitStore } from '../stores/commit.store';
       import { useAppStore } from '../stores/app.store';
      +import { useTransactionStore } from '../stores/transaction.store';
       
       export const useGitCommitScreen = () => {
      -    const { transactionsToCommit, finalCommitMessage, isCommitting } =
      useCommitStore();

      +    const { finalCommitMessage, isCommitting } = useCommitStore();

      +    const transactionsToCommit = useTransactionStore(s =>
      s.transactions.filter(tx => tx.status === 'APPLIED'));
           const { commit } = useCommitStore(s => s.actions);
           const { showDashboardScreen } = useAppStore(s => s.actions);
       
      @@ -17,5 +19,5 @@
               }
           });
       
      -    return { transactionsToCommit, finalCommitMessage, isCommitting };

      +    return { transactionsToCommit, finalCommitMessage, isCommitting };
       };

    patchStrategy: standard-diff
  - type: write
    path: src/stores/review.store.ts
    content: >+
      --- src/stores/review.store.ts

      +++ src/stores/review.store.ts

      @@ -13,15 +13,8 @@
       
       interface ReviewState {
           // Transaction Info
      -    transactionId: string | null;

      -    hash: string;

      -    message: string;

      -    prompt: string;

      -    reasoning: string;

      -    linesAdded: number;

      -    linesRemoved: number;

      -    duration: number;

      +    transactionId: string | null;
           patchStatus: PatchStatus;
       
           // File & Script Info
      @@ -58,7 +51,7 @@
               navigateScriptErrorDown: () => void,
       
               // "Private" actions for service layer
      -        load: (transaction: Transaction, files: ReviewFileItem[],
      patchStatus: PatchStatus) => void;

      +        load: (transactionId: string) => void;
               _updateApplyStep: (id: string, status: ApplyStep['status'], duration?: number, details?: string) => void;
               _addApplySubstep: (parentId: string, substep: Omit<ApplyStep, 'substeps'>) => void;
           };
      @@ -67,14 +60,7 @@
       export const useReviewStore = create<ReviewState>((set, get) => ({
           // Transaction Info
           transactionId: null,
      -    hash: '',

      -    message: '',

      -    prompt: '',

      -    reasoning: '',

      -    linesAdded: 0,

      -    linesRemoved: 0,

      -    duration: 0,

      -    patchStatus: 'SUCCESS',

      +    patchStatus: 'SUCCESS', // This will be set on load
       
           // File & Script Info
           files: [],
      @@ -160,11 +146,14 @@
                   }
               },
               confirmHandoff: () => {
      -            const { hash, message, reasoning, files } = get();

      -            const handoffPrompt =
      ReviewService.generateHandoffPrompt(hash, message, reasoning, files);

      +            const { transactionId, files } = get();

      +            const transaction =
      useTransactionStore.getState().transactions.find(t => t.id ===
      transactionId);

      +            if (!transaction) return;

      +

      +            const handoffPrompt =
      ReviewService.generateHandoffPrompt(transaction.hash, transaction.message,
      transaction.reasoning || '', files);
       
                   // eslint-disable-next-line no-console
                   console.log('[CLIPBOARD] Copied Handoff Prompt.'); // In real app: clipboardy.writeSync(handoffPrompt)
      -            ReviewService.performHandoff(hash);

      +            ReviewService.performHandoff(transaction.hash);
               },
       
               // Navigation Actions
      @@ -193,22 +182,31 @@
               }),
       
               // "Private" actions for service layer
      -        load: (transaction, files, patchStatus) => {

      -            const totalLinesAdded = files.reduce((sum, file) => sum +
      (file.linesAdded || 0), 0);

      -            const totalLinesRemoved = files.reduce((sum, file) => sum +
      (file.linesRemoved || 0), 0);

      +        load: (transactionId) => {

      +            const transaction =
      useTransactionStore.getState().transactions.find(t => t.id ===
      transactionId);

      +            if (!transaction) return;

      +

      +            // This simulates the backend determining which files failed
      or succeeded.

      +            // For this demo, tx '1' is the failure case, any other is
      success.

      +            const isFailureCase = transaction.id === '1';

      +            const patchStatus = isFailureCase ? 'PARTIAL_FAILURE' :
      'SUCCESS';

      +

      +            const reviewFiles: ReviewFileItem[] = (transaction.files ||
      []).map((file, index) => {

      +                if (isFailureCase) {

      +                    return {

      +                        ...file,

      +                        status: index === 0 ? 'APPROVED' : 'FAILED',

      +                        error: index > 0 ? (index === 1 ? 'Hunk #1 failed
      to apply' : 'Context mismatch at line 92') : undefined,

      +                        strategy: file.strategy || 'standard-diff',

      +                    };

      +                }

      +                return { ...file, status: 'APPROVED', strategy:
      file.strategy || 'standard-diff' };

      +            });
       
                   set({
                       transactionId: transaction.id,
      -                hash: transaction.hash,

      -                message: transaction.message,

      -                prompt: transaction.prompt || '',

      -                reasoning: transaction.reasoning || '',

      -                linesAdded: totalLinesAdded,

      -                linesRemoved: totalLinesRemoved,

      -                duration: 0, // Will be updated during apply process
                       patchStatus,
      -                files,

      -                scripts: [], // Scripts will be populated during apply
      process

      +                files: reviewFiles,

      +                scripts: transaction.scripts || [],
                       selectedItemIndex: 0,
                       bodyView: 'none' as const,
                       isDiffExpanded: false,

    patchStrategy: standard-diff
  - type: write
    path: src/services/review.service.ts
    content: >+
      --- src/services/review.service.ts

      +++ src/services/review.service.ts

      @@ -74,31 +74,7 @@
       };
       
       const loadTransactionForReview = (transactionId: string) => {
      -    const tx = useTransactionStore.getState().transactions.find(t => t.id
      === transactionId);

      -    if (!tx) return;

      -

      -    // This simulates the backend determining which files failed or
      succeeded.

      -    // For this demo, tx '1' is the failure case, any other is success.

      -    const isFailureCase = tx.id === '1';

      -

      -    const reviewFiles: ReviewFileItem[] = (tx.files || []).map((file,
      index) => {

      -        if (isFailureCase) {

      -            return {

      -                ...file,

      -                status: index === 0 ? 'APPROVED' : 'FAILED',

      -                error: index > 0 ? (index === 1 ? 'Hunk #1 failed to
      apply' : 'Context mismatch at line 92') : undefined,

      -                strategy: file.strategy || 'standard-diff',

      -            };

      -        }

      -        return { ...file, status: 'APPROVED', strategy: file.strategy ||
      'standard-diff' };

      -    });

      -

      -    useReviewStore.getState().actions.load(tx, reviewFiles, isFailureCase
      ? 'PARTIAL_FAILURE' : 'SUCCESS');

      +    useReviewStore.getState().actions.load(transactionId);
       };
       
       const generateSingleFileRepairPrompt = (file: ReviewFileItem): string => {

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useReviewScreen.tsx
    content: >+
      --- src/hooks/useReviewScreen.tsx

      +++ src/hooks/useReviewScreen.tsx

      @@ -2,17 +2,19 @@
       import { useInput, useApp } from 'ink';
       import { useReviewStore } from '../stores/review.store';
       import { useAppStore } from '../stores/app.store';
      +import { useTransactionStore } from '../stores/transaction.store';
       import { CopyService } from '../services/copy.service';
       
       export const useReviewScreen = () => {
           const { exit } = useApp();
           const store = useReviewStore();
      +    const { transactionId } = store;

      +    const transaction = useTransactionStore(s => s.transactions.find(t =>
      t.id === transactionId));
           const { showDashboardScreen } = useAppStore(s => s.actions);
           const {
      -        hash, message, prompt, reasoning, files, scripts, patchStatus,

      +        files, scripts, patchStatus,
               selectedItemIndex, bodyView,
           } = store;
           const {
      @@ -36,8 +38,9 @@
           }, [files]);
       
           const openCopyMode = () => {
      -        const { hash, message, prompt, reasoning, files,
      selectedItemIndex } = store;

      +        if (!transaction) return;

      +        const { hash, message, prompt, reasoning } = transaction;

      +        const { files, selectedItemIndex } = store;
               const selectedFile = selectedItemIndex < files.length ? files[selectedItemIndex] : undefined;
               CopyService.open('REVIEW', { txInfo: { hash, message, prompt, reasoning }, files, selectedFile });
           };
      @@ -171,5 +174,12 @@
               }
           });
       
      -    return { ...store, numFiles, approvedFilesCount, approvedLinesAdded,
      approvedLinesRemoved };

      +    return {

      +        ...store,

      +        transaction,

      +        numFiles,

      +        approvedFilesCount,

      +        approvedLinesAdded,

      +        approvedLinesRemoved,

      +    };
       };

    patchStrategy: standard-diff
  - type: write
    path: src/components/ReviewScreen.tsx
    content: >+
      --- src/components/ReviewScreen.tsx

      +++ src/components/ReviewScreen.tsx

      @@ -95,8 +95,11 @@
       
       const ReviewScreen = () => {
           const {
      -        hash, message, prompt, reasoning, files, scripts, patchStatus,

      -        linesAdded, linesRemoved, duration,

      +        transaction,

      +        files,

      +        scripts,

      +        patchStatus,
               selectedItemIndex, bodyView, isDiffExpanded, reasoningScrollIndex, scriptErrorIndex,
               numFiles,
               approvedFilesCount,
      @@ -104,11 +107,16 @@
               approvedLinesRemoved,
           } = useReviewScreen();
       
      +    if (!transaction) {

      +        return <Text>Loading review...</Text>;

      +    }

      +    const { hash, message, prompt = '', reasoning = '' } = transaction;

      +
           const renderBody = () => {
               if (bodyView === 'none') return null;
       
               if (bodyView === 'reasoning') {
      -            const reasoningLinesCount = reasoning.split('\n').length;

      +            const reasoningLinesCount = (reasoning ||
      '').split('\n').length;
                   const visibleLinesCount = 10;
                   return (
                       <Box flexDirection="column">
      @@ -263,22 +271,22 @@
                   <Box flexDirection="column" marginY={1}>
                       <Box flexDirection="column">
                           <Text>{hash} · {message}</Text>
                           <Text>
      -                        (<Text
      color="green">+{approvedLinesAdded}</Text>/<Text
      color="red">-{approvedLinesRemoved}</Text>) ·
      {approvedFilesCount}/{numFiles} Files · {duration}s

      +                        (<Text
      color="green">+{approvedLinesAdded}</Text>/<Text
      color="red">-{approvedLinesRemoved}</Text>) ·
      {approvedFilesCount}/{numFiles} Files
                               {patchStatus === 'PARTIAL_FAILURE' && scripts.length === 0 && <Text> · Scripts: SKIPPED</Text>}
                               {patchStatus === 'PARTIAL_FAILURE' && <Text color="red" bold> · MULTIPLE PATCHES FAILED</Text>}
                           </Text>
                       </Box>
       
                       <Box flexDirection="column" marginTop={1}>
                           <Text>
      -                        (P)rompt ▸ {prompt.substring(0, 60)}...

      +                        (P)rompt ▸ {(prompt || '').substring(0, 60)}...
                           </Text>
                           <Text>
      -                        (R)easoning ({reasoning.split('\n\n').length}
      steps) {bodyView === 'reasoning' ? '▾' : '▸'}{' '}

      -                        {(reasoning.split('\n')[0] ?? '').substring(0,
      50)}...

      +                        (R)easoning ({(reasoning ||
      '').split('\n\n').length} steps) {bodyView === 'reasoning' ? '▾' : '▸'}{'
      '}

      +                        {((reasoning || '').split('\n')[0] ??
      '').substring(0, 50)}...
                           </Text>
                       </Box>
                   </Box>

    patchStrategy: standard-diff
  - type: write
    path: src/components/ReviewProcessingScreen.tsx
    content: >+
      --- src/components/ReviewProcessingScreen.tsx

      +++ src/components/ReviewProcessingScreen.tsx

      @@ -1,6 +1,6 @@
       import React from 'react';
       import { Box, Text } from 'ink';
      -import { useReviewStore, type ApplyStep } from '../stores/review.store';

      +import { useReviewStore, type ApplyStep, useTransactionStore } from
      '../stores/review.store';
       import Separator from './Separator';
       
       const ApplyStepRow = ({ step, isSubstep = false }: { step: ApplyStep, isSubstep?: boolean }) => {
      @@ -43,24 +43,29 @@
       };
       
       const ReviewProcessingScreen = () => {
      -    const { hash, message, patchStatus, applySteps } =
      useReviewStore(state => ({

      -        hash: state.hash,

      -        message: state.message,

      +    const { transactionId, patchStatus, applySteps } =
      useReviewStore(state => ({

      +        transactionId: state.transactionId,
               patchStatus: state.patchStatus,
               applySteps: state.applySteps,
           }));
      +    const transaction = useTransactionStore(s => s.transactions.find(t =>
      t.id === transactionId));
       
           const totalDuration = applySteps.reduce((acc, step) => acc + (step.duration || 0), 0);
           const failureCase = patchStatus === 'PARTIAL_FAILURE';
           const footerText = failureCase
               ? `Elapsed: ${totalDuration.toFixed(1)}s · Transitioning to repair workflow...`
               : `Elapsed: ${totalDuration.toFixed(1)}s · Processing... Please wait.`;
      +

      +    if (!transaction) {

      +        return <Text>Loading...</Text>;

      +    }
       
           return (
               <Box flexDirection="column">
                   <Text color="cyan">▲ relaycode apply</Text>
                   <Separator />
                   <Box marginY={1} flexDirection="column">
      -                <Text>Applying patch {hash}... ({message})</Text>

      +                <Text>Applying patch {transaction.hash}...
      ({transaction.message})</Text>
                       <Box flexDirection="column" marginTop={1} gap={1}>
                           {applySteps.map(step => <ApplyStepRow key={step.id} step={step} />)}
                       </Box>

    patchStrategy: standard-diff
  - type: write
    path: src/components/ReviewProcessingScreen.tsx
    content: |
      <<<<<<< SEARCH
      import { useReviewStore, type ApplyStep } from '../stores/review.store';
      =======
      import { useReviewStore, type ApplyStep } from '../stores/review.store';
      import { useTransactionStore } from '../stores/transaction.store';
      >>>>>>> REPLACE
    patchStrategy: search-replace
snapshot:
  src/stores/transaction.store.ts: >-
    import { create } from 'zustand';

    import { TransactionService } from '../services/transaction.service';

    import type { Transaction, TransactionStatus } from
    '../types/transaction.types';


    export type { Transaction } from '../types/transaction.types';


    interface TransactionState {
        transactions: Transaction[];
        actions: {
            loadTransactions: () => void;
            updateTransactionStatus: (id: string, status: TransactionStatus) => void;
        };
    }


    export const useTransactionStore = create<TransactionState>((set, get) => ({
        transactions: [],
        actions: {
            loadTransactions: () => {
                const transactions = TransactionService.getAllTransactions();
                set({ transactions });
            },
            updateTransactionStatus: (id, status) => {
                set(state => ({
                    transactions: state.transactions.map(tx =>
                        tx.id === id ? { ...tx, status, timestamp: Date.now() } : tx,
                    ),
                }));
            },
        },
    }));


    // Initialize the store with data on load.

    useTransactionStore.getState().actions.loadTransactions();
  index.tsx: >-
    import React from 'react';

    import { render } from 'ink';

    import App from './src/App';

    import { useAppStore } from './src/stores/app.store';

    import { useCommitStore } from './src/stores/commit.store';

    import { useReviewStore } from './src/stores/review.store';

    import { ReviewService } from './src/services/review.service';

    import { useTransactionDetailStore } from
    './src/stores/transaction-detail.store';

    import { useTransactionHistoryStore } from
    './src/stores/transaction-history.store';


    const main = () => {
        const args = process.argv.slice(2);

        if (args[0] === 'debug-screen' && args[1]) {
            const screenName = args[1].replace(/\.tsx$/, '');
            const { actions: appActions } = useAppStore.getState();

            switch (screenName) {
                case 'DashboardScreen':
                    appActions.showDashboardScreen();
                    break;
                case 'GitCommitScreen':
                    useCommitStore.getState().actions.prepareCommitScreen();
                    appActions.showGitCommitScreen();
                    break;
                case 'ReviewProcessingScreen':
                    ReviewService.loadTransactionForReview('1');
                    appActions.showReviewProcessingScreen();
                    break;
                case 'ReviewScreen':
                    ReviewService.loadTransactionForReview('1');
                    appActions.showReviewScreen();
                    break;
                case 'TransactionDetailScreen':
                    useTransactionDetailStore.getState().actions.loadTransaction('3');
                    appActions.showTransactionDetailScreen();
                    break;
                case 'TransactionHistoryScreen':
                    useTransactionHistoryStore.getState().actions.load();
                    appActions.showTransactionHistoryScreen();
                    break;
                case 'InitializationScreen':
                     appActions.showInitScreen();
                     break;
                case 'SplashScreen':
                     appActions.showSplashScreen();
                     break;
                default:
                    process.stderr.write(`Unknown debug screen: ${args[1]}\n`);
                    process.exit(1);
            }
        }

        // Check if we're running in an interactive terminal
        if (process.stdin.isTTY && process.stdout.isTTY) {
            render(<App />);
        } else {
            process.stderr.write('Interactive terminal required. Please run in a terminal that supports raw input mode.\n');
            process.exit(1);
        }
    };


    main();
  src/stores/commit.store.ts: |-
    import { create } from 'zustand';
    import type { Transaction } from '../types/transaction.types';
    import { CommitService } from '../services/commit.service';
    import { useTransactionStore } from './transaction.store';

    interface CommitState {
        transactionsToCommit: Transaction[];
        finalCommitMessage: string;
        isCommitting: boolean;
        actions: {
            prepareCommitScreen: () => void;
            commit: () => Promise<void>;
        }
    }

    export const useCommitStore = create<CommitState>((set, get) => ({
        transactionsToCommit: [],
        finalCommitMessage: '',
        isCommitting: false,
        actions: {
            prepareCommitScreen: () => {
                const { transactions } = useTransactionStore.getState();
                const appliedTransactions = transactions.filter(tx => tx.status === 'APPLIED');

                const finalCommitMessage = CommitService.generateCommitMessage(appliedTransactions);

                set({
                    transactionsToCommit: appliedTransactions,
                    finalCommitMessage,
                });
            },
            commit: async () => {
                set({ isCommitting: true });
                const { transactionsToCommit } = get();
                await CommitService.commit(transactionsToCommit);
                set({ isCommitting: false });
            },
        },
    }));
  src/hooks/useGitCommitScreen.tsx: |-
    import { useInput } from 'ink';
    import { useCommitStore } from '../stores/commit.store';
    import { useAppStore } from '../stores/app.store';

    export const useGitCommitScreen = () => {
        const { transactionsToCommit, finalCommitMessage, isCommitting } = useCommitStore();
        const { commit } = useCommitStore(s => s.actions);
        const { showDashboardScreen } = useAppStore(s => s.actions);

        useInput((input, key) => {
            if (isCommitting) return;

            if (key.escape) {
                showDashboardScreen();
            }
            if (key.return) {
                commit().then(() => {
                    showDashboardScreen();
                });
            }
        });

        return { transactionsToCommit, finalCommitMessage, isCommitting };
    };
  src/stores/review.store.ts: >-
    import { create } from 'zustand';

    import { sleep } from '../utils';

    import { useAppStore } from './app.store';

    import { ReviewService } from '../services/review.service';

    import { useTransactionStore, type Transaction } from './transaction.store';

    import { moveIndex } from './navigation.utils';

    import type { ReviewFileItem } from '../types/file.types';

    import type { ScriptResult, ApplyStep, ReviewBodyView, PatchStatus } from
    '../types/review.types';


    export type { ReviewFileItem } from '../types/file.types';

    export type { ScriptResult, ApplyStep } from '../types/review.types';


    export const initialApplySteps: ApplyStep[] = [
        { id: 'snapshot', title: 'Reading initial file snapshot...', status: 'pending' },
        { id: 'memory', title: 'Applying operations to memory...', status: 'pending', substeps: [] },
        { id: 'post-command', title: 'Running post-command script...', status: 'pending', substeps: [] },
        { id: 'linter', title: 'Analyzing changes with linter...', status: 'pending', substeps: [] },
    ];


    interface ReviewState {
        // Transaction Info
        transactionId: string | null;
        hash: string;
        message: string;
        prompt: string;
        reasoning: string;
        linesAdded: number;
        linesRemoved: number;
        duration: number;
        patchStatus: PatchStatus;

        // File & Script Info
        files: ReviewFileItem[];
        scripts: ScriptResult[];

        // UI State
        applySteps: ApplyStep[];
        selectedItemIndex: number; // Can be file or script
        bodyView: ReviewBodyView;
        isDiffExpanded: boolean;

        // Reasoning Scroll State
        reasoningScrollIndex: number;

        // Script Navigation State
        scriptErrorIndex: number;

        actions: {
            moveSelectionUp: () => void;
            moveSelectionDown: () => void;
            toggleFileApproval: () => void;
            rejectAllFiles: () => void;
            expandDiff: () => void;
            toggleBodyView: (view: Extract<ReviewBodyView, 'diff' | 'reasoning' | 'script_output' | 'bulk_repair' | 'confirm_handoff'>) => void;
            setBodyView: (view: ReviewBodyView) => void;
            approve: () => void;
            startApplySimulation: (scenario: 'success' | 'failure') => void;

            // Repair Actions
            tryRepairFile: () => void;
            showBulkRepair: () => void;
            executeBulkRepairOption: (option: number) => Promise<void>;
            confirmHandoff: () => void;

            // Navigation Actions
            scrollReasoningUp: () => void;
            scrollReasoningDown: () => void;
            navigateScriptErrorUp: () => void;
            navigateScriptErrorDown: () => void,

            // "Private" actions for service layer
            load: (transaction: Transaction, files: ReviewFileItem[], patchStatus: PatchStatus) => void;
            _updateApplyStep: (id: string, status: ApplyStep['status'], duration?: number, details?: string) => void;
            _addApplySubstep: (parentId: string, substep: Omit<ApplyStep, 'substeps'>) => void;
        };
    }


    export const useReviewStore = create<ReviewState>((set, get) => ({
        // Transaction Info
        transactionId: null,
        hash: '',
        message: '',
        prompt: '',
        reasoning: '',
        linesAdded: 0,
        linesRemoved: 0,
        duration: 0,
        patchStatus: 'SUCCESS',

        // File & Script Info
        files: [],
        scripts: [],

        // UI State
        applySteps: initialApplySteps,
        selectedItemIndex: 0,
        bodyView: 'none' as const,
        isDiffExpanded: false,

        // Reasoning Scroll State
        reasoningScrollIndex: 0,

        // Script Navigation State
        scriptErrorIndex: 0,

        actions: {
            moveSelectionUp: () => set(state => ({
                selectedItemIndex: moveIndex(state.selectedItemIndex, 'up', state.files.length + state.scripts.length),
            })),
            moveSelectionDown: () => set(state => ({
                selectedItemIndex: moveIndex(state.selectedItemIndex, 'down', state.files.length + state.scripts.length),
            })),
            toggleFileApproval: () => set(state => {
                const { selectedItemIndex, files } = state;
                if (selectedItemIndex >= files.length) return {}; // Not a file

                const newFiles = [...files];
                const file = newFiles[selectedItemIndex];
                if (file) {
                    if (file.status === 'APPROVED') {
                        file.status = 'REJECTED';
                    } else if (file.status === 'REJECTED') {
                        file.status = 'APPROVED';
                    }
                }
                return { files: newFiles };
            }),
            rejectAllFiles: () => set(state => {
                const newFiles = state.files.map(file => {
                    if (file.status === 'APPROVED') {
                        return { ...file, status: 'REJECTED' as const };
                    }
                    return file;
                });
                return { files: newFiles };
            }),
            toggleBodyView: (view) => set(state => {
                if (view === 'diff' && state.selectedItemIndex >= state.files.length) return {}; // Can't show diff for scripts
                return {
                    bodyView: state.bodyView === view ? 'none' : view,
                    isDiffExpanded: false, // Always start collapsed
                };
            }),
            setBodyView: (view) => set({ bodyView: view }),
            expandDiff: () => set(state => ({ isDiffExpanded: !state.isDiffExpanded })),
            approve: () => {
                const { transactionId } = get();
                if (transactionId) {
                    // Update transaction status to COMMITTED
                    useTransactionStore.getState().actions.updateTransactionStatus(transactionId, 'COMMITTED');
                    // Navigate back to dashboard
                    useAppStore.getState().actions.showDashboardScreen();
                }
            },
            startApplySimulation: async (scenario: 'success' | 'failure') => {
                const { showReviewProcessingScreen, showReviewScreen } = useAppStore.getState().actions;

                set({ applySteps: JSON.parse(JSON.stringify(initialApplySteps)) });
                showReviewProcessingScreen();

                await ReviewService.runApplySimulation(scenario);

                showReviewScreen();
            },

            // Repair Actions
            tryRepairFile: () => {
                const { selectedItemIndex, files } = get();
                if (selectedItemIndex < files.length) {
                    const file = files[selectedItemIndex];
                    if (file && file.status === 'FAILED') {
                        ReviewService.tryRepairFile(file, selectedItemIndex);
                    }
                }
            },
            showBulkRepair: () => get().actions.toggleBodyView('bulk_repair'),
            executeBulkRepairOption: async (option: number) => {
                const { files } = get();

                switch (option) {
                    case 1: { // Generate & Copy Bulk Repair Prompt
                        const bulkPrompt = ReviewService.generateBulkRepairPrompt(files);
                        const failedFiles = files.filter(f => f.status === 'FAILED');
                        // eslint-disable-next-line no-console
                        console.log(`[CLIPBOARD] Copied bulk repair prompt for ${failedFiles.length} files.`);
                        // In a real app, this would use clipboardy.writeSync(bulkPrompt),
                        set({ bodyView: 'none' as const });
                        break;
                    }

                    case 2: { // Attempt Bulk Re-apply
                        set({ bodyView: 'none' as const });
                        await ReviewService.runBulkReapply();
                        break;
                    }

                    case 3: { // Handoff to Human
                        get().actions.setBodyView('confirm_handoff');
                        break;
                    }

                    case 4: { // Reject All Failed
                        set(state => ({
                            files: state.files.map(file =>
                                file.status === 'FAILED'
                                    ? { ...file, status: 'REJECTED' as const }
                                    : file,
                            ),
                            bodyView: 'none' as const,
                        }));
                        break;
                    }

                    default: // Close modal
                        set({ bodyView: 'none' as const });
                }
            },
            confirmHandoff: () => {
                const { hash, message, reasoning, files } = get();
                const handoffPrompt = ReviewService.generateHandoffPrompt(hash, message, reasoning, files);

                // eslint-disable-next-line no-console
                console.log('[CLIPBOARD] Copied Handoff Prompt.'); // In real app: clipboardy.writeSync(handoffPrompt)
                ReviewService.performHandoff(hash);
            },

            // Navigation Actions
            scrollReasoningUp: () => set(state => ({
                reasoningScrollIndex: Math.max(0, state.reasoningScrollIndex - 1),
            })),
            scrollReasoningDown: () => set(state => {
                const maxLines = state.reasoning.split('\n').length;
                return { reasoningScrollIndex: Math.min(maxLines - 1, state.reasoningScrollIndex + 1) };
            }),
            navigateScriptErrorUp: () => set(state => ({
                scriptErrorIndex: Math.max(0, state.scriptErrorIndex - 1),
            })),
            navigateScriptErrorDown: () => set(state => {
                const selectedScript = state.scripts[state.selectedItemIndex - state.files.length];
                if (selectedScript && selectedScript.output) {
                    const errorLines = selectedScript.output.split('\n').filter(line =>
                        line.includes('Error') || line.includes('Warning'),
                    );
                    return { scriptErrorIndex: Math.min(errorLines.length - 1, state.scriptErrorIndex + 1) };
                }
                return {};
            }),

            // "Private" actions for service layer
            load: (transaction, files, patchStatus) => {
                const totalLinesAdded = files.reduce((sum, file) => sum + (file.linesAdded || 0), 0);
                const totalLinesRemoved = files.reduce((sum, file) => sum + (file.linesRemoved || 0), 0);

                set({
                    transactionId: transaction.id,
                    hash: transaction.hash,
                    message: transaction.message,
                    prompt: transaction.prompt || '',
                    reasoning: transaction.reasoning || '',
                    linesAdded: totalLinesAdded,
                    linesRemoved: totalLinesRemoved,
                    duration: 0, // Will be updated during apply process
                    patchStatus,
                    files,
                    scripts: [], // Scripts will be populated during apply process
                    selectedItemIndex: 0,
                    bodyView: 'none' as const,
                    isDiffExpanded: false,
                    reasoningScrollIndex: 0,
                    scriptErrorIndex: 0,
                    applySteps: JSON.parse(JSON.stringify(initialApplySteps)), // Reset apply steps
                });
            },
            _updateApplyStep: (id, status, duration, details) => {
                set(state => ({
                    applySteps: state.applySteps.map(s => {
                        if (s.id === id) {
                            const newStep = { ...s, status };
                            if (duration !== undefined) newStep.duration = duration;
                            if (details !== undefined) newStep.details = details;
                            return newStep;
                        }
                        return s;
                    }),
                }));
            },
            _addApplySubstep: (parentId, substep) => {
                 set(state => ({
                    applySteps: state.applySteps.map(s => {
                        if (s.id === parentId) {
                            const newSubsteps = [...(s.substeps || []), substep as ApplyStep];
                            return { ...s, substeps: newSubsteps };
                        }
                        return s;
                    }),
                }));
            },
        },
    }));
  src/services/review.service.ts: >-
    import { useReviewStore, type ReviewFileItem } from
    '../stores/review.store';

    import { useTransactionStore } from '../stores/transaction.store';

    import { useAppStore } from '../stores/app.store';

    import { sleep } from '../utils';

    import type { ApplyStep } from '../types/review.types';


    const generateBulkRepairPrompt = (files: ReviewFileItem[]): string => {
        const failedFiles = files.filter(f => f.status === 'FAILED');
        return `The previous patch failed to apply to MULTIPLE files. Please generate a new, corrected patch that addresses all the files listed below.

    IMPORTANT: The response MUST contain a complete code block for EACH file
    that needs to be fixed.


    ${failedFiles.map(file => `--- FILE: ${file.path} ---

    Strategy: ${file.strategy}

    Error: ${file.error}


    ORIGINAL CONTENT:

    ---

    // ... original content of ${file.path} ...

    ---


    FAILED PATCH:

    ---

    ${file.diff || '// ... failed diff ...'}

    ---

    `).join('\n')}


    Please analyze all failed files and provide a complete, corrected
    response.`;

    };


    const generateHandoffPrompt = (
        hash: string,
        message: string,
        reasoning: string,
        files: ReviewFileItem[],
    ): string => {
        const successfulFiles = files.filter(f => f.status === 'APPROVED');
        const failedFiles = files.filter(f => f.status === 'FAILED');

        return `I am handing off a failed automated code transaction to you. Your task is to act as my programming assistant and complete the planned changes.

    The full plan for this transaction is detailed in the YAML file located at:
    .relay/transactions/${hash}.yml. Please use this file as your primary source
    of truth for the overall goal.


    Here is the current status of the transaction:


    --- TRANSACTION SUMMARY ---

    Goal: ${message}

    Reasoning:

    ${reasoning}


    --- CURRENT FILE STATUS ---

    SUCCESSFUL CHANGES (already applied, no action needed):

    ${successfulFiles.map(f => `- MODIFIED: ${f.path}`).join('\n') || ' 
    (None)'}


    FAILED CHANGES (these are the files you need to fix):

    ${failedFiles.map(f => `- FAILED: ${f.path} (Error:
    ${f.error})`).join('\n')}


    Your job is to now work with me to fix the FAILED files and achieve the
    original goal of the transaction. Please start by asking me which file you
    should work on first.`;

    };


    const performHandoff = (hash: string) => {
        // This is a bit of a hack to find the right transaction to update in the demo
        const txToUpdate = useTransactionStore.getState().transactions.find(tx => tx.hash === hash);
        if (txToUpdate) {
            useTransactionStore.getState().actions.updateTransactionStatus(txToUpdate.id, 'HANDOFF');
        }

        useAppStore.getState().actions.showDashboardScreen();
    };


    const runApplySimulation = async (scenario: 'success' | 'failure') => {
        const { actions } = useReviewStore.getState();
        const { _updateApplyStep, _addApplySubstep } = actions;

        if (scenario === 'success') {
            _updateApplyStep('snapshot', 'active'); await sleep(100);
            _updateApplyStep('snapshot', 'done', 0.1);

            _updateApplyStep('memory', 'active'); await sleep(100);
            _addApplySubstep('memory', { id: 's1', title: '[✓] write: src/core/clipboard.ts (strategy: replace)', status: 'done' });
            await sleep(100);
            _addApplySubstep('memory', { id: 's2', title: '[✓] write: src/utils/shell.ts (strategy: standard-diff)', status: 'done' });
            _updateApplyStep('memory', 'done', 0.3);

            _updateApplyStep('post-command', 'active'); await sleep(1300);
            _addApplySubstep('post-command', { id: 's3', title: '`bun run test` ... Passed', status: 'done' });
            _updateApplyStep('post-command', 'done', 2.3);

            _updateApplyStep('linter', 'active'); await sleep(1200);
            _addApplySubstep('linter', { id: 's4', title: '`bun run lint` ... 0 Errors', status: 'done' });
            _updateApplyStep('linter', 'done', 1.2);

            await sleep(500);

        } else { // failure scenario
            _updateApplyStep('snapshot', 'active'); await sleep(100);
            _updateApplyStep('snapshot', 'done', 0.1);

            _updateApplyStep('memory', 'active'); await sleep(100);
            _addApplySubstep('memory', { id: 'f1', title: '[✓] write: src/core/transaction.ts (strategy: replace)', status: 'done' });
            await sleep(100);
            _addApplySubstep('memory', { id: 'f2', title: '[!] failed: src/utils/logger.ts (Hunk #1 failed to apply)', status: 'failed' });
            await sleep(100);
            _addApplySubstep('memory', { id: 'f3', title: '[!] failed: src/commands/apply.ts (Context mismatch at line 92)', status: 'failed' });
            _updateApplyStep('memory', 'done', 0.5);

            await sleep(100);
            _updateApplyStep('post-command', 'skipped', undefined, 'Skipped due to patch application failure');
            await sleep(100);
            _updateApplyStep('linter', 'skipped', undefined, 'Skipped due to patch application failure');

            await sleep(500);
        }
    };


    const loadTransactionForReview = (transactionId: string) => {
        const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
        if (!tx) return;

        // This simulates the backend determining which files failed or succeeded.
        // For this demo, tx '1' is the failure case, any other is success.
        const isFailureCase = tx.id === '1';

        const reviewFiles: ReviewFileItem[] = (tx.files || []).map((file, index) => {
            if (isFailureCase) {
                return {
                    ...file,
                    status: index === 0 ? 'APPROVED' : 'FAILED',
                    error: index > 0 ? (index === 1 ? 'Hunk #1 failed to apply' : 'Context mismatch at line 92') : undefined,
                    strategy: file.strategy || 'standard-diff',
                };
            }
            return { ...file, status: 'APPROVED', strategy: file.strategy || 'standard-diff' };
        });

        useReviewStore.getState().actions.load(tx, reviewFiles, isFailureCase ? 'PARTIAL_FAILURE' : 'SUCCESS');
    };


    const generateSingleFileRepairPrompt = (file: ReviewFileItem): string => {
        return `The patch failed to apply to ${file.path}. Please generate a corrected patch.

    Error: ${file.error}

    Strategy: ${file.strategy}


    ORIGINAL CONTENT:

    ---

    // ... original file content would be here ...

    ---


    FAILED PATCH:

    ---

    ${file.diff || '// ... failed diff would be here ...'}

    ---


    Please provide a corrected patch that addresses the error.`;

    };


    const tryRepairFile = (file: ReviewFileItem, selectedIndex: number): void =>
    {
        const repairPrompt = generateSingleFileRepairPrompt(file);
        // In a real app: clipboardy.writeSync(repairPrompt)
        // eslint-disable-next-line no-console
        console.log(`[CLIPBOARD] Copied repair prompt for: ${file.path}`);

        // Mock: Update file status to show it's being repaired
        useReviewStore.setState(state => {
            const newFiles = [...state.files];
            newFiles[selectedIndex] = { ...file, status: 'APPROVED' as const, error: undefined, linesAdded: 5, linesRemoved: 2 };
            return { files: newFiles, copyModeLastCopied: 'Repair prompt copied to clipboard' };
        });
    };


    const runBulkReapply = async (): Promise<void> => {
        const { files } = useReviewStore.getState();
        const failedFileIds = new Set(files.filter(f => f.status === 'FAILED').map(f => f.id));
        if (failedFileIds.size === 0) {
            return;
        }

        useReviewStore.setState(state => ({
            files: state.files.map(file =>
                failedFileIds.has(file.id)
                    ? { ...file, status: 'RE_APPLYING' as const }
                    : file,
            ),
        }));

        await sleep(1500); // Simulate re-apply

        // Mock a mixed result
        let first = true;
        useReviewStore.setState(state => ({
            files: state.files.map(file => {
                if (failedFileIds.has(file.id)) {
                    if (first) {
                        first = false;
                        return { ...file, status: 'APPROVED' as const, strategy: 'replace' as const, error: undefined, linesAdded: 9, linesRemoved: 2 };
                    }
                    return { ...file, status: 'FAILED' as const, error: "'replace' failed: markers not found" };
                }
                return file;
            }),
        }));
    };


    export const ReviewService = {
        loadTransactionForReview,
        generateBulkRepairPrompt,
        generateHandoffPrompt,
        performHandoff,
        runApplySimulation,
        generateSingleFileRepairPrompt,
        tryRepairFile,
        runBulkReapply,
    };
  src/hooks/useReviewScreen.tsx: |-
    import { useMemo } from 'react';
    import { useInput, useApp } from 'ink';
    import { useReviewStore } from '../stores/review.store';
    import { useAppStore } from '../stores/app.store';
    import { CopyService } from '../services/copy.service';

    export const useReviewScreen = () => {
        const { exit } = useApp();
        const store = useReviewStore();
        const { showDashboardScreen } = useAppStore(s => s.actions);
        const {
            hash, message, prompt, reasoning, files, scripts, patchStatus,
            selectedItemIndex, bodyView,
        } = store;
        const {
            moveSelectionUp, moveSelectionDown, toggleFileApproval, expandDiff,
            toggleBodyView, setBodyView,
            startApplySimulation, rejectAllFiles, approve,
            tryRepairFile, showBulkRepair, executeBulkRepairOption, confirmHandoff,
            scrollReasoningUp, scrollReasoningDown, navigateScriptErrorUp, navigateScriptErrorDown,
        } = store.actions;

        const {
            numFiles,
            approvedFilesCount,
            approvedLinesAdded,
            approvedLinesRemoved,
        } = useMemo(() => {
            const approvedFiles = files.filter(f => f.status === 'APPROVED');
            return {
                numFiles: files.length,
                approvedFilesCount: approvedFiles.length,
                approvedLinesAdded: approvedFiles.reduce((sum, f) => sum + f.linesAdded, 0),
                approvedLinesRemoved: approvedFiles.reduce((sum, f) => sum + f.linesRemoved, 0),
            };
        }, [files]);

        const openCopyMode = () => {
            const { hash, message, prompt, reasoning, files, selectedItemIndex } = store;
            const selectedFile = selectedItemIndex < files.length ? files[selectedItemIndex] : undefined;
            CopyService.open('REVIEW', { txInfo: { hash, message, prompt, reasoning }, files, selectedFile });
        };

        useInput((input, key) => {
            // For demo purposes: Pressing 1 or 2 triggers the processing screen simulation.
            if (input === '1') {
                startApplySimulation('success');
                return;
            }
            if (input === '2') {
                // The store's default is failure, but to re-trigger the processing screen
                startApplySimulation('failure');
                return;
            }

            if (input.toLowerCase() === 'q') exit();

            // Handle Escape key - context-sensitive behavior
            if (key.escape) {
                if (bodyView === 'bulk_repair' || bodyView === 'confirm_handoff') {
                    toggleBodyView(bodyView); // Close modal
                } else if (bodyView !== 'none') {
                    setBodyView('none');
                } else {
                    showDashboardScreen();
                }
                return;
            }

            // Handoff Confirmation
            if (bodyView === 'confirm_handoff') {
                if (key.return) {
                    confirmHandoff();
                }
                return;
            }

            // Bulk Repair Navigation
            if (bodyView === 'bulk_repair') {
                if (input >= '1' && input <= '4') {
                    executeBulkRepairOption(parseInt(input));
                }
                return;
            }

            // Reasoning Scroll Navigation
            if (bodyView === 'reasoning') {
                if (key.upArrow) scrollReasoningUp();
                if (key.downArrow) scrollReasoningDown();
                if (input.toLowerCase() === 'r') toggleBodyView('reasoning');
                return;
            }

            // Script Output Navigation
            if (bodyView === 'script_output') {
                if (input.toLowerCase() === 'j') navigateScriptErrorDown();
                if (input.toLowerCase() === 'k') navigateScriptErrorUp();
                if (key.return) toggleBodyView('script_output');
                if (input.toLowerCase() === 'c') {
                    // Copy script output
                    const scriptIndex = selectedItemIndex - numFiles;
                    const selectedScript = scripts[scriptIndex];
                    if (selectedScript) {
                        // eslint-disable-next-line no-console
                        console.log(`[CLIPBOARD] Copied script output: ${selectedScript.command}`);
                    }
                }
                return;
            }

            // Diff View Navigation
            if (bodyView === 'diff') {
                if (input.toLowerCase() === 'x') expandDiff();
                if (input.toLowerCase() === 'd') toggleBodyView('diff');
                return;
            }

            // Handle Shift+R for reject all
            if (key.shift && input.toLowerCase() === 'r') {
                if (approvedFilesCount > 0) {
                    rejectAllFiles();
                }
                return;
            }

            // Main View Navigation
            if (key.upArrow) moveSelectionUp();
            if (key.downArrow) moveSelectionDown();

            if (input.toLowerCase() === 'r') toggleBodyView('reasoning');

            if (input === ' ') {
                if (selectedItemIndex < numFiles) {
                    const file = files[selectedItemIndex];
                    if (file && file.status !== 'FAILED') {
                        toggleFileApproval();
                    }
                }
            }

            if (input.toLowerCase() === 'd') {
                if (selectedItemIndex < numFiles) {
                    toggleBodyView('diff');
                }
            }

            if (key.return) { // Enter key
                 if (selectedItemIndex >= numFiles) { // It's a script
                    toggleBodyView('script_output');
                }
            }

            if (input.toLowerCase() === 'a') {
                if (approvedFilesCount > 0) {
                    approve();
                    showDashboardScreen();
                }
            }

            if (input.toLowerCase() === 'c') {
                openCopyMode();
            }

            // Handle T for single repair and Shift+T for bulk repair
            if (input.toLowerCase() === 't') {
                if (key.shift) {
                    const hasFailedFiles = files.some(f => f.status === 'FAILED');
                    if (hasFailedFiles) {
                        showBulkRepair();
                    }
                } else {
                    if (selectedItemIndex < numFiles) {
                        const file = files[selectedItemIndex];
                        if (file && file.status === 'FAILED') {
                            tryRepairFile();
                        }
                    }
                }
            }

            if (input.toLowerCase() === 'q') {
                showDashboardScreen();
            }
        });

        return { ...store, numFiles, approvedFilesCount, approvedLinesAdded, approvedLinesRemoved };
    };
  src/components/ReviewScreen.tsx: >-
    import React from 'react';

    import { Box, Text } from 'ink';

    import { type ReviewFileItem, type ScriptResult } from
    '../stores/review.store';

    import Separator from './Separator';

    import DiffScreen from './DiffScreen';

    import ReasonScreen from './ReasonScreen';

    import { useReviewScreen } from '../hooks/useReviewScreen';


    // --- Sub-components ---


    const FileItemRow = ({ file, isSelected }: { file: ReviewFileItem,
    isSelected: boolean }) => {
        let icon;
        let iconColor;
        switch (file.status) {
            case 'APPROVED': icon = '[✓]'; iconColor = 'green'; break;
            case 'REJECTED': icon = '[✗]'; iconColor = 'red'; break;
            case 'FAILED': icon = '[!]'; iconColor = 'red'; break;
            case 'AWAITING': icon = '[●]'; iconColor = 'yellow'; break;
            case 'RE_APPLYING': icon = '[●]'; iconColor = 'cyan'; break;
        }

        const diffStats = `(+${file.linesAdded}/-${file.linesRemoved})`;
        const strategy = file.strategy === 'standard-diff' ? 'diff' : file.strategy;
        const prefix = isSelected ? '> ' : '  ';

        if (file.status === 'FAILED') {
            return (
                <Box>
                    <Text bold={isSelected} color={isSelected ? 'cyan' : undefined}>
                        {prefix}<Text color={iconColor}>{icon} FAILED {file.path}</Text>
                        <Text color="red">    ({file.error})</Text>
                    </Text>
                </Box>
            );
        }

        if (file.status === 'AWAITING') {
            return (
                <Box>
                    <Text bold={isSelected} color={isSelected ? 'cyan' : undefined}>
                        {prefix}<Text color={iconColor}>{icon} AWAITING {file.path}</Text>
                        <Text color="yellow">    (Bulk re-apply prompt copied!)</Text>
                    </Text>
                </Box>
            );
        }

        if (file.status === 'RE_APPLYING') {
            return (
                 <Box>
                    <Text bold={isSelected} color={isSelected ? 'cyan' : undefined}>
                        {prefix}<Text color={iconColor}>{icon} RE-APPLYING... {file.path}</Text>
                        <Text color="cyan"> (using &apos;replace&apos; strategy)</Text>
                    </Text>
                </Box>
            );
        }

        return (
            <Box>
                <Text bold={isSelected} color={isSelected ? 'cyan' : undefined}>
                    {prefix}<Text color={iconColor}>{icon}</Text> MOD {file.path} {diffStats} [{strategy}]
                </Text>
            </Box>
        );
    };


    const ScriptItemRow = ({
        script,
        isSelected,
        isExpanded,
    }: {
        script: ScriptResult;
        isSelected: boolean;
        isExpanded: boolean;
    }) => {
        const icon = script.success ? '✓' : '✗';
        const iconColor = script.success ? 'green' : 'red';
        const arrow = isExpanded ? '▾' : '▸';
        const prefix = isSelected ? '> ' : '  ';
        
        // Extract script type from command (e.g., "bun run test" -> "Post-Command", "bun run lint" -> "Linter")
        const scriptType = script.command.includes('test') ? 'Post-Command' : 
                          script.command.includes('lint') ? 'Linter' : 
                          'Script';

        return (
            <Box>
                <Text bold={isSelected} color={isSelected ? 'cyan' : undefined}>
                    {prefix}<Text color={iconColor}>{icon}</Text> {scriptType}: `{script.command}` ({script.duration}s) {arrow}{' '}
                    {script.summary}
                </Text>
            </Box>
        );
    };


    // --- Main Component ---


    const ReviewScreen = () => {
        const {
            hash, message, prompt, reasoning, files, scripts, patchStatus,
            linesAdded, linesRemoved, duration,
            selectedItemIndex, bodyView, isDiffExpanded, reasoningScrollIndex, scriptErrorIndex,
            numFiles,
            approvedFilesCount,
            approvedLinesAdded,
            approvedLinesRemoved,
        } = useReviewScreen();

        const renderBody = () => {
            if (bodyView === 'none') return null;

            if (bodyView === 'reasoning') {
                const reasoningLinesCount = reasoning.split('\n').length;
                const visibleLinesCount = 10;
                return (
                    <Box flexDirection="column">
                        <ReasonScreen
                            reasoning={reasoning}
                            scrollIndex={reasoningScrollIndex}
                            visibleLinesCount={visibleLinesCount}
                        />
                        {reasoningLinesCount > visibleLinesCount && (
                            <Text color="gray">
                                Showing lines {reasoningScrollIndex + 1}-{Math.min(reasoningScrollIndex + visibleLinesCount, reasoningLinesCount)}{' '}
                                of {reasoningLinesCount}
                            </Text>
                        )}
                    </Box>
                );
            }
            
            if (bodyView === 'diff') {
                const selectedFile = files[selectedItemIndex];
                if (!selectedFile) return null;
                return (
                    <DiffScreen
                        filePath={selectedFile.path}
                        diffContent={selectedFile.diff}
                        isExpanded={isDiffExpanded}
                    />
                );
            }

            if (bodyView === 'script_output') {
                 const scriptIndex = selectedItemIndex - numFiles;
                 const selectedScript = scripts[scriptIndex];
                 if (!selectedScript) return null;
                 
                 const outputLines = selectedScript.output.split('\n');
                 const errorLines = outputLines.filter(line =>
                    line.includes('Error') || line.includes('Warning'),
                 );
                 
                 return (
                    <Box flexDirection="column">
                        <Text>{selectedScript.command.includes('lint') ? 'LINTER' : 'SCRIPT'} OUTPUT: `{selectedScript.command}`</Text>
                        <Box marginTop={1}>
                            {outputLines.map((line, index) => {
                                const isError = line.includes('Error');
                                const isWarning = line.includes('Warning');
                                const isHighlighted = errorLines[scriptErrorIndex] === line;
                                
                                return (
                                    <Text 
                                        key={index} 
                                        color={isError ? 'red' : isWarning ? 'yellow' : undefined}
                                        bold={isHighlighted}
                                        backgroundColor={isHighlighted ? 'blue' : undefined}
                                    >
                                        {line}
                                    </Text>
                                );
                            })}
                        </Box>
                        {errorLines.length > 0 && (
                            <Text color="gray">
                                Error {scriptErrorIndex + 1} of {errorLines.length} highlighted
                            </Text>
                        )}
                    </Box>
                 );
            }

            if (bodyView === 'confirm_handoff') {
                return (
                    <Box flexDirection="column" gap={1}>
                        <Text bold>HANDOFF TO EXTERNAL AGENT</Text>
                        <Box flexDirection="column">
                            <Text>This action will:</Text>
                            <Text>1. Copy a detailed prompt to your clipboard for an agentic AI.</Text>
                            <Text>2. Mark the current transaction as &apos;Handoff&apos; and close this review.</Text>
                            <Text>3. Assume that you and the external agent will complete the work.</Text>
                        </Box>
                        <Text>Relaycode will NOT wait for a new patch. This is a final action.</Text>
                        <Text bold color="yellow">Are you sure you want to proceed?</Text>
                    </Box>
                );
            }

            if (bodyView === 'bulk_repair') {
                const failedFiles = files.filter(f => f.status === 'FAILED');
                const repairOptions = [
                    '(1) Copy Bulk Re-apply Prompt (for single-shot AI)',
                    '(2) Bulk Change Strategy & Re-apply',
                    '(3) Handoff to External Agent',
                    '(4) Bulk Abandon All Failed Files',
                    '(Esc) Cancel',
                ];

                return (
                    <Box flexDirection="column" gap={1}>
                        <Text bold>BULK REPAIR ACTION</Text>

                        <Box flexDirection="column">
                            <Text>The following {failedFiles.length} files failed to apply:</Text>
                            {failedFiles.map(file => (
                                <Text key={file.id}>- {file.path}</Text>
                            ))}
                        </Box>

                        <Text>How would you like to proceed?</Text>

                        <Box flexDirection="column">
                            {repairOptions.map((opt, i) => (
                                <Text key={i}>
                                    {i === 0 ? '> ' : '  '}
                                    {opt}
                                </Text>
                            ))}
                        </Box>
                    </Box>
                );
            }

            return null;
        };

        const renderFooter = () => {
            // Contextual footer for body views
            if (bodyView === 'diff') {
                return <Text>(↑↓) Nav · (X)pand · (D/Esc) Back</Text>;
            }
            if (bodyView === 'reasoning') {
                return <Text>(↑↓) Scroll Text · (R)Collapse View · (C)opy Mode</Text>;
            }
            if (bodyView === 'script_output') {
                return (
                    <Text>(↑↓) Nav · (J↓/K↑) Next/Prev Error · (C)opy Output · (Ent/Esc) Back</Text>
                );
            }
            if (bodyView === 'bulk_repair') {
                return <Text>Choose an option [1-4, Esc]:</Text>;
            }
            if (bodyView === 'confirm_handoff') {
                return <Text>(Enter) Confirm Handoff      (Esc) Cancel</Text>;
            }

            // Main footer
            const actions = ['(↑↓) Nav'];

            const isFileSelected = selectedItemIndex < numFiles;
            const hasFailedFiles = files.some(f => f.status === 'FAILED');
            
            if (isFileSelected) {
                const selectedFile = files[selectedItemIndex];
                if (selectedFile && selectedFile.status !== 'FAILED') {
                    actions.push('(Spc) Toggle');
                }
                actions.push('(D)iff');
                
                // Add repair options for failed files
                if (selectedFile && selectedFile.status === 'FAILED') {
                    actions.push('(T)ry Repair');
                }
            } else { // script selected
                actions.push('(Ent) Expand Details');
            }

            actions.push('(R)easoning');
            
            // Add bulk repair if there are failed files
            if (hasFailedFiles) {
                actions.push('(Shift+T) Bulk Repair');
            }
            
            actions.push('(C)opy');

            if (approvedFilesCount > 0) {
                actions.push('(A)pprove');
            }

            if (files.some(f => f.status === 'APPROVED' || f.status === 'FAILED')) {
                actions.push('(Shift+R) Reject All');
            }
            actions.push('(Q)uit');

            return <Text>{actions.join(' · ')}</Text>;
        };

        return (
            <Box flexDirection="column">
                {/* Header */}
                <Text color="cyan">▲ relaycode review</Text>
                <Separator />
                
                {/* Navigator Section */}
                <Box flexDirection="column" marginY={1}>
                    <Box flexDirection="column">
                        <Text>{hash} · {message}</Text>
                        <Text>
                            (<Text color="green">+{approvedLinesAdded}</Text>/<Text color="red">-{approvedLinesRemoved}</Text>) · {approvedFilesCount}/{numFiles} Files · {duration}s
                            {patchStatus === 'PARTIAL_FAILURE' && scripts.length === 0 && <Text> · Scripts: SKIPPED</Text>}
                            {patchStatus === 'PARTIAL_FAILURE' && <Text color="red" bold> · MULTIPLE PATCHES FAILED</Text>}
                        </Text>
                    </Box>

                    <Box flexDirection="column" marginTop={1}>
                        <Text>
                            (P)rompt ▸ {prompt.substring(0, 60)}...
                        </Text>
                        <Text>
                            (R)easoning ({reasoning.split('\n\n').length} steps) {bodyView === 'reasoning' ? '▾' : '▸'}{' '}
                            {(reasoning.split('\n')[0] ?? '').substring(0, 50)}...
                        </Text>
                    </Box>
                </Box>

                <Separator/>

                {/* Script Results (if any) */}
                {scripts.length > 0 && (
                    <>
                        <Box flexDirection="column" marginY={1}>
                            {scripts.map((script, index) => (
                                <ScriptItemRow
                                    key={script.command}
                                    script={script}
                                    isSelected={selectedItemIndex === numFiles + index}
                                    isExpanded={bodyView === 'script_output' && selectedItemIndex === numFiles + index}
                                />
                            ))}
                        </Box>
                        <Separator/>
                    </>
                )}

                {/* Files Section */}
                <Box flexDirection="column" marginY={1}>
                    <Text bold>FILES</Text>
                    {files.map((file, index) => (
                        <FileItemRow
                            key={file.id}
                            file={file}
                            isSelected={selectedItemIndex === index}
                        />
                    ))}
                </Box>
                
                <Separator/>
                
                {/* Body Viewport */}
                {bodyView !== 'none' && (
                    <>
                        <Box marginY={1}>
                            {renderBody()}
                        </Box>
                        <Separator />
                    </>
                )}

                {/* Footer */}
                <Box>
                    {renderFooter()}
                </Box>
            </Box>
        );
    };


    export default ReviewScreen;
  src/components/ReviewProcessingScreen.tsx: >-
    import React from 'react';

    import { Box, Text } from 'ink';

    import { useReviewStore, type ApplyStep } from '../stores/review.store';

    import Separator from './Separator';


    const ApplyStepRow = ({ step, isSubstep = false }: { step: ApplyStep,
    isSubstep?: boolean }) => {
        if (isSubstep) {
            let color;
            if (step.status === 'done' && step.title.startsWith('[✓]')) color = 'green';
            if (step.status === 'failed') color = 'red';

            return (
                <Text color={color}>
                    {'     └─ '}{step.title}
                </Text>
            );
        }

        let symbol;
        let color;
        switch (step.status) {
            case 'pending': symbol = '( )'; break;
            case 'active': symbol = '(●)'; color = 'cyan'; break;
            case 'done': symbol = '[✓]'; color = 'green'; break;
            case 'failed': symbol = '[!]'; color = 'red'; break;
            case 'skipped': symbol = '(-)'; color = 'gray'; break;
        }

        return (
            <Box flexDirection="column">
                <Text>
                    <Text color={color}>{symbol}</Text> {step.title} {step.duration && !isSubstep && `(${step.duration}s)`}
                </Text>
                {step.details && (
                    <Text color="gray">
                        {'     └─ '}{step.details}
                    </Text>
                )}
                {step.substeps?.map((sub, i) => (
                    <ApplyStepRow key={i} step={sub} isSubstep={true} />
                ))}
            </Box>
        );
    };


    const ReviewProcessingScreen = () => {
        const { hash, message, patchStatus, applySteps } = useReviewStore(state => ({
            hash: state.hash,
            message: state.message,
            patchStatus: state.patchStatus,
            applySteps: state.applySteps,
        }));

        const totalDuration = applySteps.reduce((acc, step) => acc + (step.duration || 0), 0);
        const failureCase = patchStatus === 'PARTIAL_FAILURE';
        const footerText = failureCase
            ? `Elapsed: ${totalDuration.toFixed(1)}s · Transitioning to repair workflow...`
            : `Elapsed: ${totalDuration.toFixed(1)}s · Processing... Please wait.`;

        return (
            <Box flexDirection="column">
                <Text color="cyan">▲ relaycode apply</Text>
                <Separator />
                <Box marginY={1} flexDirection="column">
                    <Text>Applying patch {hash}... ({message})</Text>
                    <Box flexDirection="column" marginTop={1} gap={1}>
                        {applySteps.map(step => <ApplyStepRow key={step.id} step={step} />)}
                    </Box>
                </Box>
                <Separator />
                <Text>{footerText}</Text>
            </Box>
        );
    };


    export default ReviewProcessingScreen;
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 68
