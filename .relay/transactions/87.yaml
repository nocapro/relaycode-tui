uuid: 4400e93a-86a0-4965-9854-4734b41a5423
projectId: relaycode-tui
createdAt: '2025-09-24T15:15:36.594Z'
gitCommitMsg: >-
  refactor(state): Centralize review state into transaction store

  Executed Part 1 of a major state management refactor to improve data integrity
  and reduce redundancy, establishing a single source of truth for transaction
  data.

  Key changes: - `transaction.store.ts` now exclusively manages the review
  status of files (`reviewStatus`, `reviewError`) via new actions
  (`updateFileReviewStatus`, `toggleFileApproval`, `rejectAllFiles`). - Removed
  the redundant `fileReviewStates` property and its related logic from
  `review.store.ts`, which now only manages UI state for the review screen. -
  Moved the one-time logic for initializing review statuses from the store to
  `review.service.ts` to ensure data is populated correctly before the view
  loads. - Refactored `useReviewScreen.tsx` to read file data directly from the
  transaction object in `transaction.store.ts`, eliminating the need for complex
  memoization and state merging.
promptSummary: >-
  Execute Part 1 of a radical DRYness refactor to unify data models and
  centralize state.
reasoning:
  - >-
    This is an excellent plan. Executing Part 1 will establish a solid, DRY
    foundation for the application's data layer, significantly improving
    maintainability and reducing the risk of state synchronization bugs. Here
    are the required modifications.
  - '### Step 1: Centralize Review State Management in `transaction.store.ts`'
  - >-
    I will start by adding new actions to `transaction.store.ts`. These actions
    will be responsible for mutating the review-related properties
    (`reviewStatus`, `reviewError`) directly on the `FileItem` objects within a
    `Transaction`. This makes the `Transaction` object the single source of
    truth for all its data.
  - '### Step 2: Move Review State Initialization Logic to `review.service.ts`'
  - >-
    The logic for setting the initial review status of files (which was
    previously in `review.store.ts`) will now be moved to the `ReviewService`.
    This service will directly call the new actions in `transaction.store.ts` to
    populate the review data before the review screen is loaded.
  - '### Step 3: Deprecate Redundant State from `review.store.ts`'
  - >-
    Now that `transaction.store.ts` manages the review data, I will remove the
    redundant `fileReviewStates` property and its related actions from
    `review.store.ts`. I will also update actions like `tryRepairFile` and
    `executeBulkRepairOption` to use the new centralized actions in
    `transaction.store.ts`.
  - '### Step 4: Update `useReviewScreen.tsx` to Use the Single Source of Truth'
  - >-
    Finally, I will refactor the `useReviewScreen` hook. It will no longer need
    to merge transaction data with a separate review state. Instead, it will
    read the `transaction.files` array directly, which now contains the complete
    and authoritative review status for each file. I will also update its input
    handler to call the new actions on `transaction.store`.
  - >-
    With these changes, Part 1 of the refactor is complete. The application's
    data layer is now significantly more robust and adheres to the DRY
    principle.
operations:
  - type: write
    path: src/stores/transaction.store.ts
    content: >+
      --- src/stores/transaction.store.ts

      +++ src/stores/transaction.store.ts

      @@ -1,13 +1,18 @@
       import { create } from 'zustand';
       import { TransactionService } from '../services/transaction.service';
      -import type { Transaction, TransactionStatus } from
      '../types/domain.types';

      +import type { Transaction, TransactionStatus, FileReviewStatus } from
      '../types/domain.types';
       
       export type { Transaction };
       
       interface TransactionState {
           transactions: Transaction[];
           actions: {
               loadTransactions: () => void;
               updateTransactionStatus: (id: string, status: TransactionStatus) => void;
      +        // New actions for managing review state directly on the
      transaction

      +        updateFileReviewStatus: (transactionId: string, fileId: string,
      status: FileReviewStatus, error?: string) => void;

      +        toggleFileApproval: (transactionId: string, fileId: string) =>
      void;

      +        rejectAllFiles: (transactionId: string) => void;
           };
       }
       
      @@ -23,5 +28,54 @@
                       ),
                   }));
               },
      +        updateFileReviewStatus: (transactionId, fileId, status, error) =>
      {

      +            set(state => ({

      +                transactions: state.transactions.map(tx => {

      +                    if (tx.id === transactionId) {

      +                        const newFiles = tx.files?.map(file => {

      +                            if (file.id === fileId) {

      +                                return { ...file, reviewStatus: status,
      reviewError: error };

      +                            }

      +                            return file;

      +                        });

      +                        return { ...tx, files: newFiles };

      +                    }

      +                    return tx;

      +                }),

      +            }));

      +        },

      +        toggleFileApproval: (transactionId, fileId) => {

      +            set(state => ({

      +                transactions: state.transactions.map(tx => {

      +                    if (tx.id === transactionId) {

      +                        const newFiles = tx.files?.map(file => {

      +                            if (file.id === fileId) {

      +                                const newStatus = file.reviewStatus ===
      'APPROVED' ? 'REJECTED' : 'APPROVED';

      +                                return { ...file, reviewStatus: newStatus
      };

      +                            }

      +                            return file;

      +                        });

      +                        return { ...tx, files: newFiles };

      +                    }

      +                    return tx;

      +                }),

      +            }));

      +        },

      +        rejectAllFiles: (transactionId) => {

      +            set(state => ({

      +                transactions: state.transactions.map(tx => {

      +                    if (tx.id === transactionId) {

      +                        const newFiles = tx.files?.map(file =>

      +                            file.reviewStatus === 'APPROVED' ? { ...file,
      reviewStatus: 'REJECTED' } : file,

      +                        );

      +                        return { ...tx, files: newFiles };

      +                    }

      +                    return tx;

      +                }),

      +            }));

      +        },
           },
       }));

    patchStrategy: standard-diff
  - type: write
    path: src/services/review.service.ts
    content: >+
      --- src/services/review.service.ts

      +++ src/services/review.service.ts

      @@ -87,7 +87,29 @@
       }
       
       const loadTransactionForReview = (transactionId: string, initialState?: { bodyView: ReviewBodyView }) => {
      +    const transaction =
      useTransactionStore.getState().transactions.find(t => t.id ===
      transactionId);

      +    if (!transaction) return;

      +

      +    // This simulates the backend determining which files failed or
      succeeded and sets it ONCE on load.

      +    // For this demo, tx '1' is the failure case, any other is success.

      +    const isFailureCase = transaction.id === '1';

      +    const { updateFileReviewStatus } =
      useTransactionStore.getState().actions;

      +

      +    (transaction.files || []).forEach((file, index) => {

      +        if (isFailureCase) {

      +            const isFailedFile = index > 0;

      +            updateFileReviewStatus(

      +                transactionId,

      +                file.id,

      +                isFailedFile ? 'FAILED' : 'APPROVED',

      +                isFailedFile ? (index === 1 ? 'Hunk #1 failed to apply' :
      'Context mismatch at line 92') : undefined,

      +            );

      +        } else {

      +            updateFileReviewStatus(transactionId, file.id, 'APPROVED');

      +        }

      +    });
           useReviewStore.getState().actions.load(transactionId, initialState);
       };
       
       const generateSingleFileRepairPrompt = (file: FileItem): string => {

    patchStrategy: standard-diff
  - type: write
    path: src/stores/review.store.ts
    content: >+
      --- src/stores/review.store.ts

      +++ src/stores/review.store.ts

      @@ -14,13 +14,9 @@
           { id: 'linter', title: 'Analyzing changes with linter...', status: 'pending', substeps: [] },
       ];
       
      -type FileReviewState = { status: FileReviewStatus; error?: string };

      -
       interface ReviewState {
           // Transaction Info
           transactionId: string | null;
           patchStatus: PatchStatus;
      -    fileReviewStates: Record<string, FileReviewState>; // Keyed by
      FileItem ID
       
           // UI State
           applySteps: ApplyStep[];
      @@ -36,8 +32,6 @@
           actions: {
               moveSelectionUp: () => void;
               moveSelectionDown: () => void;
      -        toggleFileApproval: () => void;

      -        rejectAllFiles: () => void;
               expandDiff: () => void;
               toggleBodyView: (view: Extract<ReviewBodyView, 'diff' | 'reasoning' | 'script_output' | 'bulk_repair' | 'confirm_handoff'>) => void;
               setBodyView: (view: ReviewBodyView) => void;
      @@ -63,7 +57,6 @@
           // Transaction Info
           transactionId: null,
           patchStatus: 'SUCCESS', // This will be set on load
      -    fileReviewStates: {},
           
           // UI State
           applySteps: initialApplySteps,
      @@ -87,32 +80,6 @@
                   if (!tx) return {};
                   const listSize = (tx.files?.length || 0) + (tx.scripts?.length || 0);
                   return { selectedItemIndex: moveIndex(state.selectedItemIndex, 'down', listSize) };
      -        }),

      -        toggleFileApproval: () => set(state => {

      -            const tx = useTransactionStore.getState().transactions.find(t
      => t.id === state.transactionId);

      -            const file = tx?.files?.[state.selectedItemIndex];

      -            if (!file) return {};

      -

      -            const currentState = state.fileReviewStates[file.id];

      -            if (!currentState) return {};

      -

      -            const newStatus = currentState.status === 'APPROVED' ?
      'REJECTED' : 'APPROVED';

      -

      -            return {

      -                fileReviewStates: {

      -                    ...state.fileReviewStates,

      -                    [file.id]: { ...currentState, status: newStatus },

      -                },

      -            };

      -        }),

      -        rejectAllFiles: () => set(state => {

      -            const newFileReviewStates = { ...state.fileReviewStates };

      -            const tx = useTransactionStore.getState().transactions.find(t
      => t.id === state.transactionId);

      -            tx?.files?.forEach(file => {

      -                const current = newFileReviewStates[file.id];

      -                if (current?.status === 'APPROVED') {

      -                    newFileReviewStates[file.id] = { ...current, status:
      'REJECTED' };

      -                }

      -            });

      -            return { fileReviewStates: newFileReviewStates };
               }),
               toggleBodyView: (view) => set(state => {
                   const tx = useTransactionStore.getState().transactions.find(t => t.id === state.transactionId);
      @@ -154,52 +121,53 @@
       
               // Repair Actions
               tryRepairFile: () => {
      -            set(state => {

      -                const tx =
      useTransactionStore.getState().transactions.find(t => t.id ===
      state.transactionId);

      -                const file = tx?.files?.[state.selectedItemIndex];

      -                if (!file) return {};

      -                

      -                const currentReviewState =
      state.fileReviewStates[file.id];

      -                if (currentReviewState?.status !== 'FAILED') return {};

      -

      -                // The service returns a new FileItem, but we only update
      the review state

      -                // to avoid re-introducing a copy of the data. The UI for
      stats won't update.

      -                const repairedFile = ReviewService.tryRepairFile(file);

      -

      -                return {

      -                    fileReviewStates: {

      -                        ...state.fileReviewStates,

      -                        [file.id]: { status: repairedFile.reviewStatus ||
      'AWAITING', error: undefined },

      -                    },

      -                };

      -            });

      +            const { transactionId, selectedItemIndex } = get();

      +            if (!transactionId) return;

      +

      +            const tx = useTransactionStore.getState().transactions.find(t
      => t.id === transactionId);

      +            const file = tx?.files?.[selectedItemIndex];

      +            if (!file || file.reviewStatus !== 'FAILED') return;

      +

      +            const repairedFile = ReviewService.tryRepairFile(file);

      +

      +           
      useTransactionStore.getState().actions.updateFileReviewStatus(

      +                transactionId,

      +                file.id,

      +                repairedFile.reviewStatus || 'AWAITING',

      +                undefined,

      +            );
               },
               showBulkRepair: () => get().actions.toggleBodyView('bulk_repair'),
               executeBulkRepairOption: async (option: number) => {
                   const { transactionId } = get();
      -            const tx = useTransactionStore.getState().transactions.find(t
      => t.id === transactionId);

      -            if (!tx?.files) return;

      +            let tx = useTransactionStore.getState().transactions.find(t
      => t.id === transactionId);

      +            if (!tx) return;
       
                   switch (option) {
                       case 1: { // Generate & Copy Bulk Repair Prompt
      -                    const bulkPrompt =
      ReviewService.generateBulkRepairPrompt(tx.files);

      -                    const failedFiles = tx.files.filter(f =>
      f.reviewStatus === 'FAILED');

      +                    if (!tx.files) break;

      +                    const bulkPrompt =
      ReviewService.generateBulkRepairPrompt(tx.files); // eslint-disable-line
      @typescript-eslint/no-unused-vars

      +                    const failedFiles = tx.files.filter(f =>
      f.reviewStatus === 'FAILED');
                           // eslint-disable-next-line no-console
                           console.log(`[CLIPBOARD] Copied bulk repair prompt for ${failedFiles.length} file(s).`);
                           set({ bodyView: 'none' as const });
                           break;
                       }
       
                       case 2: { // Attempt Bulk Re-apply
      +                    const { updateFileReviewStatus } =
      useTransactionStore.getState().actions;
                           set({ bodyView: 'none' as const });
       
      +                    if (!tx.files) break;
                           const failedFileIds = new Set(tx.files.filter(f => f.reviewStatus === 'FAILED').map(f => f.id));
                           if (failedFileIds.size === 0) break;
       
                           // Set intermediate state
      -                    set(state => {

      -                        const newStates = { ...state.fileReviewStates };

      -                        failedFileIds.forEach(id => {

      -                            if (newStates[id]) newStates[id]!.status =
      'RE_APPLYING';

      -                        });

      -                        return { fileReviewStates: newStates };

      -                    });

      +                    failedFileIds.forEach(id => {

      +                        updateFileReviewStatus(transactionId!, id,
      'RE_APPLYING');

      +                    });
       
                           // The service takes files, but returns updated files. We need to merge this back.
      -                    const finalFiles = await
      ReviewService.runBulkReapply(tx.files);

      -                    set(state => {

      -                        const newStates = { ...state.fileReviewStates };

      -                        finalFiles.forEach(file => {

      -                            if (newStates[file.id]) {

      -                                newStates[file.id] = {

      -                                    status: file.reviewStatus ||
      'AWAITING',

      -                                    error: file.reviewError,

      -                                };

      -                            }

      -                        });

      -                        return { fileReviewStates: newStates };

      +                    // Get the latest transaction data before passing to
      service

      +                    tx =
      useTransactionStore.getState().transactions.find(t => t.id ===
      transactionId)!;

      +                    const finalFiles = await
      ReviewService.runBulkReapply(tx.files!);

      +                    finalFiles.forEach(file => {

      +                        updateFileReviewStatus(

      +                            transactionId!,

      +                            file.id,

      +                            file.reviewStatus || 'AWAITING',

      +                            file.reviewError,

      +                        );
                           });
                           break;
                       }
      @@ -210,15 +178,12 @@
                       }
       
                       case 4: { // Reject All Failed
      -                    set(state => {

      -                        const newStates = { ...state.fileReviewStates };

      -                        Object.keys(newStates).forEach(fileId => {

      -                            if (newStates[fileId]?.status === 'FAILED') {

      -                                newStates[fileId]!.status = 'REJECTED';

      -                            }

      -                        });

      -                        return { fileReviewStates: newStates, bodyView:
      'none' as const };

      -                    });

      +                    if (!tx.files) break;

      +                    tx.files.forEach(file => {

      +                        if (file.reviewStatus === 'FAILED') {

      +                           
      useTransactionStore.getState().actions.updateFileReviewStatus(transactionId!,
      file.id, 'REJECTED');

      +                        }

      +                    });

      +                    set({ bodyView: 'none' as const });
                           break;
                       }
       
      @@ -261,31 +226,14 @@
               load: (transactionId, initialState) => {
                   const transaction = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                   if (!transaction) return;
      -

      -            // This simulates the backend determining which files failed
      or succeeded.

      -            // For this demo, tx '1' is the failure case, any other is
      success.

      +            
                   const isFailureCase = transaction.id === '1';
                   const patchStatus = isFailureCase ? 'PARTIAL_FAILURE' : ('SUCCESS' as PatchStatus);
       
      -            const newFileReviewStates: Record<string, FileReviewState> =
      {};

      -            (transaction.files || []).forEach((file, index) => {

      -                if (isFailureCase) {

      -                    const isFailedFile = index > 0;

      -                    newFileReviewStates[file.id] = {

      -                        status: isFailedFile ? 'FAILED' : 'APPROVED',

      -                        error: isFailedFile ? (index === 1 ? 'Hunk #1
      failed to apply' : 'Context mismatch at line 92') : undefined,

      -                    };

      -                } else {

      -                    newFileReviewStates[file.id] = { status: 'APPROVED'
      };

      -                }

      -            });

      -
                   set({
                       transactionId: transaction.id,
                       patchStatus,
      -                fileReviewStates: newFileReviewStates,
                       selectedItemIndex: 0,
                       bodyView: initialState?.bodyView ?? 'none',
                       isDiffExpanded: false,

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useReviewScreen.tsx
    content: >+
      --- src/hooks/useReviewScreen.tsx

      +++ src/hooks/useReviewScreen.tsx

      @@ -2,7 +2,6 @@
       import { useInput, useApp } from 'ink';
       import { useReviewStore } from '../stores/review.store';
       import { useAppStore } from '../stores/app.store';
      -import { useTransactionStore } from '../stores/transaction.store';
       import { useCopyStore, type CopyItem } from '../stores/copy.store';
       import { CopyService } from '../services/copy.service';
       import type { FileItem } from '../types/domain.types';
      @@ -10,29 +9,22 @@
       export const useReviewScreen = () => {
           const { exit } = useApp();
           const store = useReviewStore();
      -    const { transactionId, fileReviewStates } = store;

      +    const { transactionId } = store;
           const transaction = useTransactionStore(s => s.transactions.find(t => t.id === transactionId));
      +    const transactionActions = useTransactionStore(s => s.actions);
           const { showDashboardScreen } = useAppStore(s => s.actions);
           const {
               selectedItemIndex, bodyView,
           } = store;
       
      -    const files: FileItem[] = useMemo(() => {

      -        if (!transaction?.files) return [];

      -        return transaction.files.map(file => ({

      -            ...file,

      -            reviewStatus: fileReviewStates[file.id]?.status ||
      'AWAITING',

      -            reviewError: fileReviewStates[file.id]?.error,

      -        }));

      -    }, [transaction, fileReviewStates]);

      +    // The transaction from the store is now the single source of truth
      for file review status

      +    const files: FileItem[] = transaction?.files || [];
       
           const scripts = transaction?.scripts || [];
           const patchStatus = store.patchStatus;
       
           const {
      -        moveSelectionUp, moveSelectionDown, toggleFileApproval,
      expandDiff,

      +        moveSelectionUp, moveSelectionDown, expandDiff,
               toggleBodyView, setBodyView,
      -        startApplySimulation, rejectAllFiles, approve,

      +        startApplySimulation, approve,
               tryRepairFile, showBulkRepair, executeBulkRepairOption, confirmHandoff,
               scrollReasoningUp, scrollReasoningDown, navigateScriptErrorUp, navigateScriptErrorDown,
           } = store.actions;
      @@ -42,7 +34,7 @@
               approvedLinesAdded,
               approvedLinesRemoved,
           } = useMemo(() => {
      -        const approvedFiles = files.filter((f: FileItem) =>
      f.reviewStatus === 'APPROVED');

      +        const approvedFiles = files.filter(f => f.reviewStatus ===
      'APPROVED');
               return {
                   numFiles: files.length,
                   approvedFilesCount: approvedFiles.length,
      @@ -140,7 +132,9 @@
               // Handle Shift+R for reject all
               if (key.shift && input.toLowerCase() === 'r') {
                   if (approvedFilesCount > 0) {
      -                rejectAllFiles();

      +                if (transactionId) {

      +                    transactionActions.rejectAllFiles(transactionId);

      +                }
                   }
                   return;
               }
      @@ -153,8 +147,10 @@
               if (input === ' ') {
                   if (selectedItemIndex < numFiles) {
                       const file = files[selectedItemIndex];
      -                if (file && file.reviewStatus !== 'FAILED') {

      -                    toggleFileApproval();

      +                if (file && file.reviewStatus !== 'FAILED' &&
      transactionId) {

      +                    transactionActions.toggleFileApproval(transactionId,
      file.id);
                       }
                   }
               }

    patchStrategy: standard-diff
snapshot:
  src/stores/transaction.store.ts: |
    import { create } from 'zustand';
    import { TransactionService } from '../services/transaction.service';
    import type { Transaction, TransactionStatus } from '../types/domain.types';

    export type { Transaction };

    interface TransactionState {
        transactions: Transaction[];
        actions: {
            loadTransactions: () => void;
            updateTransactionStatus: (id: string, status: TransactionStatus) => void;
        };
    }

    export const useTransactionStore = create<TransactionState>((set, get) => ({
        transactions: [],
        actions: {
            loadTransactions: () => {
                const transactions = TransactionService.getAllTransactions();
                set({ transactions });
            },
            updateTransactionStatus: (id, status) => {
                set(state => ({
                    transactions: state.transactions.map(tx =>
                        tx.id === id ? { ...tx, status, timestamp: Date.now() } : tx,
                    ),
                }));
            },
        },
    }));
  src/services/review.service.ts: >-
    import { useReviewStore } from '../stores/review.store';

    import { useTransactionStore } from '../stores/transaction.store';

    import { useAppStore } from '../stores/app.store';

    import { sleep } from '../utils';

    import type { ApplyStep, ApplyUpdate, ReviewBodyView } from
    '../types/view.types';

    import type { FileItem } from '../types/domain.types';


    const generateBulkRepairPrompt = (files: FileItem[]): string => {
        const failedFiles = files.filter(f => f.reviewStatus === 'FAILED');
        return `The previous patch failed to apply to MULTIPLE files. Please generate a new, corrected patch that addresses all the files listed below.

    IMPORTANT: The response MUST contain a complete code block for EACH file
    that needs to be fixed.


    ${failedFiles.map(file => `--- FILE: ${file.path} ---

    Strategy: ${file.strategy}

    Error: ${file.reviewError}


    ORIGINAL CONTENT:

    ---

    // ... original content of ${file.path} ...

    ---


    FAILED PATCH:

    ---

    ${file.diff || '// ... failed diff ...'}

    ---

    `).join('\n')}


    Please analyze all failed files and provide a complete, corrected
    response.`;

    };


    const generateHandoffPrompt = (
        hash: string,
        message: string,
        reasoning: string,
        files: FileItem[],
    ): string => {
        const successfulFiles = files.filter(f => f.reviewStatus === 'APPROVED');
        const failedFiles = files.filter(f => f.reviewStatus === 'FAILED');

        return `I am handing off a failed automated code transaction to you. Your task is to act as my programming assistant and complete the planned changes.

    The full plan for this transaction is detailed in the YAML file located at:
    .relay/transactions/${hash}.yml. Please use this file as your primary source
    of truth for the overall goal.


    Here is the current status of the transaction:


    --- TRANSACTION SUMMARY ---

    Goal: ${message}

    Reasoning:

    ${reasoning}


    --- CURRENT FILE STATUS ---

    SUCCESSFUL CHANGES (already applied, no action needed):

    ${successfulFiles.map(f => `- MODIFIED: ${f.path}`).join('\n') || ' 
    (None)'}


    FAILED CHANGES (these are the files you need to fix):

    ${failedFiles.map(f => `- FAILED: ${f.path} (Error:
    ${f.reviewError})`).join('\n')}


    Your job is to now work with me to fix the FAILED files and achieve the
    original goal of the transaction. Please start by asking me which file you
    should work on first.`;

    };


    const performHandoff = (hash: string) => {
        // This is a bit of a hack to find the right transaction to update in the demo
        const txToUpdate = useTransactionStore.getState().transactions.find(tx => tx.hash === hash);
        if (txToUpdate) {
            useTransactionStore.getState().actions.updateTransactionStatus(txToUpdate.id, 'HANDOFF');
        }

        useAppStore.getState().actions.showDashboardScreen();
    };


    async function* runApplySimulation(scenario: 'success' | 'failure'):
    AsyncGenerator<ApplyUpdate> {
        if (scenario === 'success') {
            yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'active' } }; await sleep(100);
            yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'done', duration: 0.1 } };

            yield { type: 'UPDATE_STEP', payload: { id: 'memory', status: 'active' } }; await sleep(100);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 's1', title: '[✓] write: src/core/clipboard.ts (strategy: replace)', status: 'done' } } };
            await sleep(100);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 's2', title: '[✓] write: src/utils/shell.ts (strategy: standard-diff)', status: 'done' } } };
            yield { type: 'UPDATE_STEP', payload: { id: 'memory', status: 'done', duration: 0.3 } };

            yield { type: 'UPDATE_STEP', payload: { id: 'post-command', status: 'active' } }; await sleep(1300);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'post-command', substep: { id: 's3', title: '`bun run test` ... Passed', status: 'done' } } };
            yield { type: 'UPDATE_STEP', payload: { id: 'post-command', status: 'done', duration: 2.3 } };

            yield { type: 'UPDATE_STEP', payload: { id: 'linter', status: 'active' } }; await sleep(1200);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'linter', substep: { id: 's4', title: '`bun run lint` ... 0 Errors', status: 'done' } } };
            yield { type: 'UPDATE_STEP', payload: { id: 'linter', status: 'done', duration: 1.2 } };

            await sleep(500);

        } else { // failure scenario
            yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'active' } }; await sleep(100);
            yield { type: 'UPDATE_STEP', payload: { id: 'snapshot', status: 'done', duration: 0.1 } };

            yield { type: 'UPDATE_STEP', payload: { id: 'memory', status: 'active' } }; await sleep(100);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 'f1', title: '[✓] write: src/core/transaction.ts (strategy: replace)', status: 'done' } } };
            await sleep(100);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 'f2', title: '[!] failed: src/utils/logger.ts (Hunk #1 failed to apply)', status: 'failed' } } };
            await sleep(100);
            yield { type: 'ADD_SUBSTEP', payload: { parentId: 'memory', substep: { id: 'f3', title: '[!] failed: src/commands/apply.ts (Context mismatch at line 92)', status: 'failed' } } };
            yield { type: 'UPDATE_STEP', payload: { id: 'memory', status: 'done', duration: 0.5 } };

            await sleep(100);
            yield { type: 'UPDATE_STEP', payload: { id: 'post-command', status: 'skipped', details: 'Skipped due to patch application failure' } };
            await sleep(100);
            yield { type: 'UPDATE_STEP', payload: { id: 'linter', status: 'skipped', details: 'Skipped due to patch application failure' } };

            await sleep(500);
        }
    }


    const loadTransactionForReview = (transactionId: string, initialState?: {
    bodyView: ReviewBodyView }) => {
        useReviewStore.getState().actions.load(transactionId, initialState);
    };


    const generateSingleFileRepairPrompt = (file: FileItem): string => {
        return `The patch failed to apply to ${file.path}. Please generate a corrected patch.

    Error: ${file.reviewError}

    Strategy: ${file.strategy}


    ORIGINAL CONTENT:

    ---

    // ... original file content would be here ...

    ---


    FAILED PATCH:

    ---

    ${file.diff || '// ... failed diff would be here ...'}

    ---


    Please provide a corrected patch that addresses the error.`;

    };


    const tryRepairFile = (file: FileItem): FileItem => {
        const repairPrompt = generateSingleFileRepairPrompt(file);
        // In a real app: clipboardy.writeSync(repairPrompt)
        // eslint-disable-next-line no-console
        console.log(`[CLIPBOARD] Copied repair prompt for: ${file.path}`);

        // Mock: return the updated file
        return { ...file, reviewStatus: 'APPROVED' as const, reviewError: undefined, linesAdded: 5, linesRemoved: 2 };
    };


    const runBulkReapply = async (files: FileItem[]): Promise<FileItem[]> => {
        const failedFileIds = new Set(files.filter(f => f.reviewStatus === 'FAILED').map(f => f.id));
        if (failedFileIds.size === 0) {
            return files;
        }

        await sleep(1500); // Simulate re-apply

        // Mock a mixed result
        let first = true;
        return files.map(file => {
            if (failedFileIds.has(file.id)) {
                if (first) {
                    first = false;
                    // The file coming in already has the 'RE_APPLYING' status from the store action
                    return { ...file, reviewStatus: 'APPROVED' as const, strategy: 'replace' as const, reviewError: undefined, linesAdded: 9, linesRemoved: 2 };
                }
                return { ...file, reviewStatus: 'FAILED' as const, reviewError: "'replace' failed: markers not found" };
            }
            return file;
        });
    };


    export const ReviewService = {
        loadTransactionForReview,
        generateBulkRepairPrompt,
        generateHandoffPrompt,
        performHandoff,
        runApplySimulation,
        generateSingleFileRepairPrompt,
        tryRepairFile,
        runBulkReapply,
    };
  src/stores/review.store.ts: >-
    import { create } from 'zustand';

    import { sleep } from '../utils';

    import { useAppStore } from './app.store';

    import { ReviewService } from '../services/review.service';

    import { useTransactionStore } from './transaction.store';

    import { moveIndex } from './navigation.utils';

    import type { FileItem, ScriptResult, FileReviewStatus } from
    '../types/domain.types';

    import type { ApplyStep, ReviewBodyView, PatchStatus, ApplyUpdate } from
    '../types/view.types';


    export type { ScriptResult, ApplyStep };


    export const initialApplySteps: ApplyStep[] = [
        { id: 'snapshot', title: 'Reading initial file snapshot...', status: 'pending' },
        { id: 'memory', title: 'Applying operations to memory...', status: 'pending', substeps: [] },
        { id: 'post-command', title: 'Running post-command script...', status: 'pending', substeps: [] },
        { id: 'linter', title: 'Analyzing changes with linter...', status: 'pending', substeps: [] },
    ];


    type FileReviewState = { status: FileReviewStatus; error?: string };


    interface ReviewState {
        // Transaction Info
        transactionId: string | null;
        patchStatus: PatchStatus;
        fileReviewStates: Record<string, FileReviewState>; // Keyed by FileItem ID

        // UI State
        applySteps: ApplyStep[];
        selectedItemIndex: number; // Can be file or script
        bodyView: ReviewBodyView;
        isDiffExpanded: boolean;

        // Reasoning Scroll State
        reasoningScrollIndex: number;

        // Script Navigation State
        scriptErrorIndex: number;

        actions: {
            moveSelectionUp: () => void;
            moveSelectionDown: () => void;
            toggleFileApproval: () => void;
            rejectAllFiles: () => void;
            expandDiff: () => void;
            toggleBodyView: (view: Extract<ReviewBodyView, 'diff' | 'reasoning' | 'script_output' | 'bulk_repair' | 'confirm_handoff'>) => void;
            setBodyView: (view: ReviewBodyView) => void;
            approve: () => void;
            startApplySimulation: (scenario: 'success' | 'failure') => void;

            // Repair Actions
            tryRepairFile: () => void;
            showBulkRepair: () => void;
            executeBulkRepairOption: (option: number) => Promise<void>;
            confirmHandoff: () => void;

            // Navigation Actions
            scrollReasoningUp: () => void;
            scrollReasoningDown: () => void;
            navigateScriptErrorUp: () => void;
            navigateScriptErrorDown: () => void;

            // "Private" actions for service layer
            load: (transactionId: string, initialState?: { bodyView: ReviewBodyView }) => void;
            _updateApplyStep: (id: string, status: ApplyStep['status'], duration?: number, details?: string) => void;
            _addApplySubstep: (parentId: string, substep: Omit<ApplyStep, 'substeps'>) => void;
        };
    }


    export const useReviewStore = create<ReviewState>((set, get) => ({
        // Transaction Info
        transactionId: null,
        patchStatus: 'SUCCESS', // This will be set on load
        fileReviewStates: {},
        
        // UI State
        applySteps: initialApplySteps,
        selectedItemIndex: 0,
        bodyView: 'none' as const,
        isDiffExpanded: false,

        // Reasoning Scroll State
        reasoningScrollIndex: 0,

        // Script Navigation State
        scriptErrorIndex: 0,

        actions: {
            moveSelectionUp: () => set(state => {
                const tx = useTransactionStore.getState().transactions.find(t => t.id === state.transactionId);
                if (!tx) return {};
                const listSize = (tx.files?.length || 0) + (tx.scripts?.length || 0);
                return { selectedItemIndex: moveIndex(state.selectedItemIndex, 'up', listSize) };
            }),
            moveSelectionDown: () => set(state => {
                const tx = useTransactionStore.getState().transactions.find(t => t.id === state.transactionId);
                if (!tx) return {};
                const listSize = (tx.files?.length || 0) + (tx.scripts?.length || 0);
                return { selectedItemIndex: moveIndex(state.selectedItemIndex, 'down', listSize) };
            }),
            toggleFileApproval: () => set(state => {
                const tx = useTransactionStore.getState().transactions.find(t => t.id === state.transactionId);
                const file = tx?.files?.[state.selectedItemIndex];
                if (!file) return {};

                const currentState = state.fileReviewStates[file.id];
                if (!currentState) return {};

                const newStatus = currentState.status === 'APPROVED' ? 'REJECTED' : 'APPROVED';

                return {
                    fileReviewStates: {
                        ...state.fileReviewStates,
                        [file.id]: { ...currentState, status: newStatus },
                    },
                };
            }),
            rejectAllFiles: () => set(state => {
                const newFileReviewStates = { ...state.fileReviewStates };
                const tx = useTransactionStore.getState().transactions.find(t => t.id === state.transactionId);
                tx?.files?.forEach(file => {
                    const current = newFileReviewStates[file.id];
                    if (current?.status === 'APPROVED') {
                        newFileReviewStates[file.id] = { ...current, status: 'REJECTED' };
                    }
                });
                return { fileReviewStates: newFileReviewStates };
            }),
            toggleBodyView: (view) => set(state => {
                const tx = useTransactionStore.getState().transactions.find(t => t.id === state.transactionId);
                const files = tx?.files || [];
                if (view === 'diff' && state.selectedItemIndex >= files.length) return {}; // Can't show diff for scripts
                return {
                    bodyView: state.bodyView === view ? 'none' : view,
                    isDiffExpanded: false, // Always start collapsed
                };
            }),
            setBodyView: (view) => set({ bodyView: view }),
            expandDiff: () => set(state => ({ isDiffExpanded: !state.isDiffExpanded })),
            approve: () => {
                const { transactionId } = get();
                if (transactionId) {
                    // In a real app, you'd persist the fileReviewStates back into the transaction
                    // For this simulation, we just mark the whole transaction.
                    useTransactionStore.getState().actions.updateTransactionStatus(transactionId, 'APPLIED');
                    // Navigate back to dashboard
                    useAppStore.getState().actions.showDashboardScreen();
                }
            },
            startApplySimulation: async (scenario: 'success' | 'failure') => {
                const { showReviewProcessingScreen, showReviewScreen } = useAppStore.getState().actions;
                const { _updateApplyStep, _addApplySubstep } = get().actions;

                set({ applySteps: JSON.parse(JSON.stringify(initialApplySteps)) });
                showReviewProcessingScreen();

                const simulationGenerator = ReviewService.runApplySimulation(scenario);
                for await (const update of simulationGenerator) {
                    switch (update.type) {
                        case 'UPDATE_STEP':
                            _updateApplyStep(update.payload.id, update.payload.status, update.payload.duration, update.payload.details);
                            break;
                        case 'ADD_SUBSTEP':
                            _addApplySubstep(update.payload.parentId, update.payload.substep);
                            break;
                    }
                }

                // This would now update file statuses based on the result of the apply
                // For now, just return to the screen
                showReviewScreen();
            },

            // Repair Actions
            tryRepairFile: () => {
                set(state => {
                    const tx = useTransactionStore.getState().transactions.find(t => t.id === state.transactionId);
                    const file = tx?.files?.[state.selectedItemIndex];
                    if (!file) return {};
                    
                    const currentReviewState = state.fileReviewStates[file.id];
                    if (currentReviewState?.status !== 'FAILED') return {};

                    // The service returns a new FileItem, but we only update the review state
                    // to avoid re-introducing a copy of the data. The UI for stats won't update.
                    const repairedFile = ReviewService.tryRepairFile(file);

                    return {
                        fileReviewStates: {
                            ...state.fileReviewStates,
                            [file.id]: { status: repairedFile.reviewStatus || 'AWAITING', error: undefined },
                        },
                    };
                });
            },
            showBulkRepair: () => get().actions.toggleBodyView('bulk_repair'),
            executeBulkRepairOption: async (option: number) => {
                const { transactionId } = get();
                const tx = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!tx?.files) return;

                switch (option) {
                    case 1: { // Generate & Copy Bulk Repair Prompt
                        const bulkPrompt = ReviewService.generateBulkRepairPrompt(tx.files);
                        const failedFiles = tx.files.filter(f => f.reviewStatus === 'FAILED');
                        // eslint-disable-next-line no-console
                        console.log(`[CLIPBOARD] Copied bulk repair prompt for ${failedFiles.length} file(s).`);
                        set({ bodyView: 'none' as const });
                        break;
                    }

                    case 2: { // Attempt Bulk Re-apply
                        set({ bodyView: 'none' as const });

                        const failedFileIds = new Set(tx.files.filter(f => f.reviewStatus === 'FAILED').map(f => f.id));
                        if (failedFileIds.size === 0) break;

                        // Set intermediate state
                        set(state => {
                            const newStates = { ...state.fileReviewStates };
                            failedFileIds.forEach(id => {
                                if (newStates[id]) newStates[id]!.status = 'RE_APPLYING';
                            });
                            return { fileReviewStates: newStates };
                        });

                        // The service takes files, but returns updated files. We need to merge this back.
                        const finalFiles = await ReviewService.runBulkReapply(tx.files);
                        set(state => {
                            const newStates = { ...state.fileReviewStates };
                            finalFiles.forEach(file => {
                                if (newStates[file.id]) {
                                    newStates[file.id] = {
                                        status: file.reviewStatus || 'AWAITING',
                                        error: file.reviewError,
                                    };
                                }
                            });
                            return { fileReviewStates: newStates };
                        });
                        break;
                    }

                    case 3: { // Handoff to Human
                        get().actions.setBodyView('confirm_handoff');
                        break;
                    }

                    case 4: { // Reject All Failed
                        set(state => {
                            const newStates = { ...state.fileReviewStates };
                            Object.keys(newStates).forEach(fileId => {
                                if (newStates[fileId]?.status === 'FAILED') {
                                    newStates[fileId]!.status = 'REJECTED';
                                }
                            });
                            return { fileReviewStates: newStates, bodyView: 'none' as const };
                        });
                        break;
                    }

                    default: // Close modal
                        set({ bodyView: 'none' as const });
                }
            },
            confirmHandoff: () => {
                const { transactionId } = get();
                const transaction = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!transaction?.files) return;

                const handoffPrompt = ReviewService.generateHandoffPrompt(transaction.hash, transaction.message, transaction.reasoning || '', transaction.files);

                // eslint-disable-next-line no-console
                console.log('[CLIPBOARD] Copied Handoff Prompt.'); // In real app: clipboardy.writeSync(handoffPrompt)
                ReviewService.performHandoff(transaction.hash);
            },

            // Navigation Actions
            scrollReasoningUp: () => set(state => ({
                reasoningScrollIndex: Math.max(0, state.reasoningScrollIndex - 1),
            })),
            scrollReasoningDown: () => set(state => {
                const { transactionId } = state;
                if (!transactionId) return {};

                const transaction = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!transaction?.reasoning) return {};

                const maxLines = transaction.reasoning.split('\n').length;
                return { reasoningScrollIndex: Math.min(maxLines - 1, state.reasoningScrollIndex + 1) };
            }),
            navigateScriptErrorUp: () => set(state => ({
                scriptErrorIndex: Math.max(0, state.scriptErrorIndex - 1),
            })),
            navigateScriptErrorDown: () => set(state => {
                const tx = useTransactionStore.getState().transactions.find(t => t.id === state.transactionId);
                if (!tx?.scripts || !tx?.files) return {};

                const selectedScript = tx.scripts[state.selectedItemIndex - tx.files.length];
                if (selectedScript?.output) {
                    const errorLines = selectedScript.output.split('\n').filter(line =>
                        line.includes('Error') || line.includes('Warning'),
                    );
                    return { scriptErrorIndex: Math.min(errorLines.length - 1, state.scriptErrorIndex + 1) };
                }
                return {};
            }),

            // "Private" actions for service layer
            load: (transactionId, initialState) => {
                const transaction = useTransactionStore.getState().transactions.find(t => t.id === transactionId);
                if (!transaction) return;

                // This simulates the backend determining which files failed or succeeded.
                // For this demo, tx '1' is the failure case, any other is success.
                const isFailureCase = transaction.id === '1';
                const patchStatus = isFailureCase ? 'PARTIAL_FAILURE' : ('SUCCESS' as PatchStatus);

                const newFileReviewStates: Record<string, FileReviewState> = {};
                (transaction.files || []).forEach((file, index) => {
                    if (isFailureCase) {
                        const isFailedFile = index > 0;
                        newFileReviewStates[file.id] = {
                            status: isFailedFile ? 'FAILED' : 'APPROVED',
                            error: isFailedFile ? (index === 1 ? 'Hunk #1 failed to apply' : 'Context mismatch at line 92') : undefined,
                        };
                    } else {
                        newFileReviewStates[file.id] = { status: 'APPROVED' };
                    }
                });

                set({
                    transactionId: transaction.id,
                    patchStatus,
                    fileReviewStates: newFileReviewStates,
                    selectedItemIndex: 0,
                    bodyView: initialState?.bodyView ?? 'none',
                    isDiffExpanded: false,
                    reasoningScrollIndex: 0,
                    scriptErrorIndex: 0,
                    applySteps: JSON.parse(JSON.stringify(initialApplySteps)), // Reset apply steps
                });
            },
            _updateApplyStep: (id, status, duration, details) => {
                set(state => ({
                    applySteps: state.applySteps.map(s => {
                        if (s.id === id) {
                            const newStep = { ...s, status };
                            if (duration !== undefined) newStep.duration = duration;
                            if (details !== undefined) newStep.details = details;
                            return newStep;
                        }
                        return s;
                    }),
                }));
            },
            _addApplySubstep: (parentId, substep) => {
                 set(state => ({
                    applySteps: state.applySteps.map(s => {
                        if (s.id === parentId) {
                            const newSubsteps = [...(s.substeps || []), substep as ApplyStep];
                            return { ...s, substeps: newSubsteps };
                        }
                        return s;
                    }),
                }));
            },
        },
    }));
  src/hooks/useReviewScreen.tsx: |-
    import { useMemo, useDebugValue } from 'react';
    import { useInput, useApp } from 'ink';
    import { useReviewStore } from '../stores/review.store';
    import { useAppStore } from '../stores/app.store';
    import { useTransactionStore } from '../stores/transaction.store';
    import { useCopyStore, type CopyItem } from '../stores/copy.store';
    import { CopyService } from '../services/copy.service';
    import type { FileItem } from '../types/domain.types';

    export const useReviewScreen = () => {
        const { exit } = useApp();
        const store = useReviewStore();
        const { transactionId, fileReviewStates } = store;
        const transaction = useTransactionStore(s => s.transactions.find(t => t.id === transactionId));
        const { showDashboardScreen } = useAppStore(s => s.actions);
        const {
            selectedItemIndex, bodyView,
        } = store;

        const files: FileItem[] = useMemo(() => {
            if (!transaction?.files) return [];
            return transaction.files.map(file => ({
                ...file,
                reviewStatus: fileReviewStates[file.id]?.status || 'AWAITING',
                reviewError: fileReviewStates[file.id]?.error,
            }));
        }, [transaction, fileReviewStates]);

        const scripts = transaction?.scripts || [];
        const patchStatus = store.patchStatus;

        const {
            moveSelectionUp, moveSelectionDown, toggleFileApproval, expandDiff,
            toggleBodyView, setBodyView,
            startApplySimulation, rejectAllFiles, approve,
            tryRepairFile, showBulkRepair, executeBulkRepairOption, confirmHandoff,
            scrollReasoningUp, scrollReasoningDown, navigateScriptErrorUp, navigateScriptErrorDown,
        } = store.actions;
        const {
            numFiles,
            approvedFilesCount,
            approvedLinesAdded,
            approvedLinesRemoved,
        } = useMemo(() => {
            const approvedFiles = files.filter((f: FileItem) => f.reviewStatus === 'APPROVED');
            return {
                numFiles: files.length,
                approvedFilesCount: approvedFiles.length,
                approvedLinesAdded: approvedFiles.reduce((sum, f) => sum + f.linesAdded, 0),
                approvedLinesRemoved: approvedFiles.reduce((sum, f) => sum + f.linesRemoved, 0),
            };
        }, [files]);

        const openCopyMode = () => {
            if (!transaction) return;
            const title = 'Select data to copy from review:';
            const selectedFile = selectedItemIndex < files.length ? files[selectedItemIndex] : undefined;
            const items = CopyService.getCopyItemsForReview(transaction, transaction.files || [], selectedFile);
            useCopyStore.getState().actions.open(title, items);
        };

        useInput((input, key) => {
            // For demo purposes: Pressing 1 or 2 triggers the processing screen simulation.
            if (input === '1') {
                startApplySimulation('success');
                return;
            }
            if (input === '2') {
                // The store's default is failure, but to re-trigger the processing screen
                startApplySimulation('failure');
                return;
            }

            if (input.toLowerCase() === 'q') exit();

            // Handle Escape key - context-sensitive behavior
            if (key.escape) {
                if (bodyView === 'bulk_repair' || bodyView === 'confirm_handoff') {
                    toggleBodyView(bodyView); // Close modal
                } else if (bodyView !== 'none') {
                    setBodyView('none');
                } else {
                    showDashboardScreen();
                }
                return;
            }

            // Handoff Confirmation
            if (bodyView === 'confirm_handoff') {
                if (key.return) {
                    confirmHandoff();
                }
                return;
            }

            // Bulk Repair Navigation
            if (bodyView === 'bulk_repair') {
                if (input >= '1' && input <= '4') {
                    executeBulkRepairOption(parseInt(input));
                }
                return;
            }

            // Reasoning Scroll Navigation
            if (bodyView === 'reasoning') {
                if (key.upArrow) scrollReasoningUp();
                if (key.downArrow) scrollReasoningDown();
                if (input.toLowerCase() === 'r') toggleBodyView('reasoning');
                return;
            }

            // Script Output Navigation
            if (bodyView === 'script_output') {
                if (input.toLowerCase() === 'j') navigateScriptErrorDown();
                if (input.toLowerCase() === 'k') navigateScriptErrorUp();
                if (key.return) toggleBodyView('script_output');
                if (input.toLowerCase() === 'c') {
                    // Copy script output
                    const scriptIndex = selectedItemIndex - numFiles;
                    const selectedScript = scripts[scriptIndex];
                    if (selectedScript) {
                        // eslint-disable-next-line no-console
                        console.log(`[CLIPBOARD] Copied script output: ${selectedScript.command}`);
                    }
                }
                return;
            }

            // Diff View Navigation
            if (bodyView === 'diff') {
                if (input.toLowerCase() === 'x') expandDiff();
                if (input.toLowerCase() === 'd') toggleBodyView('diff');
                return;
            }

            // Handle Shift+R for reject all
            if (key.shift && input.toLowerCase() === 'r') {
                if (approvedFilesCount > 0) {
                    rejectAllFiles();
                }
                return;
            }

            // Main View Navigation
            if (key.upArrow) moveSelectionUp();
            if (key.downArrow) moveSelectionDown();

            if (input.toLowerCase() === 'r') toggleBodyView('reasoning');

            if (input === ' ') {
                if (selectedItemIndex < numFiles) {
                    const file = files[selectedItemIndex];
                    if (file && file.reviewStatus !== 'FAILED') {
                        toggleFileApproval();
                    }
                }
            }

            if (input.toLowerCase() === 'd') {
                if (selectedItemIndex < numFiles) {
                    toggleBodyView('diff');
                }
            }

            if (key.return) { // Enter key
                 if (selectedItemIndex >= numFiles) { // It's a script
                    toggleBodyView('script_output');
                }
            }

            if (input.toLowerCase() === 'a') {
                if (approvedFilesCount > 0) {
                    approve();
                    showDashboardScreen();
                }
            }

            if (input.toLowerCase() === 'c') {
                openCopyMode();
            }

            // Handle T for single repair and Shift+T for bulk repair
            if (input.toLowerCase() === 't') {
                if (key.shift) { // Bulk repair
                    const hasFailedFiles = files.some(f => f.reviewStatus === 'FAILED');
                    if (hasFailedFiles) {
                        showBulkRepair();
                    }
                } else {
                    if (selectedItemIndex < numFiles) {
                        const file = files[selectedItemIndex];
                        if (file && file.reviewStatus === 'FAILED') {
                            tryRepairFile();
                        }
                    }
                }
            }

            if (input.toLowerCase() === 'q') {
                showDashboardScreen();
            }
        });

        return {
            ...store,
            transaction,
            files,
            scripts,
            patchStatus,
            numFiles,
            approvedFilesCount,
            approvedLinesAdded,
            approvedLinesRemoved,
        };
    };
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 87
