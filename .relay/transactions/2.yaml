uuid: c6808779-1300-47b2-a4e5-9d57a9f8f2fd
projectId: relaycode-tui
createdAt: '2025-09-21T21:29:40.489Z'
gitCommitMsg: >-
  refactor: split zustand store and clear terminal on screen transitions

  Refactored the single monolithic Zustand store into two separate,
  domain-specific stores: `app.store.ts` for global app state (like the current
  screen) and `init.store.ts` for state related to the initialization flow. This
  improves modularity and maintainability.

  - Created `src/stores/` directory for the new store files. - Moved the `sleep`
  utility function to a new `src/utils.ts` file. - Updated all components to
  import from the new stores using granular
    selectors for better performance.
  - Implemented a `useEffect` hook in `App.tsx` that calls
    `console.clear()` on `currentScreen` changes, ensuring a clean render
    for each view.
promptSummary: >-
  I want to refactor the Zustand store into multiple entity-specific stores and
  clear the terminal on every screen transition.
reasoning:
  - >-
    This request involves two main changes: refactoring the single Zustand store
    into separate, domain-specific stores for better organization, and adding a
    screen-clearing effect on each view transition for a cleaner user
    experience.
  - '### Store Refactoring'
  - >-
    1.  **Splitting the Store**: I'll break down the monolithic `src/store.ts`
    into more focused stores within a new `src/stores/` directory.
  - >-
    *   `src/stores/app.store.ts`: This will manage global application state,
    specifically the `currentScreen`.
  - >-
    *   `src/stores/init.store.ts`: This will handle all state related to the
    multi-phase initialization flow.
  - >-
    2.  **Creating a Utilities File**: The `sleep` function, currently in
    `store.ts`, is a general utility. I'll move it to its own `src/utils.ts`
    file.
  - >-
    3.  **Updating Components**: I will update `App.tsx`, `SplashScreen.tsx`,
    and `InitializationScreen.tsx` to import from their respective new stores,
    using more granular selectors for state as recommended by Zustand best
    practices.
  - '### Terminal Clearing'
  - >-
    To ensure each screen is rendered in a fresh terminal view, I'll add a
    `useEffect` hook to the root `App.tsx` component. This hook will listen for
    changes to the `currentScreen` state and execute `console.clear()` whenever
    a transition occurs.
  - 'Here are the changes:'
  - First, I'll create the new store and utility files.
  - >-
    Now that the new files are in place, I'll delete the old monolithic store
    file.
  - >-
    Next, I'll update the `App` component to handle screen clearing and use the
    new `app.store`.
  - >-
    Then, I'll refactor the `InitializationScreen` to use the new `init.store`.
    I'm adopting the recommended Zustand pattern of using multiple selectors for
    each piece of state to optimize re-renders.
  - >-
    Finally, I'll update the `SplashScreen` to get its `showInitScreen` action
    from the new `app.store`.
  - >-
    These changes successfully separate the application's state management
    concerns and improve the visual flow between screens.
operations:
  - type: write
    path: src/stores/app.store.ts
    content: |-
      import { create } from 'zustand';

      export type AppScreen = 'splash' | 'init';

      interface AppState {
          currentScreen: AppScreen;
          actions: {
              showInitScreen: () => void;
          };
      }

      export const useAppStore = create<AppState>((set) => ({
          currentScreen: 'splash',
          actions: {
              showInitScreen: () => set({ currentScreen: 'init' }),
          },
      }));
    patchStrategy: replace
  - type: write
    path: src/stores/init.store.ts
    content: >-
      import { create } from 'zustand';


      // Types

      export type TaskStatus = 'pending' | 'active' | 'done';

      export type InitPhase = 'ANALYZE' | 'CONFIGURE' | 'INTERACTIVE' |
      'FINALIZE';

      export type GitignoreChoice = 'ignore' | 'share';


      export interface Task {
          id: string;
          title: string;
          subtext?: string;
          status: TaskStatus;
      }


      // Initial State definitions from README

      export const initialAnalyzeTasks: Task[] = [
          { id: 'scan', title: 'Scanning project structure...', subtext: 'Finding package.json', status: 'pending' },
          { id: 'project-id', title: 'Determining Project ID', status: 'pending' },
          { id: 'gitignore', title: 'Checking for existing .gitignore', status: 'pending' },
      ];


      export const initialConfigureTasks: Task[] = [
          { id: 'config', title: 'Creating relay.config.json', subtext: 'Writing default configuration with Project ID', status: 'pending' },
          { id: 'state-dir', title: 'Initializing .relay state directory', status: 'pending' },
          { id: 'prompt', title: 'Generating system prompt template', status: 'pending' },
      ];


      // Store Interface

      interface InitState {
          phase: InitPhase;
          analyzeTasks: Task[];
          projectId: string | null;
          gitignoreFound: boolean | null;
          configureTasks: Task[];
          interactiveChoice: GitignoreChoice | null;

          actions: {
              setPhase: (phase: InitPhase) => void;
              updateAnalyzeTask: (id: string, status: TaskStatus) => void;
              setAnalysisResults: (projectId: string, gitignoreFound: boolean) => void;
              updateConfigureTask: (id: string, status: TaskStatus) => void;
              setInteractiveChoice: (choice: GitignoreChoice) => void;
              resetInit: () => void;
          };
      }


      // Create the store

      export const useInitStore = create<InitState>((set) => ({
          phase: 'ANALYZE',
          analyzeTasks: initialAnalyzeTasks,
          projectId: null,
          gitignoreFound: null,
          configureTasks: initialConfigureTasks,
          interactiveChoice: null,

          actions: {
              setPhase: (phase) => set({ phase }),
              updateAnalyzeTask: (id, status) => set(state => ({
                  analyzeTasks: state.analyzeTasks.map(t => t.id === id ? { ...t, status } : t)
              })),
              setAnalysisResults: (projectId, gitignoreFound) => set({ projectId, gitignoreFound }),
              updateConfigureTask: (id, status) => set(state => ({
                  configureTasks: state.configureTasks.map(t => t.id === id ? { ...t, status } : t)
              })),
              setInteractiveChoice: (choice) => set({ interactiveChoice: choice }),
              resetInit: () => set({
                  phase: 'ANALYZE',
                  analyzeTasks: JSON.parse(JSON.stringify(initialAnalyzeTasks)),
                  projectId: null,
                  gitignoreFound: null,
                  configureTasks: JSON.parse(JSON.stringify(initialConfigureTasks)),
                  interactiveChoice: null,
              }),
          },
      }));
    patchStrategy: replace
  - type: write
    path: src/utils.ts
    content: >-
      // Utility for simulation

      export const sleep = (ms: number) => new Promise(resolve =>
      setTimeout(resolve, ms));
    patchStrategy: replace
  - type: delete
    path: src/store.ts
  - type: write
    path: src/App.tsx
    content: >+
      --- src/App.tsx

      +++ src/App.tsx

      @@ -1,11 +1,17 @@

      -import React from 'react';

      -import { useStore } from './store';

      +import React, { useEffect } from 'react';

      +import { useAppStore } from './stores/app.store';
       import SplashScreen from './components/SplashScreen';
       import InitializationScreen from './components/InitializationScreen';
       
       const App = () => {
      -    const currentScreen = useStore(state => state.currentScreen);

      +    const currentScreen = useAppStore(state => state.currentScreen);
       
      +    useEffect(() => {

      +        // Clear the terminal when the screen changes to ensure a clean
      view.

      +        // This is especially important when transitioning from the
      splash screen.

      +        console.clear();

      +    }, [currentScreen]);

      +    
           if (currentScreen === 'splash') {
               return <SplashScreen />;
           }

    patchStrategy: standard-diff
  - type: write
    path: src/components/InitializationScreen.tsx
    content: "--- src/components/InitializationScreen.tsx\n+++ src/components/InitializationScreen.tsx\n@@ -1,28 +1,33 @@\n import React, { useEffect } from 'react';\n import { Box, Text, useApp, useInput } from 'ink';\n-import { useStore, Task, initialAnalyzeTasks, initialConfigureTasks, sleep } from '../store';\n+import { useInitStore, Task, initialAnalyzeTasks, initialConfigureTasks } from '../stores/init.store';\n import chalk from 'chalk';\n import Separator from './Separator';\n+import { sleep } from '../utils';\n \n const TaskItem = ({ task, doneSymbol = '✓' }: { task: Task; doneSymbol?: string }) => {\n-    let symbol;\n-    switch (task.status) {\n-        case 'pending': symbol = '( )'; break;\n-        case 'active': symbol = chalk.cyan('(●)'); break;\n-        case 'done': symbol = chalk.green(doneSymbol); break;\n-    }\n-\n-    const title = task.status === 'done' && doneSymbol?.startsWith('[✓]') ? `Created ${task.title.split(' ')[1]}` : task.title;\n-\n-    return (\n-        <Box flexDirection=\"column\">\n-            <Text>\n-                {symbol} {title}\n-            </Text>\n-            {task.subtext && task.status !== 'done' && (\n-                <Text>\n-                    {'     └─ '}{task.subtext}\n-                </Text>\n-            )}\n-        </Box>\n-    );\n+\tlet symbol;\n+\tswitch (task.status) {\n+\t\tcase 'pending': symbol = '( )'; break;\n+\t\tcase 'active': symbol = chalk.cyan('(●)'); break;\n+\t\tcase 'done': symbol = chalk.green(doneSymbol); break;\n+\t}\n+\n+\tconst title = task.status === 'done' && doneSymbol?.startsWith('[✓]') ? `Created ${task.title.split(' ')[1]}` : task.title;\n+\n+\treturn (\n+\t\t<Box flexDirection=\"column\">\n+\t\t\t<Text>\n+\t\t\t\t{symbol} {title}\n+\t\t\t</Text>\n+\t\t\t{task.subtext && task.status !== 'done' && (\n+\t\t\t\t<Text>\n+\t\t\t\t\t{'     └─ '}{task.subtext}\n+\t\t\t\t</Text>\n+\t\t\t)}\n+\t\t</Box>\n+\t);\n };\n \n const InitializationScreen = () => {\n-    const store = useStore();\n-    const { actions } = store;\n+    const phase = useInitStore(s => s.phase);\n+    const analyzeTasks = useInitStore(s => s.analyzeTasks);\n+    const configureTasks = useInitStore(s => s.configureTasks);\n+    const interactiveChoice = useInitStore(s => s.interactiveChoice);\n+    const projectId = useInitStore(s => s.projectId);\n+    const actions = useInitStore(s => s.actions);\n     const { exit } = useApp();\n \n     useInput((input, key) => {\n-        if (store.phase === 'INTERACTIVE') {\n+        if (phase === 'INTERACTIVE') {\n             if (key.return) {\n                 actions.setInteractiveChoice('ignore');\n             } else if (input.toLowerCase() === 's') {\n                 actions.setInteractiveChoice('share');\n             }\n         }\n-        if (store.phase === 'FINALIZE') {\n+        if (phase === 'FINALIZE') {\n             if (input.toLowerCase() === 'q') {\n                 exit();\n             }\n@@ -58,7 +63,7 @@\n     }, []);\n \n     useEffect(() => {\n-        if (store.phase === 'INTERACTIVE' && store.interactiveChoice !== null) {\n+        if (phase === 'INTERACTIVE' && interactiveChoice !== null) {\n             const resumeSimulation = async () => {\n                 actions.setPhase('CONFIGURE');\n                 const lastTask = initialConfigureTasks[2];\n@@ -70,20 +75,20 @@\n             };\n             resumeSimulation();\n         }\n-    }, [store.interactiveChoice, store.phase]);\n+    }, [interactiveChoice, phase]);\n \n     const renderAnalyze = () => (\n         <Box flexDirection=\"column\">\n             <Text bold>PHASE 1: ANALYZE</Text>\n             <Box flexDirection=\"column\" marginTop={1} gap={1}>\n-                {store.analyzeTasks.map(t => <TaskItem key={t.id} task={t} />)}\n+                {analyzeTasks.map(t => <TaskItem key={t.id} task={t} />)}\n             </Box>\n         </Box>\n     );\n \n     const renderContext = () => (\n         <Box flexDirection=\"column\" marginBottom={1}>\n             <Text bold>CONTEXT</Text>\n-            <Text>  {chalk.green('✓')} Project ID: {store.projectId}</Text>\n+            <Text>  {chalk.green('✓')} Project ID: {projectId}</Text>\n             <Text>  {chalk.green('✓')} Gitignore:  Found at ./</Text>\n         </Box>\n     );\n@@ -93,7 +98,7 @@\n             {renderContext()}\n             <Text bold>PHASE 2: CONFIGURE</Text>\n             <Box flexDirection=\"column\" marginTop={1} gap={1}>\n-                {store.configureTasks.map(t => <TaskItem key={t.id} task={t} doneSymbol=\"[✓]\" />)}\n+                {configureTasks.map(t => <TaskItem key={t.id} task={t} doneSymbol=\"[✓]\" />)}\n             </Box>\n         </Box>\n     );\n@@ -103,7 +108,7 @@\n             {renderContext()}\n             <Text bold>PHASE 2: CONFIGURE</Text>\n             <Box flexDirection=\"column\" marginTop={1}>\n-                {store.configureTasks.slice(0, 2).map(t => <TaskItem key={t.id} task={t} doneSymbol=\"[✓]\" />)}\n+                {configureTasks.slice(0, 2).map(t => <TaskItem key={t.id} task={t} doneSymbol=\"[✓]\" />)}\n                 <Box flexDirection=\"column\" marginTop={1}>\n                     <Text>{chalk.cyan('>')} The .relay/ directory is usually ignored by git.</Text>\n                     <Text>  Do you want to share its state with your team by committing it?</Text>\n@@ -113,11 +118,11 @@\n     );\n \n     const renderFinalize = () => {\n-        const stateText = store.interactiveChoice === 'share'\n+        const stateText = interactiveChoice === 'share'\n             ? \".relay/ directory initialized. It will be committed to git.\"\n             : \".relay/ directory initialized and added to .gitignore.\";\n-        const stateSubText = store.interactiveChoice === 'share'\n+        const stateSubText = interactiveChoice === 'share'\n             ? undefined\n             : \"Local transaction history will be stored here.\";\n         \n@@ -141,7 +146,7 @@\n     };\n \n     const renderPhase = () => {\n-        switch (store.phase) {\n+        switch (phase) {\n             case 'ANALYZE': return renderAnalyze();\n             case 'CONFIGURE': return renderConfigure();\n             case 'INTERACTIVE': return renderInteractive();\n@@ -150,17 +155,17 @@\n     };\n     \n     let footerText;\n-    switch (store.phase) {\n+    switch (phase) {\n         case 'ANALYZE': footerText = 'This utility will configure relaycode for your project.'; break;\n         case 'CONFIGURE': footerText = 'Applying configuration based on project analysis...'; break;\n         case 'INTERACTIVE': footerText = `(${chalk.bold('Enter')}) No, ignore it (default)      (${chalk.bold('S')}) Yes, share it`; break;\n         case 'FINALIZE': footerText = `(${chalk.bold('W')})atch for Patches · (${chalk.bold('L')})View Logs · (${chalk.bold('Q')})uit`; break;\n     }\n \n     return (\n         <Box flexDirection=\"column\">\n-            <Text>{store.phase === 'FINALIZE' ? '▲ relaycode bootstrap complete' : '▲ relaycode bootstrap'}</Text>\n+            <Text>{phase === 'FINALIZE' ? '▲ relaycode bootstrap complete' : '▲ relaycode bootstrap'}</Text>\n             <Separator />\n             <Box marginY={1}>{renderPhase()}</Box>\n             <Separator />\n"
    patchStrategy: standard-diff
  - type: write
    path: src/components/SplashScreen.tsx
    content: >+
      --- src/components/SplashScreen.tsx

      +++ src/components/SplashScreen.tsx

      @@ -1,11 +1,11 @@
       import React, { useState, useEffect } from 'react';
       import { Box, Text, useInput } from 'ink';
      -import { useStore } from '../store';

      +import { useAppStore } from '../stores/app.store';
       import chalk from 'chalk';
       import Separator from './Separator';
       
       const SplashScreen = () => {
      -    const { showInitScreen } = useStore(state => state.actions);

      +    const showInitScreen = useAppStore(state =>
      state.actions.showInitScreen);
           const [countdown, setCountdown] = useState(5);
       
           const handleSkip = () => {

    patchStrategy: standard-diff
snapshot:
  src/stores/app.store.ts: null
  src/stores/init.store.ts: null
  src/utils.ts: null
  src/store.ts: >-
    import { create } from 'zustand';


    // Utility for simulation

    export const sleep = (ms: number) => new Promise(resolve =>
    setTimeout(resolve, ms));


    // Types

    export type AppScreen = 'splash' | 'init';

    export type TaskStatus = 'pending' | 'active' | 'done';

    export type InitPhase = 'ANALYZE' | 'CONFIGURE' | 'INTERACTIVE' |
    'FINALIZE';

    export type GitignoreChoice = 'ignore' | 'share';


    export interface Task {
        id: string;
        title: string;
        subtext?: string;
        status: TaskStatus;
    }


    // Initial State definitions from README

    export const initialAnalyzeTasks: Task[] = [
        { id: 'scan', title: 'Scanning project structure...', subtext: 'Finding package.json', status: 'pending' },
        { id: 'project-id', title: 'Determining Project ID', status: 'pending' },
        { id: 'gitignore', title: 'Checking for existing .gitignore', status: 'pending' },
    ];


    export const initialConfigureTasks: Task[] = [
        { id: 'config', title: 'Creating relay.config.json', subtext: 'Writing default configuration with Project ID', status: 'pending' },
        { id: 'state-dir', title: 'Initializing .relay state directory', status: 'pending' },
        { id: 'prompt', title: 'Generating system prompt template', status: 'pending' },
    ];


    // Store Interface

    interface TuiState {
        currentScreen: AppScreen;
        phase: InitPhase;
        analyzeTasks: Task[];
        projectId: string | null;
        gitignoreFound: boolean | null;
        configureTasks: Task[];
        interactiveChoice: GitignoreChoice | null;

        actions: {
            showInitScreen: () => void;
            setPhase: (phase: InitPhase) => void;
            updateAnalyzeTask: (id: string, status: TaskStatus) => void;
            setAnalysisResults: (projectId: string, gitignoreFound: boolean) => void;
            updateConfigureTask: (id: string, status: TaskStatus) => void;
            setInteractiveChoice: (choice: GitignoreChoice) => void;
            resetInit: () => void;
        };
    }


    // Create the store

    export const useStore = create<TuiState>((set) => ({
        currentScreen: 'splash',
        phase: 'ANALYZE',
        analyzeTasks: initialAnalyzeTasks,
        projectId: null,
        gitignoreFound: null,
        configureTasks: initialConfigureTasks,
        interactiveChoice: null,

        actions: {
            showInitScreen: () => set({ currentScreen: 'init' }),
            setPhase: (phase) => set({ phase }),
            updateAnalyzeTask: (id, status) => set(state => ({
                analyzeTasks: state.analyzeTasks.map(t => t.id === id ? { ...t, status } : t)
            })),
            setAnalysisResults: (projectId, gitignoreFound) => set({ projectId, gitignoreFound }),
            updateConfigureTask: (id, status) => set(state => ({
                configureTasks: state.configureTasks.map(t => t.id === id ? { ...t, status } : t)
            })),
            setInteractiveChoice: (choice) => set({ interactiveChoice: choice }),
            resetInit: () => set({
                phase: 'ANALYZE',
                analyzeTasks: JSON.parse(JSON.stringify(initialAnalyzeTasks)),
                projectId: null,
                gitignoreFound: null,
                configureTasks: JSON.parse(JSON.stringify(initialConfigureTasks)),
                interactiveChoice: null,
            }),
        },
    }));
  src/App.tsx: |-
    import React from 'react';
    import { useStore } from './store';
    import SplashScreen from './components/SplashScreen';
    import InitializationScreen from './components/InitializationScreen';

    const App = () => {
        const currentScreen = useStore(state => state.currentScreen);

        if (currentScreen === 'splash') {
            return <SplashScreen />;
        }

        if (currentScreen === 'init') {
            return <InitializationScreen />;
        }

        return null;
    };

    export default App;
  src/components/InitializationScreen.tsx: >-
    import React, { useEffect } from 'react';

    import { Box, Text, useApp, useInput } from 'ink';

    import { useStore, Task, initialAnalyzeTasks, initialConfigureTasks, sleep }
    from '../store';

    import chalk from 'chalk';

    import Separator from './Separator';


    const TaskItem = ({ task, doneSymbol = '✓' }: { task: Task; doneSymbol?:
    string }) => {
        let symbol;
        switch (task.status) {
            case 'pending': symbol = '( )'; break;
            case 'active': symbol = chalk.cyan('(●)'); break;
            case 'done': symbol = chalk.green(doneSymbol); break;
        }

        const title = task.status === 'done' && doneSymbol?.startsWith('[✓]') ? `Created ${task.title.split(' ')[1]}` : task.title;

        return (
            <Box flexDirection="column">
                <Text>
                    {symbol} {title}
                </Text>
                {task.subtext && task.status !== 'done' && (
                    <Text>
                        {'     └─ '}{task.subtext}
                    </Text>
                )}
            </Box>
        );
    };


    const InitializationScreen = () => {
        const store = useStore();
        const { actions } = store;
        const { exit } = useApp();

        useInput((input, key) => {
            if (store.phase === 'INTERACTIVE') {
                if (key.return) {
                    actions.setInteractiveChoice('ignore');
                } else if (input.toLowerCase() === 's') {
                    actions.setInteractiveChoice('share');
                }
            }
            if (store.phase === 'FINALIZE') {
                if (input.toLowerCase() === 'q') {
                    exit();
                }
            }
        });

        useEffect(() => {
            actions.resetInit();
            const runSimulation = async () => {
                actions.setPhase('ANALYZE');
                for (const task of initialAnalyzeTasks) {
                    actions.updateAnalyzeTask(task.id, 'active');
                    await sleep(800);
                    actions.updateAnalyzeTask(task.id, 'done');
                }
                actions.setAnalysisResults(`'relaycode' (from package.json)`, true);
                await sleep(500);

                actions.setPhase('CONFIGURE');
                const configTasksUntilInteractive = initialConfigureTasks.slice(0, 2);
                for (const task of configTasksUntilInteractive) {
                    actions.updateConfigureTask(task.id, 'active');
                    await sleep(800);
                    actions.updateConfigureTask(task.id, 'done');
                }
                await sleep(500);

                actions.setPhase('INTERACTIVE');
            };

            runSimulation();
        }, []);

        useEffect(() => {
            if (store.phase === 'INTERACTIVE' && store.interactiveChoice !== null) {
                const resumeSimulation = async () => {
                    actions.setPhase('CONFIGURE');
                    const lastTask = initialConfigureTasks[2];
                    actions.updateConfigureTask(lastTask.id, 'active');
                    await sleep(800);
                    actions.updateConfigureTask(lastTask.id, 'done');
                    await sleep(500);
                    
                    actions.setPhase('FINALIZE');
                };
                resumeSimulation();
            }
        }, [store.interactiveChoice, store.phase]);

        const renderAnalyze = () => (
            <Box flexDirection="column">
                <Text bold>PHASE 1: ANALYZE</Text>
                <Box flexDirection="column" marginTop={1} gap={1}>
                    {store.analyzeTasks.map(t => <TaskItem key={t.id} task={t} />)}
                </Box>
            </Box>
        );

        const renderContext = () => (
            <Box flexDirection="column" marginBottom={1}>
                <Text bold>CONTEXT</Text>
                <Text>  {chalk.green('✓')} Project ID: {store.projectId}</Text>
                <Text>  {chalk.green('✓')} Gitignore:  Found at ./</Text>
            </Box>
        );

        const renderConfigure = () => (
            <Box flexDirection="column">
                {renderContext()}
                <Text bold>PHASE 2: CONFIGURE</Text>
                <Box flexDirection="column" marginTop={1} gap={1}>
                    {store.configureTasks.map(t => <TaskItem key={t.id} task={t} doneSymbol="[✓]" />)}
                </Box>
            </Box>
        );

        const renderInteractive = () => (
            <Box flexDirection="column">
                {renderContext()}
                <Text bold>PHASE 2: CONFIGURE</Text>
                <Box flexDirection="column" marginTop={1}>
                    {store.configureTasks.slice(0, 2).map(t => <TaskItem key={t.id} task={t} doneSymbol="[✓]" />)}
                    <Box flexDirection="column" marginTop={1}>
                        <Text>{chalk.cyan('>')} The .relay/ directory is usually ignored by git.</Text>
                        <Text>  Do you want to share its state with your team by committing it?</Text>
                    </Box>
                </Box>
            </Box>
        );

        const renderFinalize = () => {
            const stateText = store.interactiveChoice === 'share'
                ? ".relay/ directory initialized. It will be committed to git."
                : ".relay/ directory initialized and added to .gitignore.";
            const stateSubText = store.interactiveChoice === 'share'
                ? undefined
                : "Local transaction history will be stored here.";
            
            return (
                <Box flexDirection="column">
                    <Text bold> SYSTEM READY</Text>
                    <Box flexDirection="column" marginTop={1} paddingLeft={2} gap={1}>
                        <Box flexDirection="column">
                            <Text>{chalk.green('✓')} Config:   relay.config.json created.</Text>
                            <Text>          {chalk.gray('›')} Edit this file to tune linters, git integration, etc.</Text>
                        </Box>
                        <Box flexDirection="column">
                            <Text>{chalk.green('✓')} State:    {stateText}</Text>
                            {stateSubText && <Text>          {chalk.gray('›')} {stateSubText}</Text>}
                        </Box>
                        <Box flexDirection="column">
                            <Text>{chalk.green('✓')} Prompt:   System prompt generated at .relay/prompts/system-prompt.md.</Text>
                            <Text>          {chalk.gray('›')} Copied to clipboard. Paste into your AI's custom instructions.</Text>
                        </Box>
                    </Box>
                </Box>
            );
        };

        const renderPhase = () => {
            switch (store.phase) {
                case 'ANALYZE': return renderAnalyze();
                case 'CONFIGURE': return renderConfigure();
                case 'INTERACTIVE': return renderInteractive();
                case 'FINALIZE': return renderFinalize();
            }
        };
        
        let footerText;
        switch (store.phase) {
            case 'ANALYZE': footerText = 'This utility will configure relaycode for your project.'; break;
            case 'CONFIGURE': footerText = 'Applying configuration based on project analysis...'; break;
            case 'INTERACTIVE': footerText = `(${chalk.bold('Enter')}) No, ignore it (default)      (${chalk.bold('S')}) Yes, share it`; break;
            case 'FINALIZE': footerText = `(${chalk.bold('W')})atch for Patches · (${chalk.bold('L')})View Logs · (${chalk.bold('Q')})uit`; break;
        }

        return (
            <Box flexDirection="column">
                <Text>{store.phase === 'FINALIZE' ? '▲ relaycode bootstrap complete' : '▲ relaycode bootstrap'}</Text>
                <Separator />
                <Box marginY={1}>{renderPhase()}</Box>
                <Separator />
                <Text>{footerText}</Text>
            </Box>
        );
    };


    export default InitializationScreen;
  src/components/SplashScreen.tsx: |-
    import React, { useState, useEffect } from 'react';
    import { Box, Text, useInput } from 'ink';
    import { useStore } from '../store';
    import chalk from 'chalk';
    import Separator from './Separator';

    const SplashScreen = () => {
        const { showInitScreen } = useStore(state => state.actions);
        const [countdown, setCountdown] = useState(5);

        const handleSkip = () => {
            showInitScreen();
        };

        useInput(() => {
            handleSkip();
        });

        useEffect(() => {
            if (countdown === 0) {
                showInitScreen();
                return;
            }

            const timer = setTimeout(() => {
                setCountdown(c => c - 1);
            }, 1000);

            return () => clearTimeout(timer);
        }, [countdown, showInitScreen]);

        const logo = `
             ░█▀▄░█▀▀░█░░░█▀█░█░█░█▀▀░█▀█░█▀▄░█▀▀
             ░█▀▄░█▀▀░█░░░█▀█░░█░░█░░░█░█░█░█░█▀▀
             ░▀░▀░▀▀▀░▀▀▀░▀▀▀░▀▀▀░▀░▀░░▀░░▀▀▀░▀▀▀
    `;

        return (
            <Box flexDirection="column">
                <Text>▲ relaycode</Text>
                <Separator />
                <Text>{logo}</Text>
                <Box flexDirection="column" alignItems="center">
                    <Text>A zero-friction, AI-native patch engine.</Text>
                    <Text>Built by Arman and contributors · https://relay.noca.pro</Text>
                </Box>
                
                <Box flexDirection="row" justifyContent="space-around" width="100%" marginTop={1}>
                    <Box flexDirection="column" width="45%">
                        <Text>Version 1.1.5</Text>
                        <Text>─────────────────────────</Text>
                        <Text>relaycode</Text>
                        <Text>relaycode-core</Text>
                        <Text>apply-multi-diff</Text>
                        <Text>konro</Text>
                    </Box>
                     <Box flexDirection="column" width="45%">
                        <Text>Build Timestamps</Text>
                        <Text>─────────────────────────</Text>
                        <Text>2025-09-20 13:58:05</Text>
                        <Text>2025-09-20 10:59:05</Text>
                        <Text>(versioned)</Text>
                        <Text>(versioned)</Text>
                    </Box>
                </Box>
                
                <Box marginTop={1}><Separator /></Box>
                <Text>If you love this workflow, check out https://www.noca.pro for the full</Text>
                <Text>web app with repo-wide visual context, history, and rollback.</Text>
                <Text>{chalk.bold('(V)')}isit noca.pro</Text>
                <Separator />
                <Text>Follow {chalk.bold('(X)')} · Join {chalk.bold('(D)')}iscord · Star on {chalk.bold('(G)')}itHub</Text>
                <Separator />
                <Text>Loading... {countdown} (Press any key to skip)</Text>
            </Box>
        );
    };

    export default SplashScreen;
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 2
